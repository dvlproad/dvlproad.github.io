<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5_open_app/dvlp_h5_open_app_app_route_url_demo/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5_open_app/dvlp_h5_open_app_app_route_url_demo/</url>
      
        <content type="html"><![CDATA[[{"sectionTitle":"跳转到app内的指定页面","sectionDatas":[{"unique_name":"打开XXXapp_聊天页面_1","scheme":{"value":"yuanwangwu","description":"打开XXXapp"},"path":{"value":"imChatPage","description":"聊天页面"},"argument":{"value":{"inviteCode":123},"description":{"inviteCode":"邀请码"}}},{"unique_name":"打开XXXapp_聊天页面_2","scheme":{"value":"yuanwangwu","description":"打开XXXapp"},"path":{"value":"imChatPage","description":"聊天页面"},"argument":{"value":{"inviteCode":123},"description":{"inviteCode":"邀请码"}}}],"route":[{"scheme":{"value":"yuanwangwu","description":"打开XXXapp"},"path":{"value":"imChatPage","description":"聊天页面"},"argument":{"value":{"inviteCode":123},"description":{"inviteCode":"邀请码"}}}],"route_full":[{"section_title":"1、应用标识：","section_datas":[{"title":"scheme值：","value":"yuanwangwu"},{"title":"scheme介绍","value":"打开XXXapp"}]},{"section_title":"2、应用路径","section_datas":[{"title":"path值：","value":"imChatPage"},{"title":"path介绍：","value":"聊天页面"}]},{"section_title":"3、应用路径参数","section_datas":[{"title":"argument值：","value":{"inviteCode":123}},{"title":"argument介绍：","value":{"inviteCode":"邀请码"}}]}]}]]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5_open_app/dvlp_h5_open_app_browser_url_demo/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5_open_app/dvlp_h5_open_app_browser_url_demo/</url>
      
        <content type="html"><![CDATA[[{"sectionTitle":"跳转到app内的指定页面","sectionDatas":[{"h5CallBridgeActionDes":"跳转到百度(只是用来测试app能否打开参数是百度的功能)","h5CallBridgeSendMessage":"https://www.baidu.com/"},{"h5CallBridgeActionDes":"跳转到app内的指定聊天页面","h5CallBridgeSendMessage":"yuanwangwu://openpage?pageName=imChatPage&conversationID=126191&imUserId=1602856363702501376&showName=婉艺&type=1&dialogSubjectId=1506196208391966720","scheme":"yuanwangwu","path":"imChatPage","path_Description":"聊天页面","argument":{"inviteCode":123},"argument_Description":{"inviteCode":"邀请码"}},{"h5CallBridgeActionDes":"跳转到app内的指定游戏网页(url无参可不编码)","h5CallBridgeSendMessage":"yuanwangwu://openpage?pageName=webNavPage&url=https://farm-game.yuanwangwu.com/index.html&shouldHideNavBar=true"},{"h5CallBridgeActionDes":"跳转到app内的指定游戏网页(url带参必须编码)","h5CallBridgeSendMessage":"yuanwangwu://openpage?pageName=webNavPage&shouldHideNavBar=true&navigatorBackgroundColor=0xffffff00&statusBarColor=light&url=https%3A%2F%2Ffarm-game.yuanwangwu.com%2Findex.html%26toUserId%3D111"}],"browser":[{"main_value":"https://www.baidu.com/index.html","main_description":"百度网页","appRouteUrl_useKey":"appRouteUrl","appRouteUrl_value":"yuanwangwu://openpage?pageName=webNavPage&url=https://farm-game.yuanwangwu.com/index.html&shouldHideNavBar=true&inviteCode=123","appRouteUrl_description":"打开app的网页，进入农场游戏","other_value":{"inviteCode":123},"other_description":{"inviteCode":"邀请码"}}],"browser_full":[{"section_title":"1、指定浏览器要打开的测试页面的-主地址信息：","section_datas":[{"title":"主地址值","value":"https://www.baidu.com/index.html"},{"title":"主地址介绍","value":"百度网页"}]},{"section_title":"2、指定浏览器要打开的测试页面的-app参数信息(用于从浏览器直接打开app)：(可不传，且不传的时候，页面本身也有一个内嵌的默认值供测试)","section_datas":[{"title":"app参数信息使用的key(用该key将其值一起携带给页面)：","value":"appRouteUrl"},{"title":"app参数信息的value：","value":"yuanwangwu://openpage?pageName=webNavPage&url=https://farm-game.yuanwangwu.com/index.html&shouldHideNavBar=true&inviteCode=123"},{"title":"app参数信息的value的介绍(功能及内部参数说明等)：","value":"打开app的网页，进入农场游戏"}]},{"section_title":"3、指定浏览器要打开的测试页面的-其他参数信息(网页本身可能需要使用到)：(可不传，如果所传参数在app路由里也要使用的话，需自己加上去。因为app里不会对齐自动添加，是为了避免有时候有重复添加的情况出现)","section_datas":[{"title":"其他参数信息的key及其value：","value":{"inviteCode":123}},{"title":"其他参数信息的key介绍：","value":{"inviteCode":"邀请码"}}]}]}]]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5_open_app/dvlp_h5_open_app_browser_url_demo/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5_open_app/dvlp_h5_open_app_browser_url_demo/</url>
      
        <content type="html"><![CDATA[<!-- * @Author: dvlproad * @Date: 2022-12-27 11:59:38 * @LastEditors: dvlproad * @LastEditTime: 2023-02-15 14:23:19 * @Description: 调试h5与app交互的网页demo--><!--一、使用fileUrl参数1、本地服务器测试url1:  http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?参数如下eg中的值eg1.1: fileUrl=dvlp_h5js_demo.jsoneg1.2: fileUrl=http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.json2、远程服务器测试url2:  https://dvlproad.github.io/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?参数如下eg中的值eg2.1: fileUrl=dvlp_h5js_demo.jsoneg2.2: fileUrl=https://dvlproad.github.io/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.jsoneg2.3(测试跨域): fileUrl=https://raw.githubusercontent.com/dvlproad/dvlproad.github.io/master/Architecture%E6%9E%B6%E6%9E%84/h5js/dvlp_h5js_demo/dvlp_h5js_demo.jsoneg2.4(测试跨域): eg2.5(测试跨域): 二、使用各种dataJson参数1、本地服务器测试url1:  http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?参数如下eg中的值eg1.1(未编码h5CallBridgeSendMessage，在浏览器中验证可以。但在app中不行，必须对每个参数编码后再赋值，以避免参数中含中文或者对象): h5CallBridgeActionDes=跳转到app指定页面_Name&h5CallBridgeActionName=h5CallBridgeAction_jumpAppPage&h5CallBridgeSendMessage={"pageName":"imChatPage","pageParams":{"conversationID":"126191","imUserId":"1602856363702501376","showName":"婉艺","type":1,"dialogSubjectId":"1506196208391966720"}}eg1.2(有编码h5CallBridgeSendMessage，验证可以): h5CallBridgeActionDes=跳转到app指定页面_Name&h5CallBridgeActionName=h5CallBridgeAction_jumpAppPage&h5CallBridgeSendMessage=%7B%22pageName%22%3A%22imChatPage%22%2C%22pageParams%22%3A%7B%22conversationID%22%3A%22126191%22%2C%22imUserId%22%3A%221602856363702501376%22%2C%22showName%22%3A%22%E5%A9%89%E8%89%BA%22%2C%22type%22%3A1%2C%22dialogSubjectId%22%3A%221506196208391966720%22%7D%7D--><!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0">  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">  <title>html demo</title></head><style>  .div_spearte {    height: 16px;  }  .button_half_width {    background-color: red;    color: white;    border-width: 0;    width: 45%;    font-size: 12px;  }  .button_full_width {    background-color: red;    color: white;    border-width: 0;    width: 45%;    font-size: 20px;  }  .title1 {    color: red;    font-size: 14px;    padding-left: 10px;  }  .title1 .title2 {    color: blue;    font-size: 12px;  }  .textarea_one_line {    width: 95%;    height: 16px;  }  .textarea_decription_multiline {    width: 95%;    height: 80px;  }  .textarea_one_appRouteUrl {    width: 95%;    height: 70px;  }  .textarea_one_browseUrl {    width: 95%;    height: 80px;  }</style><style>  .hide {    display: none !important;  }  .dialog {    position: absolute;    top: 0;    left: 0;    width: 100vw;    height: 100vh;    background-color: rgba(0, 0, 0, 0.6);    display: flex;    justify-content: center;    align-items: center;  }  .dialog .content {    background: white;    padding: 30px 20px;  }  .dialog .content .msg {    font-size: 16px;  }  .dialog .content .close-btn {    margin-top: 10px;    width: 100px;    height: 36px;    background-color: #fff;    border: 1px solid blue;    font-size: 14px;    color: blue;  }</style><body>  <div class="dialog hide">    <div class="content">      <div class="msg" id="msg">消息内容</div>      <button class="close-btn" onclick="handleCloseDialog()">我知道了</button>    </div>  </div>  <div id="pageTilteView" style="text-align: center; font-size: 20px;">    在指定实际项目页面(非之前的测试工具页)中测试所选路由    <button onclick="_h5Action_goDemoPage()" style="font-size: 12px;">查看示例</button>  </div>  <div id="pageSubTilteView" style="text-align: center; font-size: 14px;">数据来源于：xxx</div>  <div class="div_spearte"></div>  <div id="h5OpenAppUrlCreate_type_custom_url">自己生成    <div class="title1" id="h5OpenAppUrlCreate_type_custom_url_headerView">1、指定浏览器要打开的测试页面的-主地址信息：      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_name_titleView">主地址值：</div>      <textarea class="textarea_one_line" id="custom_browserUrl_main_Value_valueView">主地址值</textarea>      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_name_titleView">主地址介绍：</div>      <textarea class="textarea_one_line" id="custom_browserUrl_main_Description_valueView">主地址介绍</textarea>    </div>    <div class="title1"> 2、指定浏览器要打开的测试页面的-app参数信息(用于从浏览器直接打开app)：(可不传，且不传的时候，页面本身也有一个内嵌的默认值供测试)      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_name_titleView">app参数信息使用的key(用该key将其值一起携带给页面)：</div>      <textarea class="textarea_one_line" id="custom_browserUrl_appRouteUrlUseKey_valueView">        app参数信息使用什么key添加到url上      </textarea>      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_name_titleView">app参数信息的value：</div>      <textarea class="textarea_one_appRouteUrl" id="custom_browserUrl_appRouteUrlValue_valueView">app参数信息的值</textarea>      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_headerView">app参数信息的value的介绍(功能及内部参数说明等)：</div>      <textarea class="textarea_one_line" id="custom_browserUrl_appRouteUrl_Description_valueView">其他参数信息的值</textarea>    </div>    <div class="title1">      3、指定浏览器要打开的测试页面的-其他参数信息(网页本身可能需要使用到)：(可不传，如果所传参数在app路由里也要使用的话，需自己加上去。因为app里不会对齐自动添加，是为了避免有时候有重复添加的情况出现)      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_name_titleView">其他参数信息的key及其value：</div>      <textarea class="textarea_one_line" id="custom_browserUrl_otherKeyAndValues_valueView">        {"inviteCode": 123}      </textarea>      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_name_titleView">其他参数信息的key介绍：</div>      <textarea class="textarea_decription_multiline" id="custom_browserUrl_otherKeyAndValues_Description_valueView">        inviteCode: 邀请码      </textarea>    </div>  </div>  <!-- <div class="div_spearte"></div>  <div>    <div id="h5OpenAppUrlCreate_type_custom_url_headerView">生成构成后：</div>    <div id="h5OpenAppUrlCreate_type_custom_url_name_titleView">自动同步：</div>    <div id="h5OpenAppUrlCreate_type_custom_url_name_titleView">拆解分析前：</div>  </div>  <div class="div_spearte"></div> -->  <div class="div_spearte"></div>  <div>    <button class="button_half_width" id="h5OpenAppUrlCreate_type_directly" onclick="_h5Action_create('custom')">生成/构成      browseUrl</button>  </div>  <div class="div_spearte"></div>  <div id="h5OpenAppUrlCreate_type_custom_url">直接地址    <div class="title1"> 最终构成      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_name_titleView">最终浏览器地址：</div>      <textarea class="textarea_one_browseUrl" id="directly_browserUrl_Value_valueView">最终浏览器地址</textarea>    </div>  </div>  <button id="evalButtonView" onclick="_h5CallBridgeAction_eval()" style="background-color: red; color: white; width: 95%; border-width: 0; font-size: 20px;">执行按钮</button>  <!-- <div>分享内容到指定的分享方式(微信聊天页面等)</div>  <button    onclick="h5Action_updateTextAreaValue_share('只是分享网页链接，没其他操作')">'硬编码的按钮：只是分享网页链接，没其他操作'</button>  <button    onclick="h5Action_updateTextAreaValue_share('分享链接，且链接可打开app的_原生页面')">'硬编码的按钮：分享链接，且链接可打开app的_原生页面'</button>  <button    onclick="h5Action_updateTextAreaValue_share('分享链接，且链接可打开app的_网页游戏')">'硬编码的按钮：分享链接，且链接可打开app的_网页游戏'</button> -->  <div id="h5Action_updateTextAreaValue_buttons_div"></div></body><!-- [移动端调试神器vConsole使用详解](https://www.jb51.net/article/244750.htm) --><script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script><script>  // VConsole 默认会挂载到 `window.VConsole` 上  var vConsole = new window.VConsole();  // 接下来即可照常使用 `console` 等方法  console.log('Hello world');  // 结束调试后，可移除掉  vConsole.destroy();</script><!-- [引入jquery.js 修复出现的错误：ReferenceError: $ is not defined](https://blog.csdn.net/lq_ruonan/article/details/53690960) --><script src="https://code.jquery.com/jquery-3.6.3.js" type="text/javascript" charset="utf-8"></script><!-- <script src="js/jQuery.js" type="text/javascript" charset="utf-8"></script> --><!-- <script src="../../../HTML/common_js/object_util.js" type="text/javascript" charset="utf-8"></script><script src="../../../HTML/common_js/url_util.js" type="text/javascript" charset="utf-8"></script><script src="http://localhost:4000/HTML/common_js/object_util.js" type="text/javascript" charset="utf-8"></script><script src="http://localhost:4000/HTML/common_js/url_util.js" type="text/javascript" charset="utf-8"></script>--><script>  // [js 删除Object中指定的key](https://blog.csdn.net/weixin_39501680/article/details/123110404)  const isObject = (obj) => obj === Object(obj)  const isNil = (val) => val === undefined || val === null  const isEmpty = (val) => {    return isString(val) || isObject(val) || Array.isArray(val) ?      !Object.keys(val).length : isNil(val)  }  const isString = (val) => typeof val === 'string'  const deleteObjectByKey = (obj = {}, arr = []) => {    if (isEmpty(obj) || !isObject(obj)) return {}    if (isEmpty(arr) || (!Array.isArray(arr) && !isString(arr))) return obj    return Object.keys(obj)      .filter((k) => !arr.includes(k))      .reduce((acc, key) => ((acc[key] = obj[key]), acc), {})  }</script><script>  /// 获取指定地址的主地址  function getRequestUrlMain(browserUrl) {    if (browserUrl == null || browserUrl == "" || typeof browserUrl == "undefined") {      var url = decodeURI(location.search);  //获取url中"?"符后的字串    } else {      var url = browserUrl;    }    var url_main;    var paramStartIndex = url.indexOf("?");    if (paramStartIndex != -1) {      // [js中截取字符串的三个方法 substring()、substr()、slice()](https://segmentfault.com/a/1190000016387899)      url_main = url.substring(0, paramStartIndex);    } else {      url_main = url;    }    return url_main;  }  /// 获取指定地址的所有参数  function getRequestUrlParams(browserUrl) {    if (browserUrl == null || browserUrl == "" || typeof browserUrl == "undefined") {      var url = decodeURI(location.search);  //获取url中"?"符后的字串    } else {      var url = browserUrl;    }    var theRequest = new Map();    var paramStartIndex = url.indexOf("?");    if (paramStartIndex != -1) {      var str = url.substr(paramStartIndex + 1);      strs = str.split("&");      for (var i = 0; i < strs.length; i++) {        var keyValueComponent = strs[i].split("=");        var key = keyValueComponent[0];        var value = keyValueComponent[1];        theRequest[key] = unescape(value);      }    }    return theRequest;  }  // [js获取url中的中文参数出现乱码解决](https://www.codeleading.com/article/87533774933/)  // "http://localhost:4000/Architecture%E6%9E%B6%E6%9E%84/h5js/dvlp_h5js_demo/dvlp_h5js_demo.json"; // url含中文示例  // "http://localhost/test/test.html?p=广东&c=珠海"  function getValueByQueryKey(browserUrl, key) {    // 获取参数    if (browserUrl == null || browserUrl == "" || typeof browserUrl == "undefined") {      var url = decodeURI(location.search);  //获取url中"?"符后的字串      // var url = window.location.search; // 在本地用file打开，而不是http打开的话，此值会为空    } else {      var url = browserUrl;    }    // 正则筛选地址栏    var reg = new RegExp("(^|&)" + key + "=([^&]*)(&|$)");    // 匹配目标参数    var result = url.substr(1).match(reg);    //返回参数值    // return result ? unescape(result[2]) : null; // url中含中文时候，取值会出错    return result ? decodeURIComponent(result[2]) : null;  }  /// 获取本页面指定参数key的值  function getQueryString(key) {    var url = window.location.search; // 在本地用file打开，而不是http打开的话，此值会为空    return getValueByQueryKey(url, key);  }</script><script>  /// 为 oldUrl 添加 newParams 参数，返回新url  function addParamsForUrl(oldUrl, newParams) {    if (newParams == null || newParams == {} || typeof newParams == "undefined") {      return oldUrl;    }    var keys = Object.keys(newParams); // 获取map的所有keys    console.log(`keys=${keys}`);    var count = keys.length;    // var count = oldUrl.size;    var newParamsString = '';    for (var i = 0; i < count; i++) {      var key = keys[i];      var value = newParams[key];      if (i > 0) {        newParamsString += '&';      }      newParamsString += `${key}=${value}`;    }    var paramStartIndex = oldUrl.indexOf("?");    var connectorFlag;    if (paramStartIndex != -1) {      connectorFlag = '&';    } else {      connectorFlag = '?';    }    return `${oldUrl}${connectorFlag}${newParamsString}`;  }</script><script>  function getLocal_appRouteElement() {    var appRouteElement = {      "value": "yuanwangwu://openpage?pageName=webNavPage&url=https://farm-game.yuanwangwu.com/index.html&shouldHideNavBar=true&inviteCode=123",      "description": "打开app的网页，进入农场游戏",    };    return appRouteElement;  }  function getLocalDemoMapArray() {    // _browserUrl = "http://www.baidu.com/index.com?inviteCode=123&appRouteUrl=yuanwangwu://openpage?pageName=webNavPage&url=https://farm-game.yuanwangwu.com/index.html&shouldHideNavBar=true&inviteCode=123";    // _browserUrl_appRouteUrlKey = "appRouteUrl";    // analysisBrowserUrl(_browserUrl, "appRouteUrl");    var structureElementArray = [      {        "sectionTitle": "在游戏页面中测试",        "sectionDatas": [          {            "unique_name": "农场游戏1",            "website": {              "value": "https://www.baidu.com/index.html",              "description": "农场游戏"            },            "argument_appRouteUrl_useKey": {              "value": "appRouteUrl",              "description": "app参数信息使用的key(用该key将其值一起携带给页面)",            },            "argument_others": {              "value": {                "inviteCode": 123              },              "description": {                "inviteCode": "邀请码"              }            }          },          {            "unique_name": "农场游戏_2",            "website": {              "value": "https://www.baidu.com/index.html",              "description": "农场游戏"            },            "argument_appRouteUrl_useKey": {              "value": "appRouteUrl",              "description": "app参数信息使用的key(用该key将其值一起携带给页面)",            },            "argument_others": {              "value": {                "inviteCode": 123              },              "description": {                "inviteCode": "邀请码"              }            }          }        ]      }    ];    // return null; // 测试本地未赋值时候的界面展示    return structureElementArray;  }</script><script>  /// 解析浏览器地址，并更新到解析器UI  function analysisBrowserUrl(browserUrl, browserUrl_appRouteUrlKey) {    // 构造器    updateElementValueById("directly_browserUrl_Value_valueView", browserUrl);    // 解析器    // 1、主地址信息    _browserUrl_main = getRequestUrlMain(browserUrl);    updateElementValueById("custom_browserUrl_main_Value_valueView", _browserUrl_main);    updateElementValueById("custom_browserUrl_main_Description_valueView", "未标明");    // 2、app参数信息    _browserUrl_appRouteUrlKey = browserUrl_appRouteUrlKey;    updateElementValueById("custom_browserUrl_appRouteUrlUseKey_valueView", _browserUrl_appRouteUrlKey);    _browserUrl_appRouteUrlValue = getValueByQueryKey(browserUrl, browserUrl_appRouteUrlKey);    updateElementValueById("custom_browserUrl_appRouteUrlValue_valueView", _browserUrl_appRouteUrlValue);    updateElementValueById("custom_browserUrl_appRouteUrl_Description_valueView", "未标明");    // 3、其他参数信息    var browserUrl_params = getRequestUrlParams(browserUrl);    // var keys = Object.keys(browserUrl_params); // 获取map的所有keys    // console.log(`keys=${keys}`);    if (typeof browserUrl_appRouteUrlKey == "undefined" || browserUrl_appRouteUrlKey == null) {      _browserUrl_otherKeyAndValues = browserUrl_params;    } else {      _browserUrl_otherKeyAndValues = deleteObjectByKey(browserUrl_params, [browserUrl_appRouteUrlKey]);    }    updateElementValueById("custom_browserUrl_otherKeyAndValues_valueView", _browserUrl_otherKeyAndValues);    updateElementValueById("custom_browserUrl_otherKeyAndValues_Description_valueView", "未标明");  }  /// 更新 h5调用的app桥接方法名 和  h5调用app桥接方法后，发送的数据  function _h5Action_updateText_byIndex(sectionIndex, rowIndex) {    var element = _getElementByIndex(sectionIndex, rowIndex);    console.log(`-------当前所选择的值${sectionIndex}.${rowIndex}-------element=${element},elementString=${JSON.stringify(element)}`);    structureRouteUrl(element);  }  /// 根据当前文本框内容，构造 appRouteElement 元素值  function _getElementByCurrentText_appRouteElement() {    var element = {      "value": getElementValueById("custom_browserUrl_appRouteUrlValue_valueView"),      "description": getElementValueById("custom_browserUrl_appRouteUrl_Description_valueView")    };    return element;  }  /// 根据当前文本框内容，构造 element 元素值  function _getElementByCurrentText() {    var element = {      "unique_name": "打开XXXapp_聊天页面_1",      "website": {        "value": getElementValueById("custom_browserUrl_main_Value_valueView"),        "description": getElementValueById("custom_browserUrl_main_Description_valueView")      },      "argument_appRouteUrl_useKey": {        "value": getElementValueById("custom_browserUrl_appRouteUrlUseKey_valueView"),        "description": getElementValueById("custom_browserUrl_appRouteUrl_Description_valueView")      },      "argument_others": {        "value": getElementValueById("custom_browserUrl_otherKeyAndValues_valueView"),        "description": getElementValueById("custom_browserUrl_otherKeyAndValues_Description_valueView")      }    };    return element;  }  /// 根据选中的元素，构造浏览器地址，并更新到构造器UI  function updateAppRouteUI(appRouteElement) {    // 先把元素更新到解析器    // 2、app参数信息    updateElementValueById("custom_browserUrl_appRouteUrlValue_valueView", appRouteElement["value"]);    updateElementValueById("custom_browserUrl_appRouteUrl_Description_valueView", appRouteElement["description"]);    // 把各个元素整合并更新结果    _updateResultUI();  }  /// 根据当前文本框内容，构造浏览器地址，并更新到构造器UI  function structureRouteUrlByCurrentText() {    var element = _getElementByCurrentText();    structureRouteUrl(element);  }  /// 根据选中的元素，构造浏览器地址，并更新到构造器UI  function structureRouteUrl(element) {    // 先把元素更新到解析器    // 1、主地址信息    updateElementValueById("custom_browserUrl_main_Value_valueView", element["website"]["value"]);    updateElementValueById("custom_browserUrl_main_Description_valueView", element["website"]["description"]);    // 2、app参数信息    updateElementValueById("custom_browserUrl_appRouteUrlUseKey_valueView", element["argument_appRouteUrl_useKey"]["value"]);    // 3、其他参数信息    updateElementValueById("custom_browserUrl_otherKeyAndValues_valueView", element["argument_others"]["value"]);    updateElementValueById("custom_browserUrl_otherKeyAndValues_Description_valueView", element["argument_others"]["description"]);    // 把各个元素整合并更新结果    _updateResultUI();  }  /// 构造浏览器地址，并更新到构造器UI  function _updateResultUI() {    // 获取文本框内容    var browserUrl_main = document.getElementById("custom_browserUrl_main_Value_valueView").value;    var browserUrl_appRouteUrlKey = document.getElementById("custom_browserUrl_appRouteUrlUseKey_valueView").value;    var browserUrl_appRouteUrlValue = document.getElementById("custom_browserUrl_appRouteUrlValue_valueView").value;    var browserUrl_otherKeyAndValues_string = document.getElementById("custom_browserUrl_otherKeyAndValues_valueView").value;;    var browserUrl_otherKeyAndValues = JSON.parse(browserUrl_otherKeyAndValues_string);        // 构造文本框值    var browserUrl = `${browserUrl_main}`;    // var browserUrl_params = new Object;    if (browserUrl_appRouteUrlKey != null && browserUrl_appRouteUrlValue != null) {      // browserUrl_params[browserUrl_appRouteUrlKey] = browserUrl_appRouteUrlValue;      var appRouteUrlMap = new Object;      appRouteUrlMap[browserUrl_appRouteUrlKey] = browserUrl_appRouteUrlValue;      browserUrl = addParamsForUrl(browserUrl, appRouteUrlMap);    }    if (browserUrl_otherKeyAndValues != null) {      browserUrl = addParamsForUrl(browserUrl, browserUrl_otherKeyAndValues);    }    // 更新构造器UI    updateElementValueById("directly_browserUrl_Value_valueView", browserUrl);  }  function _getSectionHtmlString(sectionIndex, demoMapArray) {    console.log(`${sectionIndex}当前区要显示的数据如下:\n demoMapArray:${demoMapArray}\n demoMapArrayString:${JSON.stringify(demoMapArray)}`);    let sectionHtmlString = "";    var demoMapCount = demoMapArray.length;    for (let rowIndex = 0; rowIndex < demoMapCount; rowIndex++) {      const element = demoMapArray[rowIndex];      var unique_name = element["unique_name"];      _h5CallBridgeActionDesArray.push();      // [JS字符串拼接的几种方式](https://blog.csdn.net/u012320487/article/details/123822785)      var h5Action_updateTextAreaValue_onClick = `_h5Action_updateText_byIndex(${sectionIndex}, ${rowIndex});`;      var iButtonHtmlString = `<button onClick='${h5Action_updateTextAreaValue_onClick}' style="width: 95%; height: 30px;">${sectionIndex + 1}.${rowIndex + 1}.${unique_name}</button>`      if (rowIndex > 0) {        // htmlStr += `<>`;      }      console.log(`iButtonHtmlString${rowIndex}=${iButtonHtmlString} element=${JSON.stringify(element)}`);      sectionHtmlString += `${iButtonHtmlString}`;    }    return sectionHtmlString;  }</script><script>  function updateElementValueById(id, value) {    if (typeof value == 'string') {      //     } else {      value = JSON.stringify(value);    }    document.getElementById(id).innerHTML = '' + `${value}`;  }  function getElementValueById(id) {    var value = document.getElementById(id).value;    return value;  }</script><script>  var _isMyAppWebView; // 是否是我们开发的app中内嵌的webView(还是其他app里，或者pc上的)  /// 获取当前浏览器类型  function _getBrowserType() {    return getQueryString("isMyAppWebView") == 1;  }  /// 根据当前浏览器类型更新UI页面的标题  function _updateUITitleByCurrentBrowserType(isMyAppWebView) {    var evelButtonText;    if (isMyAppWebView == true) { // 是我的app中的WebView      evelButtonText = "将上述最终地址，在app外打开，以测试从外部能否直接打开指定app的指定页面\n(外部可包括系统浏览器、微信、iPhone备忘录等)";    } else {  // 已在外部(包括系统浏览器、微信、iPhone备忘录等)      evelButtonText = "进入上述实际项目页，测试所选路由";    }    document.getElementById("evalButtonView").innerHTML = evelButtonText;  }</script><script>  // 初始化  // localStorage.setItem('vConsole_switch_x', 50)  // var vConsole = new VConsole();  // console.log('Hello world');  var _demoSectionArray;  var _h5CallBridgeActionDesArray = [];  // function readJson(url) {  //   var request = new XMLHttpRequest();  //   request.open("get", url);/*设置请求方法与路径*/  //   request.send(null);/*不发送数据到服务器*/  //   request.onload = function () {/*XHR对象获取到返回信息后执行*/  //     if (request.status == 200) {/*返回状态为200，即为数据获取成功*/  //       var json = JSON.parse(request.responseText);  //       for (var i = 0; i < json.length; i++) {  //         console.log(json[i].name);  //       }  //       console.log(json);  //       debugger  //     }  //   }  // }  function handleCloseDialog() {    document.querySelector(".dialog").classList.add("hide");    // copy(".msg")  }  function handleShowDialog() {    document.querySelector(".dialog").classList.remove("hide");  }  // function copy(id) {  //   var clipboard = new Clipboard(id);  //   clipboard.on('success', function (e) {  //     _showAlert("复制成功");  //     //可执行其他代码操作  //   });  //   clipboard.on('error', function () {  //     _showAlert("复制失败")  //   });  // }  function _showAlert(msg) {    handleShowDialog();    let t = document.querySelector(".msg");    t.innerHTML = msg;  }  function readJson(url) {    return new Promise((resolve, reject) => {      $.ajax({        url: url,//同文件夹下的json文件路径        type: "GET",//请求方式为get        dataType: "json", //返回数据格式为json        success: function (data) {//请求成功完成后要执行的方法           console.log(`读取${url}成功,数据data的值为\n${data}`);          console.log(`读取${url}成功,数据data转字符串后的值为\n${JSON.stringify(data)}`);          // var array = data;          // for (let index = 0; index < array.length; index++) { //循环后台传过来的Json数组           //   const element = array[index];          //   console.log(`data${index}:` + element);          //   console.log(`data${index}:` + element.h5CallBridgeActionDes);          // }          resolve(data);        },        error: function (err) {          // debugger // 断点调试          resolve(null);        }      })    })    // $.get('./test_h5js_demo.json', function (data) {    //   //读进了data变量中    //   //接下来用到data的代码必须全部在此函数内部进行    //   console.log("data:" + data);    // });    // d3.json('./test_h5js_demo.json', function (error, authordata) {    //   if (error) console.error(error);    //   //读进了authordata变量    //   //接下来用到authordata的代码必须全部在此函数内部进行    //   console.log("data:" + data);    // });    // if (window.FileReader) {    //   let reader = new FileReader();    //   let file = new File(    //     [blob],    //     url,    //     {    //       type: 'text/plain',    //     }    //   );    //   reader.readAsText(file);    //   reader.onload = function () {    //     console.log('读取成功');    //     var data = reader.result;   //base64形式的文件内容    //   };    //   reader.onerror = function () {    //     console.log('读取失败');    //     console.log(reader.error);    //   }    // } else {    //   console.log('你的浏览器不支持读取文件');    // }  }  async function initAppRouteData() { // 注意必须加 async ,否则函数内使用 await 会报错    console.log("查看是否有使用appRouteUrlValue参数,若无，则将使用本html的默认数据");    let url_param_appRouteUrl = getQueryString("appRouteUrlValue"); // 从浏览器的网页地址中读取 fileUrl 参数    console.log(`========url_param_appRouteUrl:${url_param_appRouteUrl}`);    if (url_param_appRouteUrl == null) {      _h5Action_updateText_forSubTitle("appRoute 数据来源于:本html内嵌");      var promptMessage = "未设置本html的appRouteUrlValue参数，则将使用本地默认的 appRouteElement 值";      var appRouteElement = getLocal_appRouteElement();      updateAppRouteUI(appRouteElement);    } else {      _h5Action_updateText_forSubTitle(`appRoute 数据来源于:本html浏览器网页地址中的 appRouteUrlValue=${url_param_appRouteUrl} 等参数`);      var dataJsonSuccess = _checkAppRouteDataJson();      if (dataJsonSuccess != true) {        return;      }    }  }  async function initData() { // 注意必须加 async ,否则函数内使用 await 会报错    console.log("查看是否有使用fileUrl或者h5CallBridgeActionName参数,若都无，则将使用本html的默认数据");    let url_param_fileUrl = getQueryString("fileUrl"); // 从浏览器的网页地址中读取 fileUrl 参数    console.log(`========url_param_fileUrl:${url_param_fileUrl}`);    let url_param_h5CallBridgeActionName = getQueryString("h5CallBridgeActionName"); // 从浏览器的网页地址中读取 h5CallBridgeActionName 参数    console.log(`========url_param_h5CallBridgeActionName:${url_param_h5CallBridgeActionName}`);    let url_param_h5CallBridgeActionDes = getQueryString("h5CallBridgeActionDes"); // 从浏览器的网页地址中读取 h5CallBridgeActionDes 参数    console.log(`========url_param_h5CallBridgeActionDes:${url_param_h5CallBridgeActionDes}【附：不能使用h5CallBridgeActionName的值，会出现当把此html放到app项目中加载本地html的时候，莫名出现h5CallBridgeActionName有值的情况，PS当前该值为${url_param_h5CallBridgeActionName}】`);    if (url_param_fileUrl == null && url_param_h5CallBridgeActionDes == null) {      _h5Action_updateText_forSubTitle("数据来源于:本html内嵌");      var promptMessage = "未设置本html的json文件路径,也未设置h5CallBridge参数，则将使用本地默认的 demoMapArray 值";      _demoSectionArray = getLocalDemoMapArray();      if (_demoSectionArray == null) { // 本html未将json文件的值赋值给 demoMapArray        localArrayResultMessage = `${promptMessage}:获取本地默认的 demoMapArray 失败❌\n请打开本html文件，检查demoMapArray的本地赋值是否正确`;        console.log(`${localArrayResultMessage}`);        _showErrorUI(localArrayResultMessage);        return;      } else {        localArrayResultMessage = `${promptMessage}:获取本地默认的 demoMapArray 成功✅`;        console.log(`${localArrayResultMessage}`);      }    } else {      if (url_param_fileUrl == null) {        _h5Action_updateText_forSubTitle(`数据来源于:本html浏览器网页地址中的 h5CallBridgeActionName=${url_param_h5CallBridgeActionName} 等参数`);        var dataJsonSuccess = _checkDataJson();        if (dataJsonSuccess != true) {          return;        }      } else {        _h5Action_updateText_forSubTitle("数据来源于:本html浏览器网页地址中的 fileUrl 参数");        var fileUrlSuccess = await _checkFileUrlUI(url_param_fileUrl);        if (fileUrlSuccess != true) {          return;        }      }    }    //     _showSuccessUI(_demoSectionArray);  }  initAppRouteData();  initData();  _isMyAppWebView = _getBrowserType();  console.log(`========_isMyAppWebView=${_isMyAppWebView}`);  _updateUITitleByCurrentBrowserType(_isMyAppWebView);  function _checkAppRouteDataJson() {    var promptMessage = "已设置本html的dataJson参数，则将获取使用哪些参数构造出只有一个元素的 demoMapArray 值";    var remoteArrayResultMessage = `${promptMessage}:获取浏览器地址指定的dataJson各参数的值来作为 demoMapArray 成功✅`;    console.log(`${remoteArrayResultMessage}`);    // 从浏览器的网页地址中读取 h5CallBridgeSendMessage 等参数    console.log("dataJson各参数获取后，但获取过程中内部已解码，值分别如下:")    let param_string_appRouteUrlDes = getQueryString("appRouteUrlDes");    let param_string_appRouteUrlValue = getQueryString("appRouteUrlValue");    console.log(`========param_string_appRouteUrlDes:${param_string_appRouteUrlDes}`);    console.log(`========param_string_appRouteUrlValue:${param_string_appRouteUrlValue}`);    var appRouteElement = {      "value": param_string_appRouteUrlValue,      "description": param_string_appRouteUrlDes    };    updateAppRouteUI(appRouteElement);    return true;  }  function _checkDataJson() {    var promptMessage = "已设置本html的dataJson参数，则将获取使用哪些参数构造出只有一个元素的 demoMapArray 值";    var remoteArrayResultMessage = `${promptMessage}:获取浏览器地址指定的dataJson各参数的值来作为 demoMapArray 成功✅`;    console.log(`${remoteArrayResultMessage}`);    // http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?h5CallBridgeActionDes=跳转到app指定页面_Name&h5CallBridgeActionName=h5CallBridgeAction_jumpAppPage&h5CallBridgeSendMessage={"pageName":"imChatPage","pageParams":{"conversationID":"126191","imUserId":"1602856363702501376","showName":"婉艺","type":1,"dialogSubjectId":"1506196208391966720"}}    // http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?h5CallBridgeActionDes=跳转到app指定页面_Name&h5CallBridgeActionName=h5CallBridgeAction_jumpAppPage&h5CallBridgeSendMessage=%7B%22pageName%22%3A%22imChatPage%22%2C%22pageParams%22%3A%7B%22conversationID%22%3A%22126191%22%2C%22imUserId%22%3A%221602856363702501376%22%2C%22showName%22%3A%22%E5%A9%89%E8%89%BA%22%2C%22type%22%3A1%2C%22dialogSubjectId%22%3A%221506196208391966720%22%7D%7D    // {    //     "h5CallBridgeActionDes": "跳转到app指定页面_Name",    //     "h5CallBridgeActionName": "h5CallBridgeAction_jumpAppPage",    //     "h5CallBridgeSendMessage": {    //       "pageName": "imChatPage",    //       "pageParams": {    //         "conversationID": "126191",    //         "imUserId": "1602856363702501376",    //         "showName": "婉艺",    //         "type": 1,    //         "dialogSubjectId": "1506196208391966720"    //       }    //     }    //   }    // 从浏览器的网页地址中读取 h5CallBridgeSendMessage 等参数    console.log("dataJson各参数获取后，但获取过程中内部已解码，值分别如下:")    let param_string_h5CallBridgeActionDes = getQueryString("h5CallBridgeActionDes");    let param_string_h5CallBridgeActionName = getQueryString("h5CallBridgeActionName");    let param_string_h5CallBridgeSendMessage = getQueryString("h5CallBridgeSendMessage");    console.log(`========param_string_h5CallBridgeActionDes:${param_string_h5CallBridgeActionDes}`);    console.log(`========param_string_h5CallBridgeActionName:${param_string_h5CallBridgeActionName}`);    console.log(`========param_string_h5CallBridgeSendMessage:${param_string_h5CallBridgeSendMessage}`);    // console.log("dataJson各参数解码后，值分别如下:")    // let param_decode_h5CallBridgeActionDes = decodeURIComponent(param_string_h5CallBridgeActionDes);    // let param_decode_h5CallBridgeActionName = decodeURIComponent(param_string_h5CallBridgeActionName);    // let param_decode_h5CallBridgeSendMessage = decodeURIComponent(param_string_h5CallBridgeSendMessage);    // console.log(`========param_decode_h5CallBridgeActionDes:${param_decode_h5CallBridgeActionDes}`);    // console.log(`========param_decode_h5CallBridgeActionName:${param_decode_h5CallBridgeActionName}`);    // console.log(`========param_decode_h5CallBridgeSendMessage:${param_decode_h5CallBridgeSendMessage}`);    // console.log("dataJson各参数解码后并转object模型，值分别如下:")    // let param_object_h5CallBridgeSendMessage = JSON.parse(param_decode_h5CallBridgeSendMessage);    // console.log(`========param_object_h5CallBridgeSendMessage:${param_object_h5CallBridgeSendMessage}`);    let demoMap1 = {      "h5CallBridgeActionDes": param_string_h5CallBridgeActionDes,      "h5CallBridgeActionName": param_string_h5CallBridgeActionName,      "h5CallBridgeSendMessage": param_string_h5CallBridgeSendMessage    };    _demoSectionArray = [      {        "sectionTitle": "通过给此html传入dataJson各参数，所以这里只有一个元素",        "sectionDatas": [          demoMap1        ],      }    ];    return true;  }  async function _checkFileUrlUI(fileUrl) { // 注意必须加 async ,否则函数内使用 await 会报错    // http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?fileUrl=http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.json    var promptMessage = "已设置本html的json文件路径，则将获取该路径下的json值作为 _demoSectionArray 值";    _demoSectionArray = await readJson(fileUrl);    if (_demoSectionArray == null) { // 本html未将json文件的值赋值给 demoMapArray      remoteArrayResultMessage = `${promptMessage}:获取浏览器地址指定的json文件${fileUrl}的值来作为 demoMapArray 失败❌，请根据以下可能原因检查`;      let fileUrlFailureReason1 = `失败可能原因1:路径${fileUrl}写错`;      let fileUrlFailureReasonLocal = "失败可能原因2:如果本html是本地直接打开的，则json文件的需手动拷贝到本html中(因为暂不支持读取本地的json文件)";      let fileUrlFailureReasonRemote = "失败可能原因3:如果本html是从网络地址上打开的，则fileUrl必须和本html的所在工程一致(因为暂不支持跨域访问)";      remoteArrayResultMessage = `${remoteArrayResultMessage}\n${fileUrlFailureReason1}\n${fileUrlFailureReasonLocal}\n${fileUrlFailureReasonRemote}`      console.log(`${remoteArrayResultMessage}`);      _showErrorUI(remoteArrayResultMessage);      return false;    } else {      remoteArrayResultMessage = `${promptMessage}:获取浏览器地址指定的json文件${fileUrl}的值来作为 demoMapArray 成功✅`;      console.log(`${remoteArrayResultMessage}`);      return true;    }  }  function _showErrorUI(errorMessage) {    let htmlStr = "";    var h5Action_warningButton_onClick = `_h5CallBridgeAction_alert("${errorMessage}");`;    var iButtonHtmlString = `<button onClick='${h5Action_warningButton_onClick}' style="width: 95%; height: 30px;">"${errorMessage}</button>`    htmlStr += `${iButtonHtmlString}`;    document.querySelector("#h5Action_updateTextAreaValue_buttons_div").innerHTML = htmlStr;  }  // 执行 h5 弹出错误提示的 alert  function _h5CallBridgeAction_alert(errorMessage) {    console.log(errorMessage);    alert(errorMessage);  }  function _showSuccessUI(demoSectionArray) {    console.log(`最终要显示的数据如下:\n demoSectionArray:${demoSectionArray}\n demoSectionArrayString:${JSON.stringify(demoSectionArray)}`);    // 当整个section非空时候，直接使用第一个可选操作元素    const firstSectionDatas = demoSectionArray[0]["sectionDatas"];    const firstElement = firstSectionDatas[0];    _useDirectlyWhenOnlyOneElement(firstElement);    var sectionCount = demoSectionArray.length;    if (sectionCount == 1 && firstSectionDatas.length == 1) {      return;    }    /// 当整个section不止一个元素的时候，罗列在界面上，供选择使用    let htmlStr = "";    for (let sectionIndex = 0; sectionIndex < sectionCount; sectionIndex++) {      const sectionElement = demoSectionArray[sectionIndex];      let sectionHtmlString = _getSectionHtmlString(sectionIndex, sectionElement["sectionDatas"]);      // let sectionHtmlString = `<div id="pageTilteView" style="text-align: center; font-size: 20px;">演示的section</div>`      var iSectionDivHtmlString = `      <div id='section_id_${sectionIndex}' style="width: 95%;">        <div style="width: 95%; background-color: ${sectionElement["sectionBG"]};">${sectionElement["sectionTitle"]}</div>        ${sectionHtmlString}      </div>      `      if (sectionIndex < sectionCount - 1) {        iSectionDivHtmlString += `<div style="height: 20px;"></div>`;      }      // console.log(`iSectionDivHtmlString${sectionIndex}=${iSectionDivHtmlString}`);      htmlStr += `${iSectionDivHtmlString}`;    }    document.querySelector("#h5Action_updateTextAreaValue_buttons_div").innerHTML = htmlStr;  }  /// 当整个section就只有一个元素的时候，直接使用  function _useDirectlyWhenOnlyOneElement(element) {    var unique_name = element["unique_name"];    _h5CallBridgeActionDesArray.push(unique_name);    // [JS字符串拼接的几种方式](https://blog.csdn.net/u012320487/article/details/123822785)    sectionIndex = 0;    rowIndex = 0;    var h5Action_updateTextAreaValue_onClick = `_h5Action_updateText_byIndex(${sectionIndex}, ${rowIndex});`;    // [js(JavaScript)字符串转换成变量名](https://huaweicloud.csdn.net/63a55da9b878a54545945264.html?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~activity-1-102934655-blog-92951596.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~activity-1-102934655-blog-92951596.pc_relevant_recovery_v2&utm_relevant_index=1)    // 利用 eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。    var funName = h5Action_updateTextAreaValue_onClick;    try {      eval(funName);    } catch (err) {      // console.log(`---------------err:${err}`);      _showAlert(err);    }  }  /// 根据标题，获取其整个数据模型  function _getElementByIndex(sectionIndex, rowIndex) {    // var index = _h5CallBridgeActionDesArray.indexOf(h5CallBridgeActionDes);    // var demoMap = _demoSectionArray[index];    var demoMap = _demoSectionArray[sectionIndex]["sectionDatas"][rowIndex];    return demoMap;  }  /// 更新 标题  function _h5Action_updateText_forSubTitle(dataFromSource) {    console.log(`更新UI上的副标题为:${dataFromSource}`);    document.getElementById("pageSubTilteView").innerHTML = `（${dataFromSource}）`;  }  /// 获取h5调用的app桥接方法名  function _h5Action_getAppRouteUrl() {    var sendMethod = document.getElementById("h5CallBridgeActionNameDataView").value;    return sendMethod;  }  /// 获取h5调用app桥接方法后，发送的数据  function _h5Action_getSendMessage() {    var sendMessage = document.getElementById("h5CallBridgeSendMessageDataView").value;    return sendMessage;  }  // 执行 h5调用app的桥接方法  function _h5CallBridgeAction_eval() {    // var funName = 'h5CallBridgeAction_showAppToast';    // var sendMessage = '恭喜您分享成功';    // h5CallBridgeAction_showAppToast.postMessage(sendMessage);    // [js(JavaScript)字符串转换成变量名](https://huaweicloud.csdn.net/63a55da9b878a54545945264.html?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~activity-1-102934655-blog-92951596.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~activity-1-102934655-blog-92951596.pc_relevant_recovery_v2&utm_relevant_index=1)    // 利用 eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。    var appRouteUrl = getElementValueById("directly_browserUrl_Value_valueView");;    // appRouteUrl = encodeURIComponent(appRouteUrl); // 注意: appRouteUrl 是 browserUrl 的参数，所以必须编码，否则当 appRouteUrl 中含有中文，或者对象的时候会造成无法打开网页的错误    if (_isMyAppWebView != true) {      window.location.href = './dvlp_h5_open_app_browser_url_demo.html';      return;    }    var funName = "h5CallBridgeAction_test_openBrowser";    var currentUrl = window.location.href;    var currentUrlWithoutParams = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;    console.log(`---------------currentUrl=\n${currentUrl},\n currentUrlWithoutParams=\n${currentUrlWithoutParams}`);    var browserUrl = `${currentUrlWithoutParams}?appRouteUrl=${appRouteUrl}`;    console.log(`---------------appRouteUrl:\n${appRouteUrl}`);    console.log(`---------------browserUrl:\n${browserUrl}`);    var sendMessageMap = { "isMyAppWebView": 0, "url": browserUrl };    var sendMessage = JSON.stringify(sendMessageMap);    try {      eval(funName).postMessage(sendMessage);    } catch (err) {      // console.log(`---------------err:${err}`);      _showAlert(err);    }    console.log(sendMessage.message);  }  // h5Action_share 分享内容到指定的分享方式(微信聊天页面等)  /*  function h5Action_updateTextAreaValue_share(webPageType) {    var url;    if (webPageType == '只是分享网页链接，没其他操作') {      url = "https://www.baidu.com";    } else if (webPageType == '分享链接，且链接可打开app的_原生页面') {      url = 'yuanwangwu://openpage?pageName=imChatPage&conversationID=126191&imUserId=1602856363702501376&showName=婉艺&type=1&dialogSubjectId=1506196208391966720';    } else if (webPageType == '分享链接，且链接可打开app的_网页游戏') {      var appOpenUrl = "yuanwangwu://openpage?pageName=farmGamePage&accountId=1475332557208702976";      // [js 对url进行编码和解码](https://blog.csdn.net/qq_42740797/article/details/111172160)      // appOpenUrl = encodeURIComponent(appOpenUrl); // 提示🤝：实际发现，不编码，也可打开      url = "http://test-h5.yuanwangwu.com/pages-h5/share/share-farm?&accountId=1475332557208702976&appurl=" + appOpenUrl;    } else {      url = "https://www.baidu.com";    }    var map = {      // "shareType": "Wechat_SESSION", // 分享方式      "shareWebPageUrl": url,      "shareTitle": "你的好友发来一条加急消息", // 分享标题      "shareDescription": "急急急，快来帮我转大转盘，100%中奖！", // 分享描述      "shareThumbnailUrl": "https://img1.baidu.com/it/u=1605341541,1182642759&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1673370000&t=4e694f8a257f10a7f6b52bd051288e7d",    };    var message = JSON.stringify(map);    _h5Action_updateText_forData('h5CallBridgeAction_share', message);  }  */  /// 提供给原生调用的h5方法(用于测试原生调用的方法及传递回来的返回值)  function bridgeCallH5Action_showCallbackJsonString(jsonString) {    if (jsonString == null || jsonString == undefined || !jsonString) {      _showAlert("没有回传的jsonString值");      return;    }    _showAlert(`回传的jsonString值为:${JSON.stringify(jsonString)}`);  }  /// 跳转到示例页面  function _h5Action_goDemoPage() {    window.location.href = '?fileUrl=dvlp_h5_open_app_demo.json';  }  function _h5Action_create(type) {    // _showAlert(type);    if (type == 'directly') {    } else if (type == 'custom') {      structureRouteUrlByCurrentText();    }  }</script></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5_open_app/dvlp_h5_open_app_app_route_url_demo/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5_open_app/dvlp_h5_open_app_app_route_url_demo/</url>
      
        <content type="html"><![CDATA[<!-- * @Author: dvlproad * @Date: 2022-12-27 11:59:38 * @LastEditors: dvlproad * @LastEditTime: 2023-02-16 14:42:33 * @Description: 调试h5与app交互的网页demo--><!--一、使用fileUrl参数1、本地服务器测试url1:  http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?参数如下eg中的值eg1.1: fileUrl=dvlp_h5js_demo.jsoneg1.2: fileUrl=http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.json2、远程服务器测试url2:  https://dvlproad.github.io/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?参数如下eg中的值eg2.1: fileUrl=dvlp_h5js_demo.jsoneg2.2: fileUrl=https://dvlproad.github.io/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.jsoneg2.3(测试跨域): fileUrl=https://raw.githubusercontent.com/dvlproad/dvlproad.github.io/master/Architecture%E6%9E%B6%E6%9E%84/h5js/dvlp_h5js_demo/dvlp_h5js_demo.jsoneg2.4(测试跨域): eg2.5(测试跨域): 二、使用各种dataJson参数1、本地服务器测试url1:  http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?参数如下eg中的值eg1.1(未编码h5CallBridgeSendMessage，在浏览器中验证可以。但在app中不行，必须对每个参数编码后再赋值，以避免参数中含中文或者对象): h5CallBridgeActionDes=跳转到app指定页面_Name&h5CallBridgeActionName=h5CallBridgeAction_jumpAppPage&h5CallBridgeSendMessage={"pageName":"imChatPage","pageParams":{"conversationID":"126191","imUserId":"1602856363702501376","showName":"婉艺","type":1,"dialogSubjectId":"1506196208391966720"}}eg1.2(有编码h5CallBridgeSendMessage，验证可以): h5CallBridgeActionDes=跳转到app指定页面_Name&h5CallBridgeActionName=h5CallBridgeAction_jumpAppPage&h5CallBridgeSendMessage=%7B%22pageName%22%3A%22imChatPage%22%2C%22pageParams%22%3A%7B%22conversationID%22%3A%22126191%22%2C%22imUserId%22%3A%221602856363702501376%22%2C%22showName%22%3A%22%E5%A9%89%E8%89%BA%22%2C%22type%22%3A1%2C%22dialogSubjectId%22%3A%221506196208391966720%22%7D%7D--><!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0">  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">  <title>html demo</title></head><style>  .div_spearte {    height: 16px;  }  .button_half_width {    background-color: red;    color: white;    border-width: 0;    width: 45%;    font-size: 12px;  }  .button_full_width {    background-color: red;    color: white;    border-width: 0;    width: 45%;    font-size: 20px;  }  .title1 {    color: red;    font-size: 14px;    padding-left: 10px;  }  .title1 .title2 {    color: blue;    font-size: 12px;  }  .textarea_one_line {    width: 95%;    height: 16px;  }  .textarea_decription_multiline {    width: 95%;    height: 80px;  }  .textarea_one_appRouteUrl {    width: 95%;    height: 70px;  }  .textarea_one_browseUrl {    width: 95%;    height: 80px;  }</style><style>  .hide {    display: none !important;  }  .dialog {    position: absolute;    top: 0;    left: 0;    width: 100vw;    height: 100vh;    background-color: rgba(0, 0, 0, 0.6);    display: flex;    justify-content: center;    align-items: center;  }  .dialog .content {    background: white;    padding: 30px 20px;  }  .dialog .content .msg {    font-size: 16px;  }  .dialog .content .close-btn {    margin-top: 10px;    width: 100px;    height: 36px;    background-color: #fff;    border: 1px solid blue;    font-size: 14px;    color: blue;  }</style><body>  <div class="dialog hide">    <div class="content">      <div class="msg" id="msg">消息内容</div>      <button class="close-btn" onclick="handleCloseDialog()">我知道了</button>    </div>  </div>  <div id="pageTilteView" style="text-align: center; font-size: 20px;">    路由生成器    <button onclick="_h5Action_goDemoPage()" style="font-size: 12px;">查看示例</button>  </div>  <div id="pageSubTilteView" style="text-align: center; font-size: 14px;">数据来源于：xxx</div>    <div class="div_spearte"></div>  <div id="h5OpenAppUrlCreate_type_custom_url">自己生成    <button class="button_half_width" onclick="_h5Action_create('custom')">从demo中(底部)选择</button>    <div class="title1">1、应用标识：      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_name_titleView">scheme值：</div>      <textarea class="textarea_one_line" id="custom_browserUrl_main_Value_valueView">scheme值</textarea>      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_name_titleView">scheme介绍：</div>      <textarea class="textarea_one_line" id="custom_browserUrl_main_Description_valueView">scheme介绍</textarea>    </div>    <div class="title1"> 2、应用路径      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_name_titleView">path值：</div>      <textarea class="textarea_one_line" id="custom_browserUrl_appRouteUrlValue_valueView">path值</textarea>      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_headerView">path介绍：</div>      <textarea class="textarea_one_line" id="custom_browserUrl_appRouteUrl_Description_valueView">path介绍</textarea>    </div>    <div class="title1">3、应用路径参数      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_name_titleView">argument值：</div>      <textarea class="textarea_one_line" id="custom_browserUrl_otherKeyAndValues_valueView">{"inviteCode":"123"}</textarea>      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_name_titleView">argument介绍：</div>      <textarea class="textarea_decription_multiline" id="custom_browserUrl_otherKeyAndValues_Description_valueView">{"inviteCode":"邀请码"}</textarea>    </div>  </div>  <div class="div_spearte"></div>  <div>    <button class="button_half_width" id="h5OpenAppUrlCreate_type_directly" onclick="_h5Action_create('custom')">生成/构成      routeUrl</button>  </div>  <div class="div_spearte"></div>  <div id="h5OpenAppUrlCreate_type_custom_url">直接地址    <div class="title1"> 最终构成      <div class="title2" id="h5OpenAppUrlCreate_type_custom_url_name_titleView">最终路由地址：</div>      <textarea class="textarea_one_browseUrl" id="directly_browserUrl_Value_valueView">最终路由地址</textarea>    </div>  </div>  <div id="h5OpenAppUrlCreate_type_custom_url">下一步，请从下方选择你的测试方式：    <button id="evalButtonView2" onclick="_chooseAppRouteUrlTestType_copyToOther()" style="background-color: red; color: white; width: 95%; border-width: 0; font-size: 20px;">1、复制链接到其他地方：自己粘贴后点击测试跳转</button>    <button id="evalButtonView1" onclick="_chooseAppRouteUrlTestType_testToolPage()" style="background-color: red; color: white; width: 95%; border-width: 0; font-size: 20px;">2、在此工具页面直接测试：点击后将直接测试跳转</button>    <button id="evalButtonView3" onclick="_chooseAppRouteUrlTestType_goToProductPage()" style="background-color: red; color: white; width: 95%; border-width: 0; font-size: 20px;">3、将路由值传参到到项目中指定页面进行测试跳转</button>  </div>  <!-- <div>分享内容到指定的分享方式(微信聊天页面等)</div>  <button    onclick="h5Action_updateTextAreaValue_share('只是分享网页链接，没其他操作')">'硬编码的按钮：只是分享网页链接，没其他操作'</button>  <button    onclick="h5Action_updateTextAreaValue_share('分享链接，且链接可打开app的_原生页面')">'硬编码的按钮：分享链接，且链接可打开app的_原生页面'</button>  <button    onclick="h5Action_updateTextAreaValue_share('分享链接，且链接可打开app的_网页游戏')">'硬编码的按钮：分享链接，且链接可打开app的_网页游戏'</button> -->  <div id="h5Action_updateTextAreaValue_buttons_div"></div></body><!-- [移动端调试神器vConsole使用详解](https://www.jb51.net/article/244750.htm) --><script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script><script>  // VConsole 默认会挂载到 `window.VConsole` 上  var vConsole = new window.VConsole();  // 接下来即可照常使用 `console` 等方法  console.log('Hello world');  // 结束调试后，可移除掉  vConsole.destroy();</script><!-- [引入jquery.js 修复出现的错误：ReferenceError: $ is not defined](https://blog.csdn.net/lq_ruonan/article/details/53690960) --><script src="https://code.jquery.com/jquery-3.6.3.js" type="text/javascript" charset="utf-8"></script><!-- <script src="js/jQuery.js" type="text/javascript" charset="utf-8"></script> --><!-- <script src="../../../HTML/common_js/object_util.js" type="text/javascript" charset="utf-8"></script><script src="../../../HTML/common_js/url_util.js" type="text/javascript" charset="utf-8"></script><script src="http://localhost:4000/HTML/common_js/object_util.js" type="text/javascript" charset="utf-8"></script><script src="http://localhost:4000/HTML/common_js/url_util.js" type="text/javascript" charset="utf-8"></script>--><script>  // [js 删除Object中指定的key](https://blog.csdn.net/weixin_39501680/article/details/123110404)  const isObject = (obj) => obj === Object(obj)  const isNil = (val) => val === undefined || val === null  const isEmpty = (val) => {    return isString(val) || isObject(val) || Array.isArray(val) ?      !Object.keys(val).length : isNil(val)  }  const isString = (val) => typeof val === 'string'  const deleteObjectByKey = (obj = {}, arr = []) => {    if (isEmpty(obj) || !isObject(obj)) return {}    if (isEmpty(arr) || (!Array.isArray(arr) && !isString(arr))) return obj    return Object.keys(obj)      .filter((k) => !arr.includes(k))      .reduce((acc, key) => ((acc[key] = obj[key]), acc), {})  }</script><script>  /// 获取指定地址的主地址  function getRequestUrlMain(browserUrl) {    if (browserUrl == null || browserUrl == "" || typeof browserUrl == "undefined") {      var url = decodeURI(location.search);  //获取url中"?"符后的字串    } else {      var url = browserUrl;    }    var url_main;    var paramStartIndex = url.indexOf("?");    if (paramStartIndex != -1) {      // [js中截取字符串的三个方法 substring()、substr()、slice()](https://segmentfault.com/a/1190000016387899)      url_main = url.substring(0, paramStartIndex);    } else {      url_main = url;    }    return url_main;  }  /// 获取指定地址的所有参数  function getRequestUrlParams(browserUrl) {    if (browserUrl == null || browserUrl == "" || typeof browserUrl == "undefined") {      var url = decodeURI(location.search);  //获取url中"?"符后的字串    } else {      var url = browserUrl;    }    var theRequest = new Map();    var paramStartIndex = url.indexOf("?");    if (paramStartIndex != -1) {      var str = url.substr(paramStartIndex + 1);      strs = str.split("&");      for (var i = 0; i < strs.length; i++) {        var keyValueComponent = strs[i].split("=");        var key = keyValueComponent[0];        var value = keyValueComponent[1];        theRequest[key] = unescape(value);      }    }    return theRequest;  }  // [js获取url中的中文参数出现乱码解决](https://www.codeleading.com/article/87533774933/)  // "http://localhost:4000/Architecture%E6%9E%B6%E6%9E%84/h5js/dvlp_h5js_demo/dvlp_h5js_demo.json"; // url含中文示例  // "http://localhost/test/test.html?p=广东&c=珠海"  function getValueByQueryKey(browserUrl, key) {    // 获取参数    if (browserUrl == null || browserUrl == "" || typeof browserUrl == "undefined") {      var url = decodeURI(location.search);  //获取url中"?"符后的字串      // var url = window.location.search; // 在本地用file打开，而不是http打开的话，此值会为空    } else {      var url = browserUrl;    }    // 正则筛选地址栏    var reg = new RegExp("(^|&)" + key + "=([^&]*)(&|$)");    // 匹配目标参数    var result = url.substr(1).match(reg);    //返回参数值    // return result ? unescape(result[2]) : null; // url中含中文时候，取值会出错    return result ? decodeURIComponent(result[2]) : null;  }  /// 获取本页面指定参数key的值  function getQueryString(key) {    var url = window.location.search; // 在本地用file打开，而不是http打开的话，此值会为空    return getValueByQueryKey(url, key);  }</script><script>  /// 为 oldUrl 添加 newParams 参数，返回新url  function addParamsForUrl(oldUrl, newParams) {    if (newParams == null || newParams == {} || typeof newParams == "undefined") {      return oldUrl;    }    var keys = Object.keys(newParams); // 获取map的所有keys    console.log(`keys=${keys}`);    var count = keys.length;    // var count = oldUrl.size;    var newParamsString = '';    for (var i = 0; i < count; i++) {      var key = keys[i];      var value = newParams[key];      if (i > 0) {        newParamsString += '&';      }      newParamsString += `${key}=${value}`;    }        var paramStartIndex = oldUrl.indexOf("?");    var connectorFlag;    if (paramStartIndex != -1) {      connectorFlag = '&';    } else {      connectorFlag = '?';    }    return `${oldUrl}${connectorFlag}${newParamsString}`;  }</script><script>  function getLocalDemoMapArray() {    // _browserUrl = "http://www.baidu.com/index.com?inviteCode=123&appRouteUrl=yuanwangwu://openpage?pageName=webNavPage&url=https://farm-game.yuanwangwu.com/index.html&shouldHideNavBar=true&inviteCode=123";    // _browserUrl_appRouteUrlKey = "appRouteUrl";    // analysisBrowserUrl(_browserUrl, "appRouteUrl");    var structureElementArray = [      {        "sectionTitle": "跳转到app内的指定页面",        "sectionDatas": [          {            "unique_name": "打开XXXapp_聊天页面_1",            "scheme": {              "value": "yuanwangwu",              "description": "打开XXXapp"            },            "path": {              "value": "imChatPage",              "description": "聊天页面"            },            "argument": {              "value": {                "inviteCode": 123              },              "description": {                "inviteCode": "邀请码"              }            }          },          {            "unique_name": "打开XXXapp_网络页面_2",            "scheme": {              "value": "yuanwangwu",              "description": "打开XXXapp"            },            "path": {              "value": "webNavPage",              "description": "网络页面"            },            "argument": {              "value": {                "url": "https://www.baidu.com"              },              "description": {                "url": "百度网页"              }            }          }        ]      }    ];    // return null; // 测试本地未赋值时候的界面展示    return structureElementArray;  }</script><script>  /// 解析浏览器地址，并更新到解析器UI  function analysisBrowserUrl(browserUrl, browserUrl_appRouteUrlKey) {    // 构造器    updateElementValueById("directly_browserUrl_Description_valueView", "未标明");    updateElementValueById("directly_browserUrl_appRouteUrlKey_valueView", browserUrl_appRouteUrlKey);    updateElementValueById("directly_browserUrl_Value_valueView", browserUrl);    // 解析器    // 1、主地址信息    _browserUrl_main = getRequestUrlMain(browserUrl);    updateElementValueById("custom_browserUrl_main_Value_valueView", _browserUrl_main);    updateElementValueById("custom_browserUrl_main_Description_valueView", "未标明");    // 2、app参数信息    _browserUrl_appRouteUrlKey = browserUrl_appRouteUrlKey;    updateElementValueById("custom_browserUrl_appRouteUrlUseKey_valueView", _browserUrl_appRouteUrlKey);    _browserUrl_appRouteUrlValue = getValueByQueryKey(browserUrl, browserUrl_appRouteUrlKey);    updateElementValueById("custom_browserUrl_appRouteUrlValue_valueView", _browserUrl_appRouteUrlValue);    updateElementValueById("custom_browserUrl_appRouteUrl_Description_valueView", "未标明");    // 3、其他参数信息    var browserUrl_params = getRequestUrlParams(browserUrl);    // var keys = Object.keys(browserUrl_params); // 获取map的所有keys    // console.log(`keys=${keys}`);    if (typeof browserUrl_appRouteUrlKey == "undefined" || browserUrl_appRouteUrlKey == null) {      _browserUrl_otherKeyAndValues = browserUrl_params;    } else {      _browserUrl_otherKeyAndValues = deleteObjectByKey(browserUrl_params, [browserUrl_appRouteUrlKey]);    }    updateElementValueById("custom_browserUrl_otherKeyAndValues_valueView", JSON.stringify(_browserUrl_otherKeyAndValues));    updateElementValueById("custom_browserUrl_otherKeyAndValues_Description_valueView", "未标明");  }  /// 更新 h5调用的app桥接方法名 和  h5调用app桥接方法后，发送的数据  function _h5Action_updateText_byIndex(sectionIndex, rowIndex) {    var element = _getElementByIndex(sectionIndex, rowIndex);    console.log(`-------当前所选择的值${sectionIndex}.${rowIndex}-------element=${element},elementString=${JSON.stringify(element)}`);    structureRouteUrl(element);  }  /// 根据当前文本框内容，构造 element 元素值  function _getElementByCurrentText() {    var element = {      "unique_name": "打开XXXapp_聊天页面_1",      "scheme": {        "value": getElementValueById("custom_browserUrl_main_Value_valueView"),        "description": getElementValueById("custom_browserUrl_main_Description_valueView")      },      "path": {        "value": getElementValueById("custom_browserUrl_appRouteUrlValue_valueView"),        "description": getElementValueById("custom_browserUrl_appRouteUrl_Description_valueView")      },      "argument": {        "value": getElementValueById("custom_browserUrl_otherKeyAndValues_valueView"),        "description": getElementValueById("custom_browserUrl_otherKeyAndValues_Description_valueView")      }    };    return element;  }  /// 根据当前文本框内容，构造浏览器地址，并更新到构造器UI  function structureRouteUrlByCurrentText() {    var element = _getElementByCurrentText();    structureRouteUrl(element);  }  /// 根据选中的元素，构造浏览器地址，并更新到构造器UI  function structureRouteUrl(element) {    // 先把元素更新到解析器    // 1、主地址信息    updateElementValueById("custom_browserUrl_main_Value_valueView", element["scheme"]["value"]);    updateElementValueById("custom_browserUrl_main_Description_valueView", element["scheme"]["description"]);    // 2、app参数信息    updateElementValueById("custom_browserUrl_appRouteUrlValue_valueView", element["path"]["value"]);    updateElementValueById("custom_browserUrl_appRouteUrl_Description_valueView", element["path"]["description"]);    // 3、其他参数信息    updateElementValueById("custom_browserUrl_otherKeyAndValues_valueView", element["argument"]["value"]);    updateElementValueById("custom_browserUrl_otherKeyAndValues_Description_valueView", element["argument"]["description"]);    // 把各个元素整合并更新结果    _updateResultUI();  }  /// 构造浏览器地址，并更新到构造器UI  function _updateResultUI() {    // 获取文本框内容    var route_scheme = document.getElementById("custom_browserUrl_main_Value_valueView").value;    // var browserUrl_appRouteUrlKey = document.getElementById("custom_browserUrl_appRouteUrlUseKey_valueView").value;    var route_path = document.getElementById("custom_browserUrl_appRouteUrlValue_valueView").value;    var route_argument_string = document.getElementById("custom_browserUrl_otherKeyAndValues_valueView").value;    var route_argument = JSON.parse(route_argument_string);    // 构造文本框值    var routeUrl = `${route_scheme}://`;    routeUrl += `${route_path}`;    if (route_argument != null) {      routeUrl = addParamsForUrl(routeUrl, route_argument);    }    // 更新构造器UI    updateElementValueById("directly_browserUrl_Value_valueView", routeUrl);  }  function _getSectionHtmlString(sectionIndex, demoMapArray) {    console.log(`${sectionIndex}当前区要显示的数据如下:\n demoMapArray:${demoMapArray}\n demoMapArrayString:${JSON.stringify(demoMapArray)}`);    let sectionHtmlString = "";    var demoMapCount = demoMapArray.length;    for (let rowIndex = 0; rowIndex < demoMapCount; rowIndex++) {      const element = demoMapArray[rowIndex];      var unique_name = element["unique_name"];      _h5CallBridgeActionDesArray.push();      // [JS字符串拼接的几种方式](https://blog.csdn.net/u012320487/article/details/123822785)      var h5Action_updateTextAreaValue_onClick = `_h5Action_updateText_byIndex(${sectionIndex}, ${rowIndex});`;      var iButtonHtmlString = `<button onClick='${h5Action_updateTextAreaValue_onClick}' style="width: 95%; height: 30px;">${sectionIndex + 1}.${rowIndex + 1}.${unique_name}</button>`      if (rowIndex > 0) {        // htmlStr += `<>`;      }      console.log(`iButtonHtmlString${rowIndex}=${iButtonHtmlString} element=${JSON.stringify(element)}`);      sectionHtmlString += `${iButtonHtmlString}`;    }    return sectionHtmlString;  }</script><script>  function updateElementValueById(id, value) {    if (typeof value == 'string') {      //     } else {      value = JSON.stringify(value);    }    document.getElementById(id).innerHTML = '' + `${value}`;  }  function getElementValueById(id) {    return document.getElementById(id).value;  }</script><script>  var _isMyAppWebView; // 是否是我们开发的app中内嵌的webView(还是其他app里，或者pc上的)  /// 获取当前浏览器类型  function _getBrowserType() {    return getQueryString("isMyAppWebView") == 1;  }  /// 根据当前浏览器类型更新UI页面的标题  function _updateUITitleByCurrentBrowserType(isMyAppWebView) {    var evelButtonText;    if (isMyAppWebView == true) { // 是我的app中的WebView      // 请先确保此测试工具页面是在外部浏览器中打开的(目前还不是)。      evelButtonText = "将上述最终地址，在app外打开，以测试从外部能否直接打开指定app的指定页面\n(外部可包括系统浏览器、微信、iPhone备忘录等)";    } else {  // 已在外部(包括系统浏览器、微信、iPhone备忘录等)      evelButtonText = "2、在此工具页面直接测试：点击后将直接测试跳转";    }    evelButtonText = "2、在此工具页面直接测试：点击后将直接测试跳转";    document.getElementById("evalButtonView1").innerHTML = evelButtonText;  }</script><script>  // 初始化  // localStorage.setItem('vConsole_switch_x', 50)  // var vConsole = new VConsole();  // console.log('Hello world');  var _demoSectionArray;  var _h5CallBridgeActionDesArray = [];  // function readJson(url) {  //   var request = new XMLHttpRequest();  //   request.open("get", url);/*设置请求方法与路径*/  //   request.send(null);/*不发送数据到服务器*/  //   request.onload = function () {/*XHR对象获取到返回信息后执行*/  //     if (request.status == 200) {/*返回状态为200，即为数据获取成功*/  //       var json = JSON.parse(request.responseText);  //       for (var i = 0; i < json.length; i++) {  //         console.log(json[i].name);  //       }  //       console.log(json);  //       debugger  //     }  //   }  // }  function handleCloseDialog() {    document.querySelector(".dialog").classList.add("hide");    // copy(".msg")  }  function handleShowDialog() {    document.querySelector(".dialog").classList.remove("hide");  }  // function copy(id) {  //   var clipboard = new Clipboard(id);  //   clipboard.on('success', function (e) {  //     _showAlert("复制成功");  //     //可执行其他代码操作  //   });  //   clipboard.on('error', function () {  //     _showAlert("复制失败")  //   });  // }  function _showAlert(msg) {    handleShowDialog();    let t = document.querySelector(".msg");    t.innerHTML = msg;  }  function readJson(url) {    return new Promise((resolve, reject) => {      $.ajax({        url: url,//同文件夹下的json文件路径        type: "GET",//请求方式为get        dataType: "json", //返回数据格式为json        success: function (data) {//请求成功完成后要执行的方法           console.log(`读取${url}成功,数据data的值为\n${data}`);          console.log(`读取${url}成功,数据data转字符串后的值为\n${JSON.stringify(data)}`);          // var array = data;          // for (let index = 0; index < array.length; index++) { //循环后台传过来的Json数组           //   const element = array[index];          //   console.log(`data${index}:` + element);          //   console.log(`data${index}:` + element.h5CallBridgeActionDes);          // }          resolve(data);        },        error: function (err) {          // debugger // 断点调试          resolve(null);        }      })    })    // $.get('./test_h5js_demo.json', function (data) {    //   //读进了data变量中    //   //接下来用到data的代码必须全部在此函数内部进行    //   console.log("data:" + data);    // });    // d3.json('./test_h5js_demo.json', function (error, authordata) {    //   if (error) console.error(error);    //   //读进了authordata变量    //   //接下来用到authordata的代码必须全部在此函数内部进行    //   console.log("data:" + data);    // });    // if (window.FileReader) {    //   let reader = new FileReader();    //   let file = new File(    //     [blob],    //     url,    //     {    //       type: 'text/plain',    //     }    //   );    //   reader.readAsText(file);    //   reader.onload = function () {    //     console.log('读取成功');    //     var data = reader.result;   //base64形式的文件内容    //   };    //   reader.onerror = function () {    //     console.log('读取失败');    //     console.log(reader.error);    //   }    // } else {    //   console.log('你的浏览器不支持读取文件');    // }  }  /// 处理协议跳转  /// 规则说明：  /// yuanwangwu://openpage?pageName=XXXX&orderId=XXXXX  /// 如果是从外部h5跳转app使用 yuanwangwu://openpage?pageName=webPage&url=URLEncode(http://www.baidyu.com)  /// 例：yuanwangwu://openpage?pageName=webPage&url=http%3A%2F%2Fwww.baidu.com  /// 如果是跳转到内部页面 使用：yuanwangwu://openpage?pageName=XXXXXX&id=XXX  /// 例：yuanwangwu://openpage?pageName=testPage&id=123  /// 如果是跳转【微信小程序】 使用：yuanwangwu://openpage?pageName=mp&path=URLEncode(XXX)  /// 例：略  // var message = 'yuanwangwu://openpage?pageName=webPage&url=URLEncode(http://www.baidu.com)';  async function initData() { // 注意必须加 async ,否则函数内使用 await 会报错    console.log("查看是否有使用fileUrl或者h5CallBridgeActionName参数,若都无，则将使用本html的默认数据");    let url_param_fileUrl = getQueryString("fileUrl"); // 从浏览器的网页地址中读取 fileUrl 参数    console.log(`========url_param_fileUrl:${url_param_fileUrl}`);    let url_param_h5CallBridgeActionName = getQueryString("h5CallBridgeActionName"); // 从浏览器的网页地址中读取 h5CallBridgeActionName 参数    console.log(`========url_param_h5CallBridgeActionName:${url_param_h5CallBridgeActionName}`);    let url_param_h5CallBridgeActionDes = getQueryString("h5CallBridgeActionDes"); // 从浏览器的网页地址中读取 h5CallBridgeActionDes 参数    console.log(`========url_param_h5CallBridgeActionDes:${url_param_h5CallBridgeActionDes}【附：不能使用h5CallBridgeActionName的值，会出现当把此html放到app项目中加载本地html的时候，莫名出现h5CallBridgeActionName有值的情况，PS当前该值为${url_param_h5CallBridgeActionName}】`);    if (url_param_fileUrl == null && url_param_h5CallBridgeActionDes == null) {      _h5Action_updateText_forSubTitle("数据来源于:本html内嵌");      var promptMessage = "未设置本html的json文件路径,也未设置h5CallBridge参数，则将使用本地默认的 demoMapArray 值";      _demoSectionArray = getLocalDemoMapArray();      if (_demoSectionArray == null) { // 本html未将json文件的值赋值给 demoMapArray        localArrayResultMessage = `${promptMessage}:获取本地默认的 demoMapArray 失败❌\n请打开本html文件，检查demoMapArray的本地赋值是否正确`;        console.log(`${localArrayResultMessage}`);        _showErrorUI(localArrayResultMessage);        return;      } else {        localArrayResultMessage = `${promptMessage}:获取本地默认的 demoMapArray 成功✅`;        console.log(`${localArrayResultMessage}`);      }    } else {      if (url_param_fileUrl == null) {        _h5Action_updateText_forSubTitle(`数据来源于:本html浏览器网页地址中的 h5CallBridgeActionName=${url_param_h5CallBridgeActionName} 等参数`);        var dataJsonSuccess = _checkDataJson();        if (dataJsonSuccess != true) {          return;        }      } else {        _h5Action_updateText_forSubTitle("数据来源于:本html浏览器网页地址中的 fileUrl 参数");        var fileUrlSuccess = await _checkFileUrlUI(url_param_fileUrl);        if (fileUrlSuccess != true) {          return;        }      }    }    //     _showSuccessUI(_demoSectionArray);  }  initData();  _isMyAppWebView = _getBrowserType();  console.log(`========_isMyAppWebView=${_isMyAppWebView}`);  _updateUITitleByCurrentBrowserType(_isMyAppWebView);  function _checkDataJson() {    var promptMessage = "已设置本html的dataJson参数，则将获取使用哪些参数构造出只有一个元素的 demoMapArray 值";    var remoteArrayResultMessage = `${promptMessage}:获取浏览器地址指定的dataJson各参数的值来作为 demoMapArray 成功✅`;    console.log(`${remoteArrayResultMessage}`);    // http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?h5CallBridgeActionDes=跳转到app指定页面_Name&h5CallBridgeActionName=h5CallBridgeAction_jumpAppPage&h5CallBridgeSendMessage={"pageName":"imChatPage","pageParams":{"conversationID":"126191","imUserId":"1602856363702501376","showName":"婉艺","type":1,"dialogSubjectId":"1506196208391966720"}}    // http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?h5CallBridgeActionDes=跳转到app指定页面_Name&h5CallBridgeActionName=h5CallBridgeAction_jumpAppPage&h5CallBridgeSendMessage=%7B%22pageName%22%3A%22imChatPage%22%2C%22pageParams%22%3A%7B%22conversationID%22%3A%22126191%22%2C%22imUserId%22%3A%221602856363702501376%22%2C%22showName%22%3A%22%E5%A9%89%E8%89%BA%22%2C%22type%22%3A1%2C%22dialogSubjectId%22%3A%221506196208391966720%22%7D%7D    // {    //     "h5CallBridgeActionDes": "跳转到app指定页面_Name",    //     "h5CallBridgeActionName": "h5CallBridgeAction_jumpAppPage",    //     "h5CallBridgeSendMessage": {    //       "pageName": "imChatPage",    //       "pageParams": {    //         "conversationID": "126191",    //         "imUserId": "1602856363702501376",    //         "showName": "婉艺",    //         "type": 1,    //         "dialogSubjectId": "1506196208391966720"    //       }    //     }    //   }    // 从浏览器的网页地址中读取 h5CallBridgeSendMessage 等参数    console.log("dataJson各参数获取后，但获取过程中内部已解码，值分别如下:")    let param_string_h5CallBridgeActionDes = getQueryString("h5CallBridgeActionDes");    let param_string_h5CallBridgeActionName = getQueryString("h5CallBridgeActionName");    let param_string_h5CallBridgeSendMessage = getQueryString("h5CallBridgeSendMessage");    console.log(`========param_string_h5CallBridgeActionDes:${param_string_h5CallBridgeActionDes}`);    console.log(`========param_string_h5CallBridgeActionName:${param_string_h5CallBridgeActionName}`);    console.log(`========param_string_h5CallBridgeSendMessage:${param_string_h5CallBridgeSendMessage}`);    // console.log("dataJson各参数解码后，值分别如下:")    // let param_decode_h5CallBridgeActionDes = decodeURIComponent(param_string_h5CallBridgeActionDes);    // let param_decode_h5CallBridgeActionName = decodeURIComponent(param_string_h5CallBridgeActionName);    // let param_decode_h5CallBridgeSendMessage = decodeURIComponent(param_string_h5CallBridgeSendMessage);    // console.log(`========param_decode_h5CallBridgeActionDes:${param_decode_h5CallBridgeActionDes}`);    // console.log(`========param_decode_h5CallBridgeActionName:${param_decode_h5CallBridgeActionName}`);    // console.log(`========param_decode_h5CallBridgeSendMessage:${param_decode_h5CallBridgeSendMessage}`);    // console.log("dataJson各参数解码后并转object模型，值分别如下:")    // let param_object_h5CallBridgeSendMessage = JSON.parse(param_decode_h5CallBridgeSendMessage);    // console.log(`========param_object_h5CallBridgeSendMessage:${param_object_h5CallBridgeSendMessage}`);    let demoMap1 = {      "h5CallBridgeActionDes": param_string_h5CallBridgeActionDes,      "h5CallBridgeActionName": param_string_h5CallBridgeActionName,      "h5CallBridgeSendMessage": param_string_h5CallBridgeSendMessage    };    _demoSectionArray = [      {        "sectionTitle": "通过给此html传入dataJson各参数，所以这里只有一个元素",        "sectionDatas": [          demoMap1        ],      }    ];    return true;  }  async function _checkFileUrlUI(fileUrl) { // 注意必须加 async ,否则函数内使用 await 会报错    // http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?fileUrl=http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.json    var promptMessage = "已设置本html的json文件路径，则将获取该路径下的json值作为 _demoSectionArray 值";    _demoSectionArray = await readJson(fileUrl);    if (_demoSectionArray == null) { // 本html未将json文件的值赋值给 demoMapArray      remoteArrayResultMessage = `${promptMessage}:获取浏览器地址指定的json文件${fileUrl}的值来作为 demoMapArray 失败❌，请根据以下可能原因检查`;      let fileUrlFailureReason1 = `失败可能原因1:路径${fileUrl}写错`;      let fileUrlFailureReasonLocal = "失败可能原因2:如果本html是本地直接打开的，则json文件的需手动拷贝到本html中(因为暂不支持读取本地的json文件)";      let fileUrlFailureReasonRemote = "失败可能原因3:如果本html是从网络地址上打开的，则fileUrl必须和本html的所在工程一致(因为暂不支持跨域访问)";      remoteArrayResultMessage = `${remoteArrayResultMessage}\n${fileUrlFailureReason1}\n${fileUrlFailureReasonLocal}\n${fileUrlFailureReasonRemote}`      console.log(`${remoteArrayResultMessage}`);      _showErrorUI(remoteArrayResultMessage);      return false;    } else {      remoteArrayResultMessage = `${promptMessage}:获取浏览器地址指定的json文件${fileUrl}的值来作为 demoMapArray 成功✅`;      console.log(`${remoteArrayResultMessage}`);      return true;    }  }  function _showErrorUI(errorMessage) {    let htmlStr = "";    var h5Action_warningButton_onClick = `_h5CallBridgeAction_alert("${errorMessage}");`;    var iButtonHtmlString = `<button onClick='${h5Action_warningButton_onClick}' style="width: 95%; height: 30px;">"${errorMessage}</button>`    htmlStr += `${iButtonHtmlString}`;    document.querySelector("#h5Action_updateTextAreaValue_buttons_div").innerHTML = htmlStr;  }  // 执行 h5 弹出错误提示的 alert  function _h5CallBridgeAction_alert(errorMessage) {    console.log(errorMessage);    alert(errorMessage);  }  function _showSuccessUI(demoSectionArray) {    console.log(`最终要显示的数据如下:\n demoSectionArray:${demoSectionArray}\n demoSectionArrayString:${JSON.stringify(demoSectionArray)}`);    // 当整个section非空时候，直接使用第一个可选操作元素    const firstSectionDatas = demoSectionArray[0]["sectionDatas"];    const firstElement = firstSectionDatas[0];    _useDirectlyWhenOnlyOneElement(firstElement);    var sectionCount = demoSectionArray.length;    if (sectionCount == 1 && firstSectionDatas.length == 1) {      return;    }    /// 当整个section不止一个元素的时候，罗列在界面上，供选择使用    let htmlStr = "";    for (let sectionIndex = 0; sectionIndex < sectionCount; sectionIndex++) {      const sectionElement = demoSectionArray[sectionIndex];      let sectionHtmlString = _getSectionHtmlString(sectionIndex, sectionElement["sectionDatas"]);      // let sectionHtmlString = `<div id="pageTilteView" style="text-align: center; font-size: 20px;">演示的section</div>`      var iSectionDivHtmlString = `      <div id='section_id_${sectionIndex}' style="width: 95%;">        <div style="width: 95%; background-color: ${sectionElement["sectionBG"]};">${sectionElement["sectionTitle"]}</div>        ${sectionHtmlString}      </div>      `      if (sectionIndex < sectionCount - 1) {        iSectionDivHtmlString += `<div style="height: 20px;"></div>`;      }      // console.log(`iSectionDivHtmlString${sectionIndex}=${iSectionDivHtmlString}`);      htmlStr += `${iSectionDivHtmlString}`;    }    document.querySelector("#h5Action_updateTextAreaValue_buttons_div").innerHTML = htmlStr;  }  /// 当整个section就只有一个元素的时候，直接使用  function _useDirectlyWhenOnlyOneElement(element) {    var unique_name = element["unique_name"];    _h5CallBridgeActionDesArray.push(unique_name);    // [JS字符串拼接的几种方式](https://blog.csdn.net/u012320487/article/details/123822785)    sectionIndex = 0;    rowIndex = 0;    var h5Action_updateTextAreaValue_onClick = `_h5Action_updateText_byIndex(${sectionIndex}, ${rowIndex});`;    // [js(JavaScript)字符串转换成变量名](https://huaweicloud.csdn.net/63a55da9b878a54545945264.html?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~activity-1-102934655-blog-92951596.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~activity-1-102934655-blog-92951596.pc_relevant_recovery_v2&utm_relevant_index=1)    // 利用 eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。    var funName = h5Action_updateTextAreaValue_onClick;    try {      eval(funName);    } catch (err) {      // console.log(`---------------err:${err}`);      _showAlert(err);    }  }  /// 根据标题，获取其整个数据模型  function _getElementByIndex(sectionIndex, rowIndex) {    // var index = _h5CallBridgeActionDesArray.indexOf(h5CallBridgeActionDes);    // var demoMap = _demoSectionArray[index];    var demoMap = _demoSectionArray[sectionIndex]["sectionDatas"][rowIndex];    return demoMap;  }  /// 更新 标题  function _h5Action_updateText_forSubTitle(dataFromSource) {    console.log(`更新UI上的副标题为:${dataFromSource}`);    document.getElementById("pageSubTilteView").innerHTML = `（${dataFromSource}）`;  }  /// 获取h5调用的app桥接方法名  function _h5Action_getAppRouteUrl() {    var sendMethod = document.getElementById("h5CallBridgeActionNameDataView").value;    return sendMethod;  }  /// 获取h5调用app桥接方法后，发送的数据  function _h5Action_getSendMessage() {    var sendMessage = document.getElementById("h5CallBridgeSendMessageDataView").value;    return sendMessage;  }  // 执行 h5调用app的桥接方法  function _chooseAppRouteUrlTestType_copyToOther() {    _showAlert("暂未实现 copyToOther")  }  function _chooseAppRouteUrlTestType_testToolPage() {    // var funName = 'h5CallBridgeAction_showAppToast';    // var sendMessage = '恭喜您分享成功';    // h5CallBridgeAction_showAppToast.postMessage(sendMessage);    // [js(JavaScript)字符串转换成变量名](https://huaweicloud.csdn.net/63a55da9b878a54545945264.html?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~activity-1-102934655-blog-92951596.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~activity-1-102934655-blog-92951596.pc_relevant_recovery_v2&utm_relevant_index=1)    // 利用 eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。    var appRouteUrl = getElementValueById("directly_browserUrl_Value_valueView");;    // appRouteUrl = encodeURIComponent(appRouteUrl); // 注意: appRouteUrl 是 browserUrl 的参数，所以必须编码，否则当 appRouteUrl 中含有中文，或者对象的时候会造成无法打开网页的错误    if (_isMyAppWebView != true) {      try {        debugger        window.location.href = appRouteUrl; // TODO:如果显示报错信息        debugger      } catch (err) {        // console.log(`---------------err:${err}`);        _showAlert(err);        debugger      }      return;    }    var funName = "h5CallBridgeAction_test_openBrowser";    var currentUrl = window.location.href;    var currentUrlWithoutParams = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;    console.log(`---------------currentUrl=\n${currentUrl},\n currentUrlWithoutParams=\n${currentUrlWithoutParams}`);    var browserUrl = `${currentUrlWithoutParams}?appRouteUrl=${appRouteUrl}`;    console.log(`---------------appRouteUrl:\n${appRouteUrl}`);    console.log(`---------------browserUrl:\n${browserUrl}`);    var sendMessageMap = { "isMyAppWebView": 0, "url": browserUrl };    var sendMessage = JSON.stringify(sendMessageMap);    try {      eval(funName).postMessage(sendMessage);    } catch (err) {      // console.log(`---------------err:${err}`);      _showAlert(err);    }    console.log(sendMessage.message);  }  function _chooseAppRouteUrlTestType_goToProductPage() {    var appRouteUrlValue = getElementValueById("directly_browserUrl_Value_valueView");    var appRouteUrlDes = getElementValueById("custom_browserUrl_appRouteUrl_Description_valueView");    var params = {      "appRouteUrlValue": appRouteUrlValue,      "appRouteUrlDes": appRouteUrlDes,    };    var url = `./dvlp_h5_open_app_browser_url_demo.html`;    url = addParamsForUrl(url, params);    window.location.href = url;  }  // h5Action_share 分享内容到指定的分享方式(微信聊天页面等)  /*  function h5Action_updateTextAreaValue_share(webPageType) {    var url;    if (webPageType == '只是分享网页链接，没其他操作') {      url = "https://www.baidu.com";    } else if (webPageType == '分享链接，且链接可打开app的_原生页面') {      url = 'yuanwangwu://openpage?pageName=imChatPage&conversationID=126191&imUserId=1602856363702501376&showName=婉艺&type=1&dialogSubjectId=1506196208391966720';    } else if (webPageType == '分享链接，且链接可打开app的_网页游戏') {      var appOpenUrl = "yuanwangwu://openpage?pageName=farmGamePage&accountId=1475332557208702976";      // [js 对url进行编码和解码](https://blog.csdn.net/qq_42740797/article/details/111172160)      // appOpenUrl = encodeURIComponent(appOpenUrl); // 提示🤝：实际发现，不编码，也可打开      url = "http://test-h5.yuanwangwu.com/pages-h5/share/share-farm?&accountId=1475332557208702976&appurl=" + appOpenUrl;    } else {      url = "https://www.baidu.com";    }    var map = {      // "shareType": "Wechat_SESSION", // 分享方式      "shareWebPageUrl": url,      "shareTitle": "你的好友发来一条加急消息", // 分享标题      "shareDescription": "急急急，快来帮我转大转盘，100%中奖！", // 分享描述      "shareThumbnailUrl": "https://img1.baidu.com/it/u=1605341541,1182642759&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1673370000&t=4e694f8a257f10a7f6b52bd051288e7d",    };    var message = JSON.stringify(map);    _h5Action_updateText_forData('h5CallBridgeAction_share', message);  }  */  /// 提供给原生调用的h5方法(用于测试原生调用的方法及传递回来的返回值)  function bridgeCallH5Action_showCallbackJsonString(jsonString) {    if (jsonString == null || jsonString == undefined || !jsonString) {      _showAlert("没有回传的jsonString值");      return;    }    _showAlert(`回传的jsonString值为:${JSON.stringify(jsonString)}`);  }  /// 跳转到示例页面  function _h5Action_goDemoPage() {    window.location.href = '?fileUrl=dvlp_h5_open_app_demo.json';  }  function _h5Action_create(type) {    // _showAlert(type);    if (type == 'directly') {    } else if (type == 'custom') {      structureRouteUrlByCurrentText();    }  }</script></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/HTML/common_js/url_util/"/>
      <url>/HTML/common_js/url_util/</url>
      
        <content type="html"><![CDATA[/* * @Author: dvlproad dvlproad@163.com * @Date: 2023-02-11 14:56:20 * @LastEditors: dvlproad dvlproad@163.com * @LastEditTime: 2023-02-12 15:18:22 * @FilePath: /undefined/Users/lichaoqian/Project/CQBook/dvlproadHexo/source/_posts/Architecture架构/h5js/common_js/url_util.js * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE *//// 获取指定地址的主地址function getRequestUrlMain(browserUrl) {  if (browserUrl == null || browserUrl == "" || typeof browserUrl == "undefined") {    var url = decodeURI(location.search);  //获取url中"?"符后的字串  } else {    var url = browserUrl;  }  var url_main;  var paramStartIndex = url.indexOf("?");  if (paramStartIndex != -1) {    // [js中截取字符串的三个方法 substring()、substr()、slice()](https://segmentfault.com/a/1190000016387899)     url_main = url.substring(0, paramStartIndex);  } else {     url_main = url;  }  return url_main;}/// 获取指定地址的所有参数function getRequestUrlParams(browserUrl) {  if (browserUrl == null || browserUrl == "" || typeof browserUrl == "undefined") {    var url = decodeURI(location.search);  //获取url中"?"符后的字串  } else {    var url = browserUrl;  }  var theRequest = new Map();  var paramStartIndex = url.indexOf("?");  if (paramStartIndex != -1) {    var str = url.substr(paramStartIndex + 1);    strs = str.split("&");    for (var i = 0; i < strs.length; i++) {      var keyValueComponent = strs[i].split("=");      var key = keyValueComponent[0];      var value = keyValueComponent[1];      theRequest[key] = unescape(value);    }  }  return theRequest;}// [js获取url中的中文参数出现乱码解决](https://www.codeleading.com/article/87533774933/)// "http://localhost:4000/Architecture%E6%9E%B6%E6%9E%84/h5js/dvlp_h5js_demo/dvlp_h5js_demo.json"; // url含中文示例// "http://localhost/test/test.html?p=广东&c=珠海"function getValueByQueryKey(browserUrl, key) {  // 获取参数  if (browserUrl == null || browserUrl == "" || typeof browserUrl == "undefined") {    var url = decodeURI(location.search);  //获取url中"?"符后的字串    // var url = window.location.search; // 在本地用file打开，而不是http打开的话，此值会为空  } else {    var url = browserUrl;  }    // 正则筛选地址栏  var reg = new RegExp("(^|&)" + key + "=([^&]*)(&|$)");  // 匹配目标参数  var result = url.substr(1).match(reg);  //返回参数值  // return result ? unescape(result[2]) : null; // url中含中文时候，取值会出错  return result ? decodeURIComponent(result[2]) : null;}/// 获取本页面指定参数key的值function getQueryString(key) {  var url = window.location.search; // 在本地用file打开，而不是http打开的话，此值会为空  return getValueByQueryKey(url, key);}]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/HTML/common_js/object_util/"/>
      <url>/HTML/common_js/object_util/</url>
      
        <content type="html"><![CDATA[/* * @Author: dvlproad dvlproad@163.com * @Date: 2023-02-11 14:56:20 * @LastEditors: dvlproad dvlproad@163.com * @LastEditTime: 2023-02-12 15:07:54 * @FilePath: /undefined/Users/lichaoqian/Project/CQBook/dvlproadHexo/source/_posts/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5_open_app_url_create_demo.js * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE */const isObject = (obj) => obj === Object(obj)const isNil = (val) => val === undefined || val === nullconst isEmpty = (val) => {  return isString(val) || isObject(val) || Array.isArray(val) ?    !Object.keys(val).length : isNil(val)}const isString = (val) => typeof val === 'string'// [js 删除Object中指定的key](https://blog.csdn.net/weixin_39501680/article/details/123110404)const deleteObjectByKey = (obj = {}, arr = []) => {  if (isEmpty(obj) || !isObject(obj)) return {}  if (isEmpty(arr) || (!Array.isArray(arr) && !isString(arr))) return obj  return Object.keys(obj)    .filter((k) => !arr.includes(k))    .reduce((acc, key) => ((acc[key] = obj[key]), acc), {})}]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5_open_app/css/dvlp_h5_open_app_url_create_demo/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5_open_app/css/dvlp_h5_open_app_url_create_demo/</url>
      
        <content type="html"><![CDATA[.div_spearte {  height: 16px;}.button_half_width {  background-color: red;  color: white;  border-width: 0;  width: 45%;  font-size: 12px;}.button_full_width {  background-color: red;  color: white;  border-width: 0;  width: 45%;  font-size: 20px;}.title1 {  color: red;  font-size: 14px;  padding-left: 10px;}.title1 .title2 {  color: blue;  font-size: 12px;}.textarea_one_line {  width: 95%;  height: 16px;}.textarea_decription_multiline {  width: 95%;  height: 80px;}.textarea_one_appRouteUrl {  width: 95%;  height: 70px;}.textarea_one_browseUrl {  width: 95%;  height: 80px;}]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5js/dvlp_h5js_demo/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5js/dvlp_h5js_demo/</url>
      
        <content type="html"><![CDATA[<!-- * @Author: dvlproad * @Date: 2022-12-27 11:59:38 * @LastEditors: dvlproad * @LastEditTime: 2023-02-16 14:44:06 * @Description: 调试h5与app交互的网页demo--><!--一、使用fileUrl参数1、本地服务器测试url1:  http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?参数如下eg中的值eg1.1: fileUrl=dvlp_h5js_demo.jsoneg1.2: fileUrl=http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.json2、远程服务器测试url2:  https://dvlproad.github.io/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?参数如下eg中的值eg2.1: fileUrl=dvlp_h5js_demo.jsoneg2.2: fileUrl=https://dvlproad.github.io/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.jsoneg2.3(测试跨域): fileUrl=https://raw.githubusercontent.com/dvlproad/dvlproad.github.io/master/Architecture%E6%9E%B6%E6%9E%84/h5js/dvlp_h5js_demo/dvlp_h5js_demo.jsoneg2.4(测试跨域): eg2.5(测试跨域): 二、使用各种dataJson参数1、本地服务器测试url1:  http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?参数如下eg中的值eg1.1(未编码h5CallBridgeSendMessage，在浏览器中验证可以。但在app中不行，必须对每个参数编码后再赋值，以避免参数中含中文或者对象): h5CallBridgeActionDes=跳转到app指定页面_Name&h5CallBridgeActionName=h5CallBridgeAction_jumpAppPage&h5CallBridgeSendMessage={"pageName":"imChatPage","pageParams":{"conversationID":"126191","imUserId":"1602856363702501376","showName":"婉艺","type":1,"dialogSubjectId":"1506196208391966720"}}eg1.2(有编码h5CallBridgeSendMessage，验证可以): h5CallBridgeActionDes=跳转到app指定页面_Name&h5CallBridgeActionName=h5CallBridgeAction_jumpAppPage&h5CallBridgeSendMessage=%7B%22pageName%22%3A%22imChatPage%22%2C%22pageParams%22%3A%7B%22conversationID%22%3A%22126191%22%2C%22imUserId%22%3A%221602856363702501376%22%2C%22showName%22%3A%22%E5%A9%89%E8%89%BA%22%2C%22type%22%3A1%2C%22dialogSubjectId%22%3A%221506196208391966720%22%7D%7D--><!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0">  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">  <title>html demo</title></head><style>  .div_spearte {    height: 16px;  }  .button_half_width {    background-color: red;    color: white;    border-width: 0;    width: 45%;    font-size: 12px;  }  .button_full_width {    background-color: red;    color: white;    border-width: 0;    width: 45%;    font-size: 20px;  }  .title1 {    color: red;    font-size: 14px;    padding-left: 10px;  }  .title1 .title2 {    color: blue;    font-size: 12px;  }  .title1 .title_prompt {    color: orchid;    font-size: 12px;  }  .textarea_one_line {    width: 95%;    height: 16px;  }  .textarea_argument {    width: 95%;    height: 200px;  }  .textarea_decription_multiline {    width: 95%;    height: 80px;  }</style><style>  .hide {    display: none !important;  }  .dialog {    position: absolute;    top: 0;    left: 0;    width: 100vw;    height: 100vh;    background-color: rgba(0, 0, 0, 0.6);    display: flex;    justify-content: center;    align-items: center;  }  .dialog .content {    background: white;    padding: 30px 20px;  }  .dialog .content .msg {    font-size: 16px;  }  .dialog .content .close-btn {    margin-top: 10px;    width: 100px;    height: 36px;    background-color: #fff;    border: 1px solid blue;    font-size: 14px;    color: blue;  }</style><body>  <div class="dialog hide">    <div class="content">      <div class="msg" id="msg">消息内容</div>      <button class="close-btn" onclick="handleCloseDialog()">我知道了</button>    </div>  </div>  <div id="pageTilteView" style="text-align: center; font-size: 20px;">    app内的网页h5调用app的演示demo    <button onclick="_h5Action_goDemoPage()" style="font-size: 12px;">查看示例</button>  </div>  <div id="pageSubTilteView" style="text-align: center; font-size: 14px;">数据来源于：xxx</div>  <div id="inputContainer">H5到app的入参    <div class="title1">1、app内的h5调用app的-桥接方法名信息：      <div class="title2">桥接方法名的值：</div>      <textarea class="textarea_one_line" id="h5CallBridgeActionNameDataView">桥接方法名的值</textarea>      <div class="title2">桥接方法名的介绍：</div>      <textarea class="textarea_one_line" id="h5CallBridgeActionDesDataView">桥接方法名的介绍</textarea>    </div>    <div class="title1">2、app内的h5调用app桥接方法后，发送的参数信息：      <div class="title2">参数值：</div>      <div class="title_prompt">(注:如果key或value缺少引号",则一定是你入参的时候,json没有先转义)<button onclick="_h5Action_goJsonEscapePage()" style="font-size: 12px;">json转义工具</button></div>      <textarea class="textarea_argument" id="h5CallBridgeSendMessageDataView">参数值</textarea>      <div class="title2">参数值的介绍：</div>      <textarea class="textarea_decription_multiline" id="h5CallBridgeDescriptionDataView">参数值的介绍</textarea>    </div>  </div>  <button id="evalButtonView" onclick="_h5CallBridgeAction_eval()" style="background-color: red; color: white; height: 30px; width: 95%; font-size: 20px;">执行上述的h5调用app的方法</button>  <div class="div_spearte"></div>  <div id="outputContainer">app给H5的回值    <div class="title1">app内的h5调用app桥接方法后，app给H5的回值信息：      <div class="title2">回值：</div>      <textarea class="textarea_argument" id="bridgeCallH5ActionDataView">回值</textarea>      <div class="title2">回值的介绍：</div>      <textarea class="textarea_decription_multiline" id="bridgeCallH5ActionDescriptionDataView">回值的介绍</textarea>    </div>  </div>  <!-- <div>分享内容到指定的分享方式(微信聊天页面等)</div>  <button    onclick="h5Action_updateTextAreaValue_share('只是分享网页链接，没其他操作')">'硬编码的按钮：只是分享网页链接，没其他操作'</button>  <button    onclick="h5Action_updateTextAreaValue_share('分享链接，且链接可打开app的_原生页面')">'硬编码的按钮：分享链接，且链接可打开app的_原生页面'</button>  <button    onclick="h5Action_updateTextAreaValue_share('分享链接，且链接可打开app的_网页游戏')">'硬编码的按钮：分享链接，且链接可打开app的_网页游戏'</button> -->  <div id="h5Action_updateTextAreaValue_buttons_div"></div></body><!-- [移动端调试神器vConsole使用详解](https://www.jb51.net/article/244750.htm) --><script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script><script>  // VConsole 默认会挂载到 `window.VConsole` 上  var vConsole = new window.VConsole();  // 接下来即可照常使用 `console` 等方法  console.log('Hello world');  // 结束调试后，可移除掉  vConsole.destroy();</script><!-- [引入jquery.js 修复出现的错误：ReferenceError: $ is not defined](https://blog.csdn.net/lq_ruonan/article/details/53690960) --><script src="https://code.jquery.com/jquery-3.6.3.js" type="text/javascript" charset="utf-8"></script><!-- <script src="js/jQuery.js" type="text/javascript" charset="utf-8"></script> --><script>  function updateElementValueById(id, value) {    if (typeof value == 'string') {      //     } else {      value = JSON.stringify(value);    }    document.getElementById(id).innerHTML = '' + `${value}`;  }  function getElementValueById(id) {    return document.getElementById(id).value;  }</script><script>  // 初始化  // localStorage.setItem('vConsole_switch_x', 50)  // var vConsole = new VConsole();  // console.log('Hello world');  var _demoSectionArray;  var h5CallBridgeActionDesArray = [];  // function readJson(url) {  //   var request = new XMLHttpRequest();  //   request.open("get", url);/*设置请求方法与路径*/  //   request.send(null);/*不发送数据到服务器*/  //   request.onload = function () {/*XHR对象获取到返回信息后执行*/  //     if (request.status == 200) {/*返回状态为200，即为数据获取成功*/  //       var json = JSON.parse(request.responseText);  //       for (var i = 0; i < json.length; i++) {  //         console.log(json[i].name);  //       }  //       console.log(json);  //       debugger  //     }  //   }  // }  function handleCloseDialog() {    document.querySelector(".dialog").classList.add("hide");    // copy(".msg")  }  function handleShowDialog() {    document.querySelector(".dialog").classList.remove("hide");  }  // function copy(id) {  //   var clipboard = new Clipboard(id);  //   clipboard.on('success', function (e) {  //     _showAlert("复制成功");  //     //可执行其他代码操作  //   });  //   clipboard.on('error', function () {  //     _showAlert("复制失败")  //   });  // }  function _showAlert(msg) {    handleShowDialog();    let t = document.querySelector(".msg");    t.innerHTML = msg;  }  function readJson(url) {    return new Promise((resolve, reject) => {      $.ajax({        url: url,//同文件夹下的json文件路径        type: "GET",//请求方式为get        dataType: "json", //返回数据格式为json        success: function (data) {//请求成功完成后要执行的方法           console.log(`读取${url}成功,数据data的值为\n${data}`);          console.log(`读取${url}成功,数据data转字符串后的值为\n${JSON.stringify(data)}`);          // var array = data;          // for (let index = 0; index < array.length; index++) { //循环后台传过来的Json数组           //   const element = array[index];          //   console.log(`data${index}:` + element);          //   console.log(`data${index}:` + element.h5CallBridgeActionDes);          // }          resolve(data);        },        error: function (err) {          // debugger // 断点调试          resolve(null);        }      })    })    // $.get('./test_h5js_demo.json', function (data) {    //   //读进了data变量中    //   //接下来用到data的代码必须全部在此函数内部进行    //   console.log("data:" + data);    // });    // d3.json('./test_h5js_demo.json', function (error, authordata) {    //   if (error) console.error(error);    //   //读进了authordata变量    //   //接下来用到authordata的代码必须全部在此函数内部进行    //   console.log("data:" + data);    // });    // if (window.FileReader) {    //   let reader = new FileReader();    //   let file = new File(    //     [blob],    //     url,    //     {    //       type: 'text/plain',    //     }    //   );    //   reader.readAsText(file);    //   reader.onload = function () {    //     console.log('读取成功');    //     var data = reader.result;   //base64形式的文件内容    //   };    //   reader.onerror = function () {    //     console.log('读取失败');    //     console.log(reader.error);    //   }    // } else {    //   console.log('你的浏览器不支持读取文件');    // }  }  function getLocalDemoMapArray() {    let localDemoMapArray = [      {        "sectionTitle": "只是测试方法，不再实际项目中使用",        // "sectionBG": "#FF0000",        "sectionDatas": [          {            "h5CallBridgeActionDes": "测试 h5 调用 app 方法，并将返回值回调给 h5",            "h5CallBridgeActionName": "h5CallBridgeAction_test_h5CallAppAndCallBackToH5",            "h5CallBridgeSendMessage": {              "callbackMethod": "bridgeCallH5Action_showCallbackJsonString",              "url": "https://www.baidu.com"            }          }        ]      }    ];    // return null; // 测试本地未赋值时候的界面展示    return localDemoMapArray;  }  /// 处理协议跳转  /// 规则说明：  /// yuanwangwu://openpage?pageName=XXXX&orderId=XXXXX  /// 如果是从外部h5跳转app使用 yuanwangwu://openpage?pageName=webPage&url=URLEncode(http://www.baidyu.com)  /// 例：yuanwangwu://openpage?pageName=webPage&url=http%3A%2F%2Fwww.baidu.com  /// 如果是跳转到内部页面 使用：yuanwangwu://openpage?pageName=XXXXXX&id=XXX  /// 例：yuanwangwu://openpage?pageName=testPage&id=123  /// 如果是跳转【微信小程序】 使用：yuanwangwu://openpage?pageName=mp&path=URLEncode(XXX)  /// 例：略  // var message = 'yuanwangwu://openpage?pageName=webPage&url=URLEncode(http://www.baidu.com)';  async function initData() { // 注意必须加 async ,否则函数内使用 await 会报错    console.log("查看是否有使用fileUrl或者h5CallBridgeActionName参数,若都无，则将使用本html的默认数据");    let url_param_fileUrl = getQueryString("fileUrl"); // 从浏览器的网页地址中读取 fileUrl 参数    console.log(`========url_param_fileUrl:${url_param_fileUrl}`);    let url_param_h5CallBridgeActionName = getQueryString("h5CallBridgeActionName"); // 从浏览器的网页地址中读取 h5CallBridgeActionName 参数    console.log(`========url_param_h5CallBridgeActionName:${url_param_h5CallBridgeActionName}`);    let url_param_h5CallBridgeActionDes = getQueryString("h5CallBridgeActionDes"); // 从浏览器的网页地址中读取 h5CallBridgeActionDes 参数    console.log(`========url_param_h5CallBridgeActionDes:${url_param_h5CallBridgeActionDes}【附：不能使用h5CallBridgeActionName的值，会出现当把此html放到app项目中加载本地html的时候，莫名出现h5CallBridgeActionName有值的情况，PS当前该值为${url_param_h5CallBridgeActionName}】`);    if (url_param_fileUrl == null && url_param_h5CallBridgeActionDes == null) {      _h5Action_updateText_forTitle("数据来源于:本html内嵌");      var promptMessage = "未设置本html的json文件路径,也未设置h5CallBridge参数，则将使用本地默认的 demoMapArray 值";      _demoSectionArray = getLocalDemoMapArray();      if (_demoSectionArray == null) { // 本html未将json文件的值赋值给 demoMapArray        localArrayResultMessage = `${promptMessage}:获取本地默认的 demoMapArray 失败❌\n请打开本html文件，检查demoMapArray的本地赋值是否正确`;        console.log(`${localArrayResultMessage}`);        _showErrorUI(localArrayResultMessage);        return;      } else {        localArrayResultMessage = `${promptMessage}:获取本地默认的 demoMapArray 成功✅`;        console.log(`${localArrayResultMessage}`);      }    } else {      if (url_param_fileUrl == null) {        _h5Action_updateText_forTitle(`数据来源于:本html浏览器网页地址中的 h5CallBridgeActionName=${url_param_h5CallBridgeActionName} 等参数`);        var dataJsonSuccess = _checkDataJson();        if (dataJsonSuccess != true) {          return;        }      } else {        _h5Action_updateText_forTitle("数据来源于:本html浏览器网页地址中的 fileUrl 参数");        var fileUrlSuccess = await _checkFileUrlUI(url_param_fileUrl);        if (fileUrlSuccess != true) {          return;        }      }    }    //     _showSuccessUI(_demoSectionArray);  }  initData();  function _checkDataJson() {    var promptMessage = "已设置本html的dataJson参数，则将获取使用哪些参数构造出只有一个元素的 demoMapArray 值";    var remoteArrayResultMessage = `${promptMessage}:获取浏览器地址指定的dataJson各参数的值来作为 demoMapArray 成功✅`;    console.log(`${remoteArrayResultMessage}`);    // http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?h5CallBridgeActionDes=跳转到app指定页面_Name&h5CallBridgeActionName=h5CallBridgeAction_jumpAppPage&h5CallBridgeSendMessage={"pageName":"imChatPage","pageParams":{"conversationID":"126191","imUserId":"1602856363702501376","showName":"婉艺","type":1,"dialogSubjectId":"1506196208391966720"}}    // http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?h5CallBridgeActionDes=跳转到app指定页面_Name&h5CallBridgeActionName=h5CallBridgeAction_jumpAppPage&h5CallBridgeSendMessage=%7B%22pageName%22%3A%22imChatPage%22%2C%22pageParams%22%3A%7B%22conversationID%22%3A%22126191%22%2C%22imUserId%22%3A%221602856363702501376%22%2C%22showName%22%3A%22%E5%A9%89%E8%89%BA%22%2C%22type%22%3A1%2C%22dialogSubjectId%22%3A%221506196208391966720%22%7D%7D    // {    //     "h5CallBridgeActionDes": "跳转到app指定页面_Name",    //     "h5CallBridgeActionName": "h5CallBridgeAction_jumpAppPage",    //     "h5CallBridgeSendMessage": {    //       "pageName": "imChatPage",    //       "pageParams": {    //         "conversationID": "126191",    //         "imUserId": "1602856363702501376",    //         "showName": "婉艺",    //         "type": 1,    //         "dialogSubjectId": "1506196208391966720"    //       }    //     }    //   }    // 从浏览器的网页地址中读取 h5CallBridgeSendMessage 等参数    console.log("dataJson各参数获取后，但获取过程中内部已解码，值分别如下:")    let param_string_h5CallBridgeActionDes = getQueryString("h5CallBridgeActionDes");    let param_string_h5CallBridgeActionName = getQueryString("h5CallBridgeActionName");    let param_string_h5CallBridgeSendMessage = getQueryString("h5CallBridgeSendMessage");    console.log(`========param_string_h5CallBridgeActionDes:${param_string_h5CallBridgeActionDes}`);    console.log(`========param_string_h5CallBridgeActionName:${param_string_h5CallBridgeActionName}`);    console.log(`========param_string_h5CallBridgeSendMessage:${param_string_h5CallBridgeSendMessage}`);    // console.log("dataJson各参数解码后，值分别如下:")    // let param_decode_h5CallBridgeActionDes = decodeURIComponent(param_string_h5CallBridgeActionDes);    // let param_decode_h5CallBridgeActionName = decodeURIComponent(param_string_h5CallBridgeActionName);    // let param_decode_h5CallBridgeSendMessage = decodeURIComponent(param_string_h5CallBridgeSendMessage);    // console.log(`========param_decode_h5CallBridgeActionDes:${param_decode_h5CallBridgeActionDes}`);    // console.log(`========param_decode_h5CallBridgeActionName:${param_decode_h5CallBridgeActionName}`);    // console.log(`========param_decode_h5CallBridgeSendMessage:${param_decode_h5CallBridgeSendMessage}`);    // console.log("dataJson各参数解码后并转object模型，值分别如下:")    // let param_object_h5CallBridgeSendMessage = JSON.parse(param_decode_h5CallBridgeSendMessage);    // console.log(`========param_object_h5CallBridgeSendMessage:${param_object_h5CallBridgeSendMessage}`);    let demoMap1 = {      "h5CallBridgeActionDes": param_string_h5CallBridgeActionDes,      "h5CallBridgeActionName": param_string_h5CallBridgeActionName,      "h5CallBridgeSendMessage": param_string_h5CallBridgeSendMessage    };    _demoSectionArray = [      {        "sectionTitle": "通过给此html传入dataJson各参数，所以这里只有一个元素",        "sectionDatas": [          demoMap1        ],      }    ];    return true;  }  async function _checkFileUrlUI(fileUrl) { // 注意必须加 async ,否则函数内使用 await 会报错    // http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.html?fileUrl=http://localhost:4000/Architecture架构/h5js/dvlp_h5js_demo/dvlp_h5js_demo.json    var promptMessage = "已设置本html的json文件路径，则将获取该路径下的json值作为 _demoSectionArray 值";    _demoSectionArray = await readJson(fileUrl);    if (_demoSectionArray == null) { // 本html未将json文件的值赋值给 demoMapArray      remoteArrayResultMessage = `${promptMessage}:获取浏览器地址指定的json文件${fileUrl}的值来作为 demoMapArray 失败❌，请根据以下可能原因检查`;      let fileUrlFailureReason1 = `失败可能原因1:路径${fileUrl}写错`;      let fileUrlFailureReasonLocal = "失败可能原因2:如果本html是本地直接打开的，则json文件的需手动拷贝到本html中(因为暂不支持读取本地的json文件)";      let fileUrlFailureReasonRemote = "失败可能原因3:如果本html是从网络地址上打开的，则fileUrl必须和本html的所在工程一致(因为暂不支持跨域访问)";      remoteArrayResultMessage = `${remoteArrayResultMessage}\n${fileUrlFailureReason1}\n${fileUrlFailureReasonLocal}\n${fileUrlFailureReasonRemote}`      console.log(`${remoteArrayResultMessage}`);      _showErrorUI(remoteArrayResultMessage);      return false;    } else {      remoteArrayResultMessage = `${promptMessage}:获取浏览器地址指定的json文件${fileUrl}的值来作为 demoMapArray 成功✅`;      console.log(`${remoteArrayResultMessage}`);      return true;    }  }  function _showErrorUI(errorMessage) {    let htmlStr = "";    var h5Action_warningButton_onClick = `_h5CallBridgeAction_alert("${errorMessage}");`;    var iButtonHtmlString = `<button onClick='${h5Action_warningButton_onClick}' style="width: 95%; height: 30px;">"${errorMessage}</button>`    htmlStr += `${iButtonHtmlString}`;    document.querySelector("#h5Action_updateTextAreaValue_buttons_div").innerHTML = htmlStr;  }  // 执行 h5 弹出错误提示的 alert  function _h5CallBridgeAction_alert(errorMessage) {    console.log(errorMessage);    alert(errorMessage);  }  function _showSuccessUI(demoSectionArray) {    console.log(`最终要显示的数据如下:\n demoSectionArray:${demoSectionArray}\n demoSectionArrayString:${JSON.stringify(demoSectionArray)}`);    var sectionCount = demoSectionArray.length;    // 当整个section就只有一个可选操作元素的时候，直接使用    if (sectionCount == 1) {      const sectionDatas = demoSectionArray[0]["sectionDatas"];      if (sectionDatas.length == 1) {        const element = sectionDatas[0];        _useDirectlyWhenOnlyOneElement(element);        return;      }    }    /// 当整个section不止一个元素的时候，罗列在界面上，供选择使用    let htmlStr = "";    for (let sectionIndex = 0; sectionIndex < sectionCount; sectionIndex++) {      const sectionElement = demoSectionArray[sectionIndex];      let sectionHtmlString = _getSectionHtmlString(sectionIndex, sectionElement["sectionDatas"]);      // let sectionHtmlString = `<div id="pageTilteView" style="text-align: center; font-size: 20px;">演示的section</div>`      var iSectionDivHtmlString = `      <div id='section_id_${sectionIndex}' style="width: 95%;">        <div style="width: 95%; background-color: ${sectionElement["sectionBG"]};">${sectionElement["sectionTitle"]}</div>        ${sectionHtmlString}      </div>      `      if (sectionIndex < sectionCount - 1) {        iSectionDivHtmlString += `<div style="height: 20px;"></div>`;      }      // console.log(`iSectionDivHtmlString${sectionIndex}=${iSectionDivHtmlString}`);      htmlStr += `${iSectionDivHtmlString}`;    }    document.querySelector("#h5Action_updateTextAreaValue_buttons_div").innerHTML = htmlStr;  }  /// 当整个section就只有一个元素的时候，直接使用  function _useDirectlyWhenOnlyOneElement(element) {    var h5CallBridgeActionDes = element["h5CallBridgeActionDes"];    h5CallBridgeActionDesArray.push(h5CallBridgeActionDes);    // [JS字符串拼接的几种方式](https://blog.csdn.net/u012320487/article/details/123822785)    sectionIndex = 0;    rowIndex = 0;    var h5Action_updateTextAreaValue_onClick = `_h5Action_updateText_byIndex(${sectionIndex}, ${rowIndex});`;    // [js(JavaScript)字符串转换成变量名](https://huaweicloud.csdn.net/63a55da9b878a54545945264.html?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~activity-1-102934655-blog-92951596.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~activity-1-102934655-blog-92951596.pc_relevant_recovery_v2&utm_relevant_index=1)    // 利用 eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。    var funName = h5Action_updateTextAreaValue_onClick;    try {      eval(funName);    } catch (err) {      // console.log(`---------------err:${err}`);      _showAlert(err);    }  }  function _getSectionHtmlString(sectionIndex, demoMapArray) {    console.log(`${sectionIndex}当前区要显示的数据如下:\n demoMapArray:${demoMapArray}\n demoMapArrayString:${JSON.stringify(demoMapArray)}`);    let sectionHtmlString = "";    var demoMapCount = demoMapArray.length;    for (let rowIndex = 0; rowIndex < demoMapCount; rowIndex++) {      const element = demoMapArray[rowIndex];      var h5CallBridgeActionDes = element["h5CallBridgeActionDes"];      h5CallBridgeActionDesArray.push(h5CallBridgeActionDes);      // [JS字符串拼接的几种方式](https://blog.csdn.net/u012320487/article/details/123822785)      var h5Action_updateTextAreaValue_onClick = `_h5Action_updateText_byIndex(${sectionIndex}, ${rowIndex});`;      var iButtonHtmlString = `<button onClick='${h5Action_updateTextAreaValue_onClick}' style="width: 95%; height: 30px;">${sectionIndex + 1}.${rowIndex + 1}.${h5CallBridgeActionDes}</button>`      if (rowIndex > 0) {        // htmlStr += `<>`;      }      console.log(`iButtonHtmlString${rowIndex}=${iButtonHtmlString} element=${JSON.stringify(element)}`);      sectionHtmlString += `${iButtonHtmlString}`;    }    return sectionHtmlString;  }  // [js获取url中的中文参数出现乱码解决](https://www.codeleading.com/article/87533774933/)  // "http://localhost:4000/Architecture%E6%9E%B6%E6%9E%84/h5js/dvlp_h5js_demo/dvlp_h5js_demo.json"; // url含中文示例  // "http://localhost/test/test.html?p=广东&c=珠海"  function getQueryString(key) {    // 获取参数    var url = window.location.search;    // 正则筛选地址栏    var reg = new RegExp("(^|&)" + key + "=([^&]*)(&|$)");    // 匹配目标参数    var result = url.substr(1).match(reg);    //返回参数值    // return result ? unescape(result[2]) : null; // url中含中文时候，取值会出错    return result ? decodeURIComponent(result[2]) : null;  }  /// 根据标题，获取其整个数据模型  function _getElementByIndex(sectionIndex, rowIndex) {    // var index = h5CallBridgeActionDesArray.indexOf(h5CallBridgeActionDes);    // var demoMap = _demoSectionArray[index];    var demoMap = _demoSectionArray[sectionIndex]["sectionDatas"][rowIndex];    return demoMap;  }  /// 更新 h5调用的app桥接方法名 和  h5调用app桥接方法后，发送的数据  function _h5Action_updateText_byIndex(sectionIndex, rowIndex) {    var demoMap = _getElementByIndex(sectionIndex, rowIndex);    console.log(`-------当前所选择的值${sectionIndex}.${rowIndex}-------demoMap=${demoMap},demoMapString=${JSON.stringify(demoMap)}`);    var h5CallBridgeActionDes = demoMap["h5CallBridgeActionDes"];    var h5CallBridgeActionName = demoMap["h5CallBridgeActionName"];    var h5CallBridgeSendMessage = demoMap["h5CallBridgeSendMessage"];    if (typeof h5CallBridgeSendMessage == 'string') {      //     } else {      h5CallBridgeSendMessage = JSON.stringify(h5CallBridgeSendMessage);    }    var h5CallBridgeDescription = demoMap["h5CallBridgeDescription"];    if (typeof h5CallBridgeDescription == 'string') {      //     } else {      h5CallBridgeDescription = JSON.stringify(h5CallBridgeDescription);    }    _h5Action_updateText_forData(h5CallBridgeActionDes, h5CallBridgeActionName, h5CallBridgeSendMessage, h5CallBridgeDescription);  }  /// 更新 标题  function _h5Action_updateText_forTitle(dataFromSource) {    console.log(`更新UI上的副标题为:${dataFromSource}`);    document.getElementById("pageSubTilteView").innerHTML = `（${dataFromSource}）`;  }  /// 更新 h5调用的app桥接方法名 和  h5调用app桥接方法后，发送的数据  function _h5Action_updateText_forData(h5CallBridgeActionDes, h5CallBridgeActionName, h5CallBridgeSendMessage, h5CallBridgeDescription) {    console.log(`更新UI上的各部分数据分别为:\n----${h5CallBridgeActionName}\n----${h5CallBridgeSendMessage}\n----${h5CallBridgeDescription}`);    document.getElementById("h5CallBridgeActionDesDataView").innerHTML = '' + h5CallBridgeActionDes;    document.getElementById("h5CallBridgeActionNameDataView").innerHTML = '' + h5CallBridgeActionName;    document.getElementById("h5CallBridgeSendMessageDataView").innerHTML = h5CallBridgeSendMessage;    document.getElementById("h5CallBridgeDescriptionDataView").innerHTML = h5CallBridgeDescription;  }  /// 获取h5调用的app桥接方法名  function _h5Action_getSendMethod() {    var sendMethod = document.getElementById("h5CallBridgeActionNameDataView").value;    return sendMethod;  }  /// 获取h5调用app桥接方法后，发送的数据  function _h5Action_getSendMessage() {    var sendMessage = document.getElementById("h5CallBridgeSendMessageDataView").value;    return sendMessage;  }  // 执行 h5调用app的桥接方法  function _h5CallBridgeAction_eval() {    // var funName = 'h5CallBridgeAction_showAppToast';    // var sendMessage = '恭喜您分享成功';    // h5CallBridgeAction_showAppToast.postMessage(sendMessage);    // [js(JavaScript)字符串转换成变量名](https://huaweicloud.csdn.net/63a55da9b878a54545945264.html?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~activity-1-102934655-blog-92951596.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~activity-1-102934655-blog-92951596.pc_relevant_recovery_v2&utm_relevant_index=1)    // 利用 eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。    var funName = _h5Action_getSendMethod();    var sendMessage = _h5Action_getSendMessage();    try {      eval(funName).postMessage(sendMessage);    } catch (err) {      // console.log(`---------------err:${err}`);      _showAlert(err);    }    console.log(sendMessage.message);  }  // h5Action_share 分享内容到指定的分享方式(微信聊天页面等)  /*  function h5Action_updateTextAreaValue_share(webPageType) {    var url;    if (webPageType == '只是分享网页链接，没其他操作') {      url = "https://www.baidu.com";    } else if (webPageType == '分享链接，且链接可打开app的_原生页面') {      url = 'yuanwangwu://openpage?pageName=imChatPage&conversationID=126191&imUserId=1602856363702501376&showName=婉艺&type=1&dialogSubjectId=1506196208391966720';    } else if (webPageType == '分享链接，且链接可打开app的_网页游戏') {      var appOpenUrl = "yuanwangwu://openpage?pageName=farmGamePage&accountId=1475332557208702976";      // [js 对url进行编码和解码](https://blog.csdn.net/qq_42740797/article/details/111172160)      // appOpenUrl = encodeURIComponent(appOpenUrl); // 提示🤝：实际发现，不编码，也可打开      url = "http://test-h5.yuanwangwu.com/pages-h5/share/share-farm?&accountId=1475332557208702976&appurl=" + appOpenUrl;    } else {      url = "https://www.baidu.com";    }    var map = {      // "shareType": "Wechat_SESSION", // 分享方式      "shareWebPageUrl": url,      "shareTitle": "你的好友发来一条加急消息", // 分享标题      "shareDescription": "急急急，快来帮我转大转盘，100%中奖！", // 分享描述      "shareThumbnailUrl": "https://img1.baidu.com/it/u=1605341541,1182642759&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1673370000&t=4e694f8a257f10a7f6b52bd051288e7d",    };    var message = JSON.stringify(map);    _h5Action_updateText_forData('h5CallBridgeAction_share', message);  }  */  /// 提供给原生调用的h5方法(用于测试原生调用的方法及传递回来的返回值)  function bridgeCallH5Action_showCallbackJsonString(jsonString) {    if (jsonString == null || jsonString == undefined || !jsonString) {      _showAlert("没有回传的jsonString值");      return;    }    updateElementValueById("bridgeCallH5ActionDataView", jsonString);    // updateElementValueById("bridgeCallH5ActionDescriptionDataView", element["argument"]["value"]);  }  /// 跳转到示例页面  function _h5Action_goDemoPage() {    window.location.href = '?fileUrl=dvlp_h5js_demo.json';  }  /// 跳转到json转义工具页面  function _h5Action_goJsonEscapePage() {    window.location.href = "https://zxjson.com/";  }</script></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5js/dvlp_h5js_demo/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5js/dvlp_h5js_demo/</url>
      
        <content type="html"><![CDATA[[{"sectionTitle":"只是测试方法，不再实际项目中使用","sectionDatas":[{"h5CallBridgeActionDes":"测试 h5 调用 app 方法，并将返回值回调给 h5","h5CallBridgeActionName":"h5CallBridgeAction_test_h5CallAppAndCallBackToH5","h5CallBridgeSendMessage":{"callbackMethod":"bridgeCallH5Action_showCallbackJsonString","url":"https://www.baidu.com"}},{"h5CallBridgeActionDes":"测试浏览器中的链接显示，没其他操作","h5CallBridgeActionName":"h5CallBridgeAction_test_openBrowser","h5CallBridgeSendMessage":{"url":"https://www.baidu.com"}},{"h5CallBridgeActionDes":"测试浏览器中的链接显示，且链接可打开app的_原生页面","h5CallBridgeActionName":"h5CallBridgeAction_test_openBrowser","h5CallBridgeSendMessage":{"url":"yuanwangwu://openpage?pageName=webNavPage&url=https://www.baidu.com"}},{"h5CallBridgeActionDes":"测试浏览器中的链接显示，且链接可打开app的_网页游戏","h5CallBridgeActionName":"h5CallBridgeAction_test_openBrowser","h5CallBridgeSendMessage":{"url":"yuanwangwu://openpage?pageName=farmGamePage&accountId=1475332557208702976"}}]},{"sectionTitle":"H5调用app，回调给H5(app、device monitor、user信息)","sectionDatas":[{"h5CallBridgeActionDes":"获取app的公共信息，并回调给h5","h5CallBridgeActionName":"h5CallBridgeAction_getFixedAppInfo","h5CallBridgeSendMessage":{"callbackMethod":"bridgeCallH5Action_showCallbackJsonString"},"h5CallBridgeDescription":{"callbackMethod":"获取到的数值在h5上用哪个方法来接口"},"appCallbackDemoValue":{"version":"1.0.0","buildNumber":"1","platform":"iOS","appType":"Beyond","appFeatureType":"dev"},"appCallbackDemoDescription":{"version":"1.0.0","buildNumber":"1","platform":"iOS","appType":"App类型，公司产品上可能有多个app","appFeatureType":"dev(pgyer蒲公英)、inner(TestFlight)、formal(AppStore)"}},{"h5CallBridgeActionDes":"获取埋点monitor的公共信息，并回调给h5","h5CallBridgeActionName":"h5CallBridgeAction_getFixedMonitorInfo","h5CallBridgeSendMessage":{"callbackMethod":"bridgeCallH5Action_showCallbackJsonString"},"h5CallBridgeDescription":{"callbackMethod":"获取到的数值在h5上用哪个方法来接口"},"appCallbackDemoValue":{"callbackMethod":"bridgeCallH5Action_showCallbackJsonString","app_id":"com.dvlproad.Beyond","app_name":"愿望屋","app_version":"1.0.0","app_buildNumber":"1","platform":"iOS","lib":"iOS","systemName":"iOS","lib_version":"16.1","lib_method":"code","lib_source":1,"brand":"iPhone","model":"iPhone","os":"x86_64","screen_width":393,"screen_height":852,"screen_devicePixelRatio":3,"device_id":"8CA0BE41-DE55-41E3-ABBD-8F8EC98652E3","geo_coordinate_system":"bd09ll"}}]},{"sectionTitle":"H5调用app，回调给H5(实时变化的)","sectionDatas":[{"h5CallBridgeActionDes":"获取用户token(用于安全的告知h5用户信息)，并回调给h5","h5CallBridgeActionName":"h5CallBridgeAction_getCurrentUserToken","h5CallBridgeSendMessage":{"callbackMethod":"bridgeCallH5Action_showCallbackJsonString"},"h5CallBridgeDescription":{"callbackMethod":"获取到的数值在h5上用哪个方法来接口"},"appCallbackDemoValue":{"userToken":"bearer clientApp8983c8e6-5e3c-48e9-a3f7-9af53a946911"}},{"h5CallBridgeActionDes":"获取键盘变化高度，并回调给h5","h5CallBridgeActionName":"h5CallBridgeAction_getCurrentKeyboardHeight","h5CallBridgeSendMessage":{"callbackMethod":"bridgeCallH5Action_showCallbackJsonString"},"h5CallBridgeDescription":{"callbackMethod":"获取到的数值在h5上用哪个方法来接口"},"appCallbackDemoValue":{"keyboardHeight":123}}]},{"sectionTitle":"WebControl的方法","sectionDatas":[{"h5CallBridgeActionDes":"刷新网页(到新地址)","h5CallBridgeActionName":"h5CallBridgeAction_reloadAppWebView","h5CallBridgeSendMessage":{"url":"https://www.baidu.com"}}]},{"sectionTitle":"h5调用app的方法(①无入参和回参;②有入参给app,但无需回参;③需回参给h5)","sectionDatas":[{"h5CallBridgeActionDes":"显示app的toast样式","h5CallBridgeActionName":"h5CallBridgeAction_showAppToast","h5CallBridgeSendMessage":{"message":"恭喜您分享成功"}},{"h5CallBridgeActionDes":"更新状态栏颜色_light","h5CallBridgeActionName":"h5CallBridgeAction_updateAppStatusBarStyle","h5CallBridgeSendMessage":{"statusBarColor":"light"}},{"h5CallBridgeActionDes":"更新状态栏颜色_dark","h5CallBridgeActionName":"h5CallBridgeAction_updateAppStatusBarStyle","h5CallBridgeSendMessage":{"statusBarColor":"dark"}},{"h5CallBridgeActionDes":"更新键盘弹出时候是否自动调整页面大小_true","h5CallBridgeActionName":"h5CallBridgeAction_updateResizeToAvoidBottomInset","h5CallBridgeSendMessage":{"shouldResizeToAvoidBottomInset":"true"}},{"h5CallBridgeActionDes":"更新键盘弹出时候是否自动调整页面大小_false","h5CallBridgeActionName":"h5CallBridgeAction_updateResizeToAvoidBottomInset","h5CallBridgeSendMessage":{"shouldResizeToAvoidBottomInset":"false"}}]},{"sectionTitle":"跳转到app指定页面","sectionDatas":[{"h5CallBridgeActionDes":"跳转到app指定页面_Url_原生页面","h5CallBridgeActionName":"h5CallBridgeAction_jumpAppPageUrl","h5CallBridgeSendMessage":{"url":"yuanwangwu://openpage?pageName=imChatPage&conversationID=126191&imUserId=1602856363702501376&showName=婉艺&type=1&dialogSubjectId=1506196208391966720"}},{"h5CallBridgeActionDes":"跳转到app指定页面_Url_网页游戏(url无参可不编码)","h5CallBridgeActionName":"h5CallBridgeAction_jumpAppPageUrl","h5CallBridgeSendMessage":{"url":"yuanwangwu://openpage?pageName=webNavPage&url=https://farm-game.yuanwangwu.com/index.html&shouldHideNavBar=true"}},{"h5CallBridgeActionDes":"跳转到app指定页面_Url_网页游戏(url带参必须编码)","h5CallBridgeActionName":"h5CallBridgeAction_jumpAppPageUrl","h5CallBridgeSendMessage":{"url":"yuanwangwu://openpage?pageName=webNavPage&shouldHideNavBar=true&navigatorBackgroundColor=0xffffff00&statusBarColor=light&url=https%3A%2F%2Ffarm-game.yuanwangwu.com%2Findex.html%26toUserId%3D111"}},{"h5CallBridgeActionDes":"跳转到app指定页面_Name_原生页面","h5CallBridgeActionName":"h5CallBridgeAction_jumpAppPageName","h5CallBridgeSendMessage":{"pageName":"imChatPage","pageParams":{"conversationID":"126191","imUserId":"1602856363702501376","showName":"婉艺","type":1,"dialogSubjectId":"1506196208391966720"}}},{"h5CallBridgeActionDes":"跳转到app指定页面_Name_网页游戏","h5CallBridgeActionName":"h5CallBridgeAction_jumpAppPageName","h5CallBridgeSendMessage":{"pageName":"webNavPage","pageParams":{"shouldHideNavBar":true,"navigatorBackgroundColor":"0xffffff00","statusBarColor":"light","url":"https://farm-game.yuanwangwu.com/index.html&toUserId=111"}}}]},{"sectionTitle":"分享网页链接","sectionDatas":[{"h5CallBridgeActionDes":"只是分享网页链接，没其他操作","h5CallBridgeActionName":"h5CallBridgeAction_share","h5CallBridgeSendMessage":{"shareType":"Wechat_SESSION","shareWebPageUrl":"https://www.baidu.com","shareTitle":"你的好友发来一条加急消息","shareDescription":"急急急，快来帮我转大转盘，100%中奖！","shareThumbnailUrl":"https://img1.baidu.com/it/u=1605341541,1182642759&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1673370000&t=4e694f8a257f10a7f6b52bd051288e7d"}},{"h5CallBridgeActionDes":"分享链接，且链接可打开app的_原生页面","h5CallBridgeActionName":"h5CallBridgeAction_share","h5CallBridgeSendMessage":{"shareType":"Wechat_SESSION","shareWebPageUrl":"yuanwangwu://openpage?pageName=imChatPage&conversationID=126191&imUserId=1602856363702501376&showName=婉艺&type=1&dialogSubjectId=1506196208391966720","shareTitle":"你的好友发来一条加急消息","shareDescription":"急急急，快来帮我转大转盘，100%中奖！","shareThumbnailUrl":"https://img1.baidu.com/it/u=1605341541,1182642759&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1673370000&t=4e694f8a257f10a7f6b52bd051288e7d"}},{"h5CallBridgeActionDes":"分享链接，且链接可打开app的_网页游戏","h5CallBridgeActionName":"h5CallBridgeAction_share","h5CallBridgeSendMessage":{"shareType":"Wechat_SESSION","shareWebPageUrl":"http://test-h5.yuanwangwu.com/pages-h5/share/share-farm?&accountId=1475332557208702976&appurl=yuanwangwu://openpage?pageName=farmGamePage&accountId=1475332557208702976","shareTitle":"你的好友发来一条加急消息","shareDescription":"急急急，快来帮我转大转盘，100%中奖！","shareThumbnailUrl":"https://img1.baidu.com/it/u=1605341541,1182642759&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1673370000&t=4e694f8a257f10a7f6b52bd051288e7d"}}]},{"sectionTitle":"实际业务功能","sectionDatas":[{"h5CallBridgeActionDes":"发送IM消息_私聊_文本","h5CallBridgeDescription":["发起会话聊天，发起私聊/商家聊天 商家聊天走的是群组聊天","dialogSubjectId: 跟店铺聊天的时候，传的是shopId 跟用户聊天则是 accountId"],"h5CallBridgeActionName":"h5CallBridgeAction_sendIMText","h5CallBridgeSendMessage":{"dialogType":"user","dialogSubjectId":"228013","text":"hello, 你好"}},{"h5CallBridgeActionDes":"显示打赏弹窗及动画_给愿望单","h5CallBridgeActionName":"h5CallBridgeAction_showAppReward","h5CallBridgeSendMessage":{"rewardType":"wish","rewardParams":{"wishId":"1836962","buyerId":"108031"}}}]}]]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5js/test_h5js_demo/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5js/test_h5js_demo/</url>
      
        <content type="html"><![CDATA[<!-- * @Author: dvlproad * @Date: 2022-12-27 11:59:38 * @LastEditors: dvlproad * @LastEditTime: 2023-01-09 11:33:25 * @Description: --><!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0">  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>html demo</title></head><body>  <div style="margin-top: 80px;" id="fromFlutter"><span>Flutter发送过来的消息是： </span></div>  <div id="toFlutter"><span>我发送给Flutter的消息是：</span></div>    <textarea id="h5SendMessageToBridge" style="height: 300px; width: 300px;">多行的文本输入框</textarea>  <button onclick="h5Action_updateTextAreaValue_Toast()">h5Action_updateTextAreaValue_Toast</button>  <button onclick="h5Action_showAppToast()">h5Action_showAppToast</button>  <button onclick="h5Action_updateTextAreaValue_jumpAppPage()">h5Action_updateTextAreaValue_jumpAppPage</button>  <button onclick="h5Action_jumpAppPage()">h5Action_jumpAppPage</button>  <button onclick="h5Action_updateTextAreaValue_jump_app_url()">h5Action_updateTextAreaValue_jump_app_url</button>  <button onclick="h5Action_jump_app_url()">h5Action_jump_app_url</button>  <button onclick="h5Action_updateTextAreaValue_showAppReward()">h5Action_updateTextAreaValue_showAppReward</button>  <button onclick="h5Action_showAppReward()">h5Action_showAppReward</button>  <button onclick="h5Action_updateTextAreaValue_updateAppStatusBarStyle('light')">h5Action_updateTextAreaValue_updateAppStatusBarStyle 更新状态栏颜色 light</button>  <button onclick="h5Action_updateTextAreaValue_updateAppStatusBarStyle('dark')">h5Action_updateTextAreaValue_updateAppStatusBarStyle 更新状态栏颜色 dark</button>  <button onclick="h5Action_updateAppStatusBarStyle()">h5Action_updateAppStatusBarStyle</button>  </body><script>  // 这个方法是用来给Flutter调用的（即：Flutter调用js方法）  function fromFlutterMessage(message) {    document.getElementById("fromFlutter").innerHTML = message;    return true;  }  // h5Action_showAppToast  function h5Action_updateTextAreaValue_Toast() {    var message = '这里是来自JavaScript的方法:h5Action_showAppToast';    document.getElementById("toFlutter").innerHTML = message;    document.getElementById("h5SendMessageToBridge").innerHTML = message;    console.log(message.message);  }  // 这个方法是用来发送一个消息给Flutter的（即：js调用Flutter方法）  function h5Action_showAppToast() {    var message= document.getElementById("h5SendMessageToBridge").value;    h5CallBridgeAction_showAppToast.postMessage(message);    console.log(message.message);  }  // h5Action_jumpAppPage  function h5Action_updateTextAreaValue_jumpAppPage() {    /// 处理协议跳转    /// 规则说明：    /// yuanwangwu://openpage?pageName=XXXX&orderId=XXXXX    /// 如果是从外部h5跳转app使用 yuanwangwu://openpage?pageName=webPage&url=URLEncode(http://www.baidyu.com)    /// 例：yuanwangwu://openpage?pageName=webPage&url=http%3A%2F%2Fwww.baidu.com    /// 如果是跳转到内部页面 使用：yuanwangwu://openpage?pageName=XXXXXX&id=XXX    /// 例：yuanwangwu://openpage?pageName=testPage&id=123    /// 如果是跳转【微信小程序】 使用：yuanwangwu://openpage?pageName=mp&path=URLEncode(XXX)    /// 例：略    // var message = 'yuanwangwu://openpage?pageName=webPage&url=URLEncode(http://www.baidyu.com)';    var message = 'yuanwangwu://openpage?pageName=imChatPage&conversationID=126191&imUserId=1602856363702501376&showName=婉艺&type=1&dialogSubjectId=1506196208391966720';        document.getElementById("toFlutter").innerHTML = message;    document.getElementById("h5SendMessageToBridge").innerHTML = message;    console.log(message.message);  }  function h5Action_jumpAppPage() {    var sendMessage= document.getElementById("h5SendMessageToBridge").value;    h5CallBridgeAction_jumpAppPage.postMessage(sendMessage);  }  // h5Action_jumpAppPage  function h5Action_updateTextAreaValue_jump_app_url() {    var url = 'yuanwangwu://openpage?pageName=imChatPage&conversationID=126191&imUserId=1602856363702501376&showName=婉艺&type=1&dialogSubjectId=1506196208391966720';    var map = { "url" : url};    var message  = JSON.stringify(map);    document.getElementById("toFlutter").innerHTML = message;    document.getElementById("h5SendMessageToBridge").innerHTML = message;    console.log(message.message);  }  function h5Action_jump_app_url() {    var sendMessage= document.getElementById("h5SendMessageToBridge").value;    jump_app_url.postMessage(sendMessage);  }  // h5Action_showAppReward  function h5Action_updateTextAreaValue_showAppReward() {    var url = 'yuanwangwu://openpage?pageName=imChatPage&conversationID=126191&imUserId=1602856363702501376&showName=婉艺&type=1&dialogSubjectId=1506196208391966720';    var map = { "url" : url};    var message  = JSON.stringify(map);    document.getElementById("toFlutter").innerHTML = message;    document.getElementById("h5SendMessageToBridge").innerHTML = message;    console.log(message.message);  }  function h5Action_showAppReward() {    var sendMessage= document.getElementById("h5SendMessageToBridge").value;    h5CallBridgeAction_showAppReward.postMessage(sendMessage);  }  // h5Action_updateAppStatusBarStyle 更新状态栏颜色  function h5Action_updateTextAreaValue_updateAppStatusBarStyle(statusBarColorStyle) {    var map = { "statusBarColor" : statusBarColorStyle};    var message  = JSON.stringify(map);    document.getElementById("toFlutter").innerHTML = message;    document.getElementById("h5SendMessageToBridge").innerHTML = message;    console.log(message.message);  }  function h5Action_updateAppStatusBarStyle() {    var sendMessage= document.getElementById("h5SendMessageToBridge").value;    h5CallBridgeAction_updateAppStatusBarStyle.postMessage(sendMessage);  }</script></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>总目录</title>
      <link href="/%E6%80%BB%E7%9B%AE%E5%BD%95/"/>
      <url>/%E6%80%BB%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="Architecture架构"><a href="#Architecture架构" class="headerlink" title="Architecture架构"></a>Architecture架构</h2><ul><li><a href="Architecture架构/架构分层">第一章：架构分层</a></li><li><a href="Architecture架构/切为H5的标准">第二章：切为H5的标准</a></li><li><a href="Architecture架构/README">第三章：H5与原生交互</a><ul><li><a href="Architecture架构/h5_native_interacte/h5js">第1.1节：h5js</a></li><li><a href="Architecture架构/h5_native_interacte/h5_open_app">第1.2节：h5 open app</a></li></ul></li></ul><h2 id="iOS部分"><a href="#iOS部分" class="headerlink" title="iOS部分"></a>iOS部分</h2><ul><li><a href="./iOS/README">前言</a></li><li><a href="iOS/开发规范/开发规范">第一章：开发规范</a></li><li><a href="iOS/Swift/README">第二章：Swift</a><ul><li><a href="iOS/Swift/1入门/Swift基础知识">第1节：Swift基础知识</a></li></ul></li><li><a href="iOS/架构相关/README">第三章：架构相关</a><ul><li><a href="iOS/架构相关/1架构模式/架构模式-①概览">第1.1节：架构模式-①概览</a></li><li><a href="iOS/架构相关/1架构模式/架构模式-④MVC与MVVM">第1.2节：架构模式-④MVC与MVVM</a></li><li><a href="iOS/架构相关/1架构细节/你真的会用RAC吗">第1.3节：架构细节-①你真的会用RAC吗</a></li><li><a href="iOS/架构相关/2设计模式/设计模式-①概览">第2.1节：设计模式-①概览</a></li><li><a href="iOS/架构相关/2设计模式/设计模式-②单例模式">第2.2节：设计模式-②单例模式</a></li><li><a href="iOS/架构相关/2设计模式/设计模式-③观察者模式(KVO&amp;Notification">第2.3节：设计模式-③观察者模式(KVO&amp;Notification)</a>)</li><li><a href="iOS/架构相关/2设计模式/设计模式-⑤多代理模式">第2.4节：设计模式-⑤多代理模式</a></li><li><a href="iOS/架构相关/3组件化/5框架设计模式-⑦组件化">第3节：组件化</a></li><li><a href="iOS/架构相关/4瘦身/瘦身-①UIViewController">第4.1节：瘦身-①UIViewController</a></li><li><a href="iOS/架构相关/4瘦身/瘦身-②AppDelegate瘦身">第4.2节：瘦身-②AppDelegate瘦身</a></li><li><a href="iOS/架构相关/4瘦身/瘦身-③app安装包">第4.3节：瘦身-③app安装包</a></li><li><a href="iOS/架构相关/新项目实施步骤">其他：新项目实施步骤</a></li></ul></li><li><a href="iOS/性能相关/README">第四章：性能相关</a><ul><li><a href="iOS/性能相关/性能优化-①TableView优化">第1.1节：性能优化-①TableView优化</a></li><li><a href="iOS/性能相关/性能优化-②其他">第1.2节：性能优化-②其他</a></li><li><a href="iOS/性能相关/性能监控-①卡顿监控">第2节：性能监控-①卡顿监控</a></li><li><a href="iOS/性能相关/6编译优化hmap">第3节：编译优化hmap</a></li><li><a href="iOS/性能相关/启动优化">第4节：启动优化</a></li></ul></li><li><a href="iOS/第三方库/README">第X章：第三方库</a><ul><li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage①缓存-①NSCache">第1.1节：图片库SDWebImage①缓存-①NSCache</a></li><li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage①缓存-②缓存原理">第1.2节：图片库SDWebImage①缓存-②缓存原理</a></li><li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage①缓存-③缓存不更新问题">第1.3节：图片库SDWebImage①缓存-③缓存不更新问题</a></li><li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage②请求-①简介">第2.1节：图片库SDWebImage②请求-①简介</a></li><li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage②请求-②避免重复请求问题">第2.2节：图片库SDWebImage②请求-②避免重复请求问题</a></li><li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage③解码">第3节：图片库SDWebImage③解码</a></li><li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage④其他">第4节：图片库SDWebImage④其他</a></li><li><a href="iOS/第三方库/数据库FMDB/数据库-①FMDB">第5.1节：数据库FMDB</a></li><li><a href="iOS/第三方库/数据库FMDB/数据库">第5.2节：数据库</a></li><li><a href="iOS/第三方库/网络库AFNetworking/第三方网络库AFNetworking">第6节：网络库AFNetworking</a></li></ul></li><li>进阶<ul><li><a href="iOS/进阶/iOS进阶_多Target">第1节：iOS进阶_多Target</a></li><li><a href="iOS/进阶/iOS进阶_多Configuration">第2节：iOS进阶_多Configuration</a></li><li><a href="iOS/进阶/APNS+TCP推送流程">第3节：APNS+TCP推送流程</a></li><li><a href="iOS/进阶/iOS进阶_推送模拟">第4节：iOS进阶_推送模拟</a></li><li><a href="iOS/进阶/企业版灰度流程">第5节：企业版灰度流程</a></li></ul></li><li>功能性技术<ul><li><a href="iOS/功能性技术/iOS功能-通用链接">第1节：iOS功能-通用链接</a></li><li><a href="iOS/功能性技术/iOS功能-Transform">第2节：iOS功能-Transform</a></li></ul></li><li>证书发版<ul><li><a href="iOS/证书发版/邓白氏编码申请">第1节：邓白氏编码申请</a></li></ul></li><li><a href="iOS/移动分析/README">第四章：移动分析</a></li><li><a href="iOS/自动化/README">第五章：自动化</a><ul><li><a href="iOS/自动化/iOS 安装包0-完整自动化流程">第1节：iOS 安装包0-完整自动化流程</a></li><li><a href="iOS/自动化/iOS 安装包1-编译&amp;打包">第2节：iOS 安装包1-编译&amp;打包</a></li><li><a href="iOS/自动化/iOS 安装包2-上传">第3节：iOS 安装包2-上传</a></li><li><a href="iOS/自动化/iOS 自动化测试">第4节：iOS 自动化测试</a></li><li><a href="iOS/自动化/iOS 单元测试">第5节：iOS 单元测试</a></li></ul></li><li><a href="iOS/app安全/README">第六章：app安全</a></li></ul><h2 id="Flutter部分"><a href="#Flutter部分" class="headerlink" title="Flutter部分"></a>Flutter部分</h2><ul><li><a href="./Flutter/README">前言</a></li><li><a href="Flutter/1入门/README">第一章：入门</a><ul><li><a href="Flutter/1入门/Flutter开发环境搭建与运行">第1节：Flutter开发环境搭建与运行</a></li><li><a href="Flutter/1入门/Flutter的Hello World">第2节：Flutter的Hello World</a></li><li><a href="Flutter/1入门/Flutter的最基础知识">第3节：Flutter的最基础知识</a></li><li><a href="Flutter/1入门/Dart语言必备基础知识">第4节：Dart语言必备基础知识</a></li></ul></li><li><a href="Flutter/2集成/README">第二章：原生项目集成Flutter</a><ul><li><a href="Flutter/2集成/iOS项目集成Flutter">第1节：iOS项目集成Flutter</a></li><li><a href="Flutter/2集成/Android项目集成Flutter">第2节：Android项目集成Flutter</a></li></ul></li><li><a href="Flutter/3交互/README">第三章：原生项目与Flutter交互</a><ul><li><a href="Flutter/3交互/用于测试交互的Flutter项目">第1节：用于测试交互的Flutter项目</a></li><li><a href="Flutter/3交互/交互时iOS端的代码编写">第2节：交互时iOS端的代码编写</a></li><li><a href="Flutter/3交互/交互时Android端的代码编写">第3节：交互时Android端的代码编写</a></li></ul></li><li><a href="Flutter/4登录页实战/README">第四章：Flutter登录页实战</a><ul><li><a href="Flutter/4登录页实战/登录页在Flutter工程中的代码">第1节：登录页在Flutter工程中的代码</a></li><li><a href="Flutter/4登录页实战/登录页在iOS工程中的代码">第2节：登录页在iOS工程中的代码</a></li><li><a href="Flutter/4登录页实战/登录页在Android工程中的代码">第3节：登录页在Android工程中的代码</a></li></ul></li><li><a href="Flutter/5详解/README">第五章：Flutter详解</a><ul><li><a href="Flutter/5详解/详解Button">第1节：详解Button</a></li><li><a href="Flutter/5详解/详解TextField">第2节：详解TextField</a></li><li><a href="Flutter/5详解/详解Platform Channel">第3节：详解Platform Channel</a></li></ul></li><li><a href="Flutter/6进阶/README">第六章：Flutter进阶</a><ul><li><a href="Flutter/6进阶/iOS项目集成Flutter高级">第1节：iOS项目集成Flutter高级</a></li><li><a href="Flutter/6进阶/Flutter控件的封装">第2节：Flutter控件Widget的封装</a></li><li><a href="Flutter/6进阶/Package的使用、开发与发布">第3节：Package的使用、开发与发布</a></li><li><a href="Flutter/6进阶/Flutter的设计模式">第4节：Flutter的设计模式</a></li></ul></li><li><a href="Flutter/7规范/README">第七章：Flutter规范</a><ul><li><a href="Flutter/7规范/Flutter开发规范">第1节：Flutter开发规范</a></li></ul></li><li><a href="Flutter/8状态管理/README">第八章：Flutter状态管理</a><ul><li><a href="Flutter/8状态管理/状态管理1Provider">第1节：状态管理1Provider</a></li><li><a href="Flutter/8状态管理/状态管理-框架对比">第2节：状态管理-框架对比</a></li></ul></li><li><a href="Flutter/9框架升级/README">第九章：Flutter框架升级</a><ul><li><a href="Flutter/9框架升级/基础框架">第1节：基础框架</a></li><li><a href="Flutter/9框架升级/基础框架的接入">第2节：基础框架的接入</a></li><li><a href="Flutter/9框架升级/组件的使用">第3节：组件的使用</a></li></ul></li></ul><h2 id="React-Native-部分"><a href="#React-Native-部分" class="headerlink" title="React Native 部分"></a>React Native 部分</h2><ul><li><a href="./ReactNative/ReactNative README">前言</a></li><li><a href="ReactNative/1入门/README">第一章：入门</a><ul><li><a href="ReactNative/1入门/ReactNative开发环境搭建与运行">第1节：ReactNative开发环境搭建与运行</a></li><li><a href="ReactNative/1入门/ReactNative的Hello World">第2节：ReactNative的Hello World</a></li><li><a href="ReactNative/1入门/ReactNative的最基础知识">第3节：ReactNative的最基础知识</a></li><li><a href="ReactNative/1入门/ReactNative必备的语言基础知识">第4节：ReactNative必备的语言基础知识</a></li><li><a href="ReactNative/1入门/ReactNative的常用库">第5节：ReactNative的常用库</a></li></ul></li><li><a href="ReactNative/5详解/README">第五章：ReactNative详解</a><ul><li><a href="ReactNative/5详解/ReactNative详解布局">第1节：详解布局</a></li><li><a href="ReactNative/5详解/ReactNative详解Button">第2节：详解Button</a></li></ul></li><li><a href="ReactNative/6进阶/README">第六章：ReactNative进阶</a><ul><li><a href="ReactNative/6进阶/ReactNative使用技巧">第1节：ReactNative使用技巧</a></li><li><a href="ReactNative/6进阶/ReactNative的继承重写等">第2节：ReactNative的继承重写等</a></li><li><a href="ReactNative/6进阶/ReactNative组件的封装">第3节：ReactNative组件Component的封装</a></li></ul></li><li><a href="ReactNative/8实践/README">第八章：ReactNative实践</a><ul><li><a href="ReactNative/8实践/ReactNative的Demo实践">第1节：ReactNative的Demo实践</a></li></ul></li></ul><h2 id="React-部分"><a href="#React-部分" class="headerlink" title="React 部分"></a>React 部分</h2><ul><li><a href="./React/React README">前言</a></li><li><a href="React/1入门/README">第一章：入门</a><ul><li><a href="ReactNative/1入门/ReactNative开发环境搭建与运行">第1节：React开发环境搭建与运行</a></li><li><a href="React/1入门/ReactNative的Hello World">第2节：React的Hello World</a></li><li><a href="React/1入门/ReactNative的最基础知识">第3节：React的最基础知识</a></li><li><a href="React/1入门/ReactNative必备的语言基础知识">第4节：React必备的语言基础知识</a></li><li><a href="ReactNative/1入门/ReactNative的常用库">第5节：ReactNative的常用库</a></li><li><a href="React/1入门/React与ReactNative的区别">React与ReactNative的区别</a></li></ul></li></ul><h2 id="H5-APP"><a href="#H5-APP" class="headerlink" title="H5-APP"></a>H5-APP</h2><ul><li><a href="H5-APP/1入门/README">第一章：入门</a><ul><li><a href="H5-APP/1入门/H5-APP开发环境搭建与运行">第1节：H5-APP开发环境搭建与运行</a></li><li><a href="H5-APP/1入门/H5-APP开发小技巧">第2节：H5-APP开发小技巧</a></li></ul></li></ul><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul><li><a href="HTML/1入门/README">第一章：入门</a><ul><li><a href="HTML/1入门/web必备基础1-学习路线">第1节：web必备基础1-学习路线</a></li><li><a href="HTML/1入门/web必备基础2-实践基础">第2节：web必备基础2-实践基础</a></li><li><a href="HTML/1入门/web必备基础3-代码复用">第3节：web必备基础3-代码复用</a></li></ul></li><li><a href="HTML/2扩展/README">第二章：扩展</a><ul><li><a href="HTML/2扩展/web扩展1">第1节：web扩展1</a></li></ul></li></ul><h2 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h2><ul><li><a href="Weex/1入门/README">第一章：入门</a><ul><li><a href="Weex/1入门/Weex开发环境搭建与运行">第1节：Weex开发环境搭建与运行</a></li></ul></li></ul><h2 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h2><ul><li><a href="Script/Script README">前言</a></li><li>Shell<ul><li><a href="./Script/Shell/Shell入门">Shell</a></li></ul></li><li>Ruby<ul><li><a href="Script/Ruby/Ruby入门">Ruby</a></li></ul></li><li>JavaScript<ul><li><a href="Script/JavaScript/JavaScript入门">JavaScript</a></li></ul></li><li>Python<ul><li><a href="Script/Python/Python入门">Python</a></li></ul></li></ul><h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><ul><li><p>阿里云</p><ul><li><a href="实用工具/阿里云oss/阿里云">第1节：阿里云</a></li></ul></li><li><p>阿里云oss</p><ul><li><a href="实用工具/阿里云oss/阿里云oss1上传">第1节：阿里云oss1上传</a></li></ul></li><li><p>阿里云服务器ECS</p><ul><li><a href="实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接">第1节：阿里云服务器ECS的购买与远程连接</a></li><li><a href="实用工具/阿里云服务器ECS/阿里云服务器ECS的使用">第2节：阿里云服务器ECS的使用</a></li><li><a href="实用工具/阿里云服务器ECS/阿里云服务器ECS域名绑定">第3节：阿里云服务器ECS域名绑定</a></li><li><a href="实用工具/阿里云服务器ECS/阿里云服务器ECS的数据备份">第4节：阿里云服务器ECS的数据备份</a></li></ul></li></ul><h2 id="实用工具部分"><a href="#实用工具部分" class="headerlink" title="实用工具部分"></a>实用工具部分</h2><ul><li><p><a href="实用工具/Terminal/README">Terminal</a></p><ul><li><a href="实用工具/Terminal/1终端常用命令">第1节：终端常用命令</a></li><li><a href="实用工具/Terminal/终端命令安装">第2节：终端命令安装</a></li><li><a href="实用工具/Terminal/终端命令使用">第3节：终端命令使用</a></li></ul></li><li><p><a href="实用工具/Hexo/README">Hexo</a></p><ul><li><a href="实用工具/Hexo/1Hexo的使用">第1节：1Hexo的使用</a></li><li><a href="实用工具/Hexo/2Hexo的进阶">第2节：2Hexo的进阶</a></li></ul></li><li><p><a href="实用工具/GitBook/README">GitBook</a></p><ul><li><a href="实用工具/GitBook/1GitBook的使用">第1节：GitBook的使用</a></li></ul></li><li><p><a href="实用工具/XAMPP/XAMPP问题整理">XAMPP</a></p></li><li><p>yapi</p><ul><li><a href="实用工具/yapi/yapi的安装">第1节：yapi的安装</a></li><li><a href="实用工具/yapi/yapi的项目运行">第2节：yapi的项目运行</a></li><li><a href="实用工具/yapi/yapi在云服务器ECS上的使用-阿里云">第3节：yapi在云服务器ECS上的使用-阿里云</a></li><li><a href="实用工具/yapi/yapi的使用之设置篇">第4节：yapi的使用之设置篇</a></li><li><a href="实用工具/yapi/Mock基础知识">第5节：Mock基础知识</a></li><li><a href="实用工具/yapi/yapi的使用之Mock篇">第6节：yapi的使用之Mock篇</a></li></ul></li><li><p><a href="实用工具/MySQL/MySQL问题整理">MySQL</a></p></li><li><p><a href="实用工具/Zentao/Zentao问题整理">Zentao</a></p></li><li><p><a href="实用工具/明道/明道">明道</a></p></li><li><p><a href="实用工具/Jenkins/Jenkins使用问题常见">Jenkins</a></p><ul><li><a href="实用工具/Jenkins/Jenkins的安装与启动">第1节：Jenkins的安装与启动</a></li><li><a href="实用工具/Jenkins/Jenkins基本操作">第2节：Jenkins基本操作</a></li><li><a href="实用工具/Jenkins/Jenkins使用技巧常用">第3节：Jenkins使用技巧常用</a></li><li><a href="实用工具/Jenkins/Jenkins使用问题常见">第4节：Jenkins使用问题常见</a></li><li><a href="实用工具/Jenkins/Jenkins常用插件介绍">第5节：Jenkins常用插件介绍</a></li></ul></li><li><p>qrencode</p><ul><li><a href="实用工具/qrencode/qrencode">第1节：qrencode</a></li></ul></li><li><p>Xcode Extensions</p><ul><li><a href="实用工具/Xcode Extensions/Swifttify for Xcode">Swifttify for Xcode</a></li></ul></li><li><p><a href="实用工具/其他小工具/其他小工具">其他小工具</a></p><blockquote><p>截图、录屏、音频转换</p></blockquote></li></ul><h2 id="代码管理"><a href="#代码管理" class="headerlink" title="代码管理"></a>代码管理</h2><ul><li>Git<ul><li><a href="代码管理/Git/Git">Git</a></li></ul></li><li>CocoaPods<ul><li><a href="代码管理/CocoaPods/CocoaPods">CocoaPods</a></li></ul></li><li>npmjs<ul><li><a href="代码管理/npmjs的命令/npmjs的命令">npmjs的命令</a></li><li><a href="代码管理/npmjs的调试/npmjs的调试">npmjs的调试</a></li><li><a href="代码管理/npmjs的发布/npmjs的发布">npmjs的发布</a></li></ul></li></ul><h2 id="电脑使用"><a href="#电脑使用" class="headerlink" title="电脑使用"></a>电脑使用</h2><ul><li><a href="电脑使用/新电脑初始配置">第1节：新电脑初始配置</a></li><li><a href="电脑使用/旧电脑数据清理">第2节：旧电脑数据清理</a></li><li><a href="电脑使用/电脑使用过程中的问题">第3节：电脑使用过程中的问题</a></li><li><a href="电脑使用/Mac中个各种文件夹">第4节：Mac中个各种文件夹</a></li></ul><h2 id="常识类"><a href="#常识类" class="headerlink" title="常识类"></a>常识类</h2><ul><li>Office常识<ul><li><a href="常识类/Office常识/PPT常识">第1节：PPT常识</a></li></ul></li><li>技术常识<ul><li><a href="常识类/技术常识/技术常识">第1节：技术常识</a></li></ul></li><li>生活常识<ul><li><a href="常识类/生活常识/楼房常识">第1节：楼房常识</a></li></ul></li></ul><h2 id="编程工具部分"><a href="#编程工具部分" class="headerlink" title="编程工具部分"></a>编程工具部分</h2><ul><li><a href="编程工具/WebStorm">WebStorm</a><ul><li><a href="编程工具/WebStorm/WebStorm的使用技巧">第1节：WebStorm的使用技巧</a></li></ul></li></ul><h2 id="目前痛点"><a href="#目前痛点" class="headerlink" title="目前痛点"></a>目前痛点</h2><ul><li><a href="目前痛点/README">目前痛点</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Future</title>
      <link href="/Threads/Flutter_Dart/Future/"/>
      <url>/Threads/Flutter_Dart/Future/</url>
      
        <content type="html"><![CDATA[<h2 id="等待异步"><a href="#等待异步" class="headerlink" title="等待异步"></a>等待异步</h2><p>有时候执行某个动作，需要等到另一个事件结束，可以用Completer类。 </p><p>常见的有：</p><p>执行某个动作，需要弹窗等待用户选择某条件后再执行后续代码，</p><p>//事例</p><pre><code>var c = Completer&lt;bool&gt;();Dialogs.tipsCard(title, tip,  failMsg: &apos;&apos;,  actions: [i18n.ok],  callback: (index) =&gt; c.complete(true),  dismissCallBack: () {    if (!c.isCompleted)      c.complete(false);  },);return c.future;</code></pre><p>其他：</p><h2 id="Completer"><a href="#Completer" class="headerlink" title="Completer"></a><strong>Completer</strong></h2><p>Completer允许你做某个异步事情的时候，调用c.complete(value)方法来传入最后要返回的值。最后通过c.future的返回值来得到结果，（注意：宣告完成的complete和completeError方法只能调用一次，不然会报错）。看下面的例子更容易理解。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">test() <span class="keyword">async</span> &#123;</span><br><span class="line">   Completer c = <span class="keyword">new</span> Completer();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (i == <span class="number">900</span> &amp;&amp; c.isCompleted == <span class="keyword">false</span>) &#123;</span><br><span class="line">       c.completeError(<span class="string">'error in <span class="subst">$i<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">     &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">     if (i == 800 &amp;&amp; c.isCompleted == false) &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">       c.complete('</span></span>complete in <span class="subst">$i<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">     &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">   &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">   try &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">     String res = await c.future;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">     print(res); //得到complete传入的返回值 '</span></span>complete in 800'</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">     <span class="built_in">print</span>(e);<span class="comment">//捕获completeError返回的错误</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>怎么将一个Callback回调转化成Future同步方法（Callback to Future），可以配套async / await去使用呢？</strong></p><p>使用场景：dio请求使用call，但外部基本还是习惯使用future方式，为了减少接口的改动，使用callback转future方式。</p><p>参考文章：<a href="https://www.jianshu.com/p/e5cba8ca96bc" target="_blank" rel="noopener">Flutter&amp;Dart Callback转Future</a></p><h2 id="compute"><a href="#compute" class="headerlink" title="compute"></a>compute</h2><p>在一个页面中做耗时比较大的运算时，就算用了async / await异步处理， ui页面的动画还是会卡顿，因为还是在这个UI线程中做运算，异步只是说我可以先运行其他的，等我这边有结果再返回，但是，记住，我们的计算仍旧是在这个UI线程，仍会阻塞UI的刷新，异步只是在同一个线程的并发操作。</p><p>要解决这个卡顿问题，可以把运算移到另一个线程中，在dart中，这里不是称呼线程，是Isolate，直译叫做隔离，是因为隔离不共享数据，每个隔离中的变量都是不同的，不能相互共享。</p><p>Isolate的操作比较复杂，dart中封装了一层简单的实现</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// package:flutter/foundation.dart</span></span></span><br><span class="line">Future&lt;R&gt; <span class="built_in">Function</span>&lt;Q, R&gt;(FutureOr&lt;R&gt; <span class="built_in">Function</span>(Q), Q, &#123;debugLabel: <span class="built_in">String</span>&#125;)compute</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/foundation.dart'</span>;</span><br><span class="line"></span><br><span class="line">function callback( val )&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="markdown">/// <span class="code">`callback`</span> 必须是顶级方法或者是类的静态方法</span></span></span><br><span class="line"><span class="keyword">var</span> res = <span class="keyword">await</span> compute( callback , val );</span><br></pre></td></tr></table></figure><p>简单来讲就是运行var res = await compute( callback , val )函数。callback的传入参数是val, return的数据就是callback的res;</p><p>使用场景</p><ul><li>方法执行在几毫秒或十几毫秒左右的，应使用Future</li><li>如果一个任务需要几百毫秒或之上的，则建议compute（只有一次返回）或Isolate（用于订阅或有多次返回的）</li></ul><h2 id="Flutter-Dart-如何在app启动前等待异步任务？"><a href="#Flutter-Dart-如何在app启动前等待异步任务？" class="headerlink" title="Flutter/Dart :如何在app启动前等待异步任务？"></a>Flutter/Dart :如何在app启动前等待异步任务？</h2><p>我在一个dart应用程序上工作，我想获取缓存(SharedPreferences)中存在的数据，然后在应用程序的UI (主屏幕)上显示它。</p><p>问题:由于SharedPreferences是一个等待调用，我的主页加载，试图读取数据，应用程序崩溃，因为还没有从SharedPreferences中获取数据，并且应用程序在此之前加载。</p><p>其他参考文章：</p><h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>dart笔记13：用future实现等待多个任务完成后，再得到所有的执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import &apos;dart:async&apos;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  print(&apos;start&apos;);</span><br><span class="line"></span><br><span class="line">  Future task1 = Future(() &#123;</span><br><span class="line">    print(&apos;task1&apos;);</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Future task2 = Future(() &#123;</span><br><span class="line">    print(&apos;task2&apos;);</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Future task3 = Future(() &#123;</span><br><span class="line">    print(&apos;task3&apos;);</span><br><span class="line">    return 3;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Future future = Future.wait([task1, task2, task3]);</span><br><span class="line"></span><br><span class="line">  future.then((value) &#123;</span><br><span class="line">    print(value);</span><br><span class="line">  &#125;).catchError((e)&#123;</span><br><span class="line"> </span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  print(&apos;end&apos;);</span><br><span class="line"></span><br><span class="line">  //执行结果：</span><br><span class="line">  //start</span><br><span class="line">  //end</span><br><span class="line">  //task1</span><br><span class="line">  //task2</span><br><span class="line">  //task3</span><br><span class="line">  //[1, 2, 3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FutureBuilder"><a href="#FutureBuilder" class="headerlink" title="FutureBuilder"></a>FutureBuilder</h2><h1 id="Flutter：使用-Completer-实现自定义任务队列"><a href="#Flutter：使用-Completer-实现自定义任务队列" class="headerlink" title="Flutter：使用 Completer 实现自定义任务队列"></a>Flutter：使用 <code>Completer</code> 实现自定义任务队列</h1><ul><li><a href="https://www.jianshu.com/p/551ec32e3b6e" target="_blank" rel="noopener">Flutter：使用 <code>Completer</code> 实现自定义任务队列</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/"/>
      <url>/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>[TOC]</p><h1 id="Mac-配置环境变量"><a href="#Mac-配置环境变量" class="headerlink" title="Mac 配置环境变量"></a>Mac 配置环境变量</h1><p>环境变量的设置文件：</p><p>非M1类型的Mac：<code>~/.bash_profile</code></p><p>是M1类型的Mac：<code>~/.zshrc</code></p><p><img src="/电脑使用/环境变量设置/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/image-20220321012950969.png" alt="image-20220321012950969" style="zoom:33%;"></p><p>修改方法：</p><p>非M1类型的Mac：终端输入<code>open -n ~/.bash_profile</code></p><p>是M1类型的Mac：终端输入<code>open -n ~/.zshrc</code></p><p>编辑完保存并退出</p><p>非M1类型的Mac：输入 <code>source ~/.bash_profile</code> 使环境变量生效。</p><p>是M1类型的Mac：输入 <code>source ~/.zshrc</code> 使环境变量生效。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/Flutter%E9%9D%A2%E8%AF%95/"/>
      <url>/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/Flutter%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>通知、插件、路由</p><p>插入视图</p><p>设计模式？策略模式？单例？通知？几个原则。</p><ul><li style="list-style: none"><input type="checkbox" checked> 谈谈对项目做过的优化（历史存在什么问题，你的解决方式。）？</li><li style="list-style: none"><input type="checkbox" checked> 谈谈你做过的框架(侧重非UI部分)</li><li style="list-style: none"><input type="checkbox" checked> 谈谈埋点？</li></ul><p>搜索逻辑？冒泡排序？</p><p>封装</p><p>看过什么书，什么三方库？</p><ul><li><p>[x] 图片缓存？</p></li><li><p>[x] 性能优化（webView 优化）？</p><ul><li style="list-style: none"><input type="checkbox" checked> 内存优化、泄漏，检测？</li><li style="list-style: none"><input type="checkbox"> 启动优化</li><li style="list-style: none"><input type="checkbox"> 安装包大小优化</li></ul></li><li style="list-style: none"><input type="checkbox"> 应用在后台长时间执行（service 保活）</li><li style="list-style: none"><input type="checkbox"> 怎么区分不同平台的安装包？</li><li style="list-style: none"><input type="checkbox"> 同一应用多端，项目上怎么开发(司机端、乘客端)。</li><li><p>[ ] 路由设计 scheme://path?argument</p></li><li><p>[ ] </p></li></ul><p>app中核心的非数据组件()</p><p>图片处理、网络库、路由</p><p>锁</p><p>线程同步</p><p>掌握 RxJava + Retrofit + OkHttp 的⽹络底层框架，并结合 MVP、MVC、MVVM 三种架构模式编写出⽹络底 层框架，已应⽤于项⽬中，底层稳定性强 </p><p>了解LiveData，Viewmodel，DataBinding等新框架，且结合RxJava 使⽤MVVM架构应⽤在项⽬中 </p><p>理解内存泄露的原理，编写代码过程中能避免常⻅内存泄露。使⽤Memory Profiler 和 Memory Analyzer等 ⼯具检测内存泄露问题 </p><p>了解App启动速度优化，内存，以及APK 瘦身等优化</p><p>理解 Android 适配原理，能够做到适配各类常⽤机型 </p><p>理解Android触摸事件传递机制，⾃定义View和动画机制 理解 Handle 消息处理机制</p><p>理解多个设计模式的使⽤。如单例设计模式，观察者模式，建造者模式，装饰者设计模式等 独⽴编写多个lib库，如图库，列表适配库，⼴告库，分享库(QQ，微信，微博，Facebook等第三⽅)，均采⽤ 组件化开发⽅式，可快速移植其他项⽬中</p><p>Flutter</p><p>状态管理 setState\Provider</p><p>网络拦截器、</p><p>图片缓存</p><p>请求</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/2%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A0%E6%A6%82%E8%A7%88/"/>
      <url>/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/2%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A0%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-设计模式-①概览"><a href="#必备知识架构-设计模式-①概览" class="headerlink" title="必备知识架构-设计模式-①概览"></a>必备知识架构-设计模式-①概览</h1><p>[Toc]</p><h2 id="一、设计模式的六大原则"><a href="#一、设计模式的六大原则" class="headerlink" title="一、设计模式的六大原则"></a>一、设计模式的六大原则</h2><p>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 </p><h3 id="六大原则如下："><a href="#六大原则如下：" class="headerlink" title="六大原则如下："></a>六大原则如下：</h3><blockquote><p>①单一职责原则告诉我们实现类要职责单一;<br>eg:UserService专做用户相关，OrderService专做订单相关</p><p>②依赖倒置原则告诉我们要面向接口编程；通过抽象（接口或抽象类）使各个类或模块实现彼此独立，互不影响，实现模块间的松耦合。</p><p>定义： 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。//“抽象”指“接口或抽象类”，“细节”指“实现类”</p><p>eg：Driver开车，依赖的是Driver.drive(BaseCar)。而不能是没有基类的BenchiCar、BMWCar。</p><p><a href="https://blog.csdn.net/u013862108/article/details/79054620" target="_blank" rel="noopener">依赖倒置原则(设计模式原则)</a></p><p>③里氏替换原则告诉我们不要破坏继承体系;<br>eg：子类可以扩展父类的方法(扩展出一个showSpeed方法)，但不应该复写父类的方法。不要破坏继承体系;</p><p>④开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。<br>eg：在你有新的需求的时候，最好不要轻易修改老功能，你应当增加新的对象来实现，而不是修改原来的对象</p><p>⑤接口隔离原则告诉我们在设计接口的时候要精简单一;</p><p>通俗讲：不要把一大堆方法塞进一个接口里，导致这个接口变得臃肿无比。应该要根据实际需要，让接口中只有用得上的方法，<strong>也就是说要细化我们的接口</strong>。</p><p>定义为：</p><blockquote><ol><li>Clients should not be forced to depend upon interfaces that they don’t use. （客户端不应该依赖它不需要的接口。）</li><li>The dependency of one class to another one should depend on the smallest possible interface. （类间的依赖关系应该建立在最小的接口上。）它要求“最小的接口”，也就是该接口中没有多余的方法，所以<strong>这里的隔离是指和多余的方法隔离。</strong></li></ol></blockquote><p>⑥迪米特法则（最少知道原则），告诉我们要尽量降低类与类之间的耦合；<br>eg:UserService与OrderService之间要降低耦合</p></blockquote><h3 id="1、开闭原则"><a href="#1、开闭原则" class="headerlink" title="1、开闭原则"></a>1、开闭原则</h3><p>开闭原则：对扩展开发，对修改关闭。</p><p>在代码层面而言就是<strong>在你有新的需求的时候，你应当增加新的对象来实现，而不是修改原来的对象。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设计模式六大原则（6）：开闭原则</span><br><span class="line">定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</span><br><span class="line"></span><br><span class="line">问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</span><br><span class="line">解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</span><br><span class="line">举例：</span><br><span class="line">当有新需求时，如果增加功能涉及老功能点某些地方，最好不要轻易修改老功能，最好重新新增相应的功能，不然一些忽略的细节可能就会造成隐患。</span><br></pre></td></tr></table></figure><h3 id="2、里氏替换原则"><a href="#2、里氏替换原则" class="headerlink" title="2、里氏替换原则"></a>2、里氏替换原则</h3><p><strong>里氏替换原则:子类可以扩展父类的方法，但不应该复写父类的方法。不要破坏继承体系;</strong></p><p>假设有父类如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"汽车跑起来了"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaoMaCar</span>: <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.run()</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"当前行驶速度是80Km/h"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：子类可以扩展父类的方法(扩展出一个showSpeed方法)，但不应该复写父类的方法。不要破坏继承体系;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaoMaCar</span>: <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showSpeed</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"当前行驶速度是80Km/h"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、依赖倒置原则"><a href="#3、依赖倒置原则" class="headerlink" title="3、依赖倒置原则"></a>3、依赖倒置原则</h3><p>依赖倒置原则告诉我们要面向接口编程；通过抽象（接口或抽象类）使各个类或模块实现彼此独立，互不影响，实现模块间的松耦合。</p><p id="常见的设计模式"></p><h2 id="二、常见的设计模式"><a href="#二、常见的设计模式" class="headerlink" title="二、常见的设计模式"></a>二、常见的设计模式</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>MVC是模型、视图、控制器开发模式，对于iOS SDK，所有的View都是视图层的，它应该独立于模型层，由视图器来控制。所有的用户数据都是模型层，它应该独立于视图。所有的ViewController都是视图器，由它负责控制视图，访问模型数据。</p><h3 id="1、iOS开发中的几种设计模式介绍-应用场景、实例"><a href="#1、iOS开发中的几种设计模式介绍-应用场景、实例" class="headerlink" title="1、iOS开发中的几种设计模式介绍(应用场景、实例)"></a>1、iOS开发中的几种设计模式介绍(应用场景、实例)</h3><p><a href="http://blog.csdn.net/liwei3gjob/article/details/8926862" target="_blank" rel="noopener">iOS开发中的几种设计模式介绍</a></p><p>（一）代理模式</p><p>应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。</p><p>实例：tableview的datasource和delegate</p><p>（二）观察者模式</p><p>应用场景：一般为model层对，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。</p><p>实例：<br>①Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。<br>②KVO，键值对改变通知的观察者。</p><p>（三）MVC模式</p><p>应用场景：MVC模式是一种非常古老的设计模式，它通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。</p><p>实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。</p><p>（四）单例模式</p><p>应用场景：确保程序运行期间，某个类只有一份实例，<strong>常用于进行资源共享控制</strong>。</p><p>实例：[UIApplication sharedApplication]。</p><p>注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。<br>java，C++中使其没有公有构造函数，私有化并覆盖其构造函数。<br>object c中，重写allocWithZone方法，保证即使用户用 alloc方法直接创建单例类的实例，<br>返回的也只是此单例类的唯一静态变量。</p><p>（五）策略模式</p><p>应用场景：定义算法族，封装起来，使他们之间可以相互替换。<br>优势：使算法的变化独立于使用算法的用户<br>敏捷原则：接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。<br>实例：排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。<br>注意事项：1，剥离类中易于变化的行为，通过组合的方式嵌入抽象基类<br>2，变化的行为抽象基类为，所有可变变化的父类<br>3，用户类的最终实例，通过注入行为实例的方式，设定易变行为<br>防止了继承行为方式，导致无关行为污染子类。完成了策略封装和可替换性。</p><p>附：<a href="http://my.oschina.net/pengloo53/blog/173810" target="_blank" rel="noopener">Objective C中数组排序几种情况的总结</a></p><p>OC中常用的数组排序有以下几种方法：</p><p>①、sortedArrayUsingSelector:;</p><p>②、sortedArrayUsingComparator:;</p><p>③、sortedArrayUsingDescriptors:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//简单排序</span><br><span class="line">- (void)sortArray() &#123;</span><br><span class="line">    NSArray *array = [NSArray arrayWithObjects:@&quot;abc&quot;,@&quot;456&quot;,@&quot;123&quot;,@&quot;789&quot;,@&quot;ef&quot;, nil];</span><br><span class="line">    NSArray *sortedArray = [array sortedArrayUsingSelector:@selector(compare:)];</span><br><span class="line">    NSLog(@&quot;排序后:%@&quot;,sortedArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>策略模式的其他例子：</p><ul><li><a href="https://mp.weixin.qq.com/s/3csN2hTIHezZNm8-49jsGQ" target="_blank" rel="noopener"><strong>策略模式实例</strong></a></li><li>自己TableHomeViewController中的selector</li></ul><p>（六）工厂模式</p><p>应用场景：工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。<br>优势：易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。<br>敏捷原则：DIP依赖倒置原则<br>实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换<br>注意事项：项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很明显，<br>增 加了代码的复杂度，增加了调用层次，增加了内存负担。所以要注意防止模式的滥用。</p><p><a href="http://blog.csdn.net/xiazailushang/article/details/19040117" target="_blank" rel="noopener">iOS 设计模式之工厂模式</a><br><code>工厂模式我的理解是：他就是为了创建对象的</code></p><p>创建对象的时候，我们一般是alloc一个对象，如果需要创建100个这样的对象，如果是在一个for循环中还好说，直接一句alloc就行了，但是事实并不那么如意，我们可能会在不同的地方去创建这个对象，那么我们可能需要写100句alloc 了，但是如果我们在创建对象的时候，需要在这些对象创建完之后，为它的一个属性添加一个固定的值，比方说都是某某学校的学生，那么可能有需要多些100行重复的代码了，那么，<code>如果写一个-(void)createObj方法，把创建对象和为对象设置初始的属性值（比如学校属性）写在这个方法里边，那么就是会省事很多，也就是说我们可以alloc 创建对象封装到一个方法里边，直接调用这个方法就可以了，这就是简单工厂方法</code></p><p>如果一个工厂里有两个create创建方法，比如<code>PeopleFactory类</code>工厂同时有createTeacher和createStudent两个方法，现在假设原本创建100个老师的写法是如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PeopleFactory *factory = [PeopleFactory alloc] init];</span><br><span class="line">People *people1 = [factory createTeacher];</span><br><span class="line">People *people2 = [factory createTeacher];</span><br><span class="line">People *people3 = [factory createTeacher];</span><br><span class="line">People *people4 = [factory createTeacher];</span><br></pre></td></tr></table></figure><p>现在突然想让创建出来的对象是student，而不是老师teacher，那么这时候我们就不得不一个个的把createTeacher替换成createStudent方法了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PeopleFactory *factory = [PeopleFactory alloc] init];</span><br><span class="line">People *people1 = [factory createStudent];</span><br><span class="line">People *people2 = [factory createStudent];</span><br><span class="line">People *people3 = [factory createStudent];</span><br><span class="line">People *people4 = [factory createStudent];</span><br></pre></td></tr></table></figure><p>但是如果利用工厂模式，我们为每一个要创建的对象所在的类都相应地创建一个工厂，则我们的写法将会变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建老师</span><br><span class="line">TeacherFactory *factory = [TeacherFactory alloc] init];</span><br><span class="line">People *people1 = [factory createPeople];</span><br><span class="line">People *people2 = [factory createPeople];</span><br><span class="line">People *people3 = [factory createPeople];</span><br><span class="line">People *people4 = [factory createPeople];</span><br><span class="line"></span><br><span class="line">//创建学生</span><br><span class="line">StudentFactory *factory = [StudentFactory alloc] init];</span><br><span class="line">People *people1 = [factory createPeople];</span><br><span class="line">People *people2 = [factory createPeople];</span><br><span class="line">People *people3 = [factory createPeople];</span><br><span class="line">People *people4 = [factory createPeople];</span><br></pre></td></tr></table></figure><p>显然上面这种方法，在我们需要不同对象时，修改起来更方便点。</p><p><code>工厂方法模式是为每一个要创建的对象所在的类都相应地创建一个工厂</code></p><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/4%E7%98%A6%E8%BA%AB/%E7%98%A6%E8%BA%AB-%E2%91%A2app%E5%AE%89%E8%A3%85%E5%8C%85/"/>
      <url>/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/4%E7%98%A6%E8%BA%AB/%E7%98%A6%E8%BA%AB-%E2%91%A2app%E5%AE%89%E8%A3%85%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-瘦身-②app安装包"><a href="#必备知识架构-瘦身-②app安装包" class="headerlink" title="必备知识架构-瘦身-②app安装包"></a>必备知识架构-瘦身-②app安装包</h1><p><a href="https://www.jianshu.com/p/3e294c82356f" target="_blank" rel="noopener">iOS APP瘦身优化</a></p><p><a href="https://blog.csdn.net/weixin_43901866/article/details/103613147?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&amp;utm_relevant_index=2" target="_blank" rel="noopener">Flutter 如何缩减接近 50% 的 Flutter 包体积</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E7%AE%97%E6%B3%95/9%E7%AE%97%E6%B3%95/"/>
      <url>/%E7%AE%97%E6%B3%95/9%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-算法"><a href="#必备知识架构-算法" class="headerlink" title="必备知识架构-算法"></a>必备知识架构-算法</h1><p>[toc]</p><p>以下是我们在面试中要问的主要问题：</p><p>1.数据结构：<br>a、 链表<br>b、 堆叠<br>c、 排队<br>d、 二叉树<br>e、 哈希表</p><p>2.算法：<br>a、 排序（像快速排序和归并排序），二分搜索法，贪婪算法。<br>b、 二叉树（比如遍历、构造、操作…）</p><p><a href="https://www.cnblogs.com/ZachRobin/p/7094852.html" target="_blank" rel="noopener">iOS 开发中常用的排序（冒泡、选择、快速、插入、希尔、归并、基数）算法</a></p><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最差时间复杂度</th><th>平均空间复杂度</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n^2)</td><td></td></tr><tr><td>选择排序</td><td>O(n^2)</td><td></td><td>O(1)</td></tr><tr><td>快速排序</td><td>O(n^2)</td><td></td><td>O(nlogn)    O(nlogn)~O(n^2)</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td></td><td>O(1)</td></tr><tr><td>归并排序</td><td>O( nlogn )</td><td>O( nlogn )</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><a href="https://github.com/MisterBooo/Play-With-Sort-OC" target="_blank" rel="noopener">在Object-C中学习数据结构与算法之排序算法</a></p><p>二分搜索法，是一种【在有序数组中】查找某一特定元素的搜索算法。</p><p><a href="https://www.jianshu.com/p/2ba53d050637" target="_blank" rel="noopener">iOS查找算法之二分查找</a></p><p><a href="https://zhuanlan.zhihu.com/p/76164082" target="_blank" rel="noopener">漫画：五分钟学会贪心算法</a></p><p>想象一下下列场景：</p><ol><li>从通讯录中寻找某个联系人</li><li>从一大堆文件中寻找某个文件</li><li>到了影厅之后，寻找电影票上指定的座位</li></ol><p>如果以上情况中，联系人、文件、影厅座位这些“数据”没有按照需要的顺序组织，如何找到想要的特定“数据”呢？会非常麻烦！所以说，对于需要搜索的数据，往往应该先排个序！</p><p><a href="https://zhuanlan.zhihu.com/p/31810006" target="_blank" rel="noopener">排序比较 &amp; 对比归并排序与快速排序</a></p><h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p><a href="https://www.jianshu.com/p/a466e9033dd2" target="_blank" rel="noopener">iOS_两种排序算法（冒泡、选择）</a></p><p>实现一个冒泡排序或者快速排序</p><p>从小到大排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">假设45132，按从小到大排序</span><br><span class="line">i = 0 的时候，j的相邻两个位置都要比较排一下位置：</span><br><span class="line">         j = 0 的时候：arr_M = 45132(a[0]和a[1]比得到的结果)</span><br><span class="line">         j = 1 的时候：arr_M = 41532(a[1]和a[2]比得到的结果)</span><br><span class="line">         j = 2 的时候：arr_M = 41352(a[2]和a[3]比得到的结果)</span><br><span class="line">         j = 3 的时候：arr_M = 41325(a[3]和a[4]比得到的结果)</span><br><span class="line">i=0已经将第一个最大的值放到最后了。</span><br><span class="line"></span><br><span class="line">i = 1 的时候，j的相邻两个位置都要比较排一下位置：</span><br><span class="line">         j = 0 的时候：arr_M = 14325</span><br><span class="line">         j = 1 的时候：arr_M = 13425</span><br><span class="line">         j = 2 的时候：arr_M = 13245</span><br><span class="line">i=1已经将第二个最大的值放到最后了。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)methodMaopao &#123;</span><br><span class="line">int array[5] = &#123;4, 5, 1, 3, 2&#125;;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 5-1; i++) &#123; //需要比较几遍</span><br><span class="line">        for(int j = 0; j &lt; 5-1-i; j++) &#123; //每一遍都从0开始到倒数第-i个</span><br><span class="line">            if (array[j] &gt; array [j + 1])&#123;</span><br><span class="line">                int temp = array[j];</span><br><span class="line">                array[j] = array[j + 1];</span><br><span class="line">                array[j + 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p id=""></p><p></p><h2 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p><strong>从数组的第a[i+1]个元素开始到第n个元素，寻找最小的元素</strong>。（具体过程为:先设a[i]（i=0）为最小，逐一比较，若遇到比之小的则交换）；</p><p>先为a[0]取到最小值，再为a[1]取到最小值，再继续…..</p><p>从小到大排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">假设45132，按从小到大排序</span><br><span class="line">i = 0 的时候，j的相邻两个位置都要比较排一下位置：</span><br><span class="line">     j = i+1=1 的时候：arr_M = 45132(此时a[0]的4和a[1]的5比较：得到的结果)</span><br><span class="line">         j = 2 的时候：arr_M = 15432(此时a[0]的4和a[2]的1比较：得到的结果)</span><br><span class="line">         j = 3 的时候：arr_M = 15432(此时a[0]的1和a[3]的3比较：得到的结果)</span><br><span class="line">         j = 4 的时候：arr_M = 15432(此时a[0]的1和a[4]的2比较：得到的结果)</span><br><span class="line">i=0已经将第一个最小的值放到第一位了。</span><br><span class="line"></span><br><span class="line">i = 1 的时候，j的相邻两个位置都要比较排一下位置：</span><br><span class="line">         j = 2 的时候：arr_M = 14532(a[1]和a[2]比得到的结果)</span><br><span class="line">         j = 3 的时候：arr_M = 13542(a[1]和a[3]比得到的结果)</span><br><span class="line">         j = 4 的时候：arr_M = 12543(a[1]和a[4]比得到的结果)</span><br><span class="line">i=1已经将第二个最小的值放到最第二位了。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int i,j;</span><br><span class="line">int array[5] = &#123;4, 5, 1, 3, 2&#125;;</span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;5-1;i++) &#123;</span><br><span class="line">    for(j=i+1;j&lt;5;j++) &#123;</span><br><span class="line">        if(arr[i]&gt;arr[j]) &#123;           </span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、快速排序"><a href="#三、快速排序" class="headerlink" title="三、快速排序"></a>三、快速排序</h2><p><a href="https://www.sohu.com/a/246785807_684445" target="_blank" rel="noopener">漫画：什么是快速排序？（完整版） </a></p><p>快速排序（Quicksort）是对冒泡排序的一种改进。</p><h3 id="1、排序原理："><a href="#1、排序原理：" class="headerlink" title="1、排序原理："></a>1、排序原理：</h3><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，</p><p><a href="https://baike.baidu.com/pic/快速排序算法/369842/0/b7003af33a87e950707fdf2110385343fbf2b416?fr=lemma&amp;ct=single" target="_blank" rel="noopener"><img src="https://bkimg.cdn.bcebos.com/pic/b7003af33a87e950707fdf2110385343fbf2b416?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1" alt="快排图"></a>快排图</p><p>然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。</p><h3 id="2、排序流程"><a href="#2、排序流程" class="headerlink" title="2、排序流程"></a>2、排序流程</h3><p>快速排序算法通过多次比较和交换来实现排序，其排序流程如下：</p><p>(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 </p><p>(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。</p><p>(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p><p>(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。</p><h2 id="四、归并排序"><a href="#四、归并排序" class="headerlink" title="四、归并排序"></a>四、归并排序</h2><p>归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p><p>要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</p><p><img src="https://images2018.cnblogs.com/blog/1122709/201807/1122709-20180711175409829-1250175071.png" alt="img"></p><h1 id="iOS算法篇-leetcode题目记录"><a href="#iOS算法篇-leetcode题目记录" class="headerlink" title="iOS算法篇-leetcode题目记录"></a>iOS算法篇-leetcode题目记录</h1><ul><li><a href="https://www.jianshu.com/p/8bca07d00b3e" target="_blank" rel="noopener">iOS算法篇-leetcode题目记录</a></li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E2%91%A1%E5%A0%86%E6%A0%88/"/>
      <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E2%91%A1%E5%A0%86%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-数据结构"><a href="#必备知识架构-数据结构" class="headerlink" title="必备知识架构-数据结构"></a>必备知识架构-数据结构</h1><p>[toc]</p><h2 id="一、Stack"><a href="#一、Stack" class="headerlink" title="一、Stack"></a>一、Stack</h2><p>stack翻译为栈，时STL中实现的一个后进先出的容器。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E2%91%A1%E9%93%BE%E8%A1%A8/"/>
      <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E2%91%A1%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-数据结构"><a href="#必备知识架构-数据结构" class="headerlink" title="必备知识架构-数据结构"></a>必备知识架构-数据结构</h1><p>[toc]</p><h2 id="一、单链表"><a href="#一、单链表" class="headerlink" title="一、单链表"></a>一、单链表</h2><ul><li><a href="https://blog.csdn.net/qq_29542611/article/details/79054098" target="_blank" rel="noopener">算法面试题：如何判断单链表中是否存在环</a></li></ul><p>我们都知道单链表中结点都是一个结点指向下一个结点这样一个一个链接起来的，直到尾结点的指针域没有指向，单链表就到此结束了。</p><p>题目：已知下列是一个有环的单链表，请问<strong>如何判断单链表是否存在环</strong></p><p><img src="https://img-blog.csdn.net/20180113231431726?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjk1NDI2MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="有环的单链表"></p><p>分析：把环想象成操作。</p><p>则我们通过使用快慢指针判断单链表是否存在环。<br>使用slow、fast 2个指针，slow慢指针每次向前走1步，fast快指针每次向前走2步，<br>若存在环的话，必定存在某个时候 slow = fast 快慢指针相遇。<br>list 带头结点的单链表<br>返回值 &gt;0:存在环返回环的位置    0:不存在环</p><p><strong>在相遇点，由于两个指针继续一个走一步，一个走两步，当再次相遇时，走一步的指针所走过的节点数记为环/操场的长度。</strong></p><p><strong><em>\</em>那么问题来了，既然知道该单链表是代码单链表，那么我怎样将其还原为正常单链表呢？**</strong></p><h2 id="带环单链表去掉环"><a href="#带环单链表去掉环" class="headerlink" title="带环单链表去掉环"></a>带环单链表去掉环</h2><p><strong>我们只需要将尾结点的next指针域置为NULL就还原为正常单链表了</strong>。我们怎样找到尾结点呢？请看代码。</p><ol><li><em>去掉单链表中的环，将尾结点的next域置位空。</em></li><li><em>环位置结点之后的结点，判断其next域是否为环结点，如果是环节点，说明是尾结点</em></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E2%91%A2%E7%8E%AF/"/>
      <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E2%91%A2%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-数据结构"><a href="#必备知识架构-数据结构" class="headerlink" title="必备知识架构-数据结构"></a>必备知识架构-数据结构</h1><p>[toc]</p><h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><ul><li><p><a href="https://blog.csdn.net/yjw123456/article/details/90379925" target="_blank" rel="noopener">图论算法——环和有向无环图</a></p><blockquote><p>寻找环利用了DFS方法，<strong>维护一个递归调用期间已访问的顶点的栈，若(在递归调用期间，通过判断<code>onStack</code>标记数组)两次访问了某个顶点，则说明有环；若DFS递归调用完毕，说明无环</strong>。</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E2%91%A0nil%E3%80%81isEqual%E3%80%81Hash/"/>
      <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E2%91%A0nil%E3%80%81isEqual%E3%80%81Hash/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-数据结构-①nil、isEqual、Hash"><a href="#必备知识架构-数据结构-①nil、isEqual、Hash" class="headerlink" title="必备知识架构-数据结构-①nil、isEqual、Hash"></a>必备知识架构-数据结构-①nil、isEqual、Hash</h1><p>[toc]</p><h2 id="前言：你真的懂isEqual与hash？"><a href="#前言：你真的懂isEqual与hash？" class="headerlink" title="前言：你真的懂isEqual与hash？"></a>前言：你真的懂isEqual与hash？</h2><p>参考文章：</p><ul><li><a href="https://www.jianshu.com/p/915356e280fc" target="_blank" rel="noopener">iOS开发 之 不要告诉我你真的懂isEqual与hash!</a></li><li><a href="https://www.jianshu.com/p/2a71b027b723?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">哈希算法详解（附带 iOS 开发中实际应用）</a></li><li><a href="https://blog.csdn.net/TuGeLe/article/details/103881352?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">iOS weak关键字实现原理</a></li></ul><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、NSMutableSet/NSSet中添加对象的时候，就会调用- (NSUInteger)hash方法。</span><br><span class="line">2、NSMutableSet/NSSet中添加 obj2 对象的时候，如果NSMutableSet/NSSet 中之前就已经存在 obj1 对象，且 obj1 对象的 - (NSUInteger)hash 返回值和当前要添加的 obj2 的- (NSUInteger)hash 返回值相等, 则 obj2 会继续调用- (BOOL)isEqual:方法，其中此方法以 obj1 为参数；否则不等, 继续下一个元素判断。</span><br></pre></td></tr></table></figure><p>通过重写isEqual，我们可以做到对象的判等可以完全由您决定, 即使两个完全不同的对象。</p><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="1、nil-Nil-NULL-与-NSNull-的区别"><a href="#1、nil-Nil-NULL-与-NSNull-的区别" class="headerlink" title="1、nil, Nil,NULL 与 NSNull 的区别"></a>1、nil, Nil,NULL 与 NSNull 的区别</h3><ul><li>nil 指向一个<strong>对象的指针</strong>为空,在objc.h 的定义如下: <code>NSString *name = nil;</code></li><li>Nil 指向一个<strong>类的指针</strong>为空,定义如下: <code>Class aClass = Nil;</code></li><li>NULL 指向<strong>C类型的指针</strong>为空, 例如: <code>int*pInt = NULL;</code></li><li>NSNull 在Objective-C中是一个类,只是名字中有个Null，多用于集合(NSArray,NSDictionary)中值为空的对象</li></ul><h3 id="2、-、-isEqualToString、isEqual"><a href="#2、-、-isEqualToString、isEqual" class="headerlink" title="2、==、 isEqualToString、isEqual"></a>2、==、 isEqualToString、isEqual</h3><h4 id="2-1、背景：为什么要有isEqual方法"><a href="#2-1、背景：为什么要有isEqual方法" class="headerlink" title="2.1、背景：为什么要有isEqual方法?"></a>2.1、背景：为什么要有isEqual方法?</h4><p>答：判断两个对象是否相等（而不是判断两个对象的地址是否相等）。</p><blockquote><p>对于基本类型, ==运算符比较的是值;<br><strong>对于对象类型, ==运算符比较的是对象的地址(即是否为同一对象)</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UIColor *color1 = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1.0];</span><br><span class="line">UIColor *color2 = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1.0];</span><br><span class="line">NSLog(@&quot;color1 == color2 = %@&quot;, color1 == color2 ? @&quot;YES&quot; : @&quot;NO&quot;);</span><br><span class="line">NSLog(@&quot;[color1 isEqual:color2] = %@&quot;, [color1 isEqual:color2] ? @&quot;YES&quot; : @&quot;NO&quot;);</span><br><span class="line"></span><br><span class="line">// 打印结果如下：</span><br><span class="line">color1 == color2 = NO</span><br><span class="line">[color1 isEqual:color2] = YES</span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><p>1、==<br>判断指针指向的地址，即指针值，是否相等<br>①对于基本类型, ==运算符比较的是值;<br>②对于对象类型, ==运算符比较的是对象的地址(即是否为同一对象)）</p><p>2、isEqualToString<br>直接判断字符串内容是否相等</p><p>3、isEqual<br>先判断两个对象的地址是否相同，再判断类型是否一致，然后再判断对象的具体内容是否一致<br>//情况①：地址相同则肯定相等；<br>//情况②：地址不同时候，如果类型一致且里面的内容相等，则也算相等</p></blockquote><h4 id="2-1、苹果官方重写isEqual-的demo"><a href="#2-1、苹果官方重写isEqual-的demo" class="headerlink" title="2.1、苹果官方重写isEqual 的demo"></a>2.1、苹果官方重写isEqual 的demo</h4><p><code>isEqual</code>：先判断两个对象的地址是否相同(采用<code>==</code>)，再判断类型是否一致(采用<code>isKindOfClass</code>)，然后再判断对象的具体内容是否一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">    if (self == object) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (![object isKindOfClass:[Person class]]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [self isEqualToPerson:(Person *)object];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqualToPerson:(Person *)person &#123;</span><br><span class="line">    if (!person) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL haveEqualNames = (!self.name &amp;&amp; !person.name) || </span><br><span class="line">      [self.name isEqualToString:person.name];</span><br><span class="line">    BOOL haveEqualBirthdays = (!self.birthday &amp;&amp; !person.birthday) || </span><br><span class="line">      [self.birthday isEqualToDate:person.birthday];</span><br><span class="line"></span><br><span class="line">    return haveEqualNames &amp;&amp; haveEqualBirthdays;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附：通过重写isEqual，我们可以做到对象的判等可以完全由您决定, 即使两个完全不同的对象。</p><h4 id="2-2、-、-isEqualToString、isEqual验证示例"><a href="#2-2、-、-isEqualToString、isEqual验证示例" class="headerlink" title="2.2、==、 isEqualToString、isEqual验证示例"></a>2.2、==、 isEqualToString、isEqual验证示例</h4><blockquote><p><img src="/数据结构/9数据结构-①nil、isEqual、Hash/1语言/equal.jpg" alt="equal"></p></blockquote><h2 id="二、Hash"><a href="#二、Hash" class="headerlink" title="二、Hash"></a>二、Hash</h2><h3 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h3><p>当要在一堆数据中进行查找的时候，需要频繁的进行判等比较。<strong>为了提高整个查找的速度</strong>，我们引入hash。</p><p>问：为什么需要hash？</p><blockquote><p>答：为了提高查找的速度。(附：主要是用于在Hash Table查询成员用的)</p></blockquote><p>问：和数组相比，基于hash值索引的Hash Table【查找某个成员的过程】就是</p><blockquote><p>Step 1: 通过hash值直接找到查找目标的位置；<br>Step 2: 如果目标位置上有多个相同hash值得成员, 此时再按照数组方式进行查找。</p></blockquote><p>问：基于hash值索引的Hash Table在【查找某个成员的过程】如何确定找的对象是我们想要的？或hash方法与isEqual的关系?（优化判等）</p><blockquote><p>答：我们以基于hash的NSSet和NSDictionary举例，其在判断成员是否相等时, <strong>为了优化判等的效率</strong>，会这样做<br>Step 1: 集成成员的hash值是否和目标hash值相等, 如果相同进入Step 2, 如果不等, 直接判断不相等；<br>Step 2: hash值相同(即Step 1)的情况下, 再进行对象判等, 作为判等的结果。</p></blockquote><h3 id="2、Hash-表的实际应用"><a href="#2、Hash-表的实际应用" class="headerlink" title="2、Hash 表的实际应用"></a>2、Hash 表的实际应用</h3><ul><li>应用1：找出两文件找出重复的元素</li></ul><blockquote><p>假设有两个文件，文件中均包含一些短字符串，字符串个数分别为n。它们是有重复的字符串，现在需要找出所有重复的字符串。<br>最笨的解决办法可能是：遍历文件 1 中的每个元素，取出每一个元素分别去文件 2 中进行查找，这样的时间复杂度为O（n^2）。<br>但是借助 Hash 表可以有一种相对巧妙的方法，我们知道<strong>相同元素的 Hash 值相同</strong>。所以我们分别遍历文件 1 中的元素和文件 2 中的元素，然后放入 Hash Table 中，对于遍历的每一个元素我们只要简单的做一下计数处理即可。最后遍历整个 Hash 列表，找出所有个数大于 1 的元素即为重复的元素。</p></blockquote><ul><li>应用2：找出两文件找出出现次数最多的元素</li></ul><blockquote><p>同<code>找出两文件找出重复的元素</code>这样的问题解决方案类似，只是在最后遍历的时找计数最大的元素，即为出现次数最多的元素。</p></blockquote><h3 id="3、hash什么时候调用"><a href="#3、hash什么时候调用" class="headerlink" title="3、hash什么时候调用"></a>3、hash什么时候调用</h3><p>hash方法只在对象被添加至NSSet和设置为NSDictionary的key时会调用。</p><p>HashTable是一种基本数据结构，<strong>NSSet和NSDictionary都是使用HashTable存储数据的</strong>，因此可以可以确保他们查询成员的速度为O(1)。而NSArray使用了顺序表存储数据，查询数据的时间复杂度为O(n)。</p><h2 id="三、哈希-Hash-表-散列表"><a href="#三、哈希-Hash-表-散列表" class="headerlink" title="三、哈希(Hash)表/散列表"></a>三、哈希(Hash)表/散列表</h2><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/u011109881/article/details/80379505" target="_blank" rel="noopener">数据结构 Hash表（哈希表）</a></li></ul><h3 id="1、哈希函数-amp-Hash地址"><a href="#1、哈希函数-amp-Hash地址" class="headerlink" title="1、哈希函数 &amp; Hash地址"></a>1、哈希函数 &amp; Hash地址</h3><p>要想知道什么是哈希表，那得先了解<strong>哈希函数</strong>。</p><p>hash函数就是根据key计算出应该存储地址的位置，而哈希表是基于哈希函数建立的一种查找表</p><p><strong>地址index=H（key）</strong></p><p>通过Hash函数和关键字计算出来的存储位置（<strong>注意这里的存储位置只是表中的存储位置，并不是实际的物理地址</strong>）称作为Hash地址。</p><p>重要：<strong>相同元素的 Hash 值相同</strong>。附：两个相等的实例，他们的hash值一定相等。但是hash值相等的两个实例，不一定相等。</p><h3 id="2、哈希函数的构造方法"><a href="#2、哈希函数的构造方法" class="headerlink" title="2、哈希函数的构造方法"></a>2、哈希函数的构造方法</h3><p><strong>除留余数法</strong>用的较多<br>H（key）=key MOD p （p&lt;=m m为表长）<br>很明显，如何选取p是个关键问题。</p><blockquote><p>p应为不大于m的质数或是不含20以下的质因子的合数，这样可以减少地址的重复（冲突）</p></blockquote><p>比如key = 7，39，18，24，33，21时取表长m为9 p为7 那么存储如下</p><table><thead><tr><th>index</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>key</td><td>7</td><td>21(冲突后移)</td><td></td><td>24</td><td>4</td><td>18(冲突后移)</td><td>33(冲突后移)</td><td></td></tr></tbody></table><h3 id="3、哈希冲突的解决方案"><a href="#3、哈希冲突的解决方案" class="headerlink" title="3、哈希冲突的解决方案"></a>3、哈希冲突的解决方案</h3><p>哈希冲突即不同key值产生相同的地址，H（key1）=H（key2）<br>比如我们上面说的存储3 6 9，p取7是<br>7 MOD 7 == 21 MOD 7<br>此时7和21都发生了hash冲突</p><h3 id="4、hash表的查找"><a href="#4、hash表的查找" class="headerlink" title="4、hash表的查找"></a>4、hash表的查找</h3><p>查找过程和造表过程一致，假设采用开放定址法处理冲突，则查找过程为：<br>对于给定的key，计算hash地址index = H（key）<br>如果数组arr【index】的值为空 则查找不成功<br>如果数组arr【index】== key 则查找成功<br>否则 使用冲突解决方法求下一个地址，直到arr【index】== key或者 arr【index】==null</p><p>哈希表（hash table，也叫散列表），是根据键（key）直接访问访问在内存储存位置的数据结构。</p><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">哈希表</a>本质是一个数组，数组中的每一个元素成为一个箱子，箱子中存放的是键值对。根据下标index从数组中取value。关键是如何获取index，这就需要一个固定的函数（哈希函数），将key转换成index。</p><p><a href="https://www.jianshu.com/p/4e64fce04a38" target="_blank" rel="noopener">哈希表—什么是哈希表</a> 有助于理解哈希表</p><h2 id="四、weak"><a href="#四、weak" class="headerlink" title="四、weak"></a>四、weak</h2><p>以下内容来自： <a href="https://blog.csdn.net/TuGeLe/article/details/103881352?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">iOS weak关键字实现原理</a></p><ul><li>1、weak关键字修饰对象的【初始化及重新赋值】实现原理</li><li>2、weak关键字是如何保证在weak对象执行语句时内存对象不被释放的呢？</li><li>3、当weak对象指向的内存对象被释放后，weak对象自动置为nil。原理是怎样？</li></ul><h3 id="1、weak关键字修饰对象初始化及重新赋值实现原理"><a href="#1、weak关键字修饰对象初始化及重新赋值实现原理" class="headerlink" title="1、weak关键字修饰对象初始化及重新赋值实现原理"></a>1、weak关键字修饰对象初始化及重新赋值实现原理</h3><p><code>objc_initWeak</code>：当初始化一个weak对象并将内存对象赋值给该weak对象时会调用该方法。</p><p><code>objc_storeWeak</code>：当为一个weak对象赋新值时会调用该方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">objc_initWeak(id *location, id newObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对内存对象进行非nil判断</span></span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用storeWeak方法，三个参数的意义在storeWeak方法中描述</span></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;<span class="literal">false</span><span class="comment">/*old*/</span>, <span class="literal">true</span><span class="comment">/*new*/</span>, <span class="literal">true</span><span class="comment">/*crash*/</span>&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objc_storeWeak(id *location, id newObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//调用storeWeak方法，三个参数的意义在storeWeak方法中描述</span></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;<span class="literal">true</span><span class="comment">/*old*/</span>, <span class="literal">true</span><span class="comment">/*new*/</span>, <span class="literal">true</span><span class="comment">/*crash*/</span>&gt;</span><br><span class="line">        (location, (objc_object *)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由官方文档可知，无论是初始化weak对象还是为weak对象赋值，最终都会调用到 <code>storeWeak</code>方法，不同点在于，二者传入三个模板值不同。</p><p>如果weak对象与旧内存对象的关联，则先调用<code>weak_unregister_no_lock</code>，将weak对象与旧内存对象解除指向关系。</p><p>然后在将weak对象与旧内存对象的关联解除后，就调用 <code>weak_register_no_lock</code>方法将weak对象与新内存对象进行关联</p><p>至此，weak关键字修饰对象的初始化和重新赋值流程就完成了。</p><h3 id="2、weak关键字是如何保证在weak对象执行语句时内存对象不被释放的呢？"><a href="#2、weak关键字是如何保证在weak对象执行语句时内存对象不被释放的呢？" class="headerlink" title="2、weak关键字是如何保证在weak对象执行语句时内存对象不被释放的呢？"></a>2、weak关键字是如何保证在weak对象执行语句时内存对象不被释放的呢？</h3><p>问：weak关键字是如何保证【在weak对象执行语句时】内存对象【不被释放】的呢？</p><p>答：其实很简单，就是对内存对象进行计数增加。</p><p>每次在使用weak对象时，都相当于调用一次 <code>objc_loadWeak</code>。</p><p>在weak对象执行的语句中，weak对象所指向的内存对象计数会+1，这样就保证在语句中不会发生执行一半而释放内存对象的问题。</p><h3 id="3、当weak对象指向的内存对象被释放后，weak对象自动置为nil。原理是怎样？"><a href="#3、当weak对象指向的内存对象被释放后，weak对象自动置为nil。原理是怎样？" class="headerlink" title="3、当weak对象指向的内存对象被释放后，weak对象自动置为nil。原理是怎样？"></a>3、当weak对象指向的内存对象被释放后，weak对象自动置为nil。原理是怎样？</h3><p>当内存对象释放时，会调用到一个叫<code>weak_claer_no_lock</code>的方法。在 <code>weak_claer_no_lock</code>方法中，会进行对weak对象的置空操作。</p><h3 id="4、Weak-Strong搭配使用的误解"><a href="#4、Weak-Strong搭配使用的误解" class="headerlink" title="4、Weak-Strong搭配使用的误解"></a>4、Weak-Strong搭配使用的误解</h3><p>在使用Block时，我们可以使用weak关键字来避免外部变量被Block强引用而导致的循环引用，同时为了Block中的代码能够正常执行，许多开发者提出了Weak-Strong搭配使用的方式，类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    self.block = ^&#123;</span><br><span class="line">        __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        [strongSelf test1];</span><br><span class="line">        [strongSelf test2];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码相对于单独使用weak来说还是有好处的，使用Weak-Strong搭配的方式的话，可以保证在执行 [strongSelf test1]和 [strongSelf test2]时，是向同一对象发送消息。</p><p>为什么这么说呢？当开始执行Block语句时，若self还存在，那么strongSelf可以保证在整个Block代码块中不会被释放，即使Block中调用无数次strongSelf，strongSelf也不会因为多线程而在半途被释放；若开始执行Block时，self已经被释放，那么之后所有的消息都会被发送至nil。所以Weak-Strong搭配可以保证Block中语句被处理为一个事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    self.block = ^&#123;</span><br><span class="line">        [weakSelf test1];// 可能这时候self还没释放，有值。</span><br><span class="line">        [weakSelf test2];// 而到这时候self刚好释放，为ni。导致Block中语句不是被发送给同一对象去处理。</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，Weak-Strong并不能保证Block中语句一定会被执行，它只能保证Block中语句作为一个事务被发送到同一对象处。只要理解了weak实现原理，我们就能明白何时单独使用weak也能完成代码功能，而何时必须使用Weak-Strong来保证代码事务能力。</p><h3 id="5、weak关键字涉及到的数据结构"><a href="#5、weak关键字涉及到的数据结构" class="headerlink" title="5、weak关键字涉及到的数据结构"></a>5、weak关键字涉及到的数据结构</h3><p>略。请查看 <a href="https://blog.csdn.net/TuGeLe/article/details/103881352?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">iOS weak关键字实现原理</a></p><blockquote><p>1、SideTables</p><blockquote><p><code>SideTables</code>本质上是一个全局的 <code>StripedMap</code>。而<code>StripedMap</code>本质是一个数组。</p><p>在 <code>SideTables</code>中， Item类型为 <code>SideTable</code></p></blockquote><p>2、SideTable</p><blockquote><p><code>SideTable</code>中包含三个元素，分别是 1.自旋锁 2.记录对象引用计数的字典 3.记录对象弱引用信息的数据结构 <code>weak_table_t</code>。</p></blockquote><p>3、weak_table_t</p><blockquote><p><code>weak_table_t</code>本质上是一个数组，其中每个Item为 <code>weak_entry_t</code>。</p></blockquote><p>4、weak_entry_t</p><blockquote><p><code>weak_entry_t</code>就比较有意思了，它本质上是个字典。其中的key值为对象，而value对应为一个数组，数组中保存的值均为 <code>weak_referrer_t</code>类型的数据。</p></blockquote><p>5、weak_referrer_t</p><blockquote><p><code>weak_referrer_t</code>本质上是 <code>objc_object **</code>，即Objective-C对象的地址。</p></blockquote></blockquote><p>所以，<code>weak_entry_t</code>value数组中，每一个Item均为一个地址，即weak对象的地址。</p><p>在项目中有某个功能需要用到多个delegate对象，这就需要把delegate放到容器中，但又只能弱引用weak保存delegate，否则会导致delegate对象不能被释放。所以，我们的需求就是希望能在容器中只保存弱引用的delegate对象。</p><blockquote><p>在OC中Foundation框架中的常用容器类（NSSet，NSDictionary，NSArray）及其可变子类在加入元素时，均会对元素进行强引用。有的时候（比如持有多个Delegate对象时），希望有对应的弱引用容器使用。</p></blockquote><p>支持弱引用的容器类，有如下：</p><p>[NSHashTable weakObjectsHashTable]</p><p>[NSPointerArray weakObjectsPointerArray]</p><p>[NSPointerArray pointerArrayWithOptions:]</p><p>详见：<a href="https://www.jianshu.com/p/cf4e15b26f64" target="_blank" rel="noopener">YYKit学习笔记之NSHashTable与NSMapTable</a></p><p>其他参考：</p><ul><li><a href="https://www.jianshu.com/p/f0c33d6c39bb" target="_blank" rel="noopener">OC弱引用容器实现方案总结</a></li><li><p><a href="http://blog.sina.com.cn/s/blog_48d4cf2d0102v1jh.html" target="_blank" rel="noopener">iOS如何在容器类中使用弱引用(weak reference) </a></p></li><li><p><a href="https://www.jianshu.com/p/de3e0ffa9fde" target="_blank" rel="noopener">数组或字典如何弱引用对象</a></p></li><li><a href="https://www.jianshu.com/p/51156d4ae885" target="_blank" rel="noopener">iOS - 如何实现弱引用字典</a></li></ul><p><strong><em>在iOS项目开发过程中，我们经常会使用到<code>NSSet</code>、<code>NSArray</code>、<code>NSDictionary</code>三个类，它们为我们设计较友好的数据结构时提供了很方便的方法\</em></strong></p><p>对于NSSet来说，object是强引用的，和NSDictionary中的value是一样的。而NSDictionary中的key则是copy的，因此当开发者想要使NSSet的objects或者NSDictionary的values为weak，或者NSDictionary使用没有实现协议的对象作为key时，比较麻烦（需要使用NSValue的方法valueWithNonretainedObject）。<br>还好苹果为我们提供了相对于NSSet和NSDictionary更通用的两个类NSHashTable和NSMapTable。</p><h2 id="关联对象实现原理"><a href="#关联对象实现原理" class="headerlink" title="关联对象实现原理"></a>关联对象实现原理</h2><p><a href="https://juejin.im/post/5af86b276fb9a07aa34a59e6" target="_blank" rel="noopener">iOS底层原理总结 - 关联对象实现原理</a></p><blockquote><p><strong>关联对象并不是存储在被关联对象本身内存中，而是存储在全局的统一的一个AssociationsManager中，如果设置关联对象为nil，就相当于是移除关联对象。</strong></p></blockquote><p>回过头来看objc_AssociationPolicy policy 参数: 属性以什么形式保存的策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0,  // 指定一个弱引用相关联的对象</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 指定相关对象的强引用，非原子性</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,  // 指定相关的对象被复制，非原子性</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401,  // 指定相关对象的强引用，原子性</span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403     // 指定相关的对象被复制，原子性   </span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们会发现其中只有RETAIN和COPY而为什么没有weak呢？</p><h2 id="NSPointerArray"><a href="#NSPointerArray" class="headerlink" title="NSPointerArray"></a>NSPointerArray</h2><h3 id="1、NSPointerArray"><a href="#1、NSPointerArray" class="headerlink" title="1、NSPointerArray"></a>1、NSPointerArray</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">  if (self = [super init]) &#123;</span><br><span class="line">    _delegates = [NSPointerArray weakObjectsPointerArray];</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加对象指针</span><br><span class="line">- (void)addDelegate:(id)delegate &#123;</span><br><span class="line">  [_delegates addPointer:(__bridge void*)delegate];</span><br><span class="line">&#125;</span><br><span class="line">// 和 NSArray在概念上不一样的地方是，NSPointerArray需要添加的是对象的指针地址，尽管他俩都是在操作指针。所以在添加对象时，需要将其转换为指针类型，__bridge转换十分具有 CoreFoundation特色</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 移除对象指针</span><br><span class="line">- (void)removeDelegate:(id)delegate &#123;</span><br><span class="line">  NSUInteger index = [self indexOfDelegate:delegate];</span><br><span class="line">  if (index != NSNotFound) &#123;</span><br><span class="line">    [_delegates removePointerAtIndex:index];</span><br><span class="line">  &#125;</span><br><span class="line">  [_delegates compact];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSUInteger)indexOfDelegate:(id)delegate &#123;</span><br><span class="line">  for (NSUInteger i = 0; i &lt; _delegates.count; i += 1) &#123;</span><br><span class="line">    if ([_delegates pointerAtIndex:i] == (__bridge void*)delegate) &#123;</span><br><span class="line">      return i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return NSNotFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E2%91%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E2%91%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-数据结构"><a href="#必备知识架构-数据结构" class="headerlink" title="必备知识架构-数据结构"></a>必备知识架构-数据结构</h1><p>[toc]</p><blockquote><p>Here are main question we will ask during interview:<br>1.Data Structure:<br>a.linked lists<br>b.Stacks<br>c.Queues<br>d.binary trees<br>e.hash tables<br>2.Algorithms:<br>a.Sort (like quick sort and merge sort), binary search, greedy algorithms.<br>b.Binary tree(like traversal, construction, manipulation..)<br>You can find more to do exercises on <a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">以下是我们在面试中要问的主要问题：</span><br><span class="line"></span><br><span class="line">1.数据结构：</span><br><span class="line">a、 链接列表</span><br><span class="line">b、 堆栈</span><br><span class="line">c、 队列</span><br><span class="line">d、 二叉树</span><br><span class="line">e、 哈希表</span><br><span class="line"></span><br><span class="line">2.算法：</span><br><span class="line">a、 排序（像快速排序和合并排序），二进制搜索，贪婪算法。</span><br><span class="line">b、 二叉树（比如遍历、构造、操作…）</span><br><span class="line"></span><br><span class="line">你可以找到更多的练习https://leetcode.com/</span><br></pre></td></tr></table></figure><h2 id="一、二叉树"><a href="#一、二叉树" class="headerlink" title="一、二叉树"></a>一、二叉树</h2><p>二叉树（binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。</p><p><img src="/数据结构/9数据结构-②二叉树/Screenshots/二叉树1.png" alt="二叉树"></p><p>在二叉树中，一个元素也称作一个结点。</p><blockquote><p>节点:二叉树中每个元素都称为节点。</p></blockquote><p>叶子结点：就是出度为0的结点，就是没有子结点的结点。</p><h2 id="二、几种二叉树"><a href="#二、几种二叉树" class="headerlink" title="二、几种二叉树"></a>二、几种二叉树</h2><p><a href="https://www.cnblogs.com/-citywall123/p/11788764.html" target="_blank" rel="noopener">满二叉树、完全二叉树、平衡二叉树、最优二叉树</a></p><h3 id="1、完全二叉树"><a href="#1、完全二叉树" class="headerlink" title="1、完全二叉树"></a>1、完全二叉树</h3><p>若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都<strong>连续集中在最左边</strong>，这就是完全二叉树。</p><h3 id="2、满二叉树"><a href="#2、满二叉树" class="headerlink" title="2、满二叉树"></a>2、满二叉树</h3><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。</p><p>也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p><p>满二叉树的第i层上有2</p><p><img src="https://bkimg.cdn.bcebos.com/formula/16caf8be3a55b3d5cffcc3cff4245aae.svg" alt="img"></p><p> 个结点 (i≥1)。</p><p>满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。</p><h3 id="3、平衡二叉树"><a href="#3、平衡二叉树" class="headerlink" title="3、平衡二叉树"></a>3、平衡二叉树</h3><p><a href="https://baijiahao.baidu.com/s?id=1646617486319372351&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">一文读懂平衡二叉树｜技术头条</a></p><p>二叉搜索树（Binary Search Tree），又叫二叉排序树，简单而言就是左子树上所有节点的值均小于根节点的值，而右子树上所有结点的值均大于根节点的值，左小右大，并不是乱序，因此得名二叉排序树。</p><p> <img src="https://pics0.baidu.com/feed/9922720e0cf3d7ca3a57dd116fa0320c6a63a97d.png?token=5501bf9c3284d38423dfc047fa7bec94&amp;s=79A834724182D945487C11DA030070B1" alt="二叉搜索树"></p><p>二叉搜索树的结构与值的插入顺序有关，同一组数，若其元素的插入顺序不同，二叉搜索树的结构是千差万别的。</p><p>为了避免二叉搜索树变成“链表”，我们引入了平衡二叉树(平衡二叉树必须是二叉搜索树)，即让树的结构看起来尽量“均匀”，左右子树的节点数尽量一样多。</p><p>举例：给出一组数[1,3,5,8,9,13]。假设我们就按[1,3,5,8,9,13]这样的顺序插入，其流程是这样的：</p><p><img src="/数据结构/9数据结构-②二叉树/Screenshots/二叉搜索树_链表.png" alt="二叉搜索树_链表"></p><p><img src="/数据结构/9数据结构-②二叉树/Screenshots/平衡二叉树1.png" alt="平衡二叉树"></p><h3 id="4、最优二叉树（哈夫曼树）"><a href="#4、最优二叉树（哈夫曼树）" class="headerlink" title="4、最优二叉树（哈夫曼树）"></a>4、最优二叉树（哈夫曼树）</h3><p><a href="https://baijiahao.baidu.com/s?id=1663514710675419737&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">漫画：什么是 “哈夫曼树”？</a></p><p>在介绍哈弗曼树之前，我们必须先弄清楚和树相关的四个概念。</p><p><strong>概念1：什么是路径？</strong></p><p>在一棵树中，从一个结点到另一个结点所经过的所有结点，被我们称为两个结点之间的路径。</p><p><strong>概念2：什么是路径长度？</strong></p><p>在一棵树中，从一个结点到另一个结点所经过的“边”的数量，被我们称为两个结点之间的路径长度。</p><p><strong>概念3：什么是结点的带权路径长度？</strong></p><p>结点的带权路径长度，是指树的【根结点到该结点的路径长度】和【该结点权重】的【乘积】。</p><p><strong>概念4：什么是树的带权路径长度？</strong></p><p>在一棵树中，【所有】【叶子结点】的带权路径长度之和，被称为树的带权路径长度，也被简称为WPL。</p><p>哈夫曼树（Huffman Tree）是在叶子结点和权重确定的情况下，带权路径长度最小的二叉树，也被称为最优二叉树。</p><p>问：怎样构建二叉树，才能保证其带权路径长度最小？</p><p>答：原则上，我们应该让权重小的叶子结点远离树根，权重大的叶子结点靠近树根。</p><p>例：下图左侧的这棵树就是一颗哈夫曼树，它的WPL是46，小于之前例子当中的53。</p><p><img src="/数据结构/9数据结构-②二叉树/Screenshots/哈弗曼树.png" alt="哈弗曼树"> </p><p><code>1*3+3*3+4*2+6*2+8*2=48</code>                                                        <code>（3+6)*3+（1+4+8）*2=27+26=53</code></p><p><strong>需要注意的是，同样叶子结点所构成的哈夫曼树可能不止一颗，下面这几棵树都是哈夫曼树</strong></p><p><img src="/数据结构/9数据结构-②二叉树/Screenshots/哈弗曼树2.png" alt="哈弗曼树2"></p><p>问：怎么利用给定的结点和权重，构建哈弗曼树？</p><p>答：想看 <a href="https://baijiahao.baidu.com/s?id=1663514710675419737&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">漫画：什么是 “哈夫曼树”？</a> 还是很好理解的。</p><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，<a href="https://baike.baidu.com/item/树的遍历" target="_blank" rel="noopener">树的遍历</a>实质上是将二叉树的各个结点转换成为一个线性序列来表示。</p><p>参考文章：<a href="https://www.cnblogs.com/lanhaicode/p/10390147.html" target="_blank" rel="noopener">二叉树的遍历（前序、中序、后序、已知前中序求后序、已知中后序求前序）</a></p><p>前序遍历：根节点-&gt;左子树-&gt;右子树<strong>（根-&gt;左-&gt;右）</strong></p><p>中序遍历：左子树-&gt;根节点-&gt;右子树<strong>（左-&gt;根-&gt;右）</strong></p><p>后序遍历：左子树-&gt;右子树-&gt;根节点<strong>（左-&gt;右-&gt;根）</strong></p><p><img src="/数据结构/9数据结构-②二叉树/Screenshots/二叉树遍历1.png" alt="二叉树遍历" style="zoom:50%;"></p><ul><li>前序遍历结果：GDAFEMHZ</li><li>中序遍历结果：ADEFGHMZ</li><li>后序遍历结果：AEFDHZMG</li></ul><h2 id="进入正题，已知两种遍历结果求另一种遍历结果（其实就是重构二叉树）"><a href="#进入正题，已知两种遍历结果求另一种遍历结果（其实就是重构二叉树）" class="headerlink" title="进入正题，已知两种遍历结果求另一种遍历结果（其实就是重构二叉树）"></a>进入正题，已知两种遍历结果求另一种遍历结果（其实就是重构二叉树）</h2><p><strong>1、前序遍历的第一元素是整个二叉树的根节点</strong></p><p><strong>2、中序遍历中根节点的左边的元素是左子树，根节点右边的元素是右子树</strong></p><p><strong>3、后序遍历的最后一个元素是整个二叉树的根节点</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/4%E7%BA%BF%E7%A8%8B-%E2%91%A4%E9%9D%A2%E8%AF%95/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/4%E7%BA%BF%E7%A8%8B-%E2%91%A4%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-线程-⑤面试"><a href="#必备知识架构-线程-⑤面试" class="headerlink" title="必备知识架构-线程-⑤面试"></a>必备知识架构-线程-⑤面试</h1><p>[toc]</p><h2 id="六、队列-gt-任务-gt-线程-gt-数据安全"><a href="#六、队列-gt-任务-gt-线程-gt-数据安全" class="headerlink" title="六、队列 -&gt; 任务 -&gt; 线程 -&gt; 数据安全"></a>六、队列 -&gt; 任务 -&gt; 线程 -&gt; 数据安全</h2><p>有队列，就有需要处理的任务，有任务就有线程相关的要考虑(附队列本身也处在线程中)，有多线程的考虑，就要考虑数据安全。</p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p>3、队列和数据安全</p><p>那我们先来知道一个非常重要的事情：</p><p>——- 队列只是负责任务的调度，而不负责任务的执行  ———</p><p>——- 任务是在线程中执行的 ———</p><p>所以，这个问题其实问得就不大对。让人不知怎么答。</p><p>我们这里说下，分情况。</p><p>如果是串行队列，数据是安全的。</p><p>如果是并发队列，在读写的时候，数据是不安全的。我们可以通过以下几种方式将其处理成安全的。</p><p>①、并发队列，改成串行执行。</p><blockquote><p>可以通过</p><p>任务是同步任务；</p><p>异步任务用依赖；</p><p>异步任务用信号量控制并发量为1</p></blockquote><p>②、加锁</p><blockquote><p>@synchronized</p><p>NSLock</p><p>dispatch_semaphore</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/4%E7%BA%BF%E7%A8%8B-%E2%91%A2%E4%BB%BB%E5%8A%A1%E6%88%96%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/4%E7%BA%BF%E7%A8%8B-%E2%91%A2%E4%BB%BB%E5%8A%A1%E6%88%96%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-线程与网络-①锁"><a href="#必备知识架构-线程与网络-①锁" class="headerlink" title="必备知识架构-线程与网络-①锁"></a>必备知识架构-线程与网络-①锁</h1><p>[toc]</p><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><h2 id="四、线程安全问题"><a href="#四、线程安全问题" class="headerlink" title="四、线程安全问题"></a>四、线程安全问题</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><h4 id="1、线程安全"><a href="#1、线程安全" class="headerlink" title="1、线程安全"></a>1、线程安全</h4><p>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。就好比几个人在同一时修改同一个表格，造成数据的错乱。</p><p>参考：<a href="https://www.jianshu.com/p/938d68ed832c" target="_blank" rel="noopener">iOS中保证线程安全的几种方式与性能对比</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">性能对比</span><br><span class="line">对以上各个锁进行1000000此的加锁解锁的空操作时间如下：</span><br><span class="line">OSSpinLock: 46.15 ms</span><br><span class="line">dispatch_semaphore: 56.50 ms</span><br><span class="line">pthread_mutex: 178.28 ms</span><br><span class="line">NSCondition: 193.38 ms</span><br><span class="line">NSLock: 175.02 ms</span><br><span class="line">pthread_mutex(recursive): 172.56 ms</span><br><span class="line">NSRecursiveLock: 157.44 ms</span><br><span class="line">NSConditionLock: 490.04 ms</span><br><span class="line">@synchronized: 371.17 ms</span><br><span class="line"></span><br><span class="line">总的来说：</span><br><span class="line"></span><br><span class="line">OSSpinLock 自旋锁(性能最高的锁)和 dispatch_semaphore 信号量的效率远远高于其他。</span><br><span class="line">@synchronized和NSConditionLock效率较差。</span><br><span class="line"></span><br><span class="line">dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。</span><br><span class="line">OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。 不过最近YY大神在自己的博客不再安全的 OSSpinLock中说明了OSSpinLock已经不再安全，请大家谨慎使用。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。</span><br><span class="line">如果不考虑性能，只是图个方便的话，那就使用@synchronized。</span><br></pre></td></tr></table></figure><h4 id="NSDateFormatter在iOS7之后-包括iOS7-才是线程安全的"><a href="#NSDateFormatter在iOS7之后-包括iOS7-才是线程安全的" class="headerlink" title="NSDateFormatter在iOS7之后(包括iOS7)才是线程安全的"></a>NSDateFormatter在iOS7之后(包括iOS7)才是线程安全的</h4><ul><li>参考文章：<a href="https://blog.csdn.net/zskm001/article/details/51883076" target="_blank" rel="noopener">关于NSDateFormatter的线程安全问题</a></li></ul><h3 id="2、死锁"><a href="#2、死锁" class="headerlink" title="2、死锁"></a>2、死锁</h3><p><strong>死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace) ) ，若无外力作用，这些进程（线程）都将无法向前推进。</strong></p><p>死锁的4个必要条件</p><h2 id="一、-synchronized"><a href="#一、-synchronized" class="headerlink" title="一、@synchronized"></a>一、@synchronized</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">  </span><br><span class="line">  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">      @synchronized(obj) &#123;</span><br><span class="line">          NSLog(@&quot;需要线程同步的操作1 开始&quot;);</span><br><span class="line">          sleep(3);</span><br><span class="line">          NSLog(@&quot;需要线程同步的操作1 结束&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">      sleep(1);</span><br><span class="line">      @synchronized(obj) &#123;</span><br><span class="line">          NSLog(@&quot;需要线程同步的操作2&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>@synchronized(obj)指令使用的obj为该锁的唯一标识，<strong>只有当标识相同时，才为满足互斥</strong>，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，</p><h2 id="二、NSLock"><a href="#二、NSLock" class="headerlink" title="二、NSLock"></a>二、NSLock</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSLock *lock = [[NSLock alloc] init];</span><br><span class="line">  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">      [lock lock];// 加锁</span><br><span class="line">    NSLog(@&quot;需要线程同步的操作1 开始&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    NSLog(@&quot;需要线程同步的操作1 结束&quot;);</span><br><span class="line">      [lock unlock]; // 解锁</span><br><span class="line">      </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="三、NSRecursiveLock递归锁的使用"><a href="#三、NSRecursiveLock递归锁的使用" class="headerlink" title="三、NSRecursiveLock递归锁的使用"></a>三、NSRecursiveLock递归锁的使用</h2><p>我们先写一个典型的死锁情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSLock *lock = [[NSLock alloc] init];// 此锁在本代码中会造成死锁</span><br><span class="line">//NSRecursiveLock *lock = [[NSRecursiveLock alloc] init]; //要想下面的递归调用不会造成死锁，只要这里将锁改成递归锁NSRecursiveLock就可以了。NSRecursiveLock递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">    static void (^RecursiveMethod)(int);</span><br><span class="line"></span><br><span class="line">    RecursiveMethod = ^(int value) &#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        if (value &gt; 0) &#123;</span><br><span class="line">            NSLog(@&quot;value = %d&quot;, value);</span><br><span class="line">            sleep(2);</span><br><span class="line">            RecursiveMethod(value - 1);// 此时lock还没解锁，就有执行这个block，而block里又给加了次锁，从而造成了死锁</span><br><span class="line">        &#125;</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    RecursiveMethod(5);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在是跟你面的代码中，在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSLock *lock = [[NSLock alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">    static void (^RecursiveMethod)(int);</span><br><span class="line"></span><br><span class="line">    RecursiveMethod = ^(int value) &#123;</span><br><span class="line">        if (value &gt; 0) &#123;</span><br><span class="line">            NSLog(@&quot;value = %d&quot;, value);</span><br><span class="line">            sleep(2);</span><br><span class="line">            RecursiveMethod(value - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">[lock lock];</span><br><span class="line">    RecursiveMethod(5);</span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="四、NSCondition-amp-NSConditionLock-条件锁"><a href="#四、NSCondition-amp-NSConditionLock-条件锁" class="headerlink" title="四、NSCondition &amp; NSConditionLock 条件锁"></a>四、NSCondition &amp; NSConditionLock 条件锁</h2><p><code>wait</code>方法是傻等；</p><p><code>waitUntilDate</code>:方法是等一会；</p><p><code>signal</code>是唤起一个在等待的线程。</p><p>通过<code>wait()</code>和<code>waitUntilDate(limit: NSDate) -&gt; Bool</code>这两个方法都可以实现线程阻塞即线程睡眠。</p><p>不同之处在于</p><p><code>wait()</code>会使线程一直处于休眠状态，直到收到<code>signal()</code>为止；</p><p>而<code>waitUntilDate(limit: NSDate) -&gt; Bool</code>在使线程睡眠的同时会设置睡眠的终止时间。</p><blockquote><p>如果在终止时间前收到了<code>signal()</code>就会唤醒线程；<br>当到达终止时间的时候，即使没有收到<code>signal()</code>，也会直接唤醒线程，而不会像<code>wait()</code>方法那样一直睡眠下去。</p></blockquote><h3 id="1、NSCondition"><a href="#1、NSCondition" class="headerlink" title="1、NSCondition"></a>1、NSCondition</h3><p>基本的条件锁，手动的控制。wait</p><h3 id="2、NSConditionLock-条件锁"><a href="#2、NSConditionLock-条件锁" class="headerlink" title="2、NSConditionLock 条件锁"></a>2、NSConditionLock 条件锁</h3><p>条件锁，这里的条件并不是bool表达式中的条件，而是一个特定的int值。</p><p>条件锁，不是简单的加锁/解锁， 而是需要根据一定条件满足后进行 加锁/解锁.</p><p>以一个生产中与消费者的例子，介绍条件锁的用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static NSInteger CONDITION_NO_DATA        //条件一： 没有数据</span><br><span class="line">static NSInteger CONDITION_HAS_DATA       //条件二： 有数据</span><br><span class="line"></span><br><span class="line">// 初始化锁时，指定一个默认的条件</span><br><span class="line">NSConditionLock *lock = [[NSConditionLock alloc] initWithCondition:CONDITION_NO_DATA];</span><br><span class="line"></span><br><span class="line">//生产者，加锁与解锁的过程</span><br><span class="line">while (YES) &#123;</span><br><span class="line">    </span><br><span class="line">    //1. 当满足 【没有数据的条件时】进行加锁</span><br><span class="line">    [lock lockWhenCondition:CONDITION_NO_DATA];</span><br><span class="line"></span><br><span class="line">    //2. 生产者生成数据 </span><br><span class="line">    //.....</span><br><span class="line"></span><br><span class="line">    //3. 解锁，并设置新的条件，已经有数据了</span><br><span class="line">    [locker unlockWithCondition:CONDITION_HAS_DATA];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//消费者，加锁与解锁的过程 </span><br><span class="line">while (YES) &#123;</span><br><span class="line">    </span><br><span class="line">    //1. 当满足 【有数据的条件时】进行加锁</span><br><span class="line">    [lock lockWhenCondition:CONDITION_HAS_DATA];</span><br><span class="line"></span><br><span class="line">    //2. 消费者消费数据 </span><br><span class="line">    //.....</span><br><span class="line"></span><br><span class="line">    //3. 解锁，并设置新的条件，没有数据了</span><br><span class="line">    [locker unlockWithCondition:CONDITION_NO_DATA];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、OSSpinLock自旋锁-amp-os-unfair-lock"><a href="#五、OSSpinLock自旋锁-amp-os-unfair-lock" class="headerlink" title="五、OSSpinLock自旋锁 &amp; os_unfair_lock"></a>五、OSSpinLock自旋锁 &amp; os_unfair_lock</h1><p>由于OSSpinLock不再安全，所以这里我们就直接说一下os_unfair_lock，这个是苹果用于代替OSSpinLock的。效率很高用法很简单如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">os_unfair_lock_t</span> lock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line"></span><br><span class="line">os_unfair_lock_lock(&amp;lock);</span><br><span class="line">NSLog(@<span class="string">"os_unfair_lock_t"</span>);</span><br><span class="line">os_unfair_lock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;libkern/OSAtomic.h&gt;</span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,assign)  int ticket;</span><br><span class="line">//@property (nonatomic,assign)  OSSpinLock lock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">//    self.lock = OS_SPINLOCK_INIT;</span><br><span class="line">    self.ticket=50;</span><br><span class="line">    [self ticketsTest];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)ticketsTest&#123;</span><br><span class="line">  // 这里我们开两个线程处理同一件事</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i =0; i&lt;5; i++) &#123;</span><br><span class="line">            [self saleTicket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i =0; i&lt;5; i++) &#123;</span><br><span class="line">            [self saleTicket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)saleTicket&#123;</span><br><span class="line">    //静态创建、则不需要新建属性</span><br><span class="line">    static OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line">    //若后面是个函数、则需</span><br><span class="line">    /*</span><br><span class="line">    static OSSpinLock lock = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        lock = OS_SPINLOCK_INIT;</span><br><span class="line">    &#125;);</span><br><span class="line">     */</span><br><span class="line">    //其他线程执行到这里时，发现锁被加锁了 就会再这排队等待、直到这个锁被打开</span><br><span class="line">    //加锁</span><br><span class="line">    OSSpinLockLock(&amp;lock);</span><br><span class="line">    int ticket = self.ticket;</span><br><span class="line">    sleep(.2);</span><br><span class="line">    ticket--;</span><br><span class="line">    self.ticket=ticket;</span><br><span class="line">    NSLog(@&quot;%d&quot;,self.ticket);</span><br><span class="line">    //解锁</span><br><span class="line">    OSSpinLockUnlock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="iOS-互斥锁-amp-amp-自旋锁-多线程安全隐患"><a href="#iOS-互斥锁-amp-amp-自旋锁-多线程安全隐患" class="headerlink" title="iOS - 互斥锁&amp;&amp;自旋锁 多线程安全隐患"></a>iOS - 互斥锁&amp;&amp;自旋锁 多线程安全隐患</h1><p><a href="https://www.bbsmax.com/A/QV5ZQk92Jy/" target="_blank" rel="noopener">iOS - 互斥锁&amp;&amp;自旋锁 多线程安全隐患</a></p><p><strong>一、多线程安全隐患</strong></p><p><strong>资源共享</strong><br> 一块资源可能会被多个线程共享，也就是多个线程可能会访问到一块资源<br> 比如多个线程访问同一个对象，同一个变量，同一个文件。<br> 当多线程访问同一块资源的时候，很容易引发数据错乱和数据安全问题<br>二、原子和非原子属性<br> 1&gt;OC 在定义属性的时候有nonatomic和atomic两种选择<br>   * <strong>atomic</strong>：原子属性，为 setter 方法加锁<br>   * <strong>nonatomic</strong>：非原子属性，不会为 setter 方法加锁<br>    普通情况下都是在主线程做操作，所以一般都不会加锁。<br> 对比：<br>   <strong>* atomic</strong>：线程安全，需要消耗大量的资源<br>   <strong>* nonatomic</strong>：非线程安全，适合内存小的移动设备<br> 2&gt;synchronized 与 atomic<br>   * <strong>synchronized</strong>：互斥锁<br>   * <strong>atomic</strong>：自旋锁<br> <strong>共同点</strong>：都能保证同一时刻只能有一个线程操作锁住的代码<br>  <strong>区别</strong>：<br>   <strong>互斥锁</strong>：当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会进入睡眠状态等待任务执行完毕，当上一个线程的任务执行完毕，下一个线程会.  自动唤醒然后执行任务。<br>   <strong>自旋锁</strong>：当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会一直等待（不会睡眠），当上一个线程的任务执行完毕，下一个线程会立即执行。<br> <strong>自旋锁应用场景</strong>：比较适合做一些不耗时的操作<br>三、互斥锁<br>· 注意点：<br>   - 如果多线程访问同一个资源，那么必须使用同一把锁才能锁住<br>   - 在开发中，尽量不要加锁，能在服务端做尽量在服务端做，如果必须要加锁，一定要记住，锁的范围不能太大，哪里有安全隐患就加在哪里。<br> 技巧：因为必须使用同一把锁，开发中如果需要加锁，直接使用 self 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@synchronized(self) &#123;</span><br><span class="line">  //线程1进来之后，锁住，2和3都再外面等待</span><br><span class="line">  //1、查询剩余的票数 NSUInteger count = self.totalCount;</span><br><span class="line">  //2、判断是否还有余票</span><br><span class="line">  //2.1卖票</span><br><span class="line">  //3 、提示客户，没有票了</span><br><span class="line">  if (count&gt;0) &#123;</span><br><span class="line">    [NSThread sleepForTimeInterval:0.1];</span><br><span class="line">    self.totalCount = count-1;</span><br><span class="line">    NSLog(@&quot;%@卖了一张票,还剩%zd票&quot;,[NSThread currentThread].name,self.totalCount);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    NSLog(@&quot;没票了&quot;);</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//解锁</span><br></pre></td></tr></table></figure><p>四、自旋锁<br>注意点:<br>只会给 setter 方法加锁，并不会给getter方法加锁。</p><p><a href="https://juejin.im/post/5c67e349f265da2de33f1275" target="_blank" rel="noopener">ObjC 多线程简析（一）-多线程简述和线程锁的基本应用</a></p><p>在iOS10之后apple废弃了<code>OSSpinLock</code>自旋锁，使用<code>os_unfair_lock</code>互斥锁来替代。</p><p>在iOS10之后apple已经不再建议使用<code>OSSpinLock</code>自旋锁了，它的替代方案是一个互斥锁，所以一般情况下我们使用互斥锁来解决线程同步的问题才是比较合理的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化OSSpinLock</span><br><span class="line">_osspinlock = OS_SPINLOCK_INIT;</span><br><span class="line"></span><br><span class="line">// 加锁</span><br><span class="line">OSSpinLockLock(&amp;_osspinlock);</span><br><span class="line"></span><br><span class="line">// 操作数据</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// 解锁</span><br><span class="line">OSSpinLockUnlock(&amp;_osspinlock);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化os_unfair_lock</span><br><span class="line">_osunfairLock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line"></span><br><span class="line">// 加锁</span><br><span class="line">os_unfair_lock_lock(&amp;(_osunfairLock));</span><br><span class="line"></span><br><span class="line">// 操作数据</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// 解锁</span><br><span class="line">os_unfair_lock_unlock(&amp;(_osunfairLock));</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/c2f488ad638e" target="_blank" rel="noopener">iOS中的线程同步方案</a></p><p><strong>自旋锁、互斥锁比较:</strong></p><p>a, 什么情况使用自旋锁比较划算？</p><p>预计线程等待锁的时间很短</p><p>加锁的代码（临界区）经常被调用，但竞争情况很少发生</p><p>CPU资源不紧张</p><p>多核处理器</p><p>b,什么情况使用互斥锁比较划算？</p><p>预计线程等待锁的时间较长</p><p>单核处理器</p><p>临界区有IO操作</p><p>临界区代码复杂或者循环量大</p><p>临界区竞争非常激烈</p><h6 id="4-、自己延伸的问题：什么队列能同时存在同步任务和异步任务？-并发队列"><a href="#4-、自己延伸的问题：什么队列能同时存在同步任务和异步任务？-并发队列" class="headerlink" title="(4)、自己延伸的问题：什么队列能同时存在同步任务和异步任务？(并发队列)"></a>(4)、自己延伸的问题：什么队列能同时存在同步任务和异步任务？(并发队列)</h6><p>eg：主线程的主队列是串行队列，不可能在该队列上添加同步任务，否则会造成死锁。所以，同时存在同步任务和异步任务的队列应该只能是并发队列。</p><p>最终的执行顺序，还是看这些各式各样的任务所在的队列是什么队列，串行的还是并发的。</p><h4 id="1、死锁探究：GCD死锁及报错提示-EXC-BAD-INSTRUCTION"><a href="#1、死锁探究：GCD死锁及报错提示-EXC-BAD-INSTRUCTION" class="headerlink" title="1、死锁探究：GCD死锁及报错提示(EXC_BAD_INSTRUCTION)"></a>1、死锁探究：GCD死锁及报错提示(EXC_BAD_INSTRUCTION)</h4><h6 id="1-、死锁举例：通过串行队列里的任务，往这个串行队列里添加同步任务，会造成死锁"><a href="#1-、死锁举例：通过串行队列里的任务，往这个串行队列里添加同步任务，会造成死锁" class="headerlink" title="(1)、死锁举例：通过串行队列里的任务，往这个串行队列里添加同步任务，会造成死锁"></a>(1)、死锁举例：通过串行队列里的任务，往这个串行队列里添加同步任务，会造成死锁</h6><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)testDeadlock1:(id)sender &#123;</span><br><span class="line">    //测试死锁</span><br><span class="line">    dispatch_queue_t q1 = dispatch_queue_create(&quot;serial_queue_1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_async(q1, ^&#123;</span><br><span class="line">    NSLog(@&quot;1(属任务①).验证通过串行队列里的任务，往这个串行队列里添加同步任务，会造成死锁%@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_sync(q1, ^&#123; // 添加的同步任务和外面的任务是同一个串行队列</span><br><span class="line">    sleep(2);</span><br><span class="line">    NSLog(@&quot;2(属任务②).验证通过串行队列里的任务，往这个串行队列里添加同步任务，会造成死锁%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;3(属任务①).验证通过串行队列里的任务，往这个串行队列里添加同步任务，会造成死锁%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-、死锁结论：往串行队列里添加的同步任务不能卡住该串行队列，否则会造成死锁-这句话非常重要"><a href="#2-、死锁结论：往串行队列里添加的同步任务不能卡住该串行队列，否则会造成死锁-这句话非常重要" class="headerlink" title="(2)、死锁结论：往串行队列里添加的同步任务不能卡住该串行队列，否则会造成死锁(这句话非常重要)"></a>(2)、死锁结论：往串行队列里添加的同步任务不能卡住该串行队列，否则会造成死锁(这句话非常重要)</h6><h6 id="3-、死锁原因分析："><a href="#3-、死锁原因分析：" class="headerlink" title="(3)、死锁原因分析："></a>(3)、死锁原因分析：</h6><p>要了解<strong>通过串行队列里的任务，往这个串行队列里添加同步任务，会造成死锁</strong>，或者说<strong>往串行队列里添加的同步任务卡住该串行队列的时候会发生死锁</strong>的原因，我们首先需要知道几个概念：</p><blockquote><p>知识点①：创建同步任务的操作，在创建完之后，需要立马执行所创建的同步任务。即创建完同步任务的操作后，只有连其所创建的同步任务也结束了才能继续执行下去；</p><p>知识点②：而创建异步任务的操作，在创建完之后，即可继续执行下去，不需要等待所创建的异步任务结束。</p><p>附：在线程组的使用中，我们会遇到需要监听多个子线程中的所有任务都结束后，才去执行最后的更新UI的操作。假设最后更新UI的操作，除了需要子线程的任务结束，还需要子线程中的异步线程，如网络请求也结束后，才能更新UI，那么为了不让子线程提前退出，而是等到网络请求也结束后才退出，我们通常会通过使用gcd的enter leave或者信号量来等待。</p><p>知识点③：串行队列里的任务是一个执行完，才接着执行下一个；</p></blockquote><p>所以，由以上①②③知识点，我们就能分析出其造成死锁的原因如下：</p><blockquote><p>首先，对于标记<code>1</code>、<code>2</code>、<code>3</code>，先只看是同步任务还是异步任务，而不管是串行队列，还是并行队列，或者说是哪个队列。</p><p>从代码上我们很容易看出其是同步任务，所以由以上同步的知识点②，可以知道，最终标记输出的正确顺序应该依次是标记<code>1</code>、标记<code>2</code>、标记<code>3</code>。</p><p>即我们的关注点是标记<code>2</code>能否在标记<code>1</code>之后输出。</p><p>答，在上述代码中，标记<code>2</code>处的同步任务是被添加到串行队列的，而且还是当前的串行队列。</p><p>我们知道串行队列里的任务是一个执行完，才接着执行下一个的，也就是说，往串行队列里添加的任务要执行的条件一定是在所添加的新任务之前的所有任务都已经全部执行完了后，才会执行到这一个的。</p><p>这里我们依次往串行队列里添加了第一个任务块和第二个任务块。</p><p>要完成第一个任务块需要同时完成任务<code>1</code>+第二个任务块<code>2</code>+任务<code>3</code>。</p><p>第二个任务块要执行，根据串行队列的性质，我们知道第二个任务块要等待第一个任务块结束才会执行。（如果两个任务即使都是添加到串行队列，但是他们是不同串行队列的时候就不会需要等待）</p><p>由此死锁。</p><p>显然这里任务②需要等到任务①真正完成，而任务①的真正完成需要等任务②完成，这样的一个互相等待也就构成了一个死锁，导致我们<strong> EXC_BAD_INSTRUCTION</strong>的崩溃了。</p></blockquote><p>那么以上死锁的问题，怎么解决呢？</p><blockquote><p>答：其实只要解决标记<code>2</code>即任务②，可以在标记<code>1</code>执行之后执行就可以了。<br>解决方法有：将任务②改成异步任务，或者将任务②这个同步任务添加到非本串行队列下，可以是其他串行队列，也可以是其他并行队列都可以。即以下这种修改方案是能够解决死锁的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)testDeadlock2:(id)sender &#123;</span><br><span class="line">    //测试死锁</span><br><span class="line">    dispatch_queue_t q1 = dispatch_queue_create(&quot;serial_queue_1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_async(q1, ^&#123;</span><br><span class="line">    ​    NSLog(@&quot;1(属任务①).验证通过串行队列里的任务，往其他串行队列里添加同步任务，不会造成死锁%@&quot;, [NSThread currentThread]);</span><br><span class="line">    ​    dispatch_queue_t q2 = dispatch_queue_create(&quot;serial_queue_2&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    ​    dispatch_sync(q2, ^&#123;</span><br><span class="line">    ​        sleep(2);</span><br><span class="line">    ​        NSLog(@&quot;2(属任务②).验证通过串行队列里的任务，往其他串行队列里添加同步任务，不会造成死锁%@&quot;, [NSThread currentThread]);</span><br><span class="line">    ​    &#125;);</span><br><span class="line">    ​    NSLog(@&quot;3(属任务①).验证通过串行队列里的任务，往其他串行队列里添加同步任务，不会造成死锁%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、主队列中的死锁：在主队列开启同步任务，一定为什么会阻塞线程-看同步任务是不是加在主队列里去了-？"><a href="#2、主队列中的死锁：在主队列开启同步任务，一定为什么会阻塞线程-看同步任务是不是加在主队列里去了-？" class="headerlink" title="2、主队列中的死锁：在主队列开启同步任务，一定为什么会阻塞线程(看同步任务是不是加在主队列里去了)？"></a>2、主队列中的死锁：在主队列开启同步任务，一定为什么会阻塞线程(看同步任务是不是加在主队列里去了)？</h4><p>回答本问题前，我们需要先了解的知识点是：</p><blockquote><p>知识点①：主线程和主队列的关系：</p><p>主队列是主线程中的一个串行队列。每一个应用程序只有唯一的一个主队列用来update UI。所有的和UI的操作(刷新或者点击按钮)都必须在主线程中的主队列中去执行，否则无法更新UI。</p></blockquote><p>因为主线程是一个串行队列，<strong>所以往主队列里添加同步任务</strong>（如果不是往主队列添加同步任务就不会）是<em>很有可能</em>发生死锁卡死的。如以下代码就会发生死锁。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;打印1&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    ​    NSLog(@&quot;打印2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;打印3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由引述，我们已经知道<strong>往串行队列里添加的同步任务，如果卡住的是该串行队列，则会发生死锁</strong>，所以显然即执行往这个串行队列里添加同步任务的该任务也是在这个串行队列里的话，那么由于相互等待会造成死锁。</p><p>最简单的解决方法：将sync同步方法，替换成异步方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;标记1&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;标记3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;标记5&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//输出结果为 标记1、标记5、标记3</span><br></pre></td></tr></table></figure><p>其他修改方法：将同步任务卡住的队列改成并发队列。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDeadLock &#123;</span><br><span class="line">    NSLog(@&quot;标记1&quot;);</span><br><span class="line">    dispatch_queue_t other_queue = dispatch_queue_create(&quot;other_queue&quot;, DISPATCH_QUEUE_SERIAL);//不管是串行队列还是并发队列，都能解决这个死锁问题，因为它同步方法没有卡住这个other_queue。</span><br><span class="line">    dispatch_async(other_queue, ^&#123;</span><br><span class="line">    ​    NSLog(@&quot;标记2&quot;);</span><br><span class="line">    ​    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    ​        NSLog(@&quot;标记3&quot;);</span><br><span class="line">    ​    &#125;);</span><br><span class="line">    ​    NSLog(@&quot;标记4&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    NSLog(@&quot;标记5&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//输出结果为 标记1、标记2、标记5、标记3、标记4。</span><br></pre></td></tr></table></figure><p>有了这些基础，你再看以下文章中的例子时，就能轻松判断是否会造成死锁了 。</p><ul><li><a href="https://www.jianshu.com/p/c39c1db05305" target="_blank" rel="noopener">dispatch_get_main_queue()卡死</a></li></ul><p>#### </p><h1 id="iOS中自旋锁与互斥锁的区别"><a href="#iOS中自旋锁与互斥锁的区别" class="headerlink" title="iOS中自旋锁与互斥锁的区别"></a>iOS中自旋锁与互斥锁的区别</h1><p><strong>自旋锁（spinlock）</strong>：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。（附：获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active活跃状态的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快）</p><p>其他参考文章：<a href="https://www.jianshu.com/p/d69495dac8cb" target="_blank" rel="noopener">iOS中自旋锁与互斥锁的区别</a></p><p>pthread_mutex 表示互斥锁。互斥锁可以传入不同参数，实现递归锁pthread_mutex(recursive)。</p><blockquote><p>NSLock，NSCondition，NSRecursiveLock，NSConditionLock都是内部封装的pthread_mutex，即都属于互斥锁。@synchronized是NSLock的一种封装，牺牲了效率，简洁了语法。</p></blockquote><p>OSSpinLock 表示自旋锁，从上图可以看到自旋锁的效率最高，但是现在的iOS因为优先级反转的问题，已经不安全，所以推荐使用pthread_mutex或者dispatch_semaphore。</p><p><strong>总结</strong>：<br>　　自旋锁会忙等: 所谓忙等，即在访问被锁资源时，调用者线程不会休眠，而是不停循环在那里，直到被锁资源释放锁。<br>　　互斥锁会休眠: 所谓休眠，即在访问被锁资源时，调用者线程会休眠，此时cpu可以调度其他线程工作。直到被锁资源释放锁。此时会唤醒休眠线程。</p><p><strong>优缺点</strong>：<br>　　自旋锁的优点在于，因为自旋锁不会引起调用者睡眠，所以不会进行线程调度，cpu时间片轮转等耗时操作。所有如果能在很短的时间内获得锁，自旋锁的效率远高于互斥锁。<br>　　缺点在于，自旋锁一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时 间内获得锁，这无疑会使CPU效率降低。自旋锁不能实现递归调用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E9%94%81%E3%80%81%E9%98%9F%E5%88%97/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E9%94%81%E3%80%81%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程、锁、队列"><a href="#多线程、锁、队列" class="headerlink" title="多线程、锁、队列"></a>多线程、锁、队列</h1><ul><li><a href="https://www.jianshu.com/p/1f9f6814e3a2" target="_blank" rel="noopener">ios多线程中使用信号量形成死锁，阻塞主线程</a></li><li><a href="https://www.jianshu.com/p/17afd8db5b79" target="_blank" rel="noopener">iOS锁系列-信号量dispatch_semaphore</a></li></ul><p>信号量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">②dispatch_semaphore_signal(sem);</span><br><span class="line">③dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure><p>GCD</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①dispatch_group_t group = dispatch_group_create();</span><br><span class="line">②dispatch_group_enter(group);</span><br><span class="line">③dispatch_group_leave(group);</span><br><span class="line">④dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        这里跑去干自己的事情。。。。</span><br><span class="line">    &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>用信号量时候，</p><p>某个线程锁住后，就处于等待状态，即该线程也就无法再继续操作，所以试图尝试在该线程锁住的时候去发送信号，增加信号量，会造成死锁。</p><p>举例：</p><p>信号量使用场景</p><ul><li><a href="https://www.cnblogs.com/mnstar/articles/6050296.html" target="_blank" rel="noopener">iOS 使用信号量等待block完成</a></li></ul><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p><a href="https://www.jianshu.com/p/042c135552b8" target="_blank" rel="noopener">iOS 实现并发和串行任务</a><br>串行队列如何知道任务已经完成<br><a href="https://blog.csdn.net/u010105969/article/details/69914369" target="_blank" rel="noopener">iOS开发中的并发、串行队列，同步、异步任务</a></p><p><a href="https://www.jianshu.com/p/c6ab011f449f" target="_blank" rel="noopener">iOS代码同步到主线程的三种方法</a></p><p>autoreleasepool 使用场景、什么时候释放</p><p>临时变量什么时候释放</p><h4 id="RunLoop和线程间的关系"><a href="#RunLoop和线程间的关系" class="headerlink" title="RunLoop和线程间的关系"></a>RunLoop和线程间的关系</h4><p>每条线程都有唯一的一个与之对应的RunLoop对象，RunLoop保存在一个全局的Dictionary里，线程作为key,RunLoop作为value，主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建，RunLoop在第一次获取时创建，在线程结束时销毁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/7iOS%E4%B8%8EJS%E4%BA%A4%E4%BA%92/7iOS%E4%B8%8EJS%E4%BA%A4%E4%BA%92/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/7iOS%E4%B8%8EJS%E4%BA%A4%E4%BA%92/7iOS%E4%B8%8EJS%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构"><a href="#必备知识架构" class="headerlink" title="必备知识架构"></a>必备知识架构</h1><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><h2 id="iOS与JS交互"><a href="#iOS与JS交互" class="headerlink" title="iOS与JS交互"></a>iOS与JS交互</h2><ul><li><p><a href="https://blog.csdn.net/dolacmeng/article/details/79623708" target="_blank" rel="noopener">iOS与JS交互的4种方法</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iOS与JS交互的方法：</span><br><span class="line">1.拦截url（适用于UIWebView和WKWebView） </span><br><span class="line">2.JavaScriptCore（只适用于UIWebView，iOS7+） </span><br><span class="line">3.WKScriptMessageHandler（只适用于WKWebView，iOS8+） </span><br><span class="line">4.WebViewJavascriptBridge（适用于UIWebView和WKWebView，属于第三方框架）</span><br><span class="line"></span><br><span class="line">更详细介绍，请点击以上链接进入查看。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/4%E7%BA%BF%E7%A8%8B-%E2%91%A0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/4%E7%BA%BF%E7%A8%8B-%E2%91%A0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-线程与网络-①线程"><a href="#必备知识架构-线程与网络-①线程" class="headerlink" title="必备知识架构-线程与网络-①线程"></a>必备知识架构-线程与网络-①线程</h1><p>[toc]</p><p></p><p id="线程间的通信"></p><p></p><h2 id="二、谈谈你对线程间的通信的了解"><a href="#二、谈谈你对线程间的通信的了解" class="headerlink" title="二、谈谈你对线程间的通信的了解"></a>二、谈谈你对线程间的通信的了解</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信。</p><p>线程间通信的体现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 一个线程传递数据给另一个线程</span><br><span class="line">2. 在一个线程中执行完特定任务后，转到另一个线程继续执行任务</span><br></pre></td></tr></table></figure><p>线程间通信应用举例：（即在一个线程中执行完特定任务后，转到另一个线程继续执行任务，并将该线程数据传递给另一个线程的应用举例）</p><blockquote><p>以下例子摘自：<a href="https://www.cnblogs.com/supper-Ho/p/6379606.html" target="_blank" rel="noopener">线程间通讯</a></p><p>①<code>NSThread</code>可以先将自己的当前线程对象注册到某个全局的对象中去，这样相互之间就可以获取对方的线程对象，然后就可以使用下面的方法进行线程间的通信了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;回到主线程执行，执行self的showImage方法，参数是arg</span><br><span class="line">&gt;</span><br><span class="line">&gt;- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">&gt;</span><br><span class="line">&gt;回到后台线程执行aSelector方法，参数是arg</span><br><span class="line">&gt;- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg</span><br><span class="line">&gt;</span><br><span class="line">&gt;回到xx线程执行aSelector方法，参数是arg</span><br><span class="line">&gt;</span><br><span class="line">&gt;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>②、<code>GCD</code>一个线程传递数据给另一个线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">&gt;     NSLog(@&quot;donwload---%@&quot;, [NSThread currentThread]);</span><br><span class="line">&gt;     // 1.子线程下载图片</span><br><span class="line">&gt;     NSURL *url = [NSURL URLWithString:@&quot;http://d.jpg&quot;];</span><br><span class="line">&gt;     NSData *data = [NSData dataWithContentsOfURL:url];</span><br><span class="line">&gt;     UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">&gt;     // 2.回到主线程设置图片</span><br><span class="line">&gt;     dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">&gt;         NSLog(@&quot;setting---%@ %@&quot;, [NSThread currentThread], image);</span><br><span class="line">&gt;         [self.button setImage:image forState:UIControlStateNormal];</span><br><span class="line">&gt;     &#125;);</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>③、NSOperation线程通信的举例：在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。这里有两种方法，一种是线程里转线程，另一种是线程间使用依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; // 1.创建一个新的队列</span><br><span class="line">&gt; NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">&gt; // 2.添加任务(操作)</span><br><span class="line">&gt; [queue addOperationWithBlock:^&#123;</span><br><span class="line">&gt;     // 2.1在子线程中下载图片</span><br><span class="line">&gt;     NSURL *url  = [NSURL URLWithString:@&quot;http://imgcache.mysodao.com/img2/M04/8C/74/CgAPDk9dyjvS1AanAAJPpRypnFA573_700x0x1.JPG&quot;];</span><br><span class="line">&gt;     NSData *data = [NSData dataWithContentsOfURL:url];</span><br><span class="line">&gt;     UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">&gt;     // 2.2回到主线程更新UI</span><br><span class="line">&gt;     [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">&gt;         self.imageView.image = image;</span><br><span class="line">&gt;     &#125;];</span><br><span class="line">&gt; &#125;];</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>首先我们先来说说线程与线程间的关系，其引入了我们下面的第二点线程等待(线程同步)问题、线程依赖问题。</p><p>然后我们再来说说，有时候我们还常经常在多个线程中操作一个全局变量，这个的话，也算线程间通信吗？不管他算不算(应该是不算的，个人觉得)，但是他的存在使得我们引入了另一个线程安全的问题，即多个线程操作同一个变量。也就是下面说的第三点，线程安全问题。</p><h4 id="附：其他传值方法总结"><a href="#附：其他传值方法总结" class="headerlink" title="附：其他传值方法总结"></a>附：其他传值方法总结</h4><p>参考：<a href="http://blog.csdn.net/DJH996064549/article/details/50497371" target="_blank" rel="noopener">其他传值方法总结</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、A界面到B界面的正向传值，即A界面传值给B界面使用</span><br><span class="line">2、。。。</span><br></pre></td></tr></table></figure></p><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/4%E7%BA%BF%E7%A8%8B-%E2%91%A0%E7%BA%BF%E7%A8%8BGCD/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/4%E7%BA%BF%E7%A8%8B-%E2%91%A0%E7%BA%BF%E7%A8%8BGCD/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-线程与网络-①线程GCD"><a href="#必备知识架构-线程与网络-①线程GCD" class="headerlink" title="必备知识架构-线程与网络-①线程GCD"></a>必备知识架构-线程与网络-①线程GCD</h1><p>[toc]</p><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><p></p><p id="GCD"></p><p></p><h2 id="六、GCD"><a href="#六、GCD" class="headerlink" title="六、GCD"></a>六、GCD</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>精： <a href="http://www.cnblogs.com/wendingding/p/3806821.html" target="_blank" rel="noopener">iOS开发多线程篇—GCD介绍</a></p><h4 id="0、dispatch-sync、dispatch-async"><a href="#0、dispatch-sync、dispatch-async" class="headerlink" title="0、dispatch_sync、dispatch_async"></a>0、dispatch_sync、dispatch_async</h4><p>1.GCD中有2个用来执行任务的函数</p><p>说明：<code>把右边的参数（任务）提交给左边的参数（队列）进行执行</code>。</p><p>（1）用同步的方式执行任务 dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</p><p>（2）用异步的方式执行任务 dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</p><p>以下参考自：<a href="http://www.cnblogs.com/ygm900/p/3696371.html" target="_blank" rel="noopener">dispatch_group_async 使用详解</a></p><h4 id="1、dispatch-group-async-（可实现队列同步）"><a href="#1、dispatch-group-async-（可实现队列同步）" class="headerlink" title="1、dispatch_group_async （可实现队列同步）"></a>1、dispatch_group_async （可实现队列同步）</h4><p><code>要实现监听一组任务是否全部完成，等到全部完成后执行其他的操作可以使用dispatch_group_async（这个方法很有用）</code>。比如异步下载多张图片，等所有图片下载完成之后，再去做一些事情（比如才通知界面说完成的）。</p><p>如果想在dispatch_queue中所有的任务执行完成后在做某种操作，在串行队列中，我们只需把该操作放到最后一个任务来执行就可以，但是在并行队列中怎么做呢。答案是用dispatch_group任务组来做。</p><p>思路：<code>创建一个任务组，然后将异步操作都放进任务组里面，在最后用notify 告知所有任务完成，并做相应处理，一般最后的处理都是在主线程里面刷新UI来提示用户。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //创建并行队列queue</span><br><span class="line">dispatch_group_t group = dispatch_group_create();          //创建任务组group</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;group1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;group2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;group3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;updateUi&quot;); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_release(group);</span><br></pre></td></tr></table></figure><p>附：下面的两种调用其实是等价的， </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A)</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123; </span><br><span class="line"></span><br><span class="line">　　// 。。。 </span><br><span class="line"></span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">B) </span><br><span class="line"></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">　　//。。。</span><br><span class="line"></span><br><span class="line">　　dispatch_group_leave(group);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 其他：</p><p><a href="http://zhidao.baidu.com/link?url=T16NuXqHjBDteT_OQYav1f4lEWM6EVfATRuBMcuKSKh6rIPlupbFkTPVZGQ4reP7pFojqox7BGdgo2d8Isk3qZ3O0GUxj5EEfsWc1rGLVtK" target="_blank" rel="noopener">使用gcd怎么让两个线程执行完结束后再去执行另一个线程</a></p><p><a href="http://blog.csdn.net/wangzitao126/article/details/43195533" target="_blank" rel="noopener">多线程并发流程控制之dispatch_group 有关函数</a></p><h4 id="2、dispatch-barrier-async（可实现队列同步）"><a href="#2、dispatch-barrier-async（可实现队列同步）" class="headerlink" title="2、dispatch_barrier_async（可实现队列同步）"></a>2、dispatch_barrier_async（可实现队列同步）</h4><p>dispatch_barrier_async是在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;**test.abc.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [NSThread sleepForTimeInterval:2];</span><br><span class="line">    NSLog(@&quot;dispatch_async1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [NSThread sleepForTimeInterval:4];</span><br><span class="line">    NSLog(@&quot;dispatch_async2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123; //dispatch_barrier_async是在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行</span><br><span class="line">    NSLog(@&quot;dispatch_barrier_async&quot;);</span><br><span class="line">    [NSThread sleepForTimeInterval:4];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [NSThread sleepForTimeInterval:1]; </span><br><span class="line">    NSLog(@&quot;dispatch_async3&quot;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3、dispatch-apply"><a href="#3、dispatch-apply" class="headerlink" title="3、dispatch_apply"></a>3、dispatch_apply</h4><p>dispatch_apply执行某个代码片段N次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_apply(5, globalQ, ^(size_t index) &#123;</span><br><span class="line">// 执行5次</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4、小结dispatch-group-async、dispatch-barrier-async、dispatch-apply分别是什么？"><a href="#4、小结dispatch-group-async、dispatch-barrier-async、dispatch-apply分别是什么？" class="headerlink" title="4、小结dispatch_group_async、dispatch_barrier_async、dispatch_apply分别是什么？"></a>4、小结dispatch_group_async、dispatch_barrier_async、dispatch_apply分别是什么？</h4><p><code>dispatch_group_async</code> 可以实现监听一组任务是否完成，完成后得到通知执行其他的操作。这个方法很有用，比如你执行三个下载任务，当三个任务都下载完成后你才通知界面说完成的了<br><code>dispatch_barrier_async</code> 是在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行<br><code>dispatch_apply</code> 执行某个代码片段N次。</p><h4 id="5、GCD四大队列"><a href="#5、GCD四大队列" class="headerlink" title="5、GCD四大队列"></a>5、GCD四大队列</h4><p><a href="https://www.jianshu.com/p/368e8621dc27" target="_blank" rel="noopener">iOS GCD四大队列</a></p><h6 id="1-、串行队列"><a href="#1-、串行队列" class="headerlink" title="(1)、串行队列"></a>(1)、串行队列</h6><h6 id="2-、并发队列"><a href="#2-、并发队列" class="headerlink" title="(2)、并发队列"></a>(2)、并发队列</h6><h6 id="3-、全局队列"><a href="#3-、全局队列" class="headerlink" title="(3)、全局队列"></a>(3)、全局队列</h6><p>全局队列:<br>和并发队列,执行效果一样,只是说,并发队列,需要我们程序员,自己创建<br>而全局队列,是由于系统提供</p><h6 id="4-、主队列"><a href="#4-、主队列" class="headerlink" title="(4)、主队列"></a>(4)、主队列</h6><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/4%E7%BA%BF%E7%A8%8B-%E2%91%A0%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/4%E7%BA%BF%E7%A8%8B-%E2%91%A0%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-线程与网络-①线程"><a href="#必备知识架构-线程与网络-①线程" class="headerlink" title="必备知识架构-线程与网络-①线程"></a>必备知识架构-线程与网络-①线程</h1><p>[toc]</p><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><h4 id="5、进程和线程的区别"><a href="#5、进程和线程的区别" class="headerlink" title="5、进程和线程的区别"></a>5、进程和线程的区别</h4><h6 id="1-、进程和线程的区别"><a href="#1-、进程和线程的区别" class="headerlink" title="(1)、进程和线程的区别"></a>(1)、进程和线程的区别</h6><blockquote><p>以下区别摘自：<a href="https://www.cnblogs.com/zhuzhu2016/p/5804875.html" target="_blank" rel="noopener">进程和线程的区别</a>。</p><p>一个程序至少一个进程，一个进程至少一个线程。</p><p><strong>一个线程只能属于一个进程，而一个进程可以有多个线程，且至少有一个线程。</strong></p></blockquote><p>进程线程的区别：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">资源拥有：同一进程内的所有线程共享该进程的资源。如内存、I/O、cpu等，但是进程之间的资源是独立的。</span><br><span class="line">地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。</span><br><span class="line">&gt; </span><br><span class="line">一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</span><br><span class="line">&gt; </span><br><span class="line">进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。</span><br><span class="line">&gt; </span><br><span class="line">两者均可并发执行。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h6 id="2-、一个app运行时只有一个进程吗？有没有多进程？"><a href="#2-、一个app运行时只有一个进程吗？有没有多进程？" class="headerlink" title="(2)、一个app运行时只有一个进程吗？有没有多进程？"></a>(2)、一个app运行时只有一个进程吗？有没有多进程？</h6><p>一个正在运行的程序可以看做一个进程。（例如：正在运行的QQ就是一个进程），进程拥有独立运行所需的全部资源。</p><p><a href="https://blog.csdn.net/kuangdacaikuang/article/details/78891379" target="_blank" rel="noopener">iOS (APP)进程间8中常用通信方式总结</a></p><h6 id="3-、什么时候用进程？什么时候用线程？"><a href="#3-、什么时候用进程？什么时候用线程？" class="headerlink" title="(3)、什么时候用进程？什么时候用线程？"></a>(3)、什么时候用进程？什么时候用线程？</h6><p>进程与线程的选择取决以下几点：</p><blockquote><p>1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。</p></blockquote><blockquote><p>2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应</p></blockquote><blockquote><p>3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；</p></blockquote><blockquote><p>4、并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求；</p></blockquote><blockquote><p>5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。</p></blockquote><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/4%E7%BA%BF%E7%A8%8B-%E2%91%A1%E9%98%9F%E5%88%97%E4%B8%8E%E4%BB%BB%E5%8A%A1%E6%88%96%E7%BA%BF%E7%A8%8B/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A0%E7%BA%BF%E7%A8%8B/4%E7%BA%BF%E7%A8%8B-%E2%91%A1%E9%98%9F%E5%88%97%E4%B8%8E%E4%BB%BB%E5%8A%A1%E6%88%96%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-线程与网络-①队列与任务或线程"><a href="#必备知识架构-线程与网络-①队列与任务或线程" class="headerlink" title="必备知识架构-线程与网络-①队列与任务或线程"></a>必备知识架构-线程与网络-①队列与任务或线程</h1><p>[toc]</p><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><ul><li><a href="#队列与执行">五、队列与执行</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;1、死锁探究：GCD死锁及报错提示(EXC_BAD_INSTRUCTION)</span><br><span class="line">&gt;(1)、死锁举例：通过串行队列里的任务，往这个串行队列里添加同步任务，会造成死锁</span><br><span class="line">&gt;(2)、死锁结论：往串行队列里添加的同步任务不能卡住该串行队列，否则会造成死锁(这句话非常重要)</span><br><span class="line">&gt;(3)、死锁原因分析</span><br><span class="line">&gt;</span><br><span class="line">&gt;2、主队列中的死锁：在主队列开启同步任务，一定为什么会阻塞线程？</span><br><span class="line">&gt;</span><br><span class="line">&gt;3、iOS多线程中，队列和执行的排列组合结果分析</span><br><span class="line">&gt;(1)、队列的类型</span><br><span class="line">&gt;(2)、四个比较容易混淆的术语：同步、异步、并发、串行</span><br><span class="line">&gt;(3)、队列和线程的关系</span><br><span class="line">&gt;(4)、自己延伸的问题：一个队列同时存在同步任务和异步任务？</span><br><span class="line">&gt;</span><br><span class="line">&gt;4、并发是并发队列，并行又是什么鬼？？？</span><br><span class="line">&gt;(1)、多个处理器和多核处理器的区别</span><br><span class="line">&gt;(2)、并发和并行的区别</span><br><span class="line">&gt;</span><br><span class="line">&gt;5、进程和线程的区别</span><br><span class="line">&gt;(1)、进程和线程的区别</span><br><span class="line">&gt;(2)、一个app运行时只有一个进程吗？有没有多进程？</span><br><span class="line">&gt;(3)、什么时候用进程？什么时候用线程？</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、队列与任务执行"><a href="#五、队列与任务执行" class="headerlink" title="五、队列与任务执行"></a>五、队列与任务执行</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><h3 id="1、队列的类型（并发队列（Concurrent-Dispatch-Queue）-amp-串行队列（Serial-Dispatch-Queue））"><a href="#1、队列的类型（并发队列（Concurrent-Dispatch-Queue）-amp-串行队列（Serial-Dispatch-Queue））" class="headerlink" title="1、队列的类型（并发队列（Concurrent Dispatch Queue）&amp; 串行队列（Serial Dispatch Queue））"></a>1、队列的类型（并发队列（Concurrent Dispatch Queue）&amp; 串行队列（Serial Dispatch Queue））</h3><p>GCD的队列可以分为2大类型：并发队列和串行队列。</p><h4 id="（1）并发队列（Concurrent-Dispatch-Queue）"><a href="#（1）并发队列（Concurrent-Dispatch-Queue）" class="headerlink" title="（1）并发队列（Concurrent Dispatch Queue）"></a>（1）并发队列（Concurrent Dispatch Queue）</h4><blockquote><p>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）并发功能只有在异步（dispatch_async）函数下才有效<br><img src="http://images.cnitblog.com/i/450136/201406/242239575804246.png" alt="并发队列"></p></blockquote><p>####（2）串行队列（Serial Dispatch Queue）</p><blockquote><p>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）<br><img src="http://images.cnitblog.com/i/450136/201406/242240281274213.png" alt="串行队列"></p></blockquote><p> 问：并发是并发队列，并行又是什么鬼？？？</p><p>答案：下文会详细介绍。</p><h3 id="2、队列是用来干嘛的？说一说【队列与任务-】或【队列与线程】的关系？（重要）"><a href="#2、队列是用来干嘛的？说一说【队列与任务-】或【队列与线程】的关系？（重要）" class="headerlink" title="2、队列是用来干嘛的？说一说【队列与任务 】或【队列与线程】的关系？（重要）"></a>2、队列是用来干嘛的？说一说【队列与任务 】或【队列与线程】的关系？（重要）</h3><p>答：</p><blockquote><p><strong>1、队列是用来添加任务/保存以及管理任务的，它只是负责任务的调度(是按串行队列还是按并发队列调度)，而不负责任务的执行</strong><br><strong>2、任务是添加到队列里的，可以添加同步任务或者异步任务。</strong></p><p>往队列里面添加任务，<br>①如果是添加异步任务，则会开启新的线程工作，开启的线程数根据队列类型决定。串行只开一条，并行开多条。<br>②如果是添加同步任务，会在当前线程内工作，不会创建新的线程。</p><p><strong>3、对队列所添加的任务是在线程中执行的/由线程负责进行执行，至于在什么线程根据是同步任务还是异步任务，以及当前是什么队列共同决定。</strong></p><p>（所以不管是将同步任务添加到串行队列还是并行队列，因为同步任务都不会创建新线程。所以并行同步队列和串行同步队列其实是一样的，它们都不会创建新的线程而且会是顺序执行）</p><p><strong>4、补充：在一个线程内可能有多个队列。</strong></p></blockquote><h4 id="2-1、理解队列是用来添加任务-保存以及管理任务的，它只是负责任务的调度，而不负责任务的执行的代码"><a href="#2-1、理解队列是用来添加任务-保存以及管理任务的，它只是负责任务的调度，而不负责任务的执行的代码" class="headerlink" title="2.1、理解队列是用来添加任务/保存以及管理任务的，它只是负责任务的调度，而不负责任务的执行的代码"></a>2.1、理解队列是用来添加任务/保存以及管理任务的，它只是负责任务的调度，而不负责任务的执行的代码</h4><p>看以下代码，我们通过它来方便我们理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//  NSOperationQueueCJHelper.m</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  创建队列</span><br><span class="line"> *</span><br><span class="line"> *  @param operations    队列的操作数组</span><br><span class="line"> *  @param lastOperation 队列的最后一条(最后一条，会等到前面都结束后才会结束)</span><br><span class="line"> *</span><br><span class="line"> *  return 队列</span><br><span class="line"> */</span><br><span class="line">+ (NSOperationQueue *)createOperationQueueWithOperations:(NSArray&lt;NSOperation *&gt; *)operations lastOperation:(NSOperation *)lastOperation &#123;</span><br><span class="line">    </span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue.name = @&quot;this is a queue&quot;;</span><br><span class="line">    </span><br><span class="line">    for (NSBlockOperation *operation in operations) &#123;</span><br><span class="line">        [queue addOperation:operation];</span><br><span class="line">        </span><br><span class="line">        [lastOperation addDependency:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:lastOperation];</span><br><span class="line">    </span><br><span class="line">    return queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">NSOperationQueue *operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self</span><br><span class="line">selector:@selector(myTask) object:nil];</span><br><span class="line">[operationQueue addOperation:operation];</span><br></pre></td></tr></table></figure><p>附：队列的取消、暂停、恢复<br>取消队列的所有操作使用NSOperationQueue的 <code>- (void)cancelAllOperations;</code></p><p>也可以调用NSOperation的- (void)cancel方法取消单个操作</p><p>暂停和恢复队列</p><pre><code>- (void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列</code></pre><h4 id="2-2、iOS主线程、主队列-串行队列-、全局队列"><a href="#2-2、iOS主线程、主队列-串行队列-、全局队列" class="headerlink" title="2.2、iOS主线程、主队列(串行队列)、全局队列"></a>2.2、iOS主线程、主队列(串行队列)、全局队列</h4><p><a href="https://blog.csdn.net/syzd451529064/article/details/100039633" target="_blank" rel="noopener">iOS 主队列 全局队列</a></p><p><strong>主队列是系统为我们创建的串行队列</strong>，而且每个APP只有一个主队列，负责调度处理APP的唯一主线程的UI事件。</p><p>注意：<strong>主队列没有办法开辟新的线程。所以，在主队列下的任务不管是异步任务还是同步任务都不会开辟线程，任务只会在主线程顺序执行。</strong></p><p>主队列异步任务：先将任务放在主队列中，但是不是马上执行，等到主队列中的其它所有除我们使用代码添加到主队列的任务的任务都执行完毕之后才会执行我们使用代码添加的任务。</p><p>主队列同步任务：容易阻塞主线程，所以不要这样写。原因：我们自己代码任务需要马上执行，但是主线程正在执行代码任务的方法体，因此代码任务就必须等待，而主线程又在等待代码任务的完成好去完成下面的任务，因此就形成了相互等待。整个主线程就被阻塞了。</p><p>全局队列：本质是一个并发队列，由系统提供，方便编程，可以不用创建就直接使用。</p><h4 id="2-3、插入问：NSOperationQueue是什么队列？"><a href="#2-3、插入问：NSOperationQueue是什么队列？" class="headerlink" title="2.3、插入问：NSOperationQueue是什么队列？"></a>2.3、插入问：NSOperationQueue是什么队列？</h4><p>答：NSOperationQueue是操作队列。结合实际才知道它是并发队列，还是串行队列。</p><p><em>①<code>[NSOperationQueue mainQueue]</code>是主队列，和GCD中的主队列一样，是串行队列</em>。</p><p><em>②<code>[[NSOperationQueue alloc]init]</code>是非主队列，非常特殊(同时具备并发和串行的功能)。默认情况下，非主队列是并发队列。</em></p><p>NSOperationQueue *operationQueue = [[NSOperationQueue alloc] init];<br>当operationQueue.maxConcurrentOperationCount &gt; 1，那么operationQueue就是并发队列；<br>当operationQueue.maxConcurrentOperationCount == 1，那么operationQueue就是串行队列。</p><h3 id="3、总结四个比较容易混淆的术语：并发队列、串行队列、同步任务、异步任务"><a href="#3、总结四个比较容易混淆的术语：并发队列、串行队列、同步任务、异步任务" class="headerlink" title="3、总结四个比较容易混淆的术语：并发队列、串行队列、同步任务、异步任务"></a>3、总结四个比较容易混淆的术语：并发队列、串行队列、同步任务、异步任务</h3><h4 id="3-1、并发和串行决定了任务的执行方式-队列-。"><a href="#3-1、并发和串行决定了任务的执行方式-队列-。" class="headerlink" title="3.1、并发和串行决定了任务的执行方式(队列)。"></a>3.1、并发和串行决定了任务的执行方式(队列)。</h4><blockquote><p>并发队列：多个任务并发（同时）执行，指<strong>一个处理器</strong>同时处理多个任务<br>串行队列：一个任务执行完毕后，再执行下一个任务</p></blockquote><h4 id="3-2、同步和异步决定了要不要开启新的线程-线程"><a href="#3-2、同步和异步决定了要不要开启新的线程-线程" class="headerlink" title="3.2、同步和异步决定了要不要开启新的线程(线程)"></a>3.2、同步和异步决定了要不要开启新的线程(线程)</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;同步：在当前线程中执行任务，不具备开启新线程的能力</span><br><span class="line">&gt;异步：在新的线程中执行任务，具备开启新线程的能力</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="4、并发是并发队列，并行又是什么鬼-多核处理器同时执行任务-？？？"><a href="#4、并发是并发队列，并行又是什么鬼-多核处理器同时执行任务-？？？" class="headerlink" title="4、并发是并发队列，并行又是什么鬼(多核处理器同时执行任务)？？？"></a>4、并发是并发队列，并行又是什么鬼(多核处理器同时执行任务)？？？</h3><h6 id="1-、多个处理器和多核处理器的区别"><a href="#1-、多个处理器和多核处理器的区别" class="headerlink" title="(1)、多个处理器和多核处理器的区别"></a>(1)、多个处理器和多核处理器的区别</h6><blockquote><p>多个处理器：多个单核处理器，就是说电脑和处理器有多个，但是这个电脑的处理器是单核的；</p></blockquote><p>多核处理器：单个多核处理器，也就是说电脑有一个处理器，但是这个处理器是多核的；</p><blockquote></blockquote><p>附：在生活中，我们的电脑上常见的处理器都是单处理器，但是这个处理器是多核的，一般是四核，有些需要玩高级游戏的，可能还是八核的处理器。</p><blockquote></blockquote><p>详情查看：<a href="https://blog.csdn.net/kevin_yzlong/article/details/70196168" target="_blank" rel="noopener">多个处理器和多核处理器的区别</a></p><h6 id="2-、并发和并行的区别"><a href="#2-、并发和并行的区别" class="headerlink" title="(2)、并发和并行的区别"></a>(2)、并发和并行的区别</h6><p>并发(concurrency)是指一个处理器同时处理多个任务。即<strong>并发指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行</strong>。这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。</p><blockquote><p><img src="/iOS/3必备知识架构/4①线程/4线程-②队列与任务或线程/4线程-①线程/进程线程/并发(concurrency" alt="并发(concurrency)">.jpg)</p></blockquote><p>并行(parallel)是指多个处理器或者是多核的处理器同时处理多个不同的任务。即并行是指在同一时刻，有多条指令在多个处理器上同时执行。</p><blockquote><p><img src="/iOS/3必备知识架构/4①线程/4线程-②队列与任务或线程/4线程-①线程/进程线程/并行(parallel" alt="并行(parallel)">.jpg)</p></blockquote><p>个人理解：是否可以理解为在出现多核处理器或者只有一个处理器的时候，我们那时候就只还有并发的概念。</p><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为<strong>并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）</strong>。</p><h3 id="5、iOS多线程中，队列和执行的排列组合结果分析"><a href="#5、iOS多线程中，队列和执行的排列组合结果分析" class="headerlink" title="5、iOS多线程中，队列和执行的排列组合结果分析"></a>5、iOS多线程中，队列和执行的排列组合结果分析</h3><ul><li><a href="http://www.cnblogs.com/dsxniubility/p/4296937.html" target="_blank" rel="noopener">iOS多线程中，队列和执行的排列组合结果分析</a></li></ul><p>该文章非常重要，且主要总结点有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 开不开线程，取决于执行任务的函数，同步不开，异步开。</span><br><span class="line">2. 开几条线程，取决于队列，串行开一条，并发可以开多条(即并发队列里有异步任务，则可以开多条，如果都只有同步任务，那由于同步任务并不会开新线程，所以此时也就不会开新线程)</span><br><span class="line">3. 主队列：专门用来在主线程上调度任务的&quot;队列&quot;，主队列不能在其他线程中调度任务！</span><br><span class="line">4. 如果主线程上当前正在有执行的任务，主队列暂时不会调度任务的执行！主队列同步任务，会造成死锁。原因是循环等待</span><br><span class="line">5. 同步任务可以队列调度多个异步任务前，指定一个同步任务，让所有的异步任务，等待同步任务执行完成，这是依赖关系。</span><br><span class="line">6. 全局队列：并发，能够调度多个线程，执行效率高，但是相对费电。 串行队列效率较低，省电省流量，或者是任务之间需要依赖也可以使用串行队列。</span><br><span class="line">7. 也可以通过判断当前用户的网络环境来决定开的线程数。WIFI下6条，3G/4G下2～3条。</span><br></pre></td></tr></table></figure><h3 id="6、代码：使用GCD为队列添加任务"><a href="#6、代码：使用GCD为队列添加任务" class="headerlink" title="6、代码：使用GCD为队列添加任务"></a>6、代码：使用GCD为队列添加任务</h3><p>实例1：并发队列添加异步任务/用异步函数往并发队列中添加任务的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">  &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    //1.获得全局的并发队列</span><br><span class="line">   dispatch_queue_t queue =  dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line"></span><br><span class="line">    //2.添加任务到队列中，就可以执行任务</span><br><span class="line">    //异步函数：具备开启新线程的能力</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">  ​      NSLog(@&quot;下载图片1----%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">  ​      NSLog(@&quot;下载图片2----%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">  ​      NSLog(@&quot;下载图片2----%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">  //打印主线程</span><br><span class="line">    NSLog(@&quot;主线程----%@&quot;,[NSThread mainThread]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">上述方法说明.GCD中有2个用来执行任务的函数</span><br></pre></td></tr></table></figure><p>说明：<code>把右边的参数（任务）提交给左边的参数（队列）进行执行</code>。</p><p>（1）用同步的方式执行任务 dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</p><p>（2）用异步的方式执行任务 dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</p><p></p><p id="GCD"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><h6 id="2、以下两种GCD队列创建有什么不同？"><a href="#2、以下两种GCD队列创建有什么不同？" class="headerlink" title="2、以下两种GCD队列创建有什么不同？"></a>2、以下两种GCD队列创建有什么不同？</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;MyQueue&quot;,DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue =dispatch_queue_create(@“MyQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">//生成一个串行队列，队列中的block按照先进先出（FIFO）的顺序去执行，实际上为单线程执行。第一个参数是队列的名称，在调试程序时会非常有用，所有尽量不要重名了。</span><br><span class="line"></span><br><span class="line">//生成一个并发执行队列，block被分发到多个线程去执行</span><br></pre></td></tr></table></figure><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/3%E8%A7%86%E5%9B%BE/3%E8%A7%86%E5%9B%BE-%E2%91%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/3%E8%A7%86%E5%9B%BE/3%E8%A7%86%E5%9B%BE-%E2%91%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-视图-②生命周期"><a href="#必备知识架构-视图-②生命周期" class="headerlink" title="必备知识架构-视图-②生命周期"></a>必备知识架构-视图-②生命周期</h1><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><p></p><p id="目录"></p><p></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#生命周期">五、控制器View的生命周期</a></li></ul><ul><li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p></li><li><p><a href="#END">END</a></p></li></ul><p></p><p id="生命周期"></p><p></p><h2 id="五、控制器View的生命周期"><a href="#五、控制器View的生命周期" class="headerlink" title="五、控制器View的生命周期"></a>五、控制器View的生命周期</h2><p><a href="#目录">&lt; 返回目录</a></p><p>更详细的生命周期请查看：<a href="https://www.jianshu.com/p/d60b388b19f5" target="_blank" rel="noopener">iOS程序执行顺序和UIViewController 的生命周期(整理)</a></p><h5 id="题目1：控制器View的生命周期及相关函数是什么-你在开发中是如何用的"><a href="#题目1：控制器View的生命周期及相关函数是什么-你在开发中是如何用的" class="headerlink" title="题目1：控制器View的生命周期及相关函数是什么?你在开发中是如何用的?"></a>题目1：控制器View的生命周期及相关函数是什么?你在开发中是如何用的?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.在视图显示之前调用viewWillAppear;该函数可以调用多次; </span><br><span class="line">2.视图显示完毕,调用viewDidAppear;</span><br><span class="line">3.在视图消失之前调用viewWillDisAppear;该函数可以调用多次(如需要);</span><br><span class="line">4.在布局变化前后,调用viewWill/DidLayoutSubviews处理相关信息;</span><br></pre></td></tr></table></figure><p>viewWillAppear——-》viewWillLayoutSubviews—–》viewDidLayoutSubviews———–》</p><p>viewDidAppear</p><h5 id="题目2：loadView-viewDidLoad-viewDidUnLoad-分别是在什么时候被调用的"><a href="#题目2：loadView-viewDidLoad-viewDidUnLoad-分别是在什么时候被调用的" class="headerlink" title="题目2：loadView, viewDidLoad, viewDidUnLoad,分别是在什么时候被调用的."></a>题目2：loadView, viewDidLoad, viewDidUnLoad,分别是在什么时候被调用的.</h5><p><a href="http://blog.csdn.net/w_sx_/article/details/39431205" target="_blank" rel="noopener">loadView, viewDidLoad, viewDidUnLoad,分别是在什么时候被调用的.</a></p><h4 id="3、layoutSubviews布局与drawRect重绘"><a href="#3、layoutSubviews布局与drawRect重绘" class="headerlink" title="3、layoutSubviews布局与drawRect重绘"></a>3、layoutSubviews布局与drawRect重绘</h4><h6 id="1-、layoutSubviews布局"><a href="#1-、layoutSubviews布局" class="headerlink" title="(1)、layoutSubviews布局"></a>(1)、layoutSubviews布局</h6><p>layoutSubviews是对subviews重新布局；<br>比如，我们想更新子视图的位置的时候，可以通过调用layoutSubviews方法，即可以实现对子视图重新布局。但实际上<strong>一般我们都是不要直接手动调用layoutSubviews方法</strong>。因为有操作时候，系统会自动调用layoutSubviews。</p><blockquote><p>那我们进行哪些操作会触发layoutSubviews方法呢？答如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先注意：</span><br><span class="line">①init初始化不会触发layoutSubviews，</span><br><span class="line">但是使用initWithFrame进行初始化时，当rect的值不为CGRectZero时，会触发layoutSubviews。</span><br><span class="line">②、直接调用setLayoutSubviews。</span><br><span class="line">③、addSubview的时候一般都会触发layoutSubviews。(最常见) 注：但当本View的frame为0时,addSubView也不会调用layoutSubViews。</span><br><span class="line">④、当view的frame发生改变的时候触发layoutSubviews。</span><br><span class="line">⑤、滑动UIScrollView的时候触发layoutSubviews。</span><br><span class="line">⑥、旋转Screen会触发父UIView上的layoutSubviews事件。</span><br><span class="line">⑦、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。</span><br></pre></td></tr></table></figure><p>所以我们可以看出当视图约束/frame变化时候，会触发layoutSubviews，进行重新布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">附：</span><br><span class="line">如果你还是想强制更新布局，你可以调用setNeedsLayout方法；</span><br><span class="line">如果你想立即显示你的views，你需要调用layoutIfNeed方法。</span><br><span class="line"></span><br><span class="line">①、- (void)layoutSubviews; </span><br><span class="line">这个方法，默认没有做任何事情，需要子类进行重写；</span><br><span class="line">②、- (void)setNeedsLayout; </span><br><span class="line">标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用；</span><br><span class="line">③、- (void)layoutIfNeeded; </span><br><span class="line">如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）。</span><br></pre></td></tr></table></figure><p>其他参考文章:<a href="https://blog.csdn.net/u011146511/article/details/51234907" target="_blank" rel="noopener">iOS layoutSubview的方法总结／重绘drawRect</a></p><p>什么时候用layoutSubviews?</p><blockquote><p>答：仅仅在以下情况下:自动布局达不到想要效果时你才有必要重写这个方法.可以直接设置subviews的尺寸.</p></blockquote><h6 id="2-、drawRect重绘"><a href="#2-、drawRect重绘" class="headerlink" title="(2)、drawRect重绘"></a>(2)、drawRect重绘</h6><p>重绘作用：重写该方法以实现自定义的绘制内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-drawRect:(CGRect)rect方法：重写此方法，执行重绘任务</span><br><span class="line">-setNeedsDisplay方法：标记为需要重绘，异步调用drawRect</span><br><span class="line">-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘</span><br></pre></td></tr></table></figure><h6 id="3-、updateConstraints更新约束、layoutSubviews重新布局与drawRect重绘的调用顺序"><a href="#3-、updateConstraints更新约束、layoutSubviews重新布局与drawRect重绘的调用顺序" class="headerlink" title="(3)、updateConstraints更新约束、layoutSubviews重新布局与drawRect重绘的调用顺序"></a>(3)、updateConstraints更新约束、layoutSubviews重新布局与drawRect重绘的调用顺序</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layoutSubviews是对subviews重新布局；</span><br><span class="line">drawRect重绘；</span><br><span class="line">layoutSubviews方法调用先于drawRect，也就是先布局子视图，在重绘。</span><br></pre></td></tr></table></figure><p>所以，在调用updateConstraintsIfNeeded可能会立即执行updateConstraints，然后调用layoutSubviews。因为按照Autolayout布局的步骤，应该是先更新约束然后更新布局的。</p><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/3%E8%A7%86%E5%9B%BE/3%E8%A7%86%E5%9B%BE-%E2%91%A2%E8%B7%B3%E8%BD%AC/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/3%E8%A7%86%E5%9B%BE/3%E8%A7%86%E5%9B%BE-%E2%91%A2%E8%B7%B3%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-视图-③跳转"><a href="#必备知识架构-视图-③跳转" class="headerlink" title="必备知识架构-视图-③跳转"></a>必备知识架构-视图-③跳转</h1><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><p></p><p id="目录"></p><p></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#视图的跳转">一、视图的跳转</a></li></ul><ul><li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p></li><li><p><a href="#END">END</a></p></li></ul><p></p><p id="视图的跳转"></p><p></p><h2 id="一、视图的跳转"><a href="#一、视图的跳转" class="headerlink" title="一、视图的跳转"></a>一、视图的跳转</h2><p><a href="#目录">&lt; 返回目录</a></p><h4 id="1、获取当前显示的视图控制器ViewController"><a href="#1、获取当前显示的视图控制器ViewController" class="headerlink" title="1、获取当前显示的视图控制器ViewController"></a>1、获取当前显示的视图控制器ViewController</h4><h4 id="2、如何在多次presentViewController后直接返回到指定层"><a href="#2、如何在多次presentViewController后直接返回到指定层" class="headerlink" title="2、如何在多次presentViewController后直接返回到指定层"></a>2、如何在多次presentViewController后直接返回到指定层</h4><p>场景：如果多个控制器都通过 present 的方式跳转呢？比如从A跳转到B，从B跳转到C，从C跳转到D，如何由D直接返回到A呢？</p><p>答：可以通过 presentingViewController 一直找到A控制器，然后调用A控制器的 dismissViewControllerAnimated 方法。方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *controller = self;</span><br><span class="line">while(controller.presentingViewController != nil)&#123;</span><br><span class="line">    controller = controller.presentingViewController;</span><br><span class="line">&#125;</span><br><span class="line">[controller dismissViewControllerAnimated:YES completion:nil];</span><br></pre></td></tr></table></figure><p>PS：如果不是想直接返回到A控制器，比如想回到B控制器，while循环的终止条件可以通过控制器的类来判断。</p><h4 id="3、presentedViewController-与-presentingViewController"><a href="#3、presentedViewController-与-presentingViewController" class="headerlink" title="3、presentedViewController 与  presentingViewController"></a>3、presentedViewController 与  presentingViewController</h4><blockquote><p>假设从A控制器通过present的方式跳转到了B控制器，那么 A.presentedViewController 就是B控制器；<br>B.presentingViewController 就是A控制器。</p></blockquote><h4 id="4、如何通过视图-view-获取该视图所在的控制器-viewController"><a href="#4、如何通过视图-view-获取该视图所在的控制器-viewController" class="headerlink" title="4、如何通过视图(view)获取该视图所在的控制器(viewController)"></a>4、如何通过视图(view)获取该视图所在的控制器(viewController)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (nullable UIViewController *)findBelongViewControllerForView:(UIView *)view &#123;</span><br><span class="line">    UIResponder *responder = view;</span><br><span class="line">    while ((responder = [responder nextResponder]))</span><br><span class="line">        if ([responder isKindOfClass: [UIViewController class]]) &#123;</span><br><span class="line">            return (UIViewController *)responder;</span><br><span class="line">        &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/3%E8%A7%86%E5%9B%BE/3%E8%A7%86%E5%9B%BE-%E2%91%A3%E5%9B%BE%E7%89%87/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/3%E8%A7%86%E5%9B%BE/3%E8%A7%86%E5%9B%BE-%E2%91%A3%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-视图-④图片"><a href="#必备知识架构-视图-④图片" class="headerlink" title="必备知识架构-视图-④图片"></a>必备知识架构-视图-④图片</h1><ul><li><a href="https://www.jianshu.com/p/7c44c3b2a056" target="_blank" rel="noopener">2019 iOS面试题—UI相关：事件传递，图像显示，性能优化，离屏渲染</a></li></ul><ul><li><p><a href="https://www.cnblogs.com/sunyanyan/p/5417792.html" target="_blank" rel="noopener">SDWebImageDecoder</a></p><blockquote><p>由于UIImage的imageWithData函数是每次画图的时候才将Data解压成ARGB的图像，</p><p>所以在每次画图的时候，会有一个解压操作，这样效率很低。为了提高效率，通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了。</p></blockquote></li><li><p><a href="https://www.jianshu.com/p/e00854ab5567" target="_blank" rel="noopener">有关请求相同地址图片的下载问题(SDWebIMage底层原理的实现)</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/3%E8%A7%86%E5%9B%BE/3%E8%A7%86%E5%9B%BE-%E2%91%A1%E5%B8%83%E5%B1%80/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/3%E8%A7%86%E5%9B%BE/3%E8%A7%86%E5%9B%BE-%E2%91%A1%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-视图-②布局"><a href="#必备知识架构-视图-②布局" class="headerlink" title="必备知识架构-视图-②布局"></a>必备知识架构-视图-②布局</h1><p>[toc]</p><h2 id="一、Intrinsic-Content-Size-Content-Hugging-Priority和Content-Compression-Resistance-Priority"><a href="#一、Intrinsic-Content-Size-Content-Hugging-Priority和Content-Compression-Resistance-Priority" class="headerlink" title="一、Intrinsic Content Size,Content Hugging Priority和Content Compression Resistance Priority"></a>一、Intrinsic Content Size,Content Hugging Priority和Content Compression Resistance Priority</h2><p>看一下下面的例子，看给出的例子约束是否完整？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UILabel *label = [[UILabel alloc] init];</span><br><span class="line"> label.font = [UIFont systemFontOfSize:15];</span><br><span class="line"> label.text = @&quot;Hello&quot;;</span><br><span class="line"> [self.view addSubview:label];</span><br><span class="line"> [label mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">     make.left.equalTo(self.view.mas_left).offset(16);</span><br><span class="line">     make.top.equalTo(self.view.mas_top).offset(16);</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure><p>这里只定义了两个约束，left 和 top，只够计算出frame的originX和orginY，没有width和height。那么是不是属于不完整的约束呢？其实在这里给出的约束已经是完整的了。因为对于UILabel这个控件而言 ，只要通过其font和text系统就可以计算出Label该有的长度和宽度。这里的长度和宽度就是UILabel的intrinsic content size（固有属性）。</p><p>Intrinsic Content Size, 通俗来讲，就是控件(UIButton,UILabel,UIImageView)能根据它们的内容(content)计算自己的大小(Size）</p><p>开发中用到的一些控件或视图，本身就自带大小，比如UIButton控件，设置完title后就能知道这个UIButton是文字的大小再加上两个固定的button margin。<br> 像这种控件或视图本身就带有的高度、宽度，就叫做intrinsic content size（固定内容尺寸）。</p><h3 id="2、浅谈-iOS-AutoLayout-中-Label-的抗拉伸和抗压缩"><a href="#2、浅谈-iOS-AutoLayout-中-Label-的抗拉伸和抗压缩" class="headerlink" title="2、浅谈 iOS AutoLayout 中 Label 的抗拉伸和抗压缩"></a>2、浅谈 iOS AutoLayout 中 Label 的抗拉伸和抗压缩</h3><ul><li><a href="https://www.jianshu.com/p/8e68b82b471a" target="_blank" rel="noopener">浅谈 iOS AutoLayout 中 Label 的抗拉伸和抗压缩</a></li></ul><blockquote><p>在 Autolayout 优先级的范围是 1 ~ 1000，创建一个约束，默认的优先级是最高的 1000。</p><p>Content Hugging Priority:<br>该优先级表示一个控件抗被拉伸的优先级。优先级越高，越不容易被拉伸(即越容易保持原状)，默认是251。</p><p>Content Compression Resistance Priority:<br>该优先级表示一个控件抗压缩的优先级。优先级越高，越不容易被压缩(即越容易保持原状)，默认是750。</p></blockquote><p>使用场景：</p><p>当一个视图上有多个 <code>intrinsic content size</code> 的子控件，并且子控件可能会超出父视图的区域时，此属性可控制哪些视图被内容被优先压缩，使其不超出父视图区域。</p><p>场景举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[yellowLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">  make.center.equalTo(self.view);</span><br><span class="line">  make.left.equalTo(self.view).offset(100);</span><br><span class="line">  make.right.equalTo(self.view).offset(-100);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>当yellowLable的宽度最多为screenWidth-200。</p><p>则我们想让lable对左右两边的约束性没那么高，可以设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[yellowLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">  make.center.equalTo(self.view);</span><br><span class="line">  make.left.equalTo(self.view).offset(100).priority(250);</span><br><span class="line">  make.right.equalTo(self.view).offset(-100).priority(250);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>给出一个比较常见的需求：</p><p>在同一行中显示标题和时间，时间必须显示完全，标题如果太长就截取可显示的部分，剩余的用…表示。</p><p><img src="/iOS/3必备知识架构/3视图/3视图-②布局/intrinsic content size.png" alt="intrinsic content size"></p><p>目标：我们想让绿色的时间显示全，则应该要压缩前面的titleLabel。也就是要降低titleLabel的抗压缩。</p><p>即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (b) &#123;</span><br><span class="line">        [timeLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line">        // 或</span><br><span class="line">        //[titleLabel setContentHuggingPriority:UILayoutPriorityFittingSizeLevel forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>UILayoutPriorityRequired：1000</p><p>UILayoutPriorityDefaultHigh：750</p><p>UILayoutPriorityDefaultLow：250</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//在同一行中显示标题和时间，时间必须显示完全，标题如果太长就截取可显示的部分，剩余的用…表示。</span><br><span class="line">- (UIView *)contentViewWith:(BOOL)b &#123;</span><br><span class="line">    UIView *contentView = [[UIView alloc] init];</span><br><span class="line">    contentView.backgroundColor = [UIColor lightGrayColor];</span><br><span class="line">    </span><br><span class="line">    UILabel *titleLabel = [[UILabel alloc] init];</span><br><span class="line">    titleLabel.backgroundColor = [UIColor redColor];</span><br><span class="line">    titleLabel.text = @&quot;Each of these constraints can have its own priority. By default, &quot;;</span><br><span class="line">    titleLabel.font = [UIFont systemFontOfSize:17];</span><br><span class="line">    [contentView addSubview:titleLabel];</span><br><span class="line">    [titleLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.top.equalTo(contentView.mas_top);</span><br><span class="line">        make.left.equalTo(contentView.mas_left).offset(16);</span><br><span class="line">    &#125;];</span><br><span class="line">        </span><br><span class="line">    UILabel *timeLabel = [[UILabel alloc] init];</span><br><span class="line">    timeLabel.backgroundColor = [UIColor greenColor];</span><br><span class="line">    timeLabel.text = @&quot;2017/03/12 18:20:22&quot;;</span><br><span class="line">    timeLabel.font = [UIFont systemFontOfSize:17];</span><br><span class="line">    [contentView addSubview:timeLabel];</span><br><span class="line">    [timeLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.top.equalTo(titleLabel.mas_top);</span><br><span class="line">        make.left.equalTo(titleLabel.mas_right).offset(8);</span><br><span class="line">        make.right.lessThanOrEqualTo(contentView.mas_right).offset(-8);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    if (b) &#123;</span><br><span class="line">        [timeLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line">        // 或</span><br><span class="line">        //[titleLabel setContentHuggingPriority:UILayoutPriorityFittingSizeLevel forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return contentView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、iOS使用topLayoutGuide和bottomLayoutGuide"><a href="#二、iOS使用topLayoutGuide和bottomLayoutGuide" class="headerlink" title="二、iOS使用topLayoutGuide和bottomLayoutGuide"></a>二、iOS使用topLayoutGuide和bottomLayoutGuide</h2><p>参考文章：<a href="https://www.jianshu.com/p/0086d11d45b7" target="_blank" rel="noopener">iOS使用topLayoutGuide和bottomLayoutGuide</a></p><p>在iOS中，可以使用topLayoutGuide和bottomLayoutGuide来适配屏幕内容，它们是属于UIViewController的属性，配合masonry和SnapKit等约束工具，效果更好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UIView *bottomPayView = [[UIView alloc] init];</span><br><span class="line">bottomPayView.backgroundColor = [UIColor grayColor];</span><br><span class="line">[self.view addSubview:bottomPayView];</span><br><span class="line">[bottomPayView mas_makeConstraints:^(MASConstraintMaker *x) &#123;</span><br><span class="line">        x.height.equalTo(@45);</span><br><span class="line">        x.left.right.equalTo(self.view);</span><br><span class="line">        x.bottom.equalTo(self.mas_bottomLayoutGuide);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="三、UITableView自动计算cell高度并缓存，再也不用管高度啦"><a href="#三、UITableView自动计算cell高度并缓存，再也不用管高度啦" class="headerlink" title="三、UITableView自动计算cell高度并缓存，再也不用管高度啦"></a>三、UITableView自动计算cell高度并缓存，再也不用管高度啦</h2><p><a href="https://www.jianshu.com/p/64f0e1557562" target="_blank" rel="noopener">UITableView自动计算cell高度并缓存，再也不用管高度啦</a></p><p>用xib加约束和用masonry加代码约束都是可以的。注意约束一定要自上而下加好，让系统知道怎么去计算高度。</p><p>加好约束后，然后告诉tableView自己去适应高度就可以了。有两种写法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.rowHeight = <span class="built_in">UITableViewAutomaticDimension</span>;</span><br><span class="line"><span class="keyword">self</span>.tableView.estimatedRowHeight = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>或者直接写这个代理方法就可以了</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView estimatedHeightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个的意思就是告诉tableView，你需要自己适应高度，我不给你算啦哈哈哈。但是我们需要告诉它一个大概高度，例如上面的100，理论上这个是可以随便写的，并不影响显示结果，但是越接近真实高度越好。</p><h3 id="可能遇到的问题和解决办法"><a href="#可能遇到的问题和解决办法" class="headerlink" title="可能遇到的问题和解决办法"></a>可能遇到的问题和解决办法</h3><p><strong>1.高度不对</strong><br>有时候有可能运行出来后看到cell的高度显示的不对。这个问题是因为约束没有满足自上而下，从而系统不知道怎么去计算。解决办法就是去修改约束，直到满足为止。一定要好好理解约束啊！</p><p><strong>2.点击状态栏无法滚动到顶部</strong><br>我们知道，如果界面中有UIScrollView的话，点击状态栏会让其滚动到顶部，就像这样：</p><p>但是如果我们用了自动计算高度的方法，又调用了tableView的reloadData方法（例如我们的数据有分页的时候，加载完下一页的数据后会去刷新tableView）。这时候就会出现问题，点击状态栏就有几率不能精确滚动到顶部了：</p><p>解决这个问题的办法是去缓存cell的高度，代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *heightAtIndexPath;<span class="comment">//缓存高度所用字典</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - UITableViewDelegate</span></span><br><span class="line">-(<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView estimatedHeightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *height = [<span class="keyword">self</span>.heightAtIndexPath objectForKey:indexPath];</span><br><span class="line">    <span class="keyword">if</span>(height)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height.floatValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *height = @(cell.frame.size.height);</span><br><span class="line">    [<span class="keyword">self</span>.heightAtIndexPath setObject:height forKey:indexPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h2><h4 id="问题1：使用Masonry的时候进行updateConstraints没有效果"><a href="#问题1：使用Masonry的时候进行updateConstraints没有效果" class="headerlink" title="问题1：使用Masonry的时候进行updateConstraints没有效果"></a>问题1：使用Masonry的时候进行updateConstraints没有效果</h4><p>原因：使用updateConstraints更新的时候必须是makeConstraints里面设置过的约束。但如果只是这样还不行，还需要约束对象匹配才能成功。</p><p>问题详见：<a href="https://blog.csdn.net/wq5201314o/article/details/52184622" target="_blank" rel="noopener">使用Masonry的时候进行updateConstraints没有效果</a></p><h1 id="iOS11适配-Safe-Area"><a href="#iOS11适配-Safe-Area" class="headerlink" title="iOS11适配-Safe Area"></a>iOS11适配-Safe Area</h1><p><a href="https://blog.csdn.net/gaoqinghuadage/article/details/79961750" target="_blank" rel="noopener">iOS11适配-Safe Area</a></p><blockquote><p>在iOS 11，UIViewController中的UIView的topLayoutGuide和bottomLayoutGuide被替换成了新的安全区属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; @available(iOS 11.0, *)</span><br><span class="line">&gt; open var safeAreaInsets: UIEdgeInsets &#123; get &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; @available(iOS 11.0, *)</span><br><span class="line">&gt; open var safeAreaLayoutGuide: UILayoutGuide &#123; get &#125;12345</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>safeAreaInsets属性意味着屏幕可以被任何方向遮挡，并不只是上下，当iPhone X出现时，我们就明白了为什么我们需要对左右两边也进行缩进。</p></blockquote><p>Masonry动画</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/3%E8%A7%86%E5%9B%BE/3%E8%A7%86%E5%9B%BE-%E2%91%A0%E6%9C%AC%E8%B4%A8RunLoop/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/3%E8%A7%86%E5%9B%BE/3%E8%A7%86%E5%9B%BE-%E2%91%A0%E6%9C%AC%E8%B4%A8RunLoop/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-视图-①本质"><a href="#必备知识架构-视图-①本质" class="headerlink" title="必备知识架构-视图-①本质"></a>必备知识架构-视图-①本质</h1><p>[toc]</p><p></p><p id="RunLoop"></p><p></p><h2 id="四、RunLoop"><a href="#四、RunLoop" class="headerlink" title="四、RunLoop"></a>四、RunLoop</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote><h3 id="1、RunLoop概念"><a href="#1、RunLoop概念" class="headerlink" title="1、RunLoop概念"></a>1、RunLoop概念</h3><p>Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。一个run loop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。其内部就是do－while循环，这个循环内部不断地处理各种任务（比如Source，Timer，Observer）。使用run loop的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。</p><h3 id="2、RunLoop和线程的关系？"><a href="#2、RunLoop和线程的关系？" class="headerlink" title="2、RunLoop和线程的关系？"></a>2、RunLoop和线程的关系？</h3><p>run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程相关的基础框架的一部分，Cocoa和CoreFundation都提供了run loop对象方便配置和管理线程的run loop（以下都已Cocoa为例）。</p><p>每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。</p><p>①、主线程的run loop默认是启动的。</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了本文开始说的为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p></blockquote><p>②、对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</p><p>③、在任何一个Cocoa程序的线程中，都可以通过：<code>NSRunLoop *runloop = [NSRunLoop currentRunLoop];</code>来获取到当前线程的run loop。</p><h3 id="3、RunLoop相关各类关系"><a href="#3、RunLoop相关各类关系" class="headerlink" title="3、RunLoop相关各类关系"></a>3、RunLoop相关各类关系</h3><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef</span><br><span class="line">CFRunLoopModeRef</span><br><span class="line">CFRunLoopSourceRef</span><br><span class="line">CFRunLoopTimerRef</span><br><span class="line">CFRunLoopObserverRef</span><br></pre></td></tr></table></figure><p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系/RunLoop相关各类关系，如下图所示：</p><blockquote><p><img src="/iOS/3必备知识架构/3视图/3视图-①本质RunLoop/3视图-①本质/RunLoop相关各类关系.png" alt="RunLoop相关各类关系"><br>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p><p>RunLoop的内部逻辑<br><img src="/iOS/3必备知识架构/3视图/3视图-①本质RunLoop/3视图-①本质/RunLoop的内部逻辑.png" alt="RunLoop的内部逻辑"></p></blockquote><h4 id="3-1-CFRunLoopSourceRef"><a href="#3-1-CFRunLoopSourceRef" class="headerlink" title="3.1 CFRunLoopSourceRef"></a>3.1 CFRunLoopSourceRef</h4><p>Source有两个版本：Source0 和 Source1。</p><ul><li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li><li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li></ul><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p><p>在iOS 中，除了source1可以自己唤醒run loop之外，其他的事件都需要用户手动唤醒run loop才可以。</p><h5 id="3-1-附上题中button点击后，关于RunLoop的过程-此处略过对响应链的描述"><a href="#3-1-附上题中button点击后，关于RunLoop的过程-此处略过对响应链的描述" class="headerlink" title="3.1.附上题中button点击后，关于RunLoop的过程(此处略过对响应链的描述)"></a>3.1.附上题中button点击后，关于RunLoop的过程(此处略过对响应链的描述)</h5><blockquote><p>大概为：当一个硬件事件(触摸/锁屏/摇晃等)发生后，<br>①、首先由 IOKit.framework 生成一个 IOHIDEvent 事件，Source1 接收到系统事件，<em>RunLoop被唤醒</em>。<br>②、RunLoop<em>通知Observer，处理Timer和Source 0</em>。<br>③、<em>RunLoop处理Source 1，Source1 触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发</em>。<br>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。<br>④、Springboard接受touch event，并用source1 的 之后mach port 转发给App进程。<br>⑤、<em>RunLoop处理完毕进入睡眠，此前会释放旧的autorelease pool并新建一个autorelease pool。</em></p></blockquote><h4 id="3-2-CFRunLoopTimerRef"><a href="#3-2-CFRunLoopTimerRef" class="headerlink" title="3.2 CFRunLoopTimerRef"></a>3.2 CFRunLoopTimerRef</h4><p>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。<strong>当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调</strong>（NSTimer 其实就是 CFRunLoopTimerRef）。</p><h4 id="3-3-CFRunLoopObserverRef"><a href="#3-3-CFRunLoopObserverRef" class="headerlink" title="3.3 CFRunLoopObserverRef"></a>3.3 CFRunLoopObserverRef</h4><p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。</p><p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p><h3 id="4、RunLoop的应用"><a href="#4、RunLoop的应用" class="headerlink" title="4、RunLoop的应用"></a>4、RunLoop的应用</h3><p>最常见的为定时器 NSTimer</p><blockquote><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p></blockquote><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>讲到RunLoop，我们需明确一点。<strong>runloop会对timer有强引用，timer会对目标对象进行强引用</strong></p><p>其他详细参考以下文章：</p><ul><li><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></li><li><a href="https://www.cnblogs.com/jiangzzz/p/5619512.html" target="_blank" rel="noopener">iOS面试题之runloop</a></li></ul><h4 id="4-1、autoreleasepool-自动释放池"><a href="#4-1、autoreleasepool-自动释放池" class="headerlink" title="4.1、autoreleasepool 自动释放池"></a>4.1、autoreleasepool 自动释放池</h4><p>既然说到runloop，简单说下autoreleasepool自动释放池。runloop会默认创建autoreleasepool，在runloop睡眠前或者退出前会执行pop操作。线程池详情查看下面的内存管理中的介绍。</p><p>@autoreleasepool是自动释放池，让我们更自由的管理内存;所以我们下面说说内存管理。</p><h4 id="4-2、runloop、autorelease-pool以及线程之间的关系"><a href="#4-2、runloop、autorelease-pool以及线程之间的关系" class="headerlink" title="4.2、runloop、autorelease pool以及线程之间的关系"></a>4.2、runloop、autorelease pool以及线程之间的关系</h4><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/%E6%97%B6%E9%97%B4%E8%AE%A1%E6%97%B6%E5%99%A8%E7%AD%89/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/%E6%97%B6%E9%97%B4%E8%AE%A1%E6%97%B6%E5%99%A8%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h1 id="NSTimer、NSDate"><a href="#NSTimer、NSDate" class="headerlink" title="NSTimer、NSDate"></a>NSTimer、NSDate</h1><p>###iOS时间那点事<br><strong>经典看前必先看：<a href="http://my.oschina.net/yongbin45/blog/156181" target="_blank" rel="noopener">iOS时间那点事NSCalendar + NSDateComponents</a></strong><br><a href="http://blog.csdn.net/samrtian/article/details/37569705" target="_blank" rel="noopener"> iOS 时区日期处理及定时 (NSDate,NSCalendar,NSTimer,NSTimeZone)</a></p><h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><p><a href="http://my.oschina.net/u/2340880/blog/398598" target="_blank" rel="noopener">NSTimer 定时器用法总结</a></p><h5 id="自动加一秒-dateByAddingComponents和dateByAddingTimeInterval"><a href="#自动加一秒-dateByAddingComponents和dateByAddingTimeInterval" class="headerlink" title="自动加一秒(dateByAddingComponents和dateByAddingTimeInterval)"></a>自动加一秒(dateByAddingComponents和dateByAddingTimeInterval)</h5><p>参考：<a href="http://www.cnblogs.com/wayne23/archive/2013/03/25/2981009.html" target="_blank" rel="noopener">时间与日期处理</a><br>涉及知识点：<br><strong>NSDate的生成</strong><br>方法①通过<code>NSDateFormatter</code>的<code>dateFromString:</code>方法对dateString生成NSDate；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</span><br><span class="line">[dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</span><br><span class="line"></span><br><span class="line">NSString *dateString = @&quot;2016-08-15 22:55:03&quot;;</span><br><span class="line">NSDate *date = [dateFormatter dateFromString:dateString];</span><br></pre></td></tr></table></figure><p>方法②通过<code>NSCalendar</code>的<code>dateFromComponents:</code>方法对dateComponents生成NSDate;(dateComponents由分个字段生成)<br><code>[greCalendar dateFromComponents:dateComponents];</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    NSCalendar *greCalendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];</span><br><span class="line">    </span><br><span class="line">NSDateComponents *dateComponents = [[NSDateComponents alloc] init];</span><br><span class="line">[dateComponents setYear:2016];</span><br><span class="line">[dateComponents setMonth:8];</span><br><span class="line">[dateComponents setDay:15];</span><br><span class="line">NSDate *operationDate = [greCalendar dateFromComponents:dateComponents];</span><br></pre></td></tr></table></figure><p><strong>NSDate转NSString</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">NSDate *operationDate;</span><br><span class="line"></span><br><span class="line">- (void)updateTimeExample &#123;</span><br><span class="line">    NSCalendar *greCalendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];</span><br><span class="line">    NSDateComponents *dateComponents = [[NSDateComponents alloc] init];</span><br><span class="line">    [dateComponents setYear:2016];</span><br><span class="line">    [dateComponents setMonth:8];</span><br><span class="line">    [dateComponents setDay:15];</span><br><span class="line">    operationDate = [greCalendar dateFromComponents:dateComponents];</span><br><span class="line">    </span><br><span class="line">    if (!self.timer) &#123;</span><br><span class="line">        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target: self selector:@selector(addOneSecondToDate:) userInfo:nil repeats:YES];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">- (void)addOneSecondToDate:(NSTimer *)timer &#123;</span><br><span class="line">//    NSDate *operationDate = [timer userInfo];</span><br><span class="line">    NSCalendar *greCalendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];</span><br><span class="line">    </span><br><span class="line">    NSDateComponents *offsetDateComponents = [[NSDateComponents alloc] init];</span><br><span class="line">    [offsetDateComponents setMinute:1];</span><br><span class="line">    [offsetDateComponents setSecond:1];</span><br><span class="line">    NSDate *finalDate = [greCalendar dateByAddingComponents:offsetDateComponents toDate:operationDate options:0];</span><br><span class="line">    operationDate = finalDate;</span><br><span class="line">    </span><br><span class="line">    //NSDate转NSString</span><br><span class="line">    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</span><br><span class="line">    [dateFormatter setDateFormat:@&quot;yyyy年MM月dd HH:mm:ss&quot;];</span><br><span class="line">    NSString *dateString = [dateFormatter stringFromDate:finalDate];</span><br><span class="line">    </span><br><span class="line">    self.networkTimeLabel.text = dateString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####NSJSONSerialization 去除不必要的空格回车<br><a href="http://blog.csdn.net/uxyheaven/article/details/7888559" target="_blank" rel="noopener">NSJSONSerialization介绍</a><br><a href="http://blog.sina.com.cn/s/blog_916e0cff0101gdlf.html" target="_blank" rel="noopener">NSJSONSerialization四个枚举什么意思</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 要去除不必要的空格回车，只需将参数Option设置为0即可。如果设置NSJSONWritingPrettyPrinted会使格式化的json更加可读，即添加空格和换行，但如果设为0，则不添加空格和换行</span><br><span class="line">    NSData *data = [NSJSONSerialization dataWithJSONObject:dictionary</span><br><span class="line">                                                   options:0</span><br><span class="line">                                                     error:nil];</span><br><span class="line">    NSString *JSON = [[NSString alloc] initWithData:data</span><br><span class="line">                                           encoding:NSUTF8StringEncoding];</span><br></pre></td></tr></table></figure></p><p>######颜色渐变 CAGradientLayer<br><a href="http://blog.csdn.net/ch_soft/article/details/7534542" target="_blank" rel="noopener">CAGradientLayer简介</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/3%E8%A7%86%E5%9B%BE/3%E8%A7%86%E5%9B%BE-%E2%91%A0%E6%9C%AC%E8%B4%A8/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/3%E8%A7%86%E5%9B%BE/3%E8%A7%86%E5%9B%BE-%E2%91%A0%E6%9C%AC%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-视图-①本质"><a href="#必备知识架构-视图-①本质" class="headerlink" title="必备知识架构-视图-①本质"></a>必备知识架构-视图-①本质</h1><p>[toc]</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><p></p><p id="目录"></p><p></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><p><a href="#响应链及事件链">一、在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么</a></p></li><li><p><a href="#事件的响应链">二、事件的响应链</a></p></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">附：整个响应链及事件链</span><br><span class="line">1、完善响应链查找知识点</span><br><span class="line">2、基础概念等详解</span><br><span class="line">2.1 响应者对象(UIResponder)</span><br><span class="line">2.2、UITouch(点击对象)</span><br><span class="line">2.2.1、UITouch的几个主要属性和方法</span><br><span class="line">2.2.2、UITouch的生成场景</span><br><span class="line">2.3、UIEvent(事件对象)</span><br><span class="line">3、响应链的应用</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#CALayer和UIView">三、CALayer和UIView</a></li></ul><ul><li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p></li><li><p><a href="#END">END</a></p></li></ul><p></p><p id="响应链及事件链"></p><p></p><h2 id="一、在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么"><a href="#一、在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么" class="headerlink" title="一、在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么"></a>一、在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>这其实是一个事件传递和响应链的问题。（其实，按钮点击后，这里还包括runloop的唤醒等知识，不过这点我们放在下一大点讲）。</p><p>答：在我们点击按钮的时候，会产生了UITouch(点击对象)和UIEvent(事件对象)，这两个对象组合成一个点击事件。而发生触摸事件后，</p><p>①消息循环(runloop)/系统就会接收到这个触摸事件，并将它放到一个由UIApplication管理的消息队列(先进先出)里。</p><p>②UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理。首先UIApplication将事件传递给的是UIWindow对象(即一般为应用程序的主窗口keyWindow)。</p><p>③然后，UIWindow(继承自UIView)对象会继续向它的子View对象传递，直到传递到最上层。（或者说UIWindow使用hitTest:withEvent:方法查找touch操作的所在的视图view）</p><p>其中的应用程序逐级寻找能够响应这个事件的对象，直到没有响应者响应。这一寻找的过程，被称作<strong>事件的响应链</strong>。</p><p></p><p id="事件的响应链"></p><p></p><h2 id="二、事件的响应链"><a href="#二、事件的响应链" class="headerlink" title="二、事件的响应链"></a>二、事件的响应链</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>事件的响应链大概过程如下图所示：</p><blockquote><p><img src="/iOS/3必备知识架构/3视图/3视图-①本质/事件的响应链.png" alt="事件的响应链"></p></blockquote><ul><li><p>1、在传递的过程中，下一响应者的查找是通过UIView里的<code>- pointInside: withEvent:</code> 和 <code>- hitTest: withEvent:</code>两个方法来确定的。当从最初的只有一个响应者通过这样的方式不断的找到下一响应者后，这些响应者就组成了一个响应者链。</p></li><li><p>2、当通过<code>- hitTest: withEvent:</code>找到第一响应者后，若第一响应者没有处理事件，则沿着响应者链向上追溯寻找响应者(即灰色箭头方向)执行touches方法。这个过程就是<strong>事件的传递过程</strong>。从这可以看出它的方向是跟响应链方向相反的。这里我们可以用UITableViewCell中点击上面的label来想象。</p></li></ul><h4 id="附：整个响应链及事件链"><a href="#附：整个响应链及事件链" class="headerlink" title="附：整个响应链及事件链"></a>附：整个响应链及事件链</h4><p>整个响应链(向下)及事件链(向上)，大概如图所示：</p><blockquote><p><img src="/iOS/3必备知识架构/3视图/3视图-①本质/响应链(向下" alt="响应链(向下)及事件链(向上)">及事件链(向上).png)<br>在上图，当<code>- hitTest: withEvent:</code>方法沿着红色箭头方向寻找第一响应者后，若第一响应者没有处理事件，则沿着响应者链向上追溯寻找响应者(即灰色箭头方向)执行touches方法。<br>所以响应链为红色部分，事件链的顺序可以理解为图上的灰色箭头部分（个人理解）。</p></blockquote><h4 id="1、完善响应链查找知识点"><a href="#1、完善响应链查找知识点" class="headerlink" title="1、完善响应链查找知识点"></a>1、完善响应链查找知识点</h4><p>我们已经知道响应者链是由多个响应者组合起来的链条。那么怎么找到这些相应者呢？</p><p><strong>响应者的查找</strong>为通过UIView内部的下面两个方法来查找的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//根据点击坐标返回事件是否发生在本视图以内</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;   // default returns YES if point is in bounds</span><br><span class="line"></span><br><span class="line">// 返回响应点击事件的对象（当点击区域在分为内时候，如果有子视图则返回子视图里最终的响应者，如果没有子视图则返回自身）</span><br><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;   // recursively calls -pointInside:withEvent:. point is in the receiver&apos;s coordinate system</span><br></pre></td></tr></table></figure><p>对于一个视图</p><blockquote><p>①、若子视图中的<code>- pointInside: withEvent:</code>方法返回为NO，即判断用户点击的区域不在该子视图范围内的话，则停止对这个子视图里的子视图继续查找，<code>- hitTest: withEvent:</code>返回nil。</p><p>②、若子视图中的<code>- pointInside: withEvent:</code>方法返回为YES，即判断用户点击的区域在该子视图范围内的话，则继续往该子视图里的子视图查找，直到没有子视图，然后<code>- hitTest: withEvent:</code>返回这个子视图，而后之前的视图的<code>- hitTest: withEvent:</code>也返回这个子视图。</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul></blockquote><p>hitTest-withEvent-查找过程举例，如下图</p><blockquote><p><img src="/iOS/3必备知识架构/3视图/3视图-①本质/hitTest-withEvent-查找过程举例.png" alt="hitTest-withEvent-查找过程举例"><br>图片中view等级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ViewA addSubview:ViewB];</span><br><span class="line">[ViewA addSubview:ViewC];</span><br><span class="line">[ViewB addSubview:ViewD];</span><br><span class="line">[ViewB addSubview:ViewE];</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>那么点击viewE后，发生的过程是怎样的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.A 是UIWindow的根视图，首先对A进行hitTest:withEvent:</span><br><span class="line">2.判断A的userInteractionEnabled，如果为NO，A的hitTest:withEvent返回nil;</span><br><span class="line">3.pointInside:withEvent:方法判断用户点击是否在A的范围内，显然返回YES</span><br><span class="line">4.遍历A的子视图B和C。由于从后向前遍历，因此先查看C，再查看B。</span><br><span class="line">&gt;</span><br><span class="line">4.1 查看C：</span><br><span class="line">调用C的hitTest:withEvent方法：pointInside:withEvent:方法判断用户点击是否在C的范围内，不在返回NO，C对应的hitTest:withEvent: 方法return nil；</span><br><span class="line">&gt;</span><br><span class="line">4.2 再查看B</span><br><span class="line">调用B的hitTest:withEvent方法：pointInside:withEvent:判断用户点击是否在B的返回内，在返回YES。</span><br><span class="line">&gt;遍历B的子视图D和E，从后向前遍历，所以先查看E，再查看D。</span><br><span class="line">4.2.1先查看E，调用E的hitTest:withEvent方法：pointInside:withEvent:方法 判断用户点击是否在E的范围内，在返回YES，E没有子视图，因此E对应的hitTest:withEvent方法返回E,再往前回溯，就是B的hitTest:withEvent方法返回E，因此A的hitTest:withEvent方法返回E。</span><br><span class="line">4.2.2查看D，略</span><br><span class="line">&gt;</span><br><span class="line">至此，点击事件的第一响应者就找到了。</span><br></pre></td></tr></table></figure><h3 id="2、基础概念等详解"><a href="#2、基础概念等详解" class="headerlink" title="2、基础概念等详解"></a>2、基础概念等详解</h3><p>iOS中的事件可以分为3大类型：</p><ol><li>触摸事件</li><li>加速计事件</li><li>远程控制事件</li></ol><p>在iOS中不是任何对象都能处理事件，能接受并这些处理事件的对象只有直接或间接继承自UIResponder的对象，我们称之为“响应者对象”。</p><h4 id="2-1-响应者对象-UIResponder"><a href="#2-1-响应者对象-UIResponder" class="headerlink" title="2.1 响应者对象(UIResponder)"></a>2.1 响应者对象(UIResponder)</h4><p>①、为什么只有继承自UIResponder的类才能够接收并处理事件呢？因为处理这些事件的方法是卸载UIResponder中的啊。详细的UIResponder中提供的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">4个处理触摸事件的对象方法</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">和3个处理加速计事件</span><br><span class="line">- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;</span><br><span class="line">- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;</span><br><span class="line">- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">以及1个处理远程控制事件的方法</span><br><span class="line">- (void)remoteControlReceivedWithEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure><p>附：如何实现UIView的拖拽呢？即让UIView随着手指的移动而移动。</p><p>答： 重写touchsMoved:withEvent:方法</p><p>代码如下：</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 想让控件随着手指移动而移动,监听手指移动</span><br><span class="line">    // 获取UITouch对象</span><br><span class="line">    UITouch *touch = [touches anyObject];</span><br><span class="line">    // 获取当前点的位置</span><br><span class="line">    CGPoint curP = [touch locationInView:self];</span><br><span class="line">    // 获取上一个点的位置</span><br><span class="line">    CGPoint preP = [touch previousLocationInView:self];</span><br><span class="line">    // 获取它们x轴的偏移量,每次都是相对上一次</span><br><span class="line">    CGFloat offsetX = curP.x - preP.x;</span><br><span class="line">    // 获取y轴的偏移量</span><br><span class="line">    CGFloat offsetY = curP.y - preP.y;</span><br><span class="line">    // 修改控件的形变或者frame,center,就可以控制控件的位置</span><br><span class="line">    // 形变也是相对上一次形变(平移)</span><br><span class="line">    // CGAffineTransformMakeTranslation:会把之前形变给清空,重新开始设置形变参数</span><br><span class="line">    // make:相对于最原始的位置形变</span><br><span class="line">    // CGAffineTransform t:相对这个t的形变的基础上再去形变</span><br><span class="line">    // 如果相对哪个形变再次形变,就传入它的形变</span><br><span class="line">    self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②、那么iOS中能接收并处理事件或者说继承自UIResponder的类有哪些呢？</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; iOS中能接收并处理事件或者说继承自UIResponder的类有：</span><br><span class="line">UIApplication、UIWindow、UIViewController和所有继承UIView的UIKit类都直接或间接的继承自UIResponder。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p>从UIResponder内部提供的方法可以看出，触摸方法接收两个参数，一个UITouch对象的集合，还有一个UIEvent对象。这两个参数分别代表的是点击对象和事件对象。</p><h4 id="2-2、UITouch-点击对象"><a href="#2-2、UITouch-点击对象" class="headerlink" title="2.2、UITouch(点击对象)"></a>2.2、UITouch(点击对象)</h4><p>UITouch表示单个点击，其类文件中存在枚举类型UITouchPhase的属性，用来表示当前点击的状态。这些状态包括点击开始、移动、停止不动、结束和取消五个状态。每次点击发生的时候，点击对象都放在一个集合中传入UIResponder的回调方法中。</p><h6 id="2-2-1、UITouch的几个主要属性和方法："><a href="#2-2-1、UITouch的几个主要属性和方法：" class="headerlink" title="2.2.1、UITouch的几个主要属性和方法："></a>2.2.1、UITouch的几个主要属性和方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly) NSTimeInterval      timestamp;    // 记录了触摸事件产生或变化时的时间，单位是秒</span><br><span class="line">@property(nonatomic,readonly) UITouchPhase        phase;        // 当前触摸事件所处的状态</span><br><span class="line">@property(nonatomic,readonly) NSUInteger          tapCount;     // 短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击</span><br><span class="line">@property(nonatomic,readonly) UITouchType         type NS_AVAILABLE_IOS(9_0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,readonly,strong) UIWindow                        *window;      //触摸产生时所处的窗口</span><br><span class="line">@property(nullable,nonatomic,readonly,strong) UIView                          *view;        //触摸产生时所处的视图</span><br><span class="line">@property(nullable,nonatomic,readonly,copy)   NSArray &lt;UIGestureRecognizer *&gt; *gestureRecognizers NS_AVAILABLE_IOS(3_2);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  获取当前点击位置的坐标点</span><br><span class="line"> *</span><br><span class="line"> *  @param view 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回值表示触摸在view上的位置点(这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）)</span><br><span class="line"> */</span><br><span class="line">- (CGPoint)locationInView:(nullable UIView *)view;</span><br><span class="line"></span><br><span class="line">/// 获取前一个触摸点位置的坐标点</span><br><span class="line">- (CGPoint)previousLocationInView:(nullable UIView *)view;</span><br></pre></td></tr></table></figure><h6 id="2-2-2、UITouch的生成场景："><a href="#2-2-2、UITouch的生成场景：" class="headerlink" title="2.2.2、UITouch的生成场景："></a>2.2.2、UITouch的生成场景：</h6><blockquote><p>前言：每根手指触摸屏幕时都会创建一个与该手指相关的UITouch对象。一根手指对应一个UITouch对象。每个UITouch对象保存着跟手指相关的信息，比如触摸的位置、时间、阶段。<br>当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置。<br>当手指离开屏幕时，系统会销毁相应的UITouch对象</p><p>实际调用现象举例：</p><p>①、当用户用一根手指触摸屏幕时，view会调用1次touchesBegan:withEvent:方法。touches参数中装着1个UITouch对象。</p><p>②、如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象。</p><p>③、如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象</p></blockquote><h4 id="2-3、UIEvent-事件对象"><a href="#2-3、UIEvent-事件对象" class="headerlink" title="2.3、UIEvent(事件对象)"></a>2.3、UIEvent(事件对象)</h4><p>iOS使用UIEvent表示用户交互的事件对象，在UIEvent.h文件中，我们可以看到有一个UIEventType类型的属性，这个属性表示了当前的响应事件类型。分别有多点触控、摇一摇以及远程操作（在iOS之后新增了3DTouch事件类型）。在一个用户点击事件处理过程中，UIEvent对象是唯一的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly) UIEventType     type NS_AVAILABLE_IOS(3_0);</span><br><span class="line">@property(nonatomic,readonly) UIEventSubtype  subtype NS_AVAILABLE_IOS(3_0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, UIEventType) &#123;</span><br><span class="line">    UIEventTypeTouches,</span><br><span class="line">    UIEventTypeMotion,</span><br><span class="line">    UIEventTypeRemoteControl,</span><br><span class="line">    UIEventTypePresses NS_ENUM_AVAILABLE_IOS(9_0),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, UIEventSubtype) &#123;</span><br><span class="line">    // available in iPhone OS 3.0</span><br><span class="line">    UIEventSubtypeNone                              = 0,</span><br><span class="line">    </span><br><span class="line">    // for UIEventTypeMotion, available in iPhone OS 3.0</span><br><span class="line">    UIEventSubtypeMotionShake                       = 1,</span><br><span class="line">    </span><br><span class="line">    // for UIEventTypeRemoteControl, available in iOS 4.0</span><br><span class="line">    UIEventSubtypeRemoteControlPlay                 = 100,</span><br><span class="line">    UIEventSubtypeRemoteControlPause                = 101,</span><br><span class="line">    UIEventSubtypeRemoteControlStop                 = 102,</span><br><span class="line">    UIEventSubtypeRemoteControlTogglePlayPause      = 103,</span><br><span class="line">    UIEventSubtypeRemoteControlNextTrack            = 104,</span><br><span class="line">    UIEventSubtypeRemoteControlPreviousTrack        = 105,</span><br><span class="line">    UIEventSubtypeRemoteControlBeginSeekingBackward = 106,</span><br><span class="line">    UIEventSubtypeRemoteControlEndSeekingBackward   = 107,</span><br><span class="line">    UIEventSubtypeRemoteControlBeginSeekingForward  = 108,</span><br><span class="line">    UIEventSubtypeRemoteControlEndSeekingForward    = 109,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>介绍了以上响应者对象(UIResponder)及其相关的UITouch(点击对象)和UIEvent(事件对象)相关概念后，我们就知道了用户点击后，会产生了UITouch(点击对象)和UIEvent(事件对象)并打包发送，最后由响应者对象(UIResponder)来处理这些事件。</p><p>现在的问题是你知道它是怎么通过用户的点击位置找到处理该点击事件的响应者对象吗？</p><h4 id="3、响应链的应用"><a href="#3、响应链的应用" class="headerlink" title="3、响应链的应用"></a>3、响应链的应用</h4><p>既然已经知道了系统是怎么获取响应视图的流程了，那么我们可以通过重写查找事件处理者的方法来实现不规则形状点击。</p><p>最常见的不规则视图就是圆形视图，在demo中我设置view的宽高为200，那么重写方法事件如下:</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    const CGFloat halfWidth = 100;</span><br><span class="line">    CGFloat xOffset = point.x - 100;</span><br><span class="line">    CGFloat yOffset = point.y - 100;</span><br><span class="line">    CGFloat radius = sqrt(xOffset * xOffset + yOffset * yOffset);</span><br><span class="line">    return radius &lt;= halfWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最终的效果图如下：<br><img src="/iOS/3必备知识架构/3视图/3视图-①本质/响应链的应用1_点击不规则图形.gif" alt="响应链的应用1_点击不规则图形"></p></blockquote><p>前面说过按钮点击后，这里还包括一些runloop相关的知识，如唤醒等，所以下面我们就专门开讲一件Runloop。</p><p></p><p id="CALayer和UIView"></p><p></p><h2 id="三、CALayer和UIView"><a href="#三、CALayer和UIView" class="headerlink" title="三、CALayer和UIView"></a>三、CALayer和UIView</h2><p><strong>UIView与CALayer</strong>是什么关系。</p><blockquote><p>&lt;单一职责原则&gt;<br>UIView为CALayer提供内容，以及负责处理触摸等事件，参与响应链<br>CALayer负责显示内容contents</p></blockquote><p><code>UIView</code>是<code>CALayer</code>的<code>delegate</code>(<code>CALayerDelegate</code>)</p><p><code>UIView</code>继承自<code>UIResponder</code>类，可以响应事件</p><p><code>CALayer</code>直接继承自<code>NSObject</code>类，不可以响应事件</p><p><code>UIView</code>主要处理事件，<code>CALayer</code>负责绘制</p><p>每个<code>UIView</code>内部都有一个<code>CALayer</code>在背后提供内容的绘制和显示，并且<code>UIView</code>的尺寸样式都由内部的<code>Layer</code>所提供。两者都有树状层级结构，<code>Layer</code>内部有<code>SubLayers</code>，<code>View</code>内部有<code>SubViews</code>，但是<code>Layer</code>比<code>View</code>多了个<code>AnchorPoint</code></p><p>CALayer的结构图如下：</p><blockquote><p><img src="/iOS/3必备知识架构/3视图/3视图-①本质/CALayer的结构图.jpg" alt="CALayer的结构图"></p></blockquote><blockquote><p>在 iOS 系统中所有显示的视图都是从基类UIView继承而来的，同时UIView负责接收用户交互。 但是<em>实际上你所看到的视图内容，包括图形等，都是由UIView的一个实例图层属性来绘制和渲染的，那就是CALaye</em>r。</p><p>CALayer类的概念与UIView非常类似，它也具有树形的层级关系，并且可以包含图片文本、背景色等。它与UIView最大的不同在于它不能响应用户交互，可以说它根本就不知道响应链的存在。</p><p>在每一个UIView实例当中，都有一个默认的支持图层，UIView负责创建并且管理这个图层。实际上这个CALayer图层才是真正用来在屏幕上显示的，UIView仅仅是对它的一层封装，实现了CALayer的delegate，提供了处理事件交互的具体功能，还有动画底层方法的高级 API。</p><p>以上摘要来自:<a href="https://blog.csdn.net/jijiji000111/article/details/50480405" target="_blank" rel="noopener">内存恶鬼drawRect - 谈画图功能的内存优化</a>中的CALayer和UIView介绍部分。</p></blockquote><p>CALayer有三个视觉元素：背景色、内容和边框，其中，内容的本质是一个CGImage</p><p><a href="https://www.cnblogs.com/jiayongqiang/p/5339678.html" target="_blank" rel="noopener">CALayer和UIView</a></p><blockquote><p>简述CALayer和UIView的关系</p></blockquote><p>答:<strong>UIView和CALayer是相互依赖的关系。UIView依赖与calayer提供的内容，CALayer依赖uivew提供的容器来显示绘制的内容。归根到底CALayer是这一切的基础，如果没有CALayer，UIView自身也不会存在，UIView是一个特殊的CALayer实现，添加了响应事件的能力</strong>。</p><blockquote></blockquote><p>结论：<br>UIView来自CALayer，高于CALayer，是CALayer高层实现与封装。UIView的所有特性来源于CALayer支持。</p><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><p><em>问：UIButton从子类到父类依次继承自什么？</em></p><blockquote><p>答:UIControl-&gt; UIView-&gt; UIResponder。</p></blockquote><h4 id="哪些视图的设置能禁止其相应事件"><a href="#哪些视图的设置能禁止其相应事件" class="headerlink" title="哪些视图的设置能禁止其相应事件"></a>哪些视图的设置能禁止其相应事件</h4><p>1、userInterface = NO;<br>2、hidden = YES;<br>3、当UIBUTTON透明度为0就不响应事件了，当UIBUTTON透明度为0就不响应事件了。</p><p>更多参考：<a href="https://blog.csdn.net/mingming24/article/details/45177377" target="_blank" rel="noopener">iOS开发经验：button不能响应的原因</a></p><h5 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h5><p>在使用圆角、阴影和遮罩等视图功能的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，所有就需要在屏幕外的上下文中渲染，即离屏渲染。</p><p>更多参考:<a href="https://www.cnblogs.com/fishbay/p/7576176.html" target="_blank" rel="noopener">iOS离屏渲染之优化分析</a>该文非常重要。</p><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%AE%9A%E4%BD%8D/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-内存-③内存泄漏定位"><a href="#必备知识架构-内存-③内存泄漏定位" class="headerlink" title="必备知识架构-内存-③内存泄漏定位"></a>必备知识架构-内存-③内存泄漏定位</h1><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><p>未整合的文章：</p><ul><li><a href="https://blog.csdn.net/clovejq/article/details/78689759" target="_blank" rel="noopener">iOS检测内存泄漏的方法</a></li><li><a href="https://blog.csdn.net/mr_zhangrmwork/article/details/76210448" target="_blank" rel="noopener">xcode8 使用Instruments检测定位并解决iOS内存泄露</a></li></ul><p></p><p id="目录"></p><p></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#重要文章">重要文章</a></li><li><a href="#Analyze">一、Analyze—静态分析</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、常见的三种泄露情形</span><br><span class="line">(1)、创建了一个对象，但是并没有使用。Xcode提示信息：Value Stored to &apos;number&apos; is never read。翻译一下：存储在&apos;number&apos;里的值从未被读取过。</span><br><span class="line">(2)、创建了一个（指针可变的）对象，且初始化了，但是初始化的值一直没读取过。Xcode提示信息：Value Stored to &apos;str&apos; during its initialization is never read</span><br><span class="line">(3)、调用了让某个对象引用计数加1的函数，但没有调用相应让其引用计数减1的函数。Xcode提示信息：Potential leak of an object stored into &apos;subImageRef&apos;。 翻译一下：subImageRef对象的内存单元有潜在的泄露风险。ARC中常见于CGxxxRef未release。</span><br><span class="line">&gt;</span><br><span class="line">2、.....</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><a href="#Leaks">二、Leaks—内存泄露</a></p></li><li><p><a href="#dealloc">三、ARC下的dealloc</a></p></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、ARC下dealloc的使用</span><br><span class="line">ARC下,系统可以帮我们释放该对象,及其包含的对象;但是却无法释放不属于该对象的一些东西,如:</span><br><span class="line">(1)、通知的观察者,或KVO的观察者；</span><br><span class="line">(2)、对象强委托/引用的解除；</span><br><span class="line">(3)、做一些其他的注销之类的操作,如一个ViewController在销毁之前有可能需要和server打交道。</span><br><span class="line">&gt;</span><br><span class="line">2、controller 不能释放，不走dealloc方法的几种可能</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p></li><li><p><a href="#END">END</a></p></li></ul><p>以下内容摘自：<a href="https://www.cnblogs.com/lisaloveyou1900/p/5383760.html" target="_blank" rel="noopener">iOS性能优化之内存管理：Analyze、Leaks、Allocations的使用和案例代码</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>内存空间的划分: 我们知道，一个进程占用的内存空间，包含5种不同的数据区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）BSS段：通常是存放未初始化的全局变量；</span><br><span class="line">（2）数据段：通常是存放已初始化的全局变量。</span><br><span class="line">（3）代码段：通常是存放程序执行代码。</span><br><span class="line">（4）堆：通常是用于存放进程运行中被动态分配的内存段，OC对象（所有继承自NSObject的对象）就存放在堆里。</span><br><span class="line">（5）栈：由编译器自动分配释放，存放函数的参数值，局部变量等值。</span><br></pre></td></tr></table></figure><p>栈内存是系统来管理的，因此我们常说的内存管理，指的是堆内存的管理，也就是所有OC对象的创建和销毁的管理。</p><p>伴随着iOS5的到来，苹果推出了ARC（自动引用计数）技术，此模式下编译器会自动在合适的地方插入retain、release、autorelease语句，也就是说编译器会自动生成内存管理的代码，解放了广大程序猿的双手，也基本上避免了内存泄露问题，但是呢…</p><p>内存泄露的定义是：用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。（其实说白了就是该内存空间使用完毕之后未回收）。</p><p>在iOS应用中的内存泄露，原因一般有循环引用、错用Strong/copy等。</p><p></p><p id="重要文章"></p><p></p><h2 id="重要文章"><a href="#重要文章" class="headerlink" title="重要文章"></a>重要文章</h2><ul><li><a href="https://blog.csdn.net/clovejq/article/details/78689759" target="_blank" rel="noopener">iOS检测内存泄漏的方法</a></li><li><a href="https://www.jianshu.com/p/b72d0a442342" target="_blank" rel="noopener">iOS 内存泄漏的查找</a></li><li><a href="https://www.jianshu.com/p/33bda0eed3aa?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">iOS 内存泄漏监测自动化</a></li></ul><p></p><p id="Analyze"></p><p></p><h2 id="一、Analyze—静态分析"><a href="#一、Analyze—静态分析" class="headerlink" title="一、Analyze—静态分析"></a>一、Analyze—静态分析</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>顾名思义，静态分析不需要运行程序，就能检查到存在内存泄露的地方。</p><p>使用方法：打开Xcode，command + shift + B；或者Xcode - Product - Analyze；</p><h3 id="1、常见的三种泄露情形："><a href="#1、常见的三种泄露情形：" class="headerlink" title="1、常见的三种泄露情形："></a>1、常见的三种泄露情形：</h3><blockquote></blockquote><p>（1）创建了一个对象，但是并没有使用。Xcode提示信息：Value Stored to ‘number’ is never read。翻译一下：存储在’number’里的值从未被读取过。</p><blockquote></blockquote><p>（2）创建了一个（指针可变的）对象，且初始化了，但是初始化的值一直没读取过。Xcode提示信息：Value Stored to ‘str’ during its initialization is never read</p><blockquote></blockquote><p>（3）调用了让某个对象引用计数加1的函数，但没有调用相应让其引用计数减1的函数。Xcode提示信息：Potential leak of an object stored into ‘subImageRef’。 翻译一下：subImageRef对象的内存单元有潜在的泄露风险。ARC中常见于CGxxxRef未release。</p><p>贴上三种常见情形的Demo代码，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 情 形 一：创建了一个对象，但是并没有使用。</span><br><span class="line"> * 提示信息：Value Stored to &apos;number&apos; is never read</span><br><span class="line"> * 翻译一下：存储在&apos;number&apos;里的值从未被读取过，</span><br><span class="line"> */</span><br><span class="line">- (void)leakOne &#123;</span><br><span class="line">    NSString *str1 = [NSString string];</span><br><span class="line">    NSNumber *number;</span><br><span class="line">    number = @(str1.length);</span><br><span class="line">    /*</span><br><span class="line">     说我们没有读取过它，那就读取一下，比如打开下面这句代码，对它发送class消息，就不再会有这个提示了。</span><br><span class="line">     当然最好的方法还是将有关number的代码都删掉，因为，你只对number赋值，又不使用，那干嘛创建出来呢。</span><br><span class="line">     这是一个比较常见和典型的错误，也很容易检查出来</span><br><span class="line">     */</span><br><span class="line">    // [number class];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 情 形 二：创建了一个（指针可变的）对象，且初始化了，但是初始化的值一直没读取过。</span><br><span class="line"> * 提示信息：Value Stored to &apos;str&apos; during its initialization is never read</span><br><span class="line"> */</span><br><span class="line">- (void)leakTwo &#123;</span><br><span class="line">    NSString *str = [NSString string]; // 创建并初始化str，此时已经有一个内存单元保存str初始化的值</span><br><span class="line">    // NSString *str; // 这样就内存不泄露，因为str是可变的，只需要先声明就行。</span><br><span class="line">    // printf(&quot;str前 = %p\n&quot;,str);</span><br><span class="line">    str = @&quot;ceshi&quot;;             // str被改变了，指向了&quot;ceshi&quot;所在的地址，指针改变了，但之前保存初始化值的内存空间还未释放，保存str初始化值的内存单元泄露了。</span><br><span class="line">    // printf(&quot;str后 = %p\n&quot;,str); // 指针改变了</span><br><span class="line">    [str class];</span><br><span class="line">     </span><br><span class="line">    // 再举两个例子，同理</span><br><span class="line">     </span><br><span class="line">    NSArray *arr = [NSArray array];</span><br><span class="line">    // printf(&quot;arr前 = %p\n&quot;,arr);</span><br><span class="line">    // NSArray *arr;            // 这样就内存不泄露</span><br><span class="line">    arr = @[@&quot;1&quot;,@&quot;2&quot;];</span><br><span class="line">    // printf(&quot;arr后 = %p\n&quot;,arr); // 指针改变了</span><br><span class="line">    [arr class];</span><br><span class="line">     </span><br><span class="line">    CGRect rect = self.view.frame;</span><br><span class="line">    // CGRect rect = CGRectZero; // 这样就内存不泄露</span><br><span class="line">    rect = CGRectMake(0, 0, 0, 0);</span><br><span class="line">    NSLog(@&quot;rect = %@&quot;,NSStringFromCGRect(rect));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 情 形 三：调用了让某个对象引用计数加1的函数，但没有调用相应让其引用计数减1的函数。</span><br><span class="line"> * 提示信息：Potential leak of an object stored into &apos;subImageRef&apos;</span><br><span class="line"> * 翻译一下：subImageRef对象的内存单元有潜在的泄露风险</span><br><span class="line"> */</span><br><span class="line">- (void)leakThree &#123;</span><br><span class="line">    CGRect rect = CGRectMake(0, 0, 50, 50);</span><br><span class="line">    UIImage *image;</span><br><span class="line">    CGImageRef subImageRef = CGImageCreateWithImageInRect(image.CGImage, rect); // subImageRef 引用计数 + 1;</span><br><span class="line">     </span><br><span class="line">    UIImage* smallImage = [UIImage imageWithCGImage:subImageRef];</span><br><span class="line">     </span><br><span class="line">    // 应该调用对应的函数，让subImageRef的引用计数减1,就不会泄露了</span><br><span class="line">    // CGImageRelease(subImageRef);</span><br><span class="line">     </span><br><span class="line">    [smallImage class];</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己遇到的实例:</p><blockquote><p>情形2：<a href="https://blog.csdn.net/sinat_30898863/article/details/51142127" target="_blank" rel="noopener">静态检测内存泄露Analyze－－Value stored to ‘dataArr’ during its initialization is never read</a><br>即初始化的时候开辟了一块内存，却始终没用到，导致该块内存泄漏</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *tempMutArr = [NSMutableArray arrayWithCapacity:0];</span><br><span class="line">   if ([self.clickedButtonTpye isEqualToString:KClickedButtonTypeLast]) &#123;</span><br><span class="line">       tempMutArr = self.lastDataSourceArr;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       tempMutArr = self.hotDataSourceArr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p></p><p id="Leaks"></p><p></p><h2 id="二、Leaks—内存泄露"><a href="#二、Leaks—内存泄露" class="headerlink" title="二、Leaks—内存泄露"></a>二、Leaks—内存泄露</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>Leaks是动态的内存泄露检查工具，需要一边运行程序，一边检测。</p><blockquote><p><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/Leak1.jpg" alt="内存泄漏Leak1"></p></blockquote><p>先不切换到Call Trees，先看看Statistics(统计数据)下的情况</p><blockquote><p><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/Leak2.jpg" alt="内存泄漏Leak2"><br>Allocation中我们主要关注的是Persistent和Persistent Bytes，分别表示当前时间段，申请了但是还没释放的内存数量和大小。</p></blockquote><p>切换到Call Trees后世这样的</p><blockquote><p><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/Leak3.jpg" alt="内存泄漏Leak3"></p></blockquote><h4 id="项目中遇到过的内存泄漏"><a href="#项目中遇到过的内存泄漏" class="headerlink" title="项目中遇到过的内存泄漏"></a>项目中遇到过的内存泄漏</h4><p>这里我们不是去查看<code>Call Tree</code>,而是查看<code>Cycles &amp; Roots</code>。</p><blockquote><p><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/循环引用定位1.jpg" alt="循环引用定位1"></p><p>点击标记4处为黑色，即代表该处会发生内存泄漏，双击进入代码，如图：<br><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/循环引用定位2.jpg" alt="循环引用定位2"><br>果然存在内存泄漏</p></blockquote><p>自己遇到的其他例子：</p><blockquote><p><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/Leak_mine_1.jpg" alt="Leak_mine_1"><br>开始不明白为什么这个变量会内存泄漏后面才能白，其实_priceDetailModel这个本身已经用OrderPriceDetailModel赋值过一次了，而这里你又赋值了一次，导致多了一个。代码情况如下两个图：<br><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/Leak_mine_2.jpg" alt="Leak_mine_2"><br>又在set方法中生成了一个地址<br><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/Leak_mine_3.jpg" alt="Leak_mine_3"></p></blockquote><p></p><p id="dealloc"></p><p></p><h2 id="三、ARC下的dealloc"><a href="#三、ARC下的dealloc" class="headerlink" title="三、ARC下的dealloc"></a>三、ARC下的dealloc</h2><h4 id="1、ARC下dealloc的使用"><a href="#1、ARC下dealloc的使用" class="headerlink" title="1、ARC下dealloc的使用"></a>1、ARC下dealloc的使用</h4><p>ARC下,系统可以帮我们释放该对象,及其包含的对象;但是却无法释放不属于该对象的一些东西,如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)、通知的观察者,或KVO的观察者；</span><br><span class="line">(2)、对象强委托/引用的解除；</span><br><span class="line">(3)、做一些其他的注销之类的操作,如一个ViewController在销毁之前有可能需要和server打交道。</span><br></pre></td></tr></table></figure><h6 id="1-、通知的观察者-或KVO的观察者；"><a href="#1-、通知的观察者-或KVO的观察者；" class="headerlink" title="(1)、通知的观察者,或KVO的观察者；"></a>(1)、通知的观察者,或KVO的观察者；</h6><blockquote><p>由于通知中心是系统的一个单例,你在注册通知的观察者时,实际上是在通知中心注册的,</p></blockquote><p>这时,即使ARC下系统帮我们释放了对象,但是在通知中心的观察还是没有移除,那么当有</p><blockquote></blockquote><p>该通知时,依然会尝试调用该对象的接受通知的方法,这可能会导致一些问题.</p><h6 id="2-、对象强委托-引用的解除；"><a href="#2-、对象强委托-引用的解除；" class="headerlink" title="(2)、对象强委托/引用的解除；"></a>(2)、对象强委托/引用的解除；</h6><blockquote><p>对于其他的对象来把你当做委托 delegate时,并且是 强引用时,即时你自身被释放,但是引用你的对象依然还在,</p></blockquote><p>这时需要在引用你的对象移除该delegate</p><h6 id="3-、做一些其他的注销之类的操作-如一个ViewController在销毁之前有可能需要和server打交道。"><a href="#3-、做一些其他的注销之类的操作-如一个ViewController在销毁之前有可能需要和server打交道。" class="headerlink" title="(3)、做一些其他的注销之类的操作,如一个ViewController在销毁之前有可能需要和server打交道。"></a>(3)、做一些其他的注销之类的操作,如一个ViewController在销毁之前有可能需要和server打交道。</h6><blockquote><p>一个对象,如一个ViewController在销毁之前有可能需要和server打交道;</p></blockquote><p>这时我们也可以在dealloc中写</p><h4 id="2、controller-不能释放，不走dealloc方法的几种可能"><a href="#2、controller-不能释放，不走dealloc方法的几种可能" class="headerlink" title="2、controller 不能释放，不走dealloc方法的几种可能"></a>2、controller 不能释放，不走dealloc方法的几种可能</h4><p>主要原因还是循环引用，引起的内存泄漏。</p><p>详情参考：<a href="https://blog.csdn.net/flg1554112450/article/details/70228353" target="_blank" rel="noopener">controller 不能释放，不走dealloc方法的4种可能</a></p><p></p><p id="Time Profile"></p><p></p><h2 id="四、Time-Profile"><a href="#四、Time-Profile" class="headerlink" title="四、Time Profile"></a>四、Time Profile</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>详情参考：<a href="http://www.cocoachina.com/ios/20160805/17300.html" target="_blank" rel="noopener">instrument Time Profiler总结</a></p><p>使用Time Profile前有两点需要注意的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、一定要使用真机调试</span><br><span class="line">2、应用程序一定要使用发布配置</span><br></pre></td></tr></table></figure><p>图标为黑色头像的就是Time Profiler给我们的提示，有可能存在性能瓶颈的地方</p><blockquote><p><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/TimeProfile1.png" alt="TimeProfile1"></p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他参考材料：</p><p>问：Xcode 运行程序，左侧memory 不显示内存。。</p><blockquote><p>答：运行程序后，xcode 不显示当前使用的内存情况，问题是打开了僵尸–enable zoombie Objects，关闭即可。<br>即打开 product—&gt;SCheme–&gt;EditSCheme –&gt;enable zoombie Objects  取消选中 ok</p></blockquote><p>就可以继续显示了</p><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A1%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8Timer/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A1%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8Timer/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-内存-②循环引用Timer"><a href="#必备知识架构-内存-②循环引用Timer" class="headerlink" title="必备知识架构-内存-②循环引用Timer"></a>必备知识架构-内存-②循环引用Timer</h1><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><p></p><p id="目录"></p><p></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#NSTimer">九、NSTimer</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、NSTimer和NSRunLoop的关系？</span><br><span class="line">2、NSTimer使用细节</span><br><span class="line">3、NSTimer的创建</span><br><span class="line">4、NSTimer的循环引用</span><br><span class="line">5、NSTimer使用的优化</span><br><span class="line">&gt;</span><br><span class="line">6、NSTimer的销毁问题</span><br><span class="line">(1)、子线程中NSTimer的创建和销毁问题</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p></li><li><p><a href="#END">END</a></p></li></ul><p></p><p id="NSTimer"></p><p></p><h2 id="九、NSTimer"><a href="#九、NSTimer" class="headerlink" title="九、NSTimer"></a>九、NSTimer</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote><h3 id="1、NSTimer的创建"><a href="#1、NSTimer的创建" class="headerlink" title="1、NSTimer的创建"></a>1、NSTimer的创建</h3><p>NSTimer的创建通常有两种方式，尽管都是类方法，一种是timerWithXXX，另一种scheduedTimerWithXXX。</p><p>二者最大的区别就是后者除了创建一个定时器外会自动以NSDefaultRunLoopModeMode添加到当前线程RunLoop中，不添加到RunLoop中的NSTimer是无法正常工作的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController1 ()</span><br><span class="line">@property (nonatomic, weak) NSTimer *timer1;</span><br><span class="line">@property (nonatomic, weak) NSTimer *timer2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation ViewController1</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.timer1 = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timeInterval1:) userInfo:nil repeats:YES];</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    错误做法：</span><br><span class="line">    self.timer2 = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timeInterval2:) userInfo:nil repeats:YES];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:self.timer2 forMode:NSDefaultRunLoopMode];</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    //正确做法：</span><br><span class="line">    //特别注意：timer2创建时并没直接赋值给timer2。</span><br><span class="line">    //原因是timer2是weak属性，如果直接赋值给timer2会被立即释放。</span><br><span class="line">    //因为timerWithXXX方法创建的NSTimer默认并没有加入RunLoop，只有后面加入RunLoop以后才可以将引用指向timer2。从而导致执行到addTimer:forMode的时候，访问了野指针而发生EXC_BAD_ACCESS，崩溃。</span><br><span class="line">    NSTimer *tempTimer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timeInterval2:) userInfo:nil repeats:YES];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:tempTimer forMode:NSDefaultRunLoopMode];</span><br><span class="line">    self.timer2 = tempTimer;</span><br><span class="line">    。。。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)timeInterval1:(id)object &#123;</span><br><span class="line">    NSLog(@&quot;111&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timeInterval2:(id)object &#123;</span><br><span class="line">    NSLog(@&quot;222&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="2、NSTimer的修饰符"><a href="#2、NSTimer的修饰符" class="headerlink" title="2、NSTimer的修饰符"></a>2、NSTimer的修饰符</h3><p><strong>runloop强制持有timer(runloop-&gt;timer),timer会强制持有其target，未处理的情况下一般都是self(timer-&gt;self)，导致self无法释放。</strong><br>虽然设置timer为weak属性时候，self未强制持有timer,没构成循环应用，但还是导致了self无法释放的问题，dealloc无法执行。</p><h3 id="2、NSTimer的循环引用"><a href="#2、NSTimer的循环引用" class="headerlink" title="2、NSTimer的循环引用"></a>2、NSTimer的循环引用</h3><p>关于循环引用，我们先看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController1 ()</span><br><span class="line">@property (nonatomic, strong) NSTimer *timer;//注意这里的属性不是为weak,从而很容易引起循环引用</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation ViewController1</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    // 代码标记1 (产生timer与self之前的强引用，如下图中的L3强引用线)</span><br><span class="line">    NSTimer *timer = [[NSTimer alloc] initWithFireDate:[NSDate date] interval:1 target:self selector:@selector(timerFire) userInfo:nil repeats:YES];</span><br><span class="line">    // 代码标记2 (产生RunLoop与timer之间的强引用，如下图中的L4强引用线)</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">    // 代码标记3 (产生self与timer之间的强引用，，如下图中的L2强引用线)</span><br><span class="line">    self.timer = timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timerFire &#123;</span><br><span class="line">    NSLog(@&quot;timer fire&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>假设代码中的视图控制器由UINavigationController管理，由于self.timer是strong类型，则强引用可以表示如下：</p><blockquote><p><img src="/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/2内存-②循环引用/NSTimer循环引用例子1.png" alt="NSTimer循环引用例子1"></p></blockquote><p>由于，很容易看出来，由于timer本身在创建时候已经与self发生了强引用。而赋值时候又由于timer是被设为strong的，而导致self与timer之间也发生了强引用，最终这两个强引用，就形成了循环引用。</p><p>所以，</p><p>①、首先，我们先解决循环引用，为了解决timer的循环应用问题，我们上面的timer属性应该使用weak。设置成weak后，L2就消失了。</p><p>②、但是<strong>即使使用了弱引用，上面的代码中ViewController1在pop退出的时候也无法正常释放，原因是在创建NSTimer时指定了target为self，这样一来造成了timer对ViewController1有一个强引用</strong>。从而导致，timer没释放的时候，viewController也是不会被释放的。<strong>为了让timer能够释放，我们就需要调用NSTimer的invalidate方法</strong>（注意：无论是重复执行的定时器还是一次性的定时器只要调用invalidate方法则会变得无效，只是一次性的定时器执行完操作后会自动调用invalidate方法）。所以，假设在viewController pop回去前，我们通过一个按钮来让timer调用invalidate方法，那么viewController在pop回去时候，就能够被释放了。</p><p>问题是我们一般不会有这个按钮操作，那么这时候让timer调用invalidate方法的操作，应该写在哪里呢。这时候，你可能会想到那就写在viewDidDisappear中呗。但是一旦在viewWillDisappear中写<code>[timer invalidate]; timer = nil;</code>那么你也得把timer的创建放在viewWillAppear中。因为我们可能执行的是push跳到下一页,再返回来的操作。然而显然将timer的创建放在viewWillAppear中这样的方式，显然会是导致当timer可能需要频繁添加。所以，我们放弃此方法，还是把timer的创建放在viewDidLoad中，然后考虑其他方法。</p><p>所以，我们最后<strong>为了让ViewController1在pop退出的时候不会因为timer的强引用，而导致无法正常释放。我们选择转移timer中的target</strong>。这样就能确保，viewController在pop退出的时候能够正常释放，从而调用viewController的dealloc方法。</p><blockquote><p>附：转移timer中的target的方法通常有两种：</p></blockquote><p>一种是将target分离出来独立成一个对象（在这个对象中创建NSTimer并将对象本身作为NSTimer的target），控制器通过这个对象间接使用NSTimer；</p><blockquote></blockquote><p>另一种方式的思路仍然是转移target，只是可以直接增加NSTimer扩展（分类），让NSTimer自身做为target，同时可以将操作selector封装到block中。</p><blockquote><p><img src="/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/2内存-②循环引用/NSTimer转移target方法二.jpg" alt="NSTimer转移target方法二"><br>图中参考<a href="https://github.com/mBrissman/NSTimer-Block" target="_blank" rel="noopener">NSTimer+Block</a></p></blockquote><p>后者相对优雅，也是目前使用较多的方案。显然Apple也认识到了这个问题，如果你可以确保代码只在iOS 10下运行就可以使用iOS 10新增的系统级block方案（上面的代码中已经贴出这种方法）。</p><p>③、如果不做②中的转移timer的target的话，那么viewController就会无法释放，造成内存泄露。<br>但是，我们发现<strong>通过转移timer的target后，虽然解决了UIViewController1因为被timer强引用而导致的在pop回来的时候无法释放的问题。</strong>我们的计时器，却在UIViewController1 pop退出被释放后，两个定时器仍然在运行，也就是它还没被释放。所以，我们还需要解决timer的释放。那怎么让timer释放呢？答：<strong>如果要让timer释放掉的话，需要调用NSTimer的invalidate方法</strong>（注意：无论是重复执行的定时器还是一次性的定时器只要调用invalidate方法则会变得无效，只是一次性的定时器执行完操作后会自动调用invalidate方法）。<br><strong>invalidate方法有2个功能：一是将timer从runloop中移除，那么图中的L4就消失，二是timer本身也会释放它持有资源，比如它的target、userinfo、block等，因为这里的target是self，所以强引用L3也就消失。</strong><br>所以，最终当viewController在pop退出的时候，其正常释放并调用了dealloc放。我们只需要在dealloc方法中，添加上timer调用invalidate的方法，即可以解决viewController被释放了，但timer没被释放的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    NSLog(@&quot;ViewController1 dealloc...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，一个完整的timer过程，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><h3 id="3、NSTimer和NSRunLoop的关系？"><a href="#3、NSTimer和NSRunLoop的关系？" class="headerlink" title="3、NSTimer和NSRunLoop的关系？"></a>3、NSTimer和NSRunLoop的关系？</h3><p>只要出现NSTimer必须要有NSRunLoop，NSTimer必须依赖NSRunLoop才能执行 。NSTimer其实也是一种资源，如果看过多线程编程指引文档的话，我们会发现所有的source如果要起作用，就得加到runloop中去。同理timer这种资源要想起作用，那肯定也需要加到runloop中才会生效喽。如果一个runloop里面不包含任何资源的话，运行该runloop时会立马退出。</p><p>NSRunLoop与timer有关方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addTimer:(NSTimer *)timer forMode:(NSString *)mode; //在run loop上注册timer</span><br></pre></td></tr></table></figure><p>注意事项:</p><blockquote><p>我们通常在主线程中使用NSTimer，有个实际遇到的问题需要注意。当滑动界面时，系统为了更好地处理UI事件和滚动显示，主线程runloop会暂时停止处理一些其它事件，这时主线程中运行的NSTimer就会被暂停。解决办法就是改变NSTimer运行的mode（mode可以看成事件类型），不使用缺省的NSDefaultRunLoopMode，而是改用NSRunLoopCommonModes，这样主线程就会继续处理NSTimer事件了。具体代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timer:) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><h3 id="4、NSTimer使用细节："><a href="#4、NSTimer使用细节：" class="headerlink" title="4、NSTimer使用细节："></a>4、NSTimer使用细节：</h3><p>NSTimer上的定时任务是在创建NSTimer的线程上执行的。NSTimer的销毁和创建必须在同一个线程上操作<br>NSTimer要被添加到当前线程的 Runloop 里面且 Runloop 被启动，定时任务（selector或者invocation）才会触发。</p><p>以下内容摘自：<a href="https://www.cnblogs.com/mddblog/p/6517377.html" target="_blank" rel="noopener">NSTimer定时器进阶——详细介绍，循环引用分析与解决</a></p><ol><li>它需要被添加到runloop，否则不会运行，当然添加的runloop不存在也不会运行；</li><li>还要指定添加到的runloop的哪个模式，而且还可以指定添加到runloop的多个模式，模式不对也是不会运行的</li><li><strong>runloop会对timer有强引用，timer会对目标对象进行强引用(是否隐约的感觉到坑了。。。)</strong></li><li>timer的执行时间并不准确，系统繁忙的话，还会被跳过去。(具体的两种不准时，请查看原文)</li><li>invalidate调用后，timer停止运行后，就一定能从runloop中消除吗，资源？？？？invalidate方法的调用必须在timer添加到的runloop所在的线程，如果不在的话：由于调用invalidate 方法后，timer本身会释放掉它自己持有的资源比如target、userinfo、block，图中的L3会消失。但是runloop不会释放timer，即图中的L4不会消失，假设，self被pop了–&gt;L1无效–&gt;self引用计数为0,self释放–&gt;L2也消失。此时就剩runloop、timer、L4，timer也就永远不会释放了，造成内存泄露。</li></ol><p>NSTimer的强引用问题举例:</p><blockquote><p><img src="/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/2内存-②循环引用/NSTimer的强引用问题举例.png" alt="NSTimer的强引用问题举例"></p></blockquote><h4 id="5、NSTimer使用的优化"><a href="#5、NSTimer使用的优化" class="headerlink" title="5、NSTimer使用的优化"></a>5、NSTimer使用的优化</h4><p>问：为什么要在非主线程创建NSTimer？</p><ul><li>将 timer 添加到主线程的Runloop里面本身会增加线程负荷；</li><li>如果主线程因为某些原因阻塞卡顿了，timer 定时任务触发的时间精度肯定也会受到影响；</li><li>有些定时任务不是UI相关的，本来就没必要在主线程执行，给主线程增加不必要的负担。当然也可以在定时任务执行时，手动将任务指派到非主线程上，但这也是有额外开销的。</li></ul><h4 id="6、NSTimer的销毁问题"><a href="#6、NSTimer的销毁问题" class="headerlink" title="6、NSTimer的销毁问题"></a>6、NSTimer的销毁问题</h4><p>前面我们已经简单讲过要让NSTimer销毁释放的时候，只能通过调用其invalidate来达到销毁目的。关于invalidate的第一个作用以及它在哪个线程调用的问题，我的理解如下：</p><p>invalidate方法的第一个作用将timer从runloop中移除。这里的runLoop指的应该是当前的runLoop，而不是timer被添加到的runLoop，这个纯属个人理解，未验证，因为如果是其添加的runLoop的话，那子线程timer的销毁，就不会有人说还要和timer所在的线程一致了。所以，这里的个人理解有如下：</p><p><em>为了销毁timer和去除runloop与timer之间的强引用</em>，我们调用了timer的invalidate方法。</p><blockquote><p>1、对于invalidate方法的调用是写在必须在timer所添加到的runloop所在的线程（如主线程）的时候，invalidate方法会将timer从runloop中移除，并且释放它持有资源。即上面的L4和L3都消失。</p><p>2、对于invalidate方法的调用不是写在必须在timer所添加到的runloop所在的线程的时候（如子线程中添加timer，在主线程中调用该timer的invalidate），虽然timer本身会释放掉它自己持有的资源比如target、userinfo、block，图中的L3会消失。但是runloop不会释放timer，即图中的L4不会消失，假设，self被pop了–&gt;L1无效–&gt;self引用计数为0,self释放–&gt;L2也消失。此时就剩runloop、timer、L4，timer也就永远不会释放了，造成内存泄露。</p><p>如果invalidate方法的调用的位置不更改的话，这时候要让L4消失的方法，</p><p>方法①手动销毁runloop。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    //[[NSRunLoop currentRunLoop] run]; //将原本的方法注释掉</span><br><span class="line">    NSDate *date = [NSDate dateWithTimeIntervalSinceNow:5.f];</span><br><span class="line">    [[NSRunLoop currentRunLoop] runUntilDate:date]; //让runloop在5s后销毁</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这种方式，只适用于销毁时间确定的情况。那如果销毁时间不确定怎么办？</p><p>方法②：因为<strong>当某个线程销毁时，其runloop也随之销毁</strong>，所以方法二即为通过销毁timer所在的线程，来达到销毁runloop的目的。如果是在主线程，线程一直存在，我们没法让主线程销毁。</p></blockquote><p>所以，下面我们讨论的是<em>在子线程中添加timer的时候，<strong>如果</strong>该timer的invalidate方法的调用位置不是写在对应子线程，而是写在主线程的时候，我们该怎么通过销毁子线程，来销毁runLoop。从而接触该runloop对timerd的强引用？</em></p><h5 id="6-1子线程中NSTimer的创建和销毁问题"><a href="#6-1子线程中NSTimer的创建和销毁问题" class="headerlink" title="6.1子线程中NSTimer的创建和销毁问题"></a>6.1子线程中NSTimer的创建和销毁问题</h5><p>我们按上诉2中②的讨论描述的：子线程中添加timer的时候，如果该timer的invalidate方法的调用位置不是写在对应子线程，而是写在主线程的时候，写出的对应代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) NSTimer *threadTimer; //子线程timer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    // 开辟子线程</span><br><span class="line">    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)newThread &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSThread *currentThread = [NSThread currentThread];</span><br><span class="line">        [currentThread setName:@&quot;这是子线程&quot;];</span><br><span class="line">        </span><br><span class="line">        self.threadTimer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(threadTimerAction) userInfo:nil repeats:YES];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)threadTimerAction &#123;</span><br><span class="line">    static NSInteger counter = 0;</span><br><span class="line">    </span><br><span class="line">    NSString *isMainThreadDescription = [NSThread isMainThread] ? @&quot;YES&quot; : @&quot;NO&quot;;</span><br><span class="line">    NSLog(@&quot;当前方法执行的线程：%@, 它是否是主线程:%@, counter = %@&quot;, [NSThread currentThread], isMainThreadDescription, @(counter++));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，我们该怎么通过销毁子线程，来销毁runLoop。从而接触该runloop对timerd的强引用？即怎么销毁线程？</p><p>乍看当在子线程开启runloop后，timer会一直在子线程中运行，所以子线程不会销毁，runloop也就无法停止，runloop也就没法销毁，runloop与timer之间的强引用则还是被保留着，这似乎又是个死循环。但实际上，<em>由于上述代码runloop的mode item只有Timer，所以只要销毁timer，runloop就会退出。</em>所以，上述的代码是没问题的，不存在内存泄露问题。</p><p>附：NSTimer上的定时任务是在创建NSTimer的线程上执行的。</p><p>–</p><p>附：以上NSTimer的内容，有空的话还可参考<a href="https://www.imooc.com/article/22331" target="_blank" rel="noopener">NSTimer,NSRunLoop,autoreleasepool,多线程的爱恨情仇</a>，它那边讲的，和这边自己理解的基本是一样的。只是对于有些点的介绍详细不一定一样而已。</p><p>其他有空可看<a href="http://www.cocoachina.com/ios/20150710/12444.html" target="_blank" rel="noopener">iOS 中的 NSTimer</a></p><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A1Block/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A1Block/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-内存-②Block"><a href="#必备知识架构-内存-②Block" class="headerlink" title="必备知识架构-内存-②Block"></a>必备知识架构-内存-②Block</h1><p>[toc]</p><h2 id="iOS-Block本质"><a href="#iOS-Block本质" class="headerlink" title="iOS-Block本质"></a>iOS-Block本质</h2><p><a href="https://www.jianshu.com/p/4e79e9a0dd82" target="_blank" rel="noopener">iOS-Block本质</a></p><p>block本质上也是一个OC对象，它内部也有个isa指针，最终继承NSObject。</p><p>如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSGlobalBlock &lt;--__NSGlobalBlock &lt;--NSBlock &lt;-- NSObject</span><br></pre></td></tr></table></figure><h4 id="Q：block有哪几种类型-及-各类型的block在内存中如何分配的？"><a href="#Q：block有哪几种类型-及-各类型的block在内存中如何分配的？" class="headerlink" title="Q：block有哪几种类型 及 各类型的block在内存中如何分配的？"></a>Q：block有哪几种类型 及 各类型的block在内存中如何分配的？</h4><p>block的类型，取决于isa指针，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型。</p><p><strong>堆</strong>：动态分配内存，需要程序员自己申请，程序员自己管理</p><p><strong>栈</strong>：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况</p><ul><li><p><strong>NSGlobalBlock </strong> 在数据区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void (^block1)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;block1&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>NSMallocBlock </strong> 在堆区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age1 = 1;</span><br><span class="line">void (^block2)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;block2:%d&quot;, age1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>NSStackBlock </strong> 在栈区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age2 = 2;</span><br><span class="line">NSLog(@&quot;%@&quot;, [^&#123;</span><br><span class="line">        NSLog(@&quot;block3:%d&quot;, age2);</span><br><span class="line">    &#125; class]);</span><br></pre></td></tr></table></figure></li></ul><p>附：打印block类型<code>NSLog(@&quot;%@&quot;, [block1 class]);</code></p><h2 id="问：以下各情况，Person的对象什么时候才销毁？或Person对象在block上是如何操作的？"><a href="#问：以下各情况，Person的对象什么时候才销毁？或Person对象在block上是如何操作的？" class="headerlink" title="问：以下各情况，Person的对象什么时候才销毁？或Person对象在block上是如何操作的？"></a>问：以下各情况，Person的对象什么时候才销毁？或Person对象在block上是如何操作的？</h2><p>有Person类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;Person dealloc&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>了解解题的基础知识：</p><h4 id="1、当对象类型的auto变量被block内部访问时，是强引用还是弱引用？-延伸：引用过后，block内部无法修改auto变量值，除非使用-block"><a href="#1、当对象类型的auto变量被block内部访问时，是强引用还是弱引用？-延伸：引用过后，block内部无法修改auto变量值，除非使用-block" class="headerlink" title="1、当对象类型的auto变量被block内部访问时，是强引用还是弱引用？(延伸：引用过后，block内部无法修改auto变量值，除非使用__block)"></a>1、当对象类型的auto变量被block内部访问时，是强引用还是弱引用？(延伸：引用过后，block内部无法修改auto变量值，除非使用__block)</h4><ul><li>如果block在<code>栈</code>空间，不管外部变量是强引用还是弱引用，block都会弱引用访问对象</li><li>如果block在<code>堆</code>空间，如果外部强引用，block内部也是强引用；如果外部弱引用，block内部也是弱引用</li></ul><p>2、GCD API的方法参数block，在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上。</p><h4 id="附：在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上的几种情况？"><a href="#附：在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上的几种情况？" class="headerlink" title="附：在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上的几种情况？"></a>附：在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上的几种情况？</h4><ul><li><p>1.block作为函数返回值时</p></li><li><p>2.将block赋值给__strong指针时</p></li><li><p>3.block作为Cocoa API中方法名含有usingBlock的方法参数时</p></li><li><p>4.block作为GCD API的方法参数时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="1、问：-下列代码中的Person的对象什么时候才销毁？"><a href="#1、问：-下列代码中的Person的对象什么时候才销毁？" class="headerlink" title="1、问： 下列代码中的Person的对象什么时候才销毁？"></a>1、问： 下列代码中的Person的对象什么时候才销毁？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = 10;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;age:%d&quot;, person.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：方法代码执行完就person就销毁了</p><h3 id="2、问：以下gcd的block中引用-Person的对象什么时候才销毁？"><a href="#2、问：以下gcd的block中引用-Person的对象什么时候才销毁？" class="headerlink" title="2、问：以下gcd的block中引用 Person的对象什么时候才销毁？"></a>2、问：以下gcd的block中引用 Person的对象什么时候才销毁？</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 不使用__weak修饰</span></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age:%d"</span>, person.age);<span class="comment">// 堆block会对Person强引用，故而也就只有block销毁时候Person才会被释放。这里是2秒后销毁。</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"touchesBegan"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：</p><p>1、gcd的block默认会做copy操作，即dispatch_after的block是堆block。</p><p>2、我们知道<code>如果block在堆空间，如果外部强引用，block内部也是强引用；如果外部弱引用，block内部也是弱引用</code>。</p><p>所以这里外部的Person没有声明为__weak，所以堆block会对Person强引用，故而也就只有block销毁时候Person才会被释放。这里是2秒后销毁。(如果没有gcd)</p><h3 id="3、续问：如果上述Person被添加上-weak修饰，那Person什么时候释放？会造成什么问题？"><a href="#3、续问：如果上述Person被添加上-weak修饰，那Person什么时候释放？会造成什么问题？" class="headerlink" title="3、续问：如果上述Person被添加上__weak修饰，那Person什么时候释放？会造成什么问题？"></a>3、续问：如果上述Person被添加上__weak修饰，那Person什么时候释放？会造成什么问题？</h3><p>续答：此时上述的代码会变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = 10;</span><br><span class="line">    </span><br><span class="line">  // 不使用__weak修饰</span><br><span class="line">    __weak Person *weakPerson = person;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;person:%p&quot;, weakPerson);// 当Person被添加上__weak修饰后，堆block会对Person弱引用。而在touchesBegan函数结束后，由于Person就会被释放，所以2秒后gcd无法捕捉到Person的后果。所以此处person 是 nil，打印的%p地址，是0x0。</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;touchesBegan&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，还是我们知道<code>如果block在堆空间，如果外部强引用，block内部也是强引用；如果外部弱引用，block内部也是弱引用</code>。所以当Person被添加上__weak修饰后，堆block会对Person弱引用。而在touchesBegan函数结束后，由于Person就会被释放，所以2秒后gcd无法捕捉到Person的后果。即上述的输出结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person 是 nil，打印的%p地址，是0x0。</span><br></pre></td></tr></table></figure><h3 id="4、上述代码使用-weak后，变量被释放了，那怎么防止block持有的对象提前释放"><a href="#4、上述代码使用-weak后，变量被释放了，那怎么防止block持有的对象提前释放" class="headerlink" title="4、上述代码使用__weak后，变量被释放了，那怎么防止block持有的对象提前释放"></a>4、上述代码使用__weak后，变量被释放了，那怎么防止block持有的对象提前释放</h3><h4 id="Q：block的属性修饰词为什么是copy？"><a href="#Q：block的属性修饰词为什么是copy？" class="headerlink" title="Q：block的属性修饰词为什么是copy？"></a>Q：block的属性修饰词为什么是copy？</h4><p>block一旦没有进行copy操作，就不会在堆上<br>block在堆上，程序员就可以对block做内存管理等操作，可以控制block的生命周期</p><h4 id="Q：当block被copy到堆时，对-block修饰的变量做了什么？"><a href="#Q：当block被copy到堆时，对-block修饰的变量做了什么？" class="headerlink" title="Q：当block被copy到堆时，对__block修饰的变量做了什么？"></a>Q：当block被copy到堆时，对__block修饰的变量做了什么？</h4><ul><li>会调用block内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会对__block变量形成强引用（retain）</li><li>对于__block 修饰的变量 assign函数对其强引用；对于外部对象 assign函数根据外部如何引用而引用</li></ul><h4 id="Q：当block从堆中移除时，对-block修饰的变量做了什么？"><a href="#Q：当block从堆中移除时，对-block修饰的变量做了什么？" class="headerlink" title="Q：当block从堆中移除时，对__block修饰的变量做了什么？"></a>Q：当block从堆中移除时，对__block修饰的变量做了什么？</h4><ul><li>会调用block内部的dispose函数</li><li>dispose函数内部会调用_Block_object_dispose函数</li><li>_Block_object_dispose函数会自动释放引用的__block变量（release）</li></ul><h2 id="二、-block修饰符"><a href="#二、-block修饰符" class="headerlink" title="二、__block修饰符"></a>二、__block修饰符</h2><h4 id="Q：-block-int-age-10，系统做了哪些？"><a href="#Q：-block-int-age-10，系统做了哪些？" class="headerlink" title="Q：__block int age = 10，系统做了哪些？"></a>Q：<code>__block</code> int age = 10，系统做了哪些？</h4><h4 id="Q：-block-修饰符作用？"><a href="#Q：-block-修饰符作用？" class="headerlink" title="Q：__block 修饰符作用？"></a>Q：__block 修饰符作用？</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A1%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A1%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-内存-②循环引用"><a href="#必备知识架构-内存-②循环引用" class="headerlink" title="必备知识架构-内存-②循环引用"></a>必备知识架构-内存-②循环引用</h1><p>[toc]</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><p></p><p id="目录"></p><p></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><p><a href="#循环引用原因">一、循环引用原因</a></p></li><li><p><a href="#NSTimer的循环引用">二、NSTimer的循环引用</a></p></li><li><p><a href="#委托delegate的循环引用">三、委托delegate的循环引用</a></p></li><li><p><a href="#block的循环引用">四、block的循环引用</a></p></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、Objective-C中block为何得用copy修饰，能否用其他</span><br><span class="line">2、block的循环引用</span><br><span class="line">3、block循环引用的解决</span><br><span class="line">4、判断该block是否会发生循环引用</span><br><span class="line">5、为什么masonry的block里引用self不需要weak？</span><br><span class="line">6、是否所有的Block中，使用self 都会导致循环引用？</span><br><span class="line">7、block修改外部局部变量</span><br><span class="line">(1)、在block中无法直接修改外部变量的原因</span><br><span class="line">(2)、解决如何在 block 中修改外部变量</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p></li><li><p><a href="#END">END</a></p></li></ul><p></p><p id="循环引用原因"></p><p></p><h2 id="一、循环引用原因"><a href="#一、循环引用原因" class="headerlink" title="一、循环引用原因"></a>一、循环引用原因</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>导致iOS对象无法按预期释放的一个无形杀手是——循环引用。循环引用可以简单理解为A引用了B，而B又引用了A，双方都同时保持对方的一个引用，导致任何时候引用计数都不为0，始终无法释放。若当前对象是一个ViewController，则在dismiss或者pop之后其dealloc无法被调用，在频繁的push或者present之后内存暴增，然后APP就duang地挂了。</p><p><strong>循环引用会导致内存泄露，因为循环应用会导致，有些对象没办法在已经不会再使用的时候被释放掉</strong></p><p>下面列举我们变成中比较容易碰到的三种循环引用的情形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）计时器NSTimer</span><br><span class="line">（2）block</span><br><span class="line">（3）委托delegate</span><br></pre></td></tr></table></figure><p></p><p id="NSTimer的循环引用"></p><p></p><h2 id="二、NSTimer的循环引用"><a href="#二、NSTimer的循环引用" class="headerlink" title="二、NSTimer的循环引用"></a>二、NSTimer的循环引用</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>NSTimer的循环引用详情，我们放在下面讲解NSTimer(前面已经提过NSTimer 其实就是RunLoop中的CFRunLoopTimerRef，一个基于时间的触发器)的时候介绍。</p><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@interface HWWeakTimerTarget : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id target;// 注意是 weak</span><br><span class="line">@property (nonatomic, assign) SEL selector; // assign</span><br><span class="line">@property (nonatomic, weak) NSTimer* timer;// 注意是 weak</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation HWWeakTimerTarget</span><br><span class="line"></span><br><span class="line">- (void) fire:(NSTimer *)timer &#123;</span><br><span class="line">    if(self.target) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">        [self.target performSelector:self.selector withObject:timer.userInfo afterDelay:0.0f];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.timer invalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation HWWeakTimer</span><br><span class="line"></span><br><span class="line">+ (NSTimer *) scheduledTimerWithTimeInterval:(NSTimeInterval)interval</span><br><span class="line">                                      target:(id)aTarget</span><br><span class="line">                                    selector:(SEL)aSelector</span><br><span class="line">                                    userInfo:(id)userInfo</span><br><span class="line">                                     repeats:(BOOL)repeats &#123;</span><br><span class="line">    HWWeakTimerTarget* timerTarget = [[HWWeakTimerTarget alloc] init];</span><br><span class="line">    timerTarget.target = aTarget;</span><br><span class="line">    timerTarget.selector = aSelector;</span><br><span class="line">    timerTarget.timer = [NSTimer scheduledTimerWithTimeInterval:interval</span><br><span class="line">                                                         target:timerTarget</span><br><span class="line">                                                       selector:@selector(fire:)</span><br><span class="line">                                                       userInfo:userInfo</span><br><span class="line">                                                        repeats:repeats];</span><br><span class="line">    return timerTarget.timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p></p><p id="委托delegate的循环引用"></p><p></p><h2 id="三、委托delegate的循环引用"><a href="#三、委托delegate的循环引用" class="headerlink" title="三、委托delegate的循环引用"></a>三、委托delegate的循环引用</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>在委托问题上出现循环引用问题已经是老生常谈了，声明delegate时请用weak(ARC)，如果是MRC则用assign。千万别手贱。</p><p></p><p id="block的循环引用"></p><p></p><h2 id="四、block的循环引用"><a href="#四、block的循环引用" class="headerlink" title="四、block的循环引用"></a>四、block的循环引用</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><h5 id="1、Objective-C中block为何得用copy修饰，能否用其他"><a href="#1、Objective-C中block为何得用copy修饰，能否用其他" class="headerlink" title="1、Objective-C中block为何得用copy修饰，能否用其他"></a>1、Objective-C中block为何得用copy修饰，能否用其他</h5><blockquote><p>答：因为<strong>block在创建的时候，它的内存是分配在栈(stack)上，而不是在堆(heap)上。他本身的作于域是属于创建时候的作用域，一旦在创建时候的作用域外面调用block将导致程序崩溃。所以，为了能够在block的声明域外也能够使用block，我们需要将block拷贝到堆上，所以使用copy属性。</strong>对于堆中的block，也就是copy修饰的block。他的生命周期是随着对象的销毁而结束的。只要对象不销毁，我们就可以调用的到在堆中的block。</p></blockquote><h5 id="2、block的循环引用"><a href="#2、block的循环引用" class="headerlink" title="2、block的循环引用"></a>2、block的循环引用</h5><p><strong>由于block在copy时都会对block内部用到的对象进行强引用(ARC)或者retainCount增1(非ARC)。所以，不管是在ARC还是非ARC环境下对block使用不当都会引起循环引用问题</strong></p><p>一般表现为，某个类将block作为自己的属性变量(则该类就对block强引用了)，然后该类在block的方法体里面又使用了该类本身。即当对象（比如self）拥有一个block属性的时候，在block属性中又引用了对象的其他成员变量或者调用了对象的其他方法。形成你中有我，我中有你，谁都无法将谁释放的困局。形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">self.myBlock = ^&#123;</span><br><span class="line">   [self doSomething];</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line">又或者</span><br><span class="line"></span><br><span class="line">ClassA* objA = [[ClassA alloc] init];</span><br><span class="line">objA.myBlock = ^&#123;</span><br><span class="line">   [self doSomething];</span><br><span class="line">&#125;;</span><br><span class="line">self.objA = objA;</span><br></pre></td></tr></table></figure><p>block的这种循环引用会被编译器捕捉到并及时提醒。</p><p>以上参考自：<a href="http://www.jianshu.com/p/b79bac09177e" target="_blank" rel="noopener">Block的循环引用</a></p><h5 id="3、block循环引用的解决"><a href="#3、block循环引用的解决" class="headerlink" title="3、block循环引用的解决"></a>3、block循环引用的解决</h5><h6 id="1-、常规简单解法"><a href="#1-、常规简单解法" class="headerlink" title="(1)、常规简单解法"></a>(1)、常规简单解法</h6><p>解决方法,就一句话的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof (self) weakSelf = self; </span><br><span class="line">self.myBlock = ^&#123;</span><br><span class="line">    [weakSelf doSomething];</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  附1：如果是non-ARC环境下就将__weak替换为__block即可。non-ARC情况下，__block变量的含义是在Block中引入一个新的结构体成员变量指向这个__block变量，那么__block typeof(self) weakSelf = self;就表示Block别再对self对象retain啦，这就打破了循环引用。</span><br><span class="line">  </span><br><span class="line">  附2：__weak 是 iOS 5.0 推出的，_weak 相当于 weak，不会做强引用，如果对象被释放，执行的地址，会指向 nil</span><br></pre></td></tr></table></figure><h6 id="2-、block中使用-weak–strong-dance-技术避免循环引用"><a href="#2-、block中使用-weak–strong-dance-技术避免循环引用" class="headerlink" title="(2)、block中使用 weak–strong dance 技术避免循环引用"></a>(2)、block中使用 weak–strong dance 技术避免循环引用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self)weakSelf = self;</span><br><span class="line">  [header setTapHandle:^&#123;</span><br><span class="line">  __strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line">  if (strongSelf) &#123;</span><br><span class="line">     NSLog(@&quot;strongSelf = %@&quot;, strongSelf);</span><br><span class="line">  &#125;</span><br><span class="line"> [weakSelf headerAction:header];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><strong>精髓2：①在 block 之前定义对 self 的一个弱引用weakSelf，因为是弱引用，所以当 self 被释放时weakSelf会变为nil；② 在 block 中引用该弱应用，考虑到多线程情况，通过使用强引用 strongSelf 来引用该弱引用，这时如果 self 不为 nil 就会 retain self，以防止在后面的使用过程中 self 被释放;③在之后的 block 块中使用该强引用 bself，注意在使用前要对 bSelf 进行了 nil 检测，因为多线程环境下在用弱引用weakSelf对强引用strongSelf赋值时，弱引用weakSelf可能已经为nil了。通过这种手法，block 就不会持有 self 的引用，从而打破了循环引用。</strong></p><h4 id="iOS开发中在block中为什么要weak和strong配合使用"><a href="#iOS开发中在block中为什么要weak和strong配合使用" class="headerlink" title="iOS开发中在block中为什么要weak和strong配合使用"></a><a href="https://www.jianshu.com/p/0b87b4e7da2c" target="_blank" rel="noopener">iOS开发中在block中为什么要<strong>weak和</strong>strong配合使用</a></h4><blockquote><p>答：<strong>weak是为了解决循环引用。</strong>strong是为了防止block持有的对象提前释放。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">  [self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line"></span><br><span class="line">  __weak typeof(self) weakSelf = self;</span><br><span class="line">  self.block = ^&#123;</span><br><span class="line">      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          NSLog(@&quot;%@&quot;, weakSelf);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  self.block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>点击屏幕，当前控制器消失，同时被销毁掉，5秒后打印的weakSelf就是一个(null)。<br>而我们如果在block内使用__strong后就能保证再打印完strongSelf之后再释放当前控制器。</p></blockquote><h5 id="4、判断该block是否会发生循环引用"><a href="#4、判断该block是否会发生循环引用" class="headerlink" title="4、判断该block是否会发生循环引用"></a>4、判断该block是否会发生循环引用</h5><p><a href="http://www.cocoachina.com/ios/20170122/18601.html" target="_blank" rel="noopener">判断该block是否会发生循环引用例子</a></p><h5 id="5、为什么masonry的block里引用self不需要weak？"><a href="#5、为什么masonry的block里引用self不需要weak？" class="headerlink" title="5、为什么masonry的block里引用self不需要weak？"></a>5、为什么masonry的block里引用self不需要weak？</h5><p>这个就和网络请求里面使用self道理是一样的。因为UIView未强持有block，所以这个block只是个栈block，而且构不成循环引用的条件。栈block有个特性就是它执行完毕之后就出栈，出栈了就会被释放掉。看mas_makexxx的方法实现会发现这个block很快就被调用了，完事儿就出栈销毁，构不成循环引用，所以可以直接放心的使用self。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    self.translatesAutoresizingMaskIntoConstraints = NO;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    return [constraintMaker install];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果要强引用，block应该是masnory的一个属性，即被masnory对象持有。且是copy修饰符</span><br></pre></td></tr></table></figure><h4 id="6、是否所有的Block中，使用self-都会导致循环引用？"><a href="#6、是否所有的Block中，使用self-都会导致循环引用？" class="headerlink" title="6、是否所有的Block中，使用self 都会导致循环引用？"></a>6、是否所有的Block中，使用self 都会导致循环引用？</h4><h4 id="7、block修改外部局部变量"><a href="#7、block修改外部局部变量" class="headerlink" title="7、block修改外部局部变量"></a>7、block修改外部局部变量</h4><p>如果是全局变量呢？</p><h6 id="1-、在block中无法直接修改外部变量的原因"><a href="#1-、在block中无法直接修改外部变量的原因" class="headerlink" title="(1)、在block中无法直接修改外部变量的原因"></a>(1)、在block中无法直接修改外部变量的原因</h6><p>错误示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//声明一个局部整型变量 </span><br><span class="line">int intValue = 3; //漏掉了__block修饰符</span><br><span class="line"></span><br><span class="line">//声明一个返回值为int,一个int参数的block变量</span><br><span class="line">int (^block)(int) = ^(int m)&#123;</span><br><span class="line">    intValue++;</span><br><span class="line">    return m * intValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//调用block变量,5作为参数之后的结果</span><br><span class="line">NSLog(@&quot;block(5) = %d&quot;,block(5));</span><br></pre></td></tr></table></figure><p>在上面的例子中,我们编译程序后发现编译器会有红色错误,错误提示为<br>Variable is not assignable (missing __block type specifier)</p><p>为什么会出现不能被赋值的错误提示呢？</p><p>block在实现时就会对它引用到的它所在方法中定义的栈变量进行一次只读拷贝，在 block 块内使用该只读拷贝。<br>那为了避免上述错误，就要<strong>精髓1：使用__block修饰符来修饰外部变量,用来通知编译器该外部变量intValue与block中的intValue指的是同一块儿内存地址，而不需要内存拷贝。</strong></p><h6 id="2-、解决如何在-block-中修改外部变量"><a href="#2-、解决如何在-block-中修改外部变量" class="headerlink" title="(2)、解决如何在 block 中修改外部变量"></a>(2)、解决如何在 block 中修改外部变量</h6><ul><li><p>有必要了解：<a href="http://www.jianshu.com/p/404ff9d3cd42" target="_blank" rel="noopener">iOS中__block 关键字的底层实现原理</a></p></li><li><p>结论：<code>block可以访问外部变量，但是无法修改外部变量的值，如果要修改外部变量的值，需要对外部变量加上__block作为该变量的修饰</code></p><p>来源：<a href="http://bbs.itheima.com/thread-248328-1-1.html" target="_blank" rel="noopener">OC学习笔记之block访问外部变量【重点面试】</a></p></li></ul><ul><li>问题： <a href="http://blog.csdn.net/huyisu/article/details/40543291" target="_blank" rel="noopener">如何在 block 中修改外部变量</a></li></ul><p>有两种办法<br>① 第一种是可以修改 static 全局变量；<br>② 第二种是可以修改用新关键字 __block 修饰的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__block int blockLocal  = 100;</span><br><span class="line">static int staticLocal  = 100;</span><br><span class="line"></span><br><span class="line">void (^aBlock)(void) = ^(void)&#123; </span><br><span class="line">    NSLog(@&quot; &gt;&gt; Sum: %d\n&quot;, global + staticLocal);</span><br><span class="line">    </span><br><span class="line">    global++;</span><br><span class="line">    blockLocal++;</span><br><span class="line">    staticLocal++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">aBlock();</span><br></pre></td></tr></table></figure><p><code>附：静态变量 和 全局变量   在加和不加  __block 都会直接引用变量地址。也就意味着静态变量和全局变量的修改可以直接修改，不需要作添加__block的步骤。</code></p><h4 id="在ARC下获取对象的引用计数值"><a href="#在ARC下获取对象的引用计数值" class="headerlink" title="在ARC下获取对象的引用计数值"></a>在ARC下获取对象的引用计数值</h4><p>在ARC下获取对象的引用计数值，可以使用CFGetRetainCount。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于Core Foundation对象：</span><br><span class="line">NSLog(@&quot;CFGetRetainCount is %ld&quot;,  CFGetRetainCount(aCFString));</span><br><span class="line"></span><br><span class="line">对于Foundation对象</span><br><span class="line">NSLog(@&quot;CFGetRetainCount is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)aNNstring));</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@ CFGetRetainCount is %ld&quot;, NSStringFromClass([self class]), CFGetRetainCount((__bridge CFTypeRef)self));</span><br></pre></td></tr></table></figure><p>以下获取引用计数的方法错了，但是不知道正确的应该怎么用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%@ dealloc&quot;, NSStringFromClass([self class]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@ viewWillDisappear and CFGetRetainCount is %ld&quot;, NSStringFromClass([self class]), CFGetRetainCount((__bridge CFTypeRef)self));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@ viewDidDisappear and CFGetRetainCount is %ld&quot;, NSStringFromClass([self class]), CFGetRetainCount((__bridge CFTypeRef)self));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几篇文章：</p><ul><li><a href="https://www.jianshu.com/p/bcc0bcaadd6c" target="_blank" rel="noopener">iOS杂谈：影响控制器正常释放的常见问题</a></li><li><a href="https://www.cnblogs.com/songliquan/p/4970505.html" target="_blank" rel="noopener">iOS中控制器的释放问题</a></li><li><a href="https://blog.csdn.net/u014222687/article/details/51767685" target="_blank" rel="noopener">Block与Self的循环引用</a></li><li><p><a href="http://www.cocoachina.com/ios/20170122/18601.html" target="_blank" rel="noopener">ARC下用块（block）的循环引用问题样例探究</a></p></li><li><p><a href="https://blog.csdn.net/y_csdnblog_xx/article/details/51483111" target="_blank" rel="noopener">ReactiveCocoa之RAC内存管理（十二）</a></p></li><li><a href="https://www.jianshu.com/p/16b78d72dc95" target="_blank" rel="noopener">ReactiveCocoa入门教程——第二部分</a></li><li><a href="https://www.jianshu.com/p/16e8e2e5773c" target="_blank" rel="noopener">subscribenext 循环引用</a></li></ul><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><h6 id="block和weak修饰符的区别是什么？"><a href="#block和weak修饰符的区别是什么？" class="headerlink" title="block和weak修饰符的区别是什么？"></a><strong>block和</strong>weak修饰符的区别是什么？</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，在MRC时代，__block修饰，可以避免循环引用；ARC时代，__block修饰，同样会引起循环引用问题；</span><br><span class="line">2，__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型；</span><br><span class="line">3，__weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；</span><br><span class="line">4，__block对象可以在block中被重新赋值，__weak不可以；</span><br></pre></td></tr></table></figure><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A0%E5%9F%BA%E7%A1%80/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A0%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-内存"><a href="#必备知识架构-内存" class="headerlink" title="必备知识架构-内存"></a>必备知识架构-内存</h1><p>[toc]</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><p></p><p id="目录"></p><p></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#指针">一、指针</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、几个本质</span><br><span class="line">&gt;</span><br><span class="line">2、空指针和未初始化的指针</span><br><span class="line">(1)、空指针和未初始化的指针的区别：</span><br><span class="line">(2)、为什么指针变量定义时一定要初始化？ </span><br><span class="line">&gt;</span><br><span class="line">3、野指针与悬空指针</span><br><span class="line">(1)、指针与内存的常见使用顺序</span><br><span class="line">(2)、内存泄漏的概念</span><br><span class="line">(3)、野指针概念</span><br><span class="line">(4)、在iOS中野指针的后果</span><br><span class="line">(5)、分析野指针的产生原因及解决办法</span><br><span class="line">&gt;</span><br><span class="line">4、iOS NSerror 用双重指针理解</span><br><span class="line">&gt;</span><br><span class="line">5、指针和引用的区别</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#内存">二、内存</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、堆和栈的区别?</span><br><span class="line">&gt;</span><br><span class="line">2、浅拷贝和深拷贝的区别</span><br><span class="line">&gt;</span><br><span class="line">3、分析NSString、NSMutableString等类的copy、mutableCopy</span><br><span class="line">(1)、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？</span><br><span class="line">(2)、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</span><br><span class="line">(3)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</span><br><span class="line">(4)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSMutableString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</span><br><span class="line">(5)、自己代码实现copy修饰符，应该怎么写？？？？</span><br><span class="line">&gt;</span><br><span class="line">4、NSCoding和NSCopy</span><br><span class="line">(1)、NSCoding的作用</span><br><span class="line">(2)、NSCopy</span><br><span class="line">&gt;</span><br><span class="line">5、@synthesize和@dynamic区别</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#内存">八、谈谈内存管理、内存泄露、循环引用</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、内存管理</span><br><span class="line">(1)、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？</span><br><span class="line">(2)、那怎么知道对象已经没有被引用了呢？</span><br><span class="line">(3)、autorelease、autoreleasepool(自动释放池)</span><br><span class="line">(4)、autoreleasepool(自动释放池)　</span><br><span class="line">(5)、autoreleasepool里面对象的内存什么时候释放? </span><br><span class="line">(6)、runloop、autorelease pool以及线程之间的关系</span><br><span class="line">(7)、自动释放池怎样创建</span><br><span class="line">(8)、自动释放池使用注意</span><br><span class="line">(9)、自动释放池的应用/什么时候要用@autoreleasepool</span><br><span class="line">&gt;</span><br><span class="line">2、如何监测内存泄漏</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#常见笔试/面试题">常见笔试/面试题</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自动释放池底层怎么实现?</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#END">END</a></li></ul><p>常用数据类型占用内存大小</p><ul><li><a href="https://www.cnblogs.com/guozht/p/7929033.html" target="_blank" rel="noopener">常用数据类型占用内存大小</a></li></ul><blockquote><p><strong>64位编译器</strong></p><p>char ：1个字节<br>char*(即指针变量): 8个字节<br>short int : 2个字节<br>int： 4个字节<br>unsigned int : 4个字节<br>float: 4个字节<br>double:  8个字节<br><strong>long:  8个字节</strong><br>long long: 8个字节<br>unsigned long: 8个字节</p></blockquote><p></p><p id="指针"></p><p></p><h2 id="一、指针"><a href="#一、指针" class="headerlink" title="一、指针"></a>一、指针</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><h4 id="1、几个本质"><a href="#1、几个本质" class="headerlink" title="1、几个本质"></a>1、几个本质</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">数据类型：</span><br><span class="line">数据类型的本质是固定大小内存的别名。</span><br><span class="line">对变量声明数据类型，是为了告诉编译器分配几个字节的内存。</span><br><span class="line"></span><br><span class="line">变量：</span><br><span class="line">变量的本质是一段内存空间的别名。</span><br><span class="line">也就是给一段内存空间取一个新的名字，就是变量。</span><br><span class="line"></span><br><span class="line">指针：</span><br><span class="line">指针也是一种数据类型，它的值是某一个内存空间的地址。</span><br><span class="line">指针的步长根据它指向的内存空间的数据类型而定。</span><br><span class="line"></span><br><span class="line">数组中[]的本质：假如有数组array，则array[i]等价于*(array+i)，是因为[]对于程序员来讲是友好的，但是编译器最终还是要将它理解为指针，也就是数组作为函数参数时的退化。array[i] ==&gt; array[0+i] ==&gt;*(array+i)</span><br></pre></td></tr></table></figure><h4 id="2、空指针和未初始化的指针-野指针"><a href="#2、空指针和未初始化的指针-野指针" class="headerlink" title="2、空指针和未初始化的指针/野指针"></a>2、空指针和未初始化的指针/野指针</h4><h6 id="1-、空指针和未初始化的指针的区别："><a href="#1-、空指针和未初始化的指针的区别：" class="headerlink" title="(1)、空指针和未初始化的指针的区别："></a>(1)、空指针和未初始化的指针的区别：</h6><blockquote><p><strong>①空指针可以确保不指向任何对象或函数</strong>;<br>而<strong>②未初始化指针则可能指向任何地方，即它所指向的地址就是随机的，也就说此时它是个野指针。（附：如果一个指针的指向对象后来被删除，却未置为空指针nil，则它也是野指针）</strong><br>所以空指针在概念上不同于未初始化的指针。<br>对于malloc在其内存分配的时候，如果内存分配成功，返回的一定不是空指针；但是如果malloc内存分配失败,返回的空指针。而不是一个未初始化的指针。</p></blockquote><p>以下是华为笔试题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下面有关空指针和未初始化指针，说法错误的是？</span><br><span class="line">A.对0x0这个地址取值是非法的</span><br><span class="line">B.空指针可以确保不指向任何对象或函数; 而未初始化指针则可能指向任何地方。</span><br><span class="line">C.空指针与任何对象或函数的指针值都不相等</span><br><span class="line">D.malloc在其内存分配失败时返回的是一个未初始化的指针</span><br></pre></td></tr></table></figure><p>错误答案是D，因malloc内存分配失败，返回的是空指针。详细请查看原文地址<br><a href="https://www.nowcoder.com/questionTerminal/9a24bf403b1c4103a23562d52a2091ea" target="_blank" rel="noopener">华为笔试：下面有关空指针和未初始化指针，说法错误的是？</a></p><h6 id="2-、为什么指针变量定义时一定要初始化？"><a href="#2-、为什么指针变量定义时一定要初始化？" class="headerlink" title="(2)、为什么指针变量定义时一定要初始化？"></a>(2)、为什么指针变量定义时一定要初始化？</h6><blockquote><p>答:因为你首先要理解一点.内存空间不是你分配了才可以使用，只是你分配了之后使用才安全。</p><p>为什么要进行对他初始化呢，因为如果你没对它初始化，那么这个指针所指向的地址就是随机的，即此时它是个野指针。这时候如果你引用这个指针并对它做了修改这个指针所指向的内容的操作的话，如果刚好这个指针所指向的内容恰好是另外一个程序的数据的话，那么你原本随意的一个修改，就造成了对另一个程序的数据的修改了，也就会导致另外一个程序可能不能正常运行了。所以使用前一定要进行初始化。</p></blockquote><h4 id="3、野指针与悬空指针"><a href="#3、野指针与悬空指针" class="headerlink" title="3、野指针与悬空指针"></a>3、野指针与悬空指针</h4><p>在C/C++等语言中，</p><p>悬空指针（Dangling Pointer）指的是：<strong>一个指针的指向对象已被删除</strong>，那么就成了悬空指针。</p><p><strong>野指针是那些未初始化的指针</strong>。</p><p>有时也把野指针和悬空指针通称悬空指针。<br>而好像在iOS中是通称为野指针。</p><p>以下内容摘自：<a href="https://baike.baidu.com/item/迷途指针/6959997?fr=aladdin" target="_blank" rel="noopener">百度百科：迷途指针</a></p><blockquote><p>在计算机编程领域中，迷途指针，或称悬空指针、野指针，指的是不指向任何合法的对象的指针。</p><p>当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址，此情况下该指针便称迷途指针。</p><p>若操作系统将这部分已经释放的内存重新分配给另外一个进程，而原来的程序重新引用现在的迷途指针，则将产生无法预料的后果。因为此时迷途指针所指向的内存现在包含的已经完全是不同的数据。通常来说，若原来的程序继续往迷途指针所指向的内存地址写入数据，这些和原来程序不相关的数据将被损坏，进而导致不可预料的程序错误。</p><p>这种类型的程序错误，不容易找到问题的原因，通常会导致存储器区块错误（Linux系统中）和一般保护错误（Windows系统中）。如果操作系统的内存分配器将已经被覆盖的数据区域再分配，就可能会影响系统的稳定性。</p><p>某些编程语言允许未初始化的指针的存在，而这类指针即为野指针。野指针所导致的错误和迷途指针非常相似，但野指针的问题更容易被发现。</p></blockquote><h6 id="1-、指针与内存的常见使用顺序"><a href="#1-、指针与内存的常见使用顺序" class="headerlink" title="(1)、指针与内存的常见使用顺序"></a>(1)、指针与内存的常见使用顺序</h6><p>在堆中申请了一块内存，并用一个指针指向它。<br>一般我们都会在不用的时候先释放该指针指向的内存，再将该指针置为空指针。<br>即一般正确的写法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针变量和指针所指向的内存变量是两个不同的概念</span></span><br><span class="line"><span class="comment">//使用动态内存分为三步</span></span><br><span class="line"><span class="comment">//1.定义时，将指针为定义NULL</span></span><br><span class="line"><span class="comment">//2.释放内存时，把指针变量重新赋值或者NULL</span></span><br><span class="line"><span class="comment">//3.释放内存后，把指针变量赋值为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);<span class="comment">//释放P所指向的内存空间,但指针变量p仍然留在栈中,成为了野指针</span></span><br><span class="line">        p = <span class="literal">NULL</span>;<span class="comment">//释放野指针（这是关键，记得释放指针所指向的内存空间后，要释放野指针）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<br>①、如果我们在未来始终没有去手动释放掉我们开辟的内存的话，会导致内存泄漏；<br>②、如果释放掉了该内存，却忘了同时释放只想该内存的指针，会导致产生悬空指针或者说是迷途指针，或者有人也称是野指针。<br>③、如果记得释放指针，却忘了释放指针只想的内存(即记得②忘了①)，那么由于指针已经消失，而指针指向的东西还在，那么久永远无法控制这块内存，而导致一定内存泄漏了。</p><h6 id="2-、内存泄漏的概念"><a href="#2-、内存泄漏的概念" class="headerlink" title="(2)、内存泄漏的概念"></a>(2)、内存泄漏的概念</h6><p><strong>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</strong></p><h6 id="3-、野指针概念"><a href="#3-、野指针概念" class="headerlink" title="(3)、野指针概念"></a>(3)、野指针概念</h6><blockquote><p>C语言: 当我们声明1个指针变量,没有为这个指针变量赋初始值.这个指针变量的值是1个垃圾指针 指向1块随机的内存空间。</p><p>OC语言: 指针指向的对象已经被回收掉了.这个指针就叫做野指针.</p><p><strong>野指针：指向内存被释放的内存或者没有访问权限的内存的指针</strong>。</p></blockquote><p>更详细的概念可查看：<a href="https://baike.baidu.com/item/野指针/9654046?fr=aladdin" target="_blank" rel="noopener">百度百科——野指针</a></p><h6 id="4-、在iOS中野指针的后果"><a href="#4-、在iOS中野指针的后果" class="headerlink" title="(4)、在iOS中野指针的后果"></a>(4)、在iOS中野指针的后果</h6><p>野指针的后果：崩溃EXC_BAD_ADDRESS</p><h6 id="5-、分析野指针的产生原因及解决办法"><a href="#5-、分析野指针的产生原因及解决办法" class="headerlink" title="(5)、分析野指针的产生原因及解决办法"></a>(5)、分析野指针的产生原因及解决办法</h6><blockquote><p>知识点：任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</p></blockquote><p>“野指针”的成因主要有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）指针变量没有被初始化。(即随机只想的这个指针很有可能只想一块没人用的内存，)</span><br><span class="line"><span class="keyword">char</span> *p; <span class="comment">//此时p为野指针</span></span><br><span class="line"><span class="comment">//正确的为在声明之后加上 p=new char[10];我们常直接写为一行，即char *p=new char[10];</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）指针p被<span class="built_in">free</span>或者<span class="keyword">delete</span>之后，没有置为<span class="literal">NULL</span>，让人误以为p是个合法的指针.</span><br><span class="line"><span class="keyword">char</span> *p=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];  <span class="comment">//指向堆中分配的内存首地址，p存储在栈区</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; p;</span><br><span class="line"><span class="keyword">delete</span> []p; <span class="comment">//p重新变为野指针</span></span><br><span class="line"><span class="comment">//正确的应该在指针p被free或者delete之后,加上p = Null;</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）指针操作超越了变量的作用范围。</span><br><span class="line"><span class="keyword">char</span> *p=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; <span class="comment">//指向堆中分配的内存首地址</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; p;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(p+<span class="number">10</span>); <span class="comment">//可能输出未知数据</span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/tgycoder/p/5661431.html" target="_blank" rel="noopener">iOS 关于僵尸对象和僵尸指针的那些事儿</a></p><h4 id="4、iOS-NSerror-用双重指针理解"><a href="#4、iOS-NSerror-用双重指针理解" class="headerlink" title="4、iOS NSerror 用双重指针理解"></a>4、iOS NSerror 用双重指针理解</h4><p>常见代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *error = nil;</span><br><span class="line">[[NSFileManager defaultManager] removeItemAtPath:absoluteFilePath error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">NSLog(@&quot;删除单个文件的时候出现错误：%@&quot;,error.localizedDescription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，如果我们不是传指针的指针&amp;error,而是传error，那么if(error)中的error就肯定是nil了。那就没用了。</p><p>所以这里传error的指针的原因可简单概括为：<br>因为我们要得到一个新的error值。所以如果有方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSError *)getNewErrorForremoveItemAtPathremoveItemAtPath:(NSString *)path  error:(NSError **)error &#123;</span><br><span class="line">NSError *newError = [NSError errorWithDomain:...];</span><br><span class="line"></span><br><span class="line">return newError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这边，我们的error,就可以直接传error本身，甚至不传都是可以的。</p><p>但是实际是这些方法本身的返回值，已经被定义为判断能否进行某种操作，而不是操作是否成功给占用了，如这边已经被判断能否进行删除文件给占用了，所以如果我们还想知道这个删除文件操作结果的error，那就把error的指针的指针传进去，最后其出来的就是我们想要的。<br>所以，猜测其内部结构应该是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)removeItemAtPath:(NSString *)path error:(NSError **)error &#123;</span><br><span class="line">BOOL canRemove = ...;</span><br><span class="line">if (!canRemove) &#123;</span><br><span class="line">* error = [NSError errorWithDomain:...];</span><br><span class="line">return NO;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//* error = * error; //即不变</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下解释原因摘自：<a href="https://zhidao.baidu.com/question/484954523.html" target="_blank" rel="noopener">ios中处理错误为什么传递的是&amp;error，而不是error？</a></p><blockquote><p>因为 需要将error 传入后修改其值，然后再返回来，返回来后还要保证己经修改过了。</p><p>&amp;error传入是传的地址引用，传入后处理函数直接访问变量的地址，可以修改其值再返回同一个地址， 调用函数就可以知道值是否有修改，即是否有错。</p><p>而error传入是传的值引用，值引用传入到程序栈中后其实是把原来的值复制了一份传过去，处理函数可以修改，但无法将改后的值传出函数体。</p></blockquote><h4 id="5、指针和引用的区别"><a href="#5、指针和引用的区别" class="headerlink" title="5、指针和引用的区别"></a>5、指针和引用的区别</h4><p>(1)定义和性质的区别<br>①指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；<br>②而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。<br>简单点说：一个是存地址，一个是变量别名<br>（2）指针和引用作为函数参数进行传递时的区别<br>①用指针传递参数，可以实现对实参进行改变的目的，是因为传递过来的是实参的地址<br>②引用作为函数参数进行传递时，实质上传递的是实参本身，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。</p><p></p><p id="内存"></p><p></p><h2 id="二、内存"><a href="#二、内存" class="headerlink" title="二、内存"></a>二、内存</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><h4 id="1、堆和栈的区别"><a href="#1、堆和栈的区别" class="headerlink" title="1、堆和栈的区别?"></a>1、堆和栈的区别?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一、堆栈空间分配区别：</span><br><span class="line">1、栈（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；</span><br><span class="line">2、堆（操作系统）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</span><br><span class="line"></span><br><span class="line">二、堆栈缓存方式区别：</span><br><span class="line">1、栈使用的是一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放；</span><br><span class="line">2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</span><br></pre></td></tr></table></figure><h2 id="八、谈谈内存管理、内存泄露、循环引用"><a href="#八、谈谈内存管理、内存泄露、循环引用" class="headerlink" title="八、谈谈内存管理、内存泄露、循环引用"></a>八、谈谈内存管理、内存泄露、循环引用</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>ARC已经出来很久了，自动释放内存的确很方便，但是并非绝对安全绝对不会产生内存泄露。</p><h3 id="1、内存管理"><a href="#1、内存管理" class="headerlink" title="1、内存管理"></a>1、内存管理</h3><h5 id="1-、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？"><a href="#1-、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？" class="headerlink" title="(1)、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？"></a>(1)、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？</h5><p>答案是：当对象没有被任何变量引用（也可以说是没有指针指向该对象）的时候，就会被释放。</p><h5 id="2-、那怎么知道对象已经没有被引用了呢？"><a href="#2-、那怎么知道对象已经没有被引用了呢？" class="headerlink" title="(2)、那怎么知道对象已经没有被引用了呢？"></a>(2)、那怎么知道对象已经没有被引用了呢？</h5><p>ObjC采用引用计数（reference counting）的技术来进行管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）每个对象都有一个关联的整数，称为引用计数器；</span><br><span class="line">2）当代码需要使用该对象时，则将对象的引用计数加1；</span><br><span class="line">3）当代码结束使用该对象时，则将对象的引用计数减1；</span><br><span class="line">4）当引用计数的值变为0时，表示对象没有被任何代码使用，此时对象将被释放。</span><br></pre></td></tr></table></figure><p>与之对应的消息发送方法如下：</p><table><thead><tr><th>对象操作</th><th>OC中对应的方法</th><th>引用计数的变化</th></tr></thead><tbody><tr><td>当对象被创建时</td><td>alloc/new/copy/mutableCopy等</td><td>+1</td></tr><tr><td>持有对象</td><td>retain</td><td>+1</td></tr><tr><td>释放对象</td><td>release</td><td>-1</td></tr><tr><td>废弃对象</td><td>dealloc</td><td>-</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）当对象被创建（通过alloc、new或copy/mutableCopy等方法）时，其引用计数初始值为1；</span><br><span class="line">2）给对象发送retain消息，其引用计数加1；</span><br><span class="line">3）给对象发送release消息，其引用计数减1；</span><br><span class="line">4）当对象引用计数归0时，ObjC給对象发送dealloc消息销毁对象</span><br><span class="line">当创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1；</span><br><span class="line">在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1；</span><br><span class="line">需要释放一个对象时，就将该对象的引用计数减1；</span><br><span class="line">直至对象的引用计数为0，对象的内存会被立刻释放。</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">// 执行后，引用计数 = 1 </span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n 引用计数 = %lu \n 对象内存 = %p \n object指针内存地址 = %x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[object retainCount], object, &amp;object);</span><br><span class="line">    <span class="keyword">self</span>.property = object;<span class="comment">// 执行后，引用计数 = 2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n 引用计数 = %lu \n 对象内存 = %p \n object指针内存地址 = %x \n property指针内存地址 = %x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[object retainCount], object, &amp;object, &amp;_property);</span><br><span class="line">    [object release];<span class="comment">// 执行后，引用计数 = 1 </span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n 引用计数 = %lu \n 对象内存 = %p \n object指针内存地址 = %x \n property指针内存地址 = %x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[object retainCount], object, &amp;object, &amp;_property);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要释放强引用指向的对象时，需要保证所有指向对象强引用置为 nil。<code>__strong</code> 修饰符是 id 类型和对象类型默认的所有权修饰符。</p><p><code>__weak</code> 表示弱引用，对应定义 <code>property</code> 时用到的 weak。弱引用不会影响对象的释放，而当对象被释放时，所有指向它的弱引用都会自定被置为 nil，这样可以防止野指针。</p><h3 id="2、如何监测内存泄漏"><a href="#2、如何监测内存泄漏" class="headerlink" title="2、如何监测内存泄漏"></a>2、如何监测内存泄漏</h3><p>如果内存管理不当，势必会造成内存泄露。那我们如何快速的来找出内存泄露呢？以前我们可能会使用Instruments来监测，但是我们会发现使用Instruments特别繁琐，而且不一定能定位到内存泄露。</p><p>所以这里伟大的Facebook工程师们开源了一些自动化工具来解决监测内存泄露问题：FBRetainCycleDetector、FBAllocationTracker、FBMemoryProfiler。详情查看<a href="http://www.cocoachina.com/ios/20160419/15954.html" target="_blank" rel="noopener">在iOS上自动检测内存泄露</a></p><h6 id="你在开发大型项目时-如何进行内存泄露检测的"><a href="#你在开发大型项目时-如何进行内存泄露检测的" class="headerlink" title="你在开发大型项目时,如何进行内存泄露检测的?"></a>你在开发大型项目时,如何进行内存泄露检测的?</h6><blockquote><p>instruments下有个leaks工具，启动此工具后，运行项目，工具里可以显示内存泄露的情况，双击可找到源码位置，可以帮助进行内存泄露的处理。</p></blockquote><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A0%E4%BF%AE%E9%A5%B0%E8%AF%8D/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A0%E4%BF%AE%E9%A5%B0%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-①语言Swift"><a href="#必备知识架构-①语言Swift" class="headerlink" title="必备知识架构-①语言Swift"></a>必备知识架构-①语言Swift</h1><p>[Toc]</p><h2 id="一、Copy"><a href="#一、Copy" class="headerlink" title="一、Copy"></a>一、Copy</h2><ol><li><p>如何让自己的类用<code>copy</code>修饰符</p><blockquote><p>若想令自己所写的对象具有拷贝功能，则需实现<code>NSCopying</code>协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现<code>NSCopying</code>与<code>NSMutableCopying</code>协议。<br>具体步骤：<br>1.需声明该类遵从<code>NSCopying</code>协议<br>2.实现<code>NSCopying</code>协议的方法，具体区别<a href="https://www.jianshu.com/p/f84803356cbb" target="_blank" rel="noopener">戳这里</a></p></blockquote></li></ol><ul><li><code>NSCopying</code>协议方法为：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">  MyObject *<span class="keyword">copy</span> = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone: zone] init];</span><br><span class="line">  <span class="keyword">copy</span>.username = <span class="keyword">self</span>.username;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">copy</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、浅拷贝和深拷贝的区别"><a href="#1、浅拷贝和深拷贝的区别" class="headerlink" title="1、浅拷贝和深拷贝的区别"></a>1、浅拷贝和深拷贝的区别</h3><blockquote><p><strong>浅层复制：只复制指向对象的指针，而不复制引用对象本身。</strong><br><strong>深层复制：复制引用对象本身。</strong></p><p>意思就是说我有个A对象，复制一份后得到A_copy对象后,</p><p>对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。<br>而对于深复制就好理解了,内存中存在了两份独立对象本身。</p><p>通俗的话将就是：<br>浅复制好比你和你的影子，你完蛋，你的影子也完蛋;<br>深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。</p></blockquote><h3 id="2、-iOS-Copy-与-MutableCopy"><a href="#2、-iOS-Copy-与-MutableCopy" class="headerlink" title="2、 iOS - Copy 与 MutableCopy"></a>2、 iOS - Copy 与 MutableCopy</h3><p><a href="http://www.jianshu.com/p/63239d4d65e0" target="_blank" rel="noopener">iOS - Copy 与 MutableCopy</a><br>①copy：因为<strong>copy默认返回的是不可变的</strong>，所以当我们对一个不可变的字符串进行copy的时候，我们只是拷贝了它的指针（浅拷贝）。当我们对一个可变的字符串进行拷贝的时候，因为类型转变了，我们需对其进行深拷贝。<br>②<strong>mutableCopy：默认返回的是一个可变的对象</strong>，适用于可变的对象，例如NSMutableString，NSMutableArray，NSMutableDictionary、etc。  无论对于可变的字符串还是不可变的字符串进行mutableCopy，系统都默认进行深拷贝。</p><p><a href="https://www.jianshu.com/p/700f58eb0b86" target="_blank" rel="noopener">其他参考</a></p><h4 id="1-、copy到底是深拷贝还是浅拷贝？"><a href="#1-、copy到底是深拷贝还是浅拷贝？" class="headerlink" title="(1)、copy到底是深拷贝还是浅拷贝？"></a>(1)、copy到底是深拷贝还是浅拷贝？</h4><p>当我们对一个不可变对象（NSString类型）使用copy关键字的时候，系统是不会产生一个新对象，因为原来的对象是不能修改的，拷贝出来的对象也是不能修改的，那么既然两个都不可以修改，所以这两个对象永远也不会影响到另一个对象（符合我们说的“修改新（旧）对象，不影响旧（新）对象”原则），系统为了节省内存，所以就不会产生一个新的对象了。那么问题来了，<strong>copy到底是深拷贝还是浅拷贝？答：是否是深浅拷贝，是否创建新的对象，是由程序运行的环境所造成的，并不是一概而论。</strong></p><h4 id="2-、这个写法会出什么问题-property-nonatomic-copy-NSMutableArray-mutableArray"><a href="#2-、这个写法会出什么问题-property-nonatomic-copy-NSMutableArray-mutableArray" class="headerlink" title="(2)、这个写法会出什么问题@property (nonatomic, copy) NSMutableArray *mutableArray;"></a>(2)、这个写法会出什么问题<code>@property (nonatomic, copy) NSMutableArray *mutableArray;</code></h4><blockquote><p>添加，删除，修改数组内元素的时候，程序会因为找不到对应的方法而崩溃。原因：</p><p>self.mutableArray = xxx；在copy的修饰下执行的是 self.mutableArray = [xxx copy]；进行了浅拷贝，导致在运行的时候，其实mutableArray是NSArray类。从而在添加，删除，修改数组内元素的时候，程序会因为找不到对应的方法而崩溃。</p></blockquote><h3 id="3、为什么NSArray用copy修饰、NSMutableArray用strong修饰"><a href="#3、为什么NSArray用copy修饰、NSMutableArray用strong修饰" class="headerlink" title="3、为什么NSArray用copy修饰、NSMutableArray用strong修饰"></a>3、为什么NSArray用copy修饰、NSMutableArray用strong修饰</h3><blockquote><p>把NSMutableArray用copy修饰有时就会crash，因为copy后的数组变成了不可变数组NSArray.当你对不可变数组NSArray进行增删改操作的时候就会crash，<br>举例如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①NSMutableArray用copy属性造成的crash：</span><br><span class="line">@property (nonatomic, copy) NSMutableArray *aArray;</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *bArray;</span><br><span class="line"></span><br><span class="line">NSMutableArray *mArray = [NSMutableArray array];</span><br><span class="line">self.aArray = mArray;// 此时得到的aArray，是通过[mArray copy]进行的深拷贝得到的一个不可变新对象，即类型在执行时候变为了 NSArray了。所以，如果相对归属为NSArray了的aArray执行NSMutableArray才有的如removeAllObjects的方法时，就会崩溃。</span><br><span class="line">self.bArray = mArray;</span><br></pre></td></tr></table></figure><p><strong>当修饰可变类型的属性时，如NSMutableArray、NSMutableDictionary、NSMutableString，用strong。</strong></p><p><strong>当修饰不可变类型的属性时，如NSArray、NSDictionary、NSString，用copy。</strong></p><h3 id="4、模型数组深拷贝"><a href="#4、模型数组深拷贝" class="headerlink" title="4、模型数组深拷贝"></a>4、模型数组深拷贝</h3><p>通常需要实现对模型的拷贝都需要先实现<code>NSCopying、 NSMutableCopying</code>协议。注意：如果是数组使用拷贝操作是不会对数组内实现copy协议的对象进行深拷贝的。</p><p>参考文章：<a href="https://www.jianshu.com/p/a75fc0677036" target="_blank" rel="noopener">iOS 模型数组深拷贝</a></p><p>1、最笨的方法就是通过遍历逐个拷贝元素</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (Person *person <span class="keyword">in</span> dataSourceAry) &#123;</span><br><span class="line">    [array addObject:[person <span class="keyword">copy</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、也有人使用归档解档实现数组内部元素拷贝</p><p>3、这么好用的一个方法现在才发现（推荐）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithArray:(<span class="built_in">NSArray</span>&lt;ObjectType&gt; *)array copyItems:(<span class="built_in">BOOL</span>)flag</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> &lt;Person *&gt;*deepCopyAry = [[<span class="built_in">NSArray</span> alloc]initWithArray:dataSourceAry copyItems:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"&lt;dataSourceAry: %@&gt;"</span>, dataSourceAry);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"&lt;deepCopyAry: %@&gt;"</span>, deepCopyAry);</span><br><span class="line">    </span><br><span class="line">[deepCopyAry enumerateObjectsUsingBlock:^(Person *obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    obj.name = <span class="string">@"弗兰克"</span>;</span><br><span class="line">    obj.dog.name = <span class="string">@"弗兰克的dog"</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="4、分析NSString、NSMutableString等类的copy、mutableCopy"><a href="#4、分析NSString、NSMutableString等类的copy、mutableCopy" class="headerlink" title="4、分析NSString、NSMutableString等类的copy、mutableCopy"></a>4、分析NSString、NSMutableString等类的copy、mutableCopy</h3><blockquote><p>在语言文章中，我们已经说明对于语句<code>NSString *obj = [[NSData alloc] init];</code> obj在编译时是NSString的类型；运行时是NSData类型的对象。</p><p>由此得出的结论是，不要被编译时的类型蒙蔽，还要看实际运行时的类型。</p></blockquote><h6 id="1-、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？"><a href="#1-、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？" class="headerlink" title="(1)、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？"></a>(1)、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？</h6><blockquote><p>你可以片面理解为</p><p><code>copy</code>是[NSString alloc]，所以生成的都是不可变的；<br><code>mutableCopy</code>是[NSMutableString alloc]，所以生成的都是可变的；</p></blockquote><p>所以以下代码的结果，即为代码中的注释一样</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;NSString *str1 = @&quot;test001&quot;;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;NSMutableString *str2 = [str1 copy];</span><br><span class="line">&gt;//编译时，str2是NSMutableString类型。因为是把str2声明为可变字符串，所以str2即为声明的可变字符串</span><br><span class="line">&gt;//运行时，str2是NSString类型。因为是copy，所以不管str1是可变不可变，str2都是不可变字符串</span><br><span class="line">&gt;</span><br><span class="line">&gt;NSMutableString *str3 = [str1 mutableCopy];</span><br><span class="line">&gt;//编译时，str3是NSMutableString类型。因为是把str3声明为可变字符串，所以str3即为声明的可变字符串</span><br><span class="line">&gt;//运行时，str3是NSMutableString类型。因为是mutableCopy，所以不管str1是可变不可变，str3都是可变字符串</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h6 id="2-、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？"><a href="#2-、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？" class="headerlink" title="(2)、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？"></a>(2)、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</h6><blockquote><p><code>copy</code>：对[string copy]是浅拷贝，即不会开辟新地址，而对[mutableString copy]是深拷贝，会开辟新地址。</p><p><code>mutableCopy</code>：不管是对[string mutableCopy]，还是对[mutableString mutableCopy]，都是深拷贝，都会开辟新地址。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)testCopy &#123;</span><br><span class="line">    NSString *testStr = [NSString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">    id copyedStr = [testStr copy];</span><br><span class="line">    id mutableCopyStr = [testStr mutableCopy];</span><br><span class="line">    NSLog(@&quot;===    对NSString变量进行copy、mutableCopy得到的地址和类型分别是    ===&quot;);</span><br><span class="line">    NSLog(@&quot;testStr        = %p, class: %@&quot;, testStr, NSStringFromClass([testStr class]));</span><br><span class="line">    NSLog(@&quot;copyedStr      = %p, class: %@&quot;, copyedStr, NSStringFromClass([copyedStr class]));</span><br><span class="line">    NSLog(@&quot;mutableCopyStr = %p, class: %@&quot;, mutableCopyStr, NSStringFromClass([mutableCopyStr class]));</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">    id copyedMutableStr = [testMutableStr copy];</span><br><span class="line">    id mutableCopyMutableStr = [testMutableStr mutableCopy];</span><br><span class="line">    NSLog(@&quot;=== 对NSMutableString变量进行copy、mutableCopy得到的地址和类型分别是 ===&quot;);</span><br><span class="line">    NSLog(@&quot;testMutableStr        = %p, class: %@&quot;, testMutableStr, NSStringFromClass([testMutableStr class]));</span><br><span class="line">    NSLog(@&quot;copyedMutableStr      = %p, class: %@&quot;, copyedMutableStr, NSStringFromClass([copyedMutableStr class]));</span><br><span class="line">    NSLog(@&quot;mutableCopyMutableStr = %p, class: %@&quot;, mutableCopyMutableStr, NSStringFromClass([mutableCopyMutableStr class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="/iOS/3必备知识架构/2内存/2内存-①修饰词/2内存-①基础/copy&amp;mutableCopy.jpg" alt="对NSString、NSMutableString变量进行copy、mutableCopy得到的地址和类型分别是"></p><p><strong>结论：分别对NSString、NSMutableString进行copy、mutableCopy操作，只有NSString copy是浅拷贝</strong>。</p></blockquote><h6 id="3-、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？-附：NSString用copy修饰是为什么"><a href="#3-、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？-附：NSString用copy修饰是为什么" class="headerlink" title="(3)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？(附：NSString用copy修饰是为什么)"></a>(3)、将NSString、NSMutableString变量赋值给<em>用copy、strong修饰</em>的<code>NSString</code>属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？(附：NSString用copy修饰是为什么)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *copyedStr;</span><br><span class="line">@property (nonatomic, strong) NSString *strongStr;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *copyedMutableStr;</span><br><span class="line">@property (nonatomic, strong) NSString *strongMutableStr;</span><br><span class="line"></span><br><span class="line">///将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候</span><br><span class="line">- (void)testCopy &#123;</span><br><span class="line">    NSString *testStr = [NSString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">    self.copyedStr = testStr;</span><br><span class="line">    self.strongStr = testStr;</span><br><span class="line">    NSLog(@&quot;===    将NSString变量赋值给用copy、strong修饰的NSString属性的时候    ===&quot;);</span><br><span class="line">    NSLog(@&quot;testStr   = %p&quot;, testStr);</span><br><span class="line">    NSLog(@&quot;copyedStr = %p&quot;, self.copyedStr);</span><br><span class="line">    NSLog(@&quot;strongStr = %p&quot;, self.strongStr);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">    self.copyedMutableStr = testMutableStr;</span><br><span class="line">    self.strongMutableStr = testMutableStr;</span><br><span class="line">    NSLog(@&quot;=== 将NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候 ===&quot;);</span><br><span class="line">    NSLog(@&quot;testMutableStr   = %p&quot;, testMutableStr);</span><br><span class="line">    NSLog(@&quot;copyedMutableStr = %p&quot;, self.copyedMutableStr);</span><br><span class="line">    NSLog(@&quot;strongMutableStr = %p&quot;, self.strongMutableStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="/iOS/3必备知识架构/2内存/2内存-①修饰词/2内存-①基础/copy1.jpg" alt="将NSString、NSMutableString赋值给用copy、strong修饰的NSString变量"></p></blockquote><p>可以看出，</p><p>①将NSString变量赋值给用copy、strong修饰的NSString属性的时候，不管是strong还是copy属性的对象，其指向的地址都是同一个，即为string指向的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *copyedStr;</span><br><span class="line">@property (nonatomic, strong) NSString *strongStr;</span><br><span class="line"></span><br><span class="line">NSString *testStr = [NSString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">self.copyedStr = testStr;</span><br><span class="line">self.strongStr = testStr;</span><br></pre></td></tr></table></figure><p>②将NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，</p><p>此时copy属性字符串<code>copyedMutableStr</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *copyedMutableStr;</span><br><span class="line"></span><br><span class="line">NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">self.copyedMutableStr = testMutableStr;</span><br></pre></td></tr></table></figure><p>深拷贝了testMutableStr字符串，并让copyedMutableStr对象指向这个字符串(即copyedMutableStr和testMutableStr只是对象值一样，但不是同一个了)。所以此时，我们如果去修改testMutableStr字符串的话，可以看到，我们用<code>@property (nonatomic, copy) NSString *copyedMutableStr;</code>修饰的<code>copyedMutableStr</code>能够不会因为其赋值源<code>testMutableStr</code>的改变而改变，也就保证了安全性。</p><p>而strong属性字符串<code>strongMutableStr</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *strongMutableStr;</span><br><span class="line"></span><br><span class="line">NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">self.strongMutableStr = testMutableStr;</span><br></pre></td></tr></table></figure><p>因为strongMutableStr与testMutableStr是指向同一对象，所以strongMutableStr的值也会跟随着改变；</p><p>综上：所以，<strong>在声明NSString属性时，到底是选择strong还是copy，可以根据实际情况来定。不过，一般我们将对象声明为NSString时，都不希望它改变(包括不希望赋值后，其他原来的值的改变会改变到它)，所以大多数情况下，我们建议用copy，以免因可变字符串的修改导致的一些非预期问题。</strong>使用copy来修饰无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本,这样更安全。</p><h6 id="4-、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSMutableString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？"><a href="#4-、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSMutableString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？" class="headerlink" title="(4)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSMutableString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？"></a>(4)、将NSString、NSMutableString变量赋值给用copy、strong修饰的<code>NSMutableString</code>属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSMutableString *copyedStr;</span><br><span class="line">@property (nonatomic, strong) NSMutableString *strongStr;</span><br><span class="line"></span><br><span class="line">NSString *testStr = [NSString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">self.copyedStr = testStr;</span><br><span class="line">self.strongStr = testStr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSMutableString *copyedMutableStr;</span><br><span class="line"></span><br><span class="line">NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">self.copyedMutableStr = testMutableStr;</span><br></pre></td></tr></table></figure><p><strong>2.自定义类如何让它具有copy功能?</strong><br>遵守NScoping协议，实现copywithzone方法即可.</p><h6 id="5-、自己代码实现copy修饰符，应该怎么写？？？？"><a href="#5-、自己代码实现copy修饰符，应该怎么写？？？？" class="headerlink" title="(5)、自己代码实现copy修饰符，应该怎么写？？？？"></a>(5)、自己代码实现copy修饰符，应该怎么写？？？？</h6><h4 id="4、NSCoding和NSCopy"><a href="#4、NSCoding和NSCopy" class="headerlink" title="4、NSCoding和NSCopy"></a>4、NSCoding和NSCopy</h4><p><a href="http://my.oschina.net/megan/blog/181463?p=1" target="_blank" rel="noopener">NSCoding和NSCopy</a></p><h6 id="1-、NSCoding的作用"><a href="#1-、NSCoding的作用" class="headerlink" title="(1)、NSCoding的作用"></a>(1)、NSCoding的作用</h6><p><a href="http://blog.csdn.net/qq5306546/article/details/9240283" target="_blank" rel="noopener">iOS通过NSCoding保存实体对象</a></p><p>很多时候我们都需要将对象序列化，比如将一个对象存入到NSUserDefault 里面去的时候，由于NSUserDefault支持存入的类型有限制，所以很多时候我们需要将NSObject类型的对象转换成NSData再存入进去。</p><h6 id="2-、NSCopy"><a href="#2-、NSCopy" class="headerlink" title="(2)、NSCopy"></a>(2)、NSCopy</h6><p>当你要进行对象拷贝的时候需要遵循NSCopy协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    id copy = [[[self class] alloc] init];</span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        [copy setId:[self.id copyWithZone:zone]];</span><br><span class="line">        [copy setNickName:[self.nickName copyWithZone:zone]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、-synthesize和-dynamic区别"><a href="#5、-synthesize和-dynamic区别" class="headerlink" title="5、@synthesize和@dynamic区别"></a>5、@synthesize和@dynamic区别</h4><p><a href="http://www.cnblogs.com/xiaodao/archive/2012/10/09/2716244.html" target="_blank" rel="noopener">@synthesize和@dynamic区别</a></p><p>在声明property属性后，有2种实现选择</p><ul><li>@synthesize</li></ul><p>编译器期间，让编译器自动生成getter/setter方法。当有自定义的存或取方法时，自定义会屏蔽自动生成该方法</p><ul><li>@dynamic</li></ul><p>告诉编译器，不自动生成getter/setter方法，避免编译期间产生警告，然后由自己实现存取方法，或存取方法在运行时动态创建绑定：主要使用在CoreData的实现NSManagedObject子类时使用，由Core Data框架在程序运行的时动态生成子类属性</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A0AutoRelease/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/2%E5%86%85%E5%AD%98/2%E5%86%85%E5%AD%98-%E2%91%A0AutoRelease/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-内存"><a href="#必备知识架构-内存" class="headerlink" title="必备知识架构-内存"></a>必备知识架构-内存</h1><p>[toc]</p><p>必看文章：</p><ul><li><a href="https://www.jianshu.com/p/1b66c4d47cd7" target="_blank" rel="noopener">AutoreleasePool的原理和实现</a></li></ul><p>什么是内存管理？是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。</p><p><strong>内存管理管理的是堆上的内存，栈上的内存并不需要我们管理。</strong></p><h2 id="说说内存管理"><a href="#说说内存管理" class="headerlink" title="说说内存管理"></a>说说内存管理</h2><p>我们知道，当不再使用一个对象时应该将其释放，但是在某些情况下，我们很难理清一个对象什么时候不再使用(比如self.name不止在一个方法里会被调用到的时候)，这可怎么办？ObjC提供autorelease方法来解决这个问题。</p><p>说到内存管理，我们就不得不提引用计数。当对象的引用计数为0，对象的内存就会被释放。</p><blockquote><p>引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。</p></blockquote><p>当我们在创建一个对象的实例并在堆上申请内存时，或者在其他对象中需要持有这个对象时，该对象的引用计数就会加1；<br>当代码结束使用该对象/释放对象时，则将对象的引用计数减1；而想要释放一个对象的内存，我们将该对象的引用计数减到0，即进行release到0。<br>在ARC的情况下，为了方便管理内存，它会有一个autorelease的东西，它省去了我们还要自己去执行release方法的操作。同时与autorelease相关的还有一个叫AutoreleasePool自动释放池。</p><p>通过autorelease，当给一个对象发送autorelease消息（类方法创建的对象系统会自动添加autorelease）时，对象在接收到autorelease消息后，它会被添加到了当前的自动释放池autoreleasepool中。在未来某个时间，当自动释放池被销毁时，会给池里所有的对象发送release消息将其释放(释放≠销毁)。如果自动释放池向对象发送release消息后对象的引用计数变为了0，则改对象就会被销毁，内存就会被回收。在释放前这个时间段内，对象还是可以使用的（<strong>注意1：autorelease不会改变对象的引用计数，release才改变引用计数</strong>）（<strong>注意2：自动释放池实质上只是在释放的时候给池中所有对象对象发送release消息，不保证对象一定会销毁，如果自动释放池向对象发送release消息后对象的引用计数仍大于1，对象就无法销毁。</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id array = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">此源代码等同于以下源码。</span><br><span class="line">id array = [[[NSMutableArray alloc] initWithCapacity:1] autorelease];</span><br></pre></td></tr></table></figure><p>所以AutoreleasePool的释放有如下两种情况。</p><ul><li><p>一是Autorelease对象是在当前的<strong>runloop</strong>迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop。（<strong>一定要回答到runloop</strong>）。那runloop什么时候结束呢？</p><blockquote><p>一个<code>RunLoop</code>包含若干个<code>Mode</code>，每个<code>Mode</code>包含若干个<code>Source</code>/<code>Timer</code>/<code>Observer</code>/<code>Port</code>。当启动一个<code>RunLoop</code>时会先指定一个<code>Mode</code>，检查指定<code>Mode</code>是否存在以及<code>Mode</code>中是否含有<code>Source</code>和<code>Timer</code>，如果<code>Mode</code>不存在或者<code>Mode</code>中无<code>Source</code>和<code>Timer</code>，认为该<code>Mode</code>是一个空的<code>Mode</code>，<code>RunLoop</code>就直接退出。</p></blockquote></li><li><p>二是手动调用AutoreleasePool的释放方法（drain方法）来销毁AutoreleasePool</p></li></ul><h2 id="AutoreleasePool（自动释放池）"><a href="#AutoreleasePool（自动释放池）" class="headerlink" title="AutoreleasePool（自动释放池）"></a>AutoreleasePool（自动释放池）</h2><h3 id="1、AutoreleasePool（自动释放池）介绍"><a href="#1、AutoreleasePool（自动释放池）介绍" class="headerlink" title="1、AutoreleasePool（自动释放池）介绍"></a>1、AutoreleasePool（自动释放池）介绍</h3><p><strong>AutoreleasePool（自动释放池）是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。</strong>即当我们创建了一个对象，并把他加入到了自动释放池中时，他不会立即被释放，会等到一次<code>runloop</code>结束或者作用域超出<code>autoreleasepool{}</code>之后再被释放。在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。</p><p>我们把<code>main.m</code>文件通过Xcode自带的xcrun命令，来编译成<a href="./2内存-①AutoRelease/main.cpp">main.cpp</a>文件</p><p>命令行如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator clang -rewrite-objc ./main.m</span><br></pre></td></tr></table></figure><p>可以在编译出来的cpp文件中，看到如下自动释放池的结构体如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; <span class="comment">// 构造函数</span></span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;<span class="comment">// 析构函数</span></span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>objc4</code>是我们通常说的Runtime源码，我们遇到的<code>libobjc.A.dylib</code>就是用它编译出来的。</p><p>源码查看，进入<a href="http://opensource.apple.com/source/" target="_blank" rel="noopener">http://opensource.apple.com/source/</a>搜索objc4，</p><p><img src="/iOS/3必备知识架构/2内存/2内存-①AutoRelease/image-20211103173107899-5931876.png" alt="image-20211103173107899"></p><h1 id="NSThread、NSRunLoop-和-NSAutoreleasePool三者之间的关系"><a href="#NSThread、NSRunLoop-和-NSAutoreleasePool三者之间的关系" class="headerlink" title="NSThread、NSRunLoop 和 NSAutoreleasePool三者之间的关系"></a>NSThread、NSRunLoop 和 NSAutoreleasePool三者之间的关系</h1><ul><li>NSThread 和 NSRunLoop是<code>一一对应</code>的关系</li><li>在NSRunLoop对象的每个<code>运行循环（event loop）</code>开始前，系统会自动创建一个autoreleasepool，并在<code>运行循环（event loop）</code>结束时<code>drain</code>掉这个pool，同时释放所有autorelease对象</li><li><code>autoreleasepool</code>只会对应<code>一个</code>线程，每个<code>线程</code>可能会对应<code>多个</code>autoreleasepool，比如autoreleasepool<code>嵌套</code>的情况</li></ul><ul><li>autorelease<code>本质</code>上就是<code>延迟</code>调用release方法</li><li>MRC环境，通过调用<code>[obj autorelease]</code>来<code>延迟</code>内存的释放</li><li>ARC环境，甚至可以<code>完全不知道</code>autorelease也能管理好内存</li></ul><p>看到这里有人可能会问，那到底延迟到什么时候执行呢？看完本文后，各位心中自然会有答案。</p><h5 id="3-、autorelease、autoreleasepool-自动释放池"><a href="#3-、autorelease、autoreleasepool-自动释放池" class="headerlink" title="(3)、autorelease、autoreleasepool(自动释放池)"></a>(3)、autorelease、autoreleasepool(自动释放池)</h5><h5 id="4-、autoreleasepool-自动释放池"><a href="#4-、autoreleasepool-自动释放池" class="headerlink" title="(4)、autoreleasepool(自动释放池)　　"></a>(4)、autoreleasepool(自动释放池)　　</h5><p>　　这里说到的自动释放池，顾名思义，就是一个池，这个池可以容纳对象，而且可以自动释放，这就大大增加了我们处理对象的灵活性。　　</p><h5 id="5-、autoreleasepool里面对象的内存什么时候释放"><a href="#5-、autoreleasepool里面对象的内存什么时候释放" class="headerlink" title="(5)、autoreleasepool里面对象的内存什么时候释放?"></a>(5)、autoreleasepool里面对象的内存什么时候释放?</h5><p>　　在runloop sleep的时候当前autoreleasePool drain（objc_autoreleasePoolPop） 掉，向里面的对象都发送release消息，建立一个新的autoreleasePool(objc_autoreleasePoolPush)。或者简单的说就是当@autoreleasepool结束时，里面的内存就会回收;</p><p>ARC时代，系统自动管理自己的autoreleasepool，runloop就是iOS中的消息循环机制，当一个runloop结束时系统才会一次性清理掉被autorelease处理过的对象，其实本质上说是在本次runloop迭代结束时清理掉被本次迭代期间被放到autorelease pool中的对象的。至于何时runloop结束并没有固定的duration。 </p><h5 id="6-、runloop、autorelease-pool以及线程之间的关系"><a href="#6-、runloop、autorelease-pool以及线程之间的关系" class="headerlink" title="(6)、runloop、autorelease pool以及线程之间的关系"></a>(6)、runloop、autorelease pool以及线程之间的关系</h5><p>每个线程(包含主线程)都有一个Runloop。对于每一个Runloop，系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个像callstack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</p><p>#####　(7)、自动释放池怎样创建</p><p>ObjC提供两种方法创建自动释放池：</p><p>方法一：使用NSAutoreleasePool来创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool * pool = [[NSAutoreleasePool alloc]init];</span><br><span class="line">//这里写代码</span><br><span class="line">[pool release];</span><br></pre></td></tr></table></figure><p>方法二：使用@autoreleasepool创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">//这里写代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动释放池创建后，就会成为活动的池子，释放池子后，池子将释放其所包含的所有对象。</p><p>以上两种方法推荐第一种，因为将内存交给ObjC管理更高效。</p><h5 id="8-、自动释放池使用注意"><a href="#8-、自动释放池使用注意" class="headerlink" title="(8)、自动释放池使用注意"></a>(8)、自动释放池使用注意</h5><blockquote><p>1）自动释放池实质上只是在释放的时候给池中所有对象对象发送release消息，不保证对象一定会销毁，如果自动释放池向对象发送release消息后对象的引用计数仍大于1，对象就无法销毁。</p><p>2）自动释放池中的对象会集中同一时间释放，如果操作需要生成的对象较多占用内存空间大，可以使用多个释放池来进行优化。比如在一个循环中需要创建大量的临时变量，可以创建内部的池子来降低内存占用峰值。</p><p>3）autorelease不会改变对象的引用计数</p></blockquote><h5 id="9-、自动释放池的应用-什么时候要用-autoreleasepool"><a href="#9-、自动释放池的应用-什么时候要用-autoreleasepool" class="headerlink" title="(9)、自动释放池的应用/什么时候要用@autoreleasepool"></a>(9)、自动释放池的应用/什么时候要用@autoreleasepool</h5><p>有些情况下，我们还是需要手动创建自动释放池，那么，什么时候呢？</p><p>苹果文档中的翻译如下：</p><ol><li>如果你正在编写不基于UI 框架的程序，比如命令行工具。</li><li>如果你编写的循环创建了很多临时对象。那么你可以在循环中使用自动释放池block，在下次迭代前处理这些对象。在循环中使用自动释放池block，有助于减少应用程序的内存占用。</li><li>你生成了一个辅助线程。 一旦线程开始执行你必须自己创建自动释放池。否则，应用将泄漏对象。</li></ol><p>按我的理解，最重要的使用场景，应该是有大量中间临时变量产生时，避免内存使用峰值过高，及时释放内存的场景。 </p><p>如在一个循环事件中，如果循环次数较大或者事件处理占用内存较大，就会导致内存占用不断增长，可能会导致不希望看到的后果。</p><p>举个例子，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSArray *urls = &lt;# An array of file URLs #&gt;;</span><br><span class="line">for (NSURL *url in urls) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSError *error;</span><br><span class="line">        NSString *fileContents = [NSString stringWithContentsOfURL:url</span><br><span class="line">                                         encoding:NSUTF8StringEncoding</span><br><span class="line">                                         error:&amp;error];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//或</span><br><span class="line">     for (int i = 0; i &lt; 100000; i ++) &#123;</span><br><span class="line">         @autoreleasepool &#123;</span><br><span class="line">             NSString * log  = [NSString stringWithFormat:@&quot;%d&quot;, i];</span><br><span class="line">             NSLog(@&quot;%@&quot;, log);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>如果这个for循环里不使用@autoreleasepool，虽然每个循环中生成的字符串对象都会放在自动释放池子中(假设是1号自动释放池)，但是这个1号自动释放池是需要等到循环事件结束时释放的。这时候由于循环太大，势必会造成在循环期间内存不增长。所以，这里我们需要使用@autoreleasepool，额外创建一个2号自动释放池，来使得在每个@autoreleasepool结束时，里面的临时变量都会回收，内存使用更加合理。</p><p>例子2：假如有2000张图片，每张1M左右，现在需要获取所有图片的尺寸，你会怎么做？<br>　　如果这样做</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 2000; i ++) &#123;</span><br><span class="line"> CGSize size = [UIImage imageNamed:[NSString stringWithFormat:@&quot;%d.jpg&quot;,i]].size;</span><br><span class="line"> //add size to array</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>　　用imageNamed方法加载图片占用Cache的内存，autoReleasePool也不能释放，对此问题需要另外的解决方法，当然保险的当然是双管齐下了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   for (int i = 0; i &lt; 2000; i ++) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">       CGSize size = [UIImage imageWithContentsOfFile:filePath].size;</span><br><span class="line">       //add siez to array</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><h6 id="自动释放池底层怎么实现"><a href="#自动释放池底层怎么实现" class="headerlink" title="自动释放池底层怎么实现?"></a>自动释放池底层怎么实现?</h6><blockquote><p>答:自动释放池以栈的形式实现:当你创建一个新的自动释放池时,它将被添加到栈顶.当一个对象收到发送autorelease消息时,他被添加到当前线程的处于栈顶的自动释放池中,当自动释放池被回收时,他们从栈中被删除,并且会给池子里面所有的对象都会做一次release操作</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/1%E8%AF%AD%E8%A8%80Common/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/1%E8%AF%AD%E8%A8%80Common/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-①语言"><a href="#必备知识架构-①语言" class="headerlink" title="必备知识架构-①语言"></a>必备知识架构-①语言</h1><p>[Toc]</p><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><p></p><p id="Objective-C与C++"></p><p></p><h2 id="面向对象-OOP"><a href="#面向对象-OOP" class="headerlink" title="面向对象(OOP)"></a>面向对象(OOP)</h2><p>面向对象的三个特性：封装、继承和多态。</p><blockquote><p>所谓封装，也就是把客观事物封装成抽象的类；</p><p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。(或者说是不同对象以自己的方式响应相同的消息的能力叫做多态。)</p></blockquote><p>继承的问题：如果架构工程师写父类，业务工程师实现子类。那么业务工程师很可能不清楚：哪些方法需要被覆盖重载，哪些不需要。如果子类没有覆重方法，而父类提供的只是空方法，就很容易出问题。如果子类在覆重的时候引入了其他不相关逻辑，那么子类对象就显得不够单纯，角色复杂了。</p><blockquote><p>多态面临的四个问题：</p><ul><li><p>父类有部分public的方法是不需要，也不允许子类覆重。</p><p>答：公司内部可以规定:<code>不允许覆盖重载父类中的方法</code>、<code>子类需要实现接口协议中的方法</code>。</p></li><li><p>父类有一些特别的方法是必须要子类去覆重的，在父类的方法其实是个空方法。</p></li><li><p>父类有一些方法即便被覆重，父类原方法还是要执行的。</p></li><li><p>父类有一些方法是可选覆重的，一旦覆重，则以子类为准。</p></li></ul></blockquote><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><h4 id="2、const-与define使用的区别"><a href="#2、const-与define使用的区别" class="headerlink" title="2、const 与define使用的区别"></a>2、const 与define使用的区别</h4><ul><li>define修饰的变量不指定类型,const的指定类型</li><li>defien修饰的变量每次引用都开辟一次内存,而const只有一份内存</li><li>如果修饰的是代码片段适合用define,如果修饰的是变量适合用const</li></ul><h4 id="6、nil-Nil-NULL-与-NSNull-的区别"><a href="#6、nil-Nil-NULL-与-NSNull-的区别" class="headerlink" title="6、nil, Nil,NULL 与 NSNull 的区别"></a>6、nil, Nil,NULL 与 NSNull 的区别</h4><ul><li>nil 指向一个<strong>对象的指针</strong>为空,在objc.h 的定义如下: <code>NSString *name = nil;</code></li><li>Nil 指向一个<strong>类的指针</strong>为空,定义如下: <code>Class aClass = Nil;</code></li><li>NULL 指向<strong>C类型的指针</strong>为空, 例如: <code>int*pInt = NULL;</code></li><li>NSNull 在Objective-C中是一个类,使用为生成一个空对象<code>[NSNull null];</code>，多用于集合(NSArray,NSDictionary)中值为空的对象</li></ul><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/1%E8%AF%AD%E8%A8%80Swift/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/1%E8%AF%AD%E8%A8%80Swift/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-①语言Swift"><a href="#必备知识架构-①语言Swift" class="headerlink" title="必备知识架构-①语言Swift"></a>必备知识架构-①语言Swift</h1><p>[Toc]</p><h2 id="一、iOS开发中使用OC和swift的对比"><a href="#一、iOS开发中使用OC和swift的对比" class="headerlink" title="一、iOS开发中使用OC和swift的对比"></a>一、iOS开发中使用OC和swift的对比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.import的类</span><br><span class="line">OC：某个只要要使用某个类就要将该类import。</span><br><span class="line">swift：如果是用户自己创建类，其他类无需import可以直接使用。pod的一些三方类和系统的一些类，在使用的时候需要import</span><br></pre></td></tr></table></figure><p>Guard语句的语法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> expression <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//语句</span></span><br><span class="line">    <span class="comment">//必须包含一个控制语句：return，break，continue或throw。</span></span><br><span class="line">&#125;</span><br><span class="line">这里，expression是一个布尔表达式（返回<span class="literal">true</span>或者<span class="literal">false</span>）。</span><br><span class="line">如果对表达式求值<span class="literal">false</span>，<span class="keyword">guard</span>则执行代码块内的语句。</span><br><span class="line">如果对表达式求值<span class="literal">true</span>，<span class="keyword">guard</span>则从执行中跳过代码块内的语句</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="literal">false</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Condition not met"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Condition met"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、【iOS】Swift和OC协议的区别？为何Swift是面向协议的？"><a href="#二、【iOS】Swift和OC协议的区别？为何Swift是面向协议的？" class="headerlink" title="二、【iOS】Swift和OC协议的区别？为何Swift是面向协议的？"></a>二、【iOS】Swift和OC协议的区别？为何Swift是面向协议的？</h2><p><a href="https://blog.csdn.net/hanrovey/article/details/106636624" target="_blank" rel="noopener">【iOS】Swift和OC协议的区别？为何Swift是面向协议的？</a></p><p>相比于OC，Swift 可以做到协议方法的具体实现，而 OC 则不行。</p><blockquote><p>OC中协议<code>（Protocol）</code>类似一个类的接口，只声明，不实现。<br>只能定义公用的一套接口，但不能提供具体的实现方法。也就是说，它只告诉你要做什么，但具体怎么做不关心。具体的实现要在遵守这个协议的类中实现。</p></blockquote><h3 id="OC的Protocol与继承的区别"><a href="#OC的Protocol与继承的区别" class="headerlink" title="OC的Protocol与继承的区别"></a>OC的Protocol与继承的区别</h3><p>继承连同方法的实现也继承了，而protocol只有声明没有实现；<br>protocol能够作用到不同类型的类上。</p><h3 id="OC的Protocol与Category的区别"><a href="#OC的Protocol与Category的区别" class="headerlink" title="OC的Protocol与Category的区别"></a>OC的Protocol与Category的区别</h3><p><code>Category</code>可以给一个类扩充方法，既有申明也有实现；而<code>Protocol</code>只有声明，没有实现。<br> 同：<code>Category</code>和<code>Protocol</code>都可以声明方法，不能声明属性。</p><h2 id="Swift-面试题解"><a href="#Swift-面试题解" class="headerlink" title="Swift 面试题解"></a>Swift 面试题解</h2><h3 id="的作用"><a href="#的作用" class="headerlink" title="?? 的作用"></a>?? 的作用</h3><p>可选值的默认值, 当可选值为nil 的时候, 会返回后面的值. 如<br><code>let someValue = optional1 ?? 0</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/Runtime/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/Runtime/</url>
      
        <content type="html"><![CDATA[<h1 id="Runtime-Interview"><a href="#Runtime-Interview" class="headerlink" title="Runtime_Interview"></a>Runtime_Interview</h1><p>Runtime</p><p>前言：</p><p>  Objective C的runtime技术功能非常强大，能够在运行时获取并修改类的各种信息，包括获取方法列表、属性列表、变量列表，修改方法、属性，增加方法，属性等等，本文对相关的几个要点做了一个小结。</p><p>目录：</p><p>（1）使用class_replaceMethod/class_addMethod函数在运行时对函数进行动态替换或增加新函数</p><p>（2）重载forwardingTargetForSelector，将无法处理的selector转发给其他对象</p><p>（3）重载resolveInstanceMethod，从而在无法处理某个selector时，动态添加一个selector</p><p>（4）使用class_copyPropertyList及property_getName获取类的属性列表及每个属性的名称</p><p>  (5) 使用class_copyMethodList获取类的所有方法列表</p><h4 id="一些参考"><a href="#一些参考" class="headerlink" title="一些参考"></a>一些参考</h4><p><a href="http://www.cnblogs.com/yswdarren/p/3619303.html" target="_blank" rel="noopener">Objective C运行时（runtime）技术总结</a></p><p>需求1、当项目中，需要继承某一个父类，但是父类中并没有提供我们需要的调用方法，一般情况下，这种时候，我们可能会再派生一个类，或者会直接为这个类写一个分类（category），在这个分类中，我们可以新增或者替换某个方法（注意：不推荐在分类中重写方法，而且也无法通过 super 来获取所谓父类的方法）。大致在这两种情况下，我们可以通过 class_addMethod 来实现我们想要的效果。</p><p>先从一个场景问题带出吧，比如一个应用都是继承于UIViewController，刚开始时候不要求要转屏，到后面才决定加上旋转屏适配，这个时候如果我们去创建一个父类，并让去修改每个类的继承这个方法显然是效率太低了。而且有时候，我们也不想多创个父类，于是我们就只能决定一次过替换掉这些controller里的viewWillAppear:和 willAnimateRotationToInterfaceOrientation:duration:，换成自己的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class clazz = object_getClass((id)self);</span><br><span class="line">        </span><br><span class="line">        //将系统的resolveInstanceMethod替换成自己的myResolveInstanceMethod，而系统的resolveInstanceMethod方法就是当运行时对象调用了一个找不到的方法的时候系统会去寻找的机制。</span><br><span class="line">        [clazz swizzleMethod:@selector(resolveInstanceMethod:) withMethod:@selector(myResolveInstanceMethod:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  用什么方法替换掉什么方法</span><br><span class="line"> *</span><br><span class="line"> *  @param origSel  原方法选择子</span><br><span class="line"> *  @param aftSel   新方法选择子</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)swizzleMethod:(SEL)origSel withMethod:(SEL)aftSel &#123;</span><br><span class="line">//通过class_getInstanceMethod()拿到对应的Method</span><br><span class="line">    Method originMethod = class_getInstanceMethod(self, origSel);</span><br><span class="line">    Method newMethod = class_getInstanceMethod(self, aftSel);</span><br><span class="line">    </span><br><span class="line">    if(originMethod &amp;&amp; newMethod)&#123; //必须两个Method都要拿到</span><br><span class="line">    //class_addMethod将本来不存在于被操作的Class里的newMethod的实现添加在被操作的Class里，并使用origSel作为其选择子</span><br><span class="line">        if(class_addMethod(self, origSel, method_getImplementation(newMethod),method_getTypeEncoding(newMethod))) &#123;</span><br><span class="line">        //当addMethod成功完成后，利用class_replaceMethod换掉method_getImplaementation(oiginMethod)的选择子，将原方法的实现的SEL换成新方法的SEL:aftSel，ok目的达成了。想一想，现在通过旧方法SEL来调用，就会实现新方法的IMP，通过新方法的SEL来调用，就会实现旧方法的IMP。</span><br><span class="line">            class_replaceMethod(self, aftSel, method_getImplementation(originMethod), method_getTypeEncoding(originMethod));</span><br><span class="line">        &#125;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/1%E8%AF%AD%E8%A8%80-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/1%E8%AF%AD%E8%A8%80-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-①语言-消息转发"><a href="#必备知识架构-①语言-消息转发" class="headerlink" title="必备知识架构-①语言-消息转发"></a>必备知识架构-①语言-消息转发</h1><ol><li>什么时候会报<code>unrecognized selector</code>的异常</li></ol><ul><li><p>当调用该对象上某个方法，而该对象上没有实现这个方法的时候。可以通过<code>消息转发</code>进行解决，流程见下图</p><p><img src="https:////upload-images.jianshu.io/upload_images/1948913-f236e31f679fe683.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/597" alt="img"></p><p>image</p></li><li><p><code>OC</code>在向一个对象发送消息时，<code>runtime</code>库会根据对象的<code>isa</code>指针找到该对象实际所属的类，然后<strong>在该类中的方法列表以及其父类方法列表中寻找方法运行，如果在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常<code>unrecognized selector sent to XXX</code></strong><br><strong>但是在这之前，OC的运行时会给出三次拯救程序崩溃的机会</strong></p></li><li><p>Method resolution（消息动态解析）<br><code>OC</code>运行时会调用<code>+resolveInstanceMethod:</code>或者<code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则，运行时就会移到下一步，消息转发（<code>Message Forwarding</code>）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写 resolveInstanceMethod: 添加对象方法实现</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="comment">// 如果是执行 run 函数，就动态解析，指定新的 IMP</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"run:"</span>)) &#123;</span><br><span class="line">        <span class="comment">// class: 给哪个类添加方法</span></span><br><span class="line">        <span class="comment">// SEL: 添加哪个方法</span></span><br><span class="line">        <span class="comment">// IMP: 方法实现 =&gt; 函数 =&gt; 函数入口 =&gt; 函数名</span></span><br><span class="line">        <span class="comment">// type: 方法类型：void用v来表示，id参数用@来表示，SEL用:来表示</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)runMethod, <span class="string">"v@:@"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新的 run 函数</span></span><br><span class="line"><span class="keyword">void</span> runMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSNumber</span> *meter) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"跑了%@"</span>, meter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Fast forwarding（消息接受者重定向）<br>  如果目标对象实现了<code>-forwardingTargetForSelector:</code>，<code>Runtime</code>这时就会调用这个方法，给你把这个消息<strong>转发给其他对象</strong>的机会。只要这个方法返回的不是<code>nil</code>和<code>self</code>，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续<code>Normal Fowarding</code>。 这里叫<code>Fast</code>，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个<code>NSInvocation</code>对象，所以相对更快点</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息接受者重定向</span></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="meta">@selector(run:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[Person alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="comment">// 返回 Person 对象，让 Person 对象接收这个消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Normal forwarding（消息重定向）<br>这一步是<code>Runtime</code>最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回<code>nil</code>，<code>Runtime</code>则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，<code>Runtime</code>就会创建一个<code>NSInvocation</code>对象并发送<code>-forwardInvocation:</code>消息给目标对象</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取函数的参数和返回值类型，返回签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(aSelector) isEqualToString:<span class="string">@"run:"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:@"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息重定向</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="comment">// 从 anInvocation 中获取消息</span></span><br><span class="line">    SEL sel = anInvocation.selector;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"run:"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 1\. 指定当前类的一个方法作为IMP</span></span><br><span class="line">        <span class="comment">// anInvocation.selector = @selector(readBook:);</span></span><br><span class="line">        <span class="comment">// [anInvocation invoke];</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2\. 指定其他类来执行这个IMP</span></span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        <span class="comment">// 判断 Person 对象方法是否可以响应 sel</span></span><br><span class="line">        <span class="keyword">if</span>([p respondsToSelector:sel]) &#123;</span><br><span class="line">            <span class="comment">// 若可以响应，则将消息转发给其他对象处理</span></span><br><span class="line">            [anInvocation invokeWithTarget:p];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若仍然无法响应，则报错：找不到响应方法</span></span><br><span class="line">            [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    [<span class="keyword">super</span> doesNotRecognizeSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>既然<code>-forwardingTargetForSelector:</code>和<code>-forwardInvocation:</code>都可以将消息转发给其他对象处理，那么两者的区别在哪？</strong><br>区别就在于<code>-forwardingTargetForSelector:</code>只能将消息转发给一个对象。而<code>-forwardInvocation:</code>可以把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。修改消息的target，selector，参数等。将消息转发给多个对象</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/1%E8%AF%AD%E8%A8%80-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91NSProxy/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/1%E8%AF%AD%E8%A8%80-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91NSProxy/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-①语言-消息转发2"><a href="#必备知识架构-①语言-消息转发2" class="headerlink" title="必备知识架构-①语言-消息转发2"></a>必备知识架构-①语言-消息转发2</h1><p>[toc]</p><h2 id="一、NSProxy"><a href="#一、NSProxy" class="headerlink" title="一、NSProxy"></a>一、NSProxy</h2><p>NSProxy，你可以通过继承它，并重写它的以下两个方法以实现消息转发到另一个实例。说白了，NSProxy专为代理而生（<strong>负责将消息转发到真正的target的代理类</strong>）。从类名来看是代理类，专门负责代理对象转发消息的。相比NSObject类来说NSProxy更轻量级，<strong>通过NSProxy可以帮助Objective-C间接的实现多重继承的功能</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel;</span><br></pre></td></tr></table></figure><h3 id="1、通过NSProxy可以帮助Objective-C间接的实现多重继承的功能的例子"><a href="#1、通过NSProxy可以帮助Objective-C间接的实现多重继承的功能的例子" class="headerlink" title="1、通过NSProxy可以帮助Objective-C间接的实现多重继承的功能的例子"></a>1、通过NSProxy可以帮助Objective-C间接的实现多重继承的功能的例子</h3><p>现在比较流行的说法是用它来模拟多重继承，大致过程就是让它Hold住/包含你要实现多继承的类的对象，然后被hold住的对象的行为定义在接口中，并让Proxy去实现这些接口。然后再转发的时候把消息转发到实现了该接口的对象去执行，这样就好像实现了多重继承一样。<strong>注意</strong>：这个真不是多重继承，只是包含，然后把消息路由到指定的对象而已，其实完全可以用NSObject类来实现。</p><p>天使=人+鸟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [Person new];</span><br><span class="line">Bird *bird = [Bird new];</span><br><span class="line"></span><br><span class="line">id angelProxy = [AngelProxy proxyForObject1:person object2:bird];</span><br><span class="line">[proxy speak];// 人可以说话</span><br><span class="line">[proxy fly];// 鸟可以飞</span><br></pre></td></tr></table></figure><p>另一个例子：<a href="https://www.cnblogs.com/vokie/p/9289958.html" target="_blank" rel="noopener">NSProxy的学习使用</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// AngelProxy.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface AngelProxy : NSProxy</span><br><span class="line"></span><br><span class="line">+ (id)proxyForObject1:(id)obj1 object2:(id)obj2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// AngelProxy.m</span><br><span class="line">#import &quot;AngelProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@interface AngelProxy()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id target1;</span><br><span class="line">@property (nonatomic, weak) id target2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AngelProxy</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithTarget1:(id)obj1 target2:(id)obj2 &#123;</span><br><span class="line">    _target1 = obj1;</span><br><span class="line">    _target2 = obj2;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)proxyForObject1:(id)obj1 object2:(id)obj2 &#123; </span><br><span class="line">    return [[AngelProxy alloc] initWithTarget1:obj1 target2:obj2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重写NSProxy如下两个方法，在处理消息转发时，将消息转发给真正的Target处理</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    id target;</span><br><span class="line">    if ([_target1 methodSignatureForSelector:invocation.selector]) &#123;</span><br><span class="line">        target = _target1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        target = _target2;</span><br><span class="line">    &#125;</span><br><span class="line">    [invocation invokeWithTarget:target];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">    NSMethodSignature *sig;</span><br><span class="line">    </span><br><span class="line">    sig = [_target1 methodSignatureForSelector:selector];</span><br><span class="line">    if (sig) &#123;</span><br><span class="line">        return sig;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sig = [_target2 methodSignatureForSelector:selector];</span><br><span class="line">    return sig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="2、NSProxy-和-NSObject-的比较"><a href="#2、NSProxy-和-NSObject-的比较" class="headerlink" title="2、NSProxy 和 NSObject 的比较"></a>2、NSProxy 和 NSObject 的比较</h3><p>相比NSObject，NSProxy更轻量级，做消息转发效率更高。</p><p>NSObject寻找方法顺序：本类-&gt;(父类-)&gt;(动态方法解析)-&gt; 消息转发；<br>NSproxy顺序：本类-&gt;消息转发</p><h3 id="3、NSProxy的用途"><a href="#3、NSProxy的用途" class="headerlink" title="3、NSProxy的用途"></a>3、NSProxy的用途</h3><ol><li><p>AOP面向切片编程</p><p>iOS中面向切片编程一般有两种方式 ，一个是直接基于runtime 的method-Swizzling.还有一种就是基于NSProxy</p></li><li><p>解决NSTimer, CADisplayLink等强引用target引起的无法释放问题。如NSTimer:利用消息转发来断开NSTimer对象与视图之间的强引用关系。初始化NSTimer时把触发事件的target替换成一个单独的对象，然后这个对象中NSTimer的SEL方法触发时让这个方法在当前的视图self中实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.timer = [NSTimer timerWithTimeInterval:1 target:self.proxy </span><br><span class="line">              selector:@selector(timerEvent) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br><span class="line">// 这里我们timer的target使用AYProxy对象，它会实现你这个timer想要实现的timerEvent消息转发给self。从而避免了循环引用</span><br></pre></td></tr></table></figure><p>协议类代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#import</span><br><span class="line"></span><br><span class="line">@interface AYProxy : NSProxy</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id obj;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;AYProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation AYProxy</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">   NSMethodSignature *sig = nil;</span><br><span class="line">   sig = [self.obj methodSignatureForSelector:aSelector];</span><br><span class="line">   return sig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">   [anInvocation invokeWithTarget:self.obj];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>多重继承</p><p>实现类似CAAnimation类族.</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/1%E8%AF%AD%E8%A8%80-%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AANSURLProtocol/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/1%E8%AF%AD%E8%A8%80-%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AANSURLProtocol/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-①语言-请求拦截NSURLProtocol"><a href="#必备知识架构-①语言-请求拦截NSURLProtocol" class="headerlink" title="必备知识架构-①语言-请求拦截NSURLProtocol"></a>必备知识架构-①语言-请求拦截NSURLProtocol</h1><p>[toc]</p><h2 id="一、NSURLProtocol"><a href="#一、NSURLProtocol" class="headerlink" title="一、NSURLProtocol"></a>一、NSURLProtocol</h2><p>如果开发者自定义的一个 NSURLProtocol 并且注册到 app 中，那么在这个自定义的 NSURLProtocol 中我们可以拦截所有的请求(（注意，不只是webView内的请求，而是整个app内的所有请求）)，进行修改，或者修改 response。即NSURLProtocol这个东西的作用可以让我们在app的内部拦截一切url请求。</p><p><strong>「或者这么说吧： NSURLProtocol 就是一个苹果允许的中间人攻击。」</strong></p><p>注意事项：</p><p>如果我们顺序注册 A B C 三个 Protocol，那么一个 connection 在发送的时候，处理的顺序是 C B A，而且最多只有一个 Protocol 会触发处理。</p><p>拦截 UIWebview 的请求，会有被拒的风险。</p><p>附：</p><blockquote><p>iOS的Foundation框架提供了 URL Loading System 这个库(后面简写为ULS)，所有基于URL（例如http://，https:// ,ftp://这些应用层的传输协议)的协议都可以通过ULS提供的基础类和协议来实现。而ULS库里提供了一个强有力的武器 NSURLProtocol。</p></blockquote><h2 id="NSURLProtocol能做什么？"><a href="#NSURLProtocol能做什么？" class="headerlink" title="NSURLProtocol能做什么？"></a>NSURLProtocol能做什么？</h2><p>举几个例子：</p><ul><li>全局网络请求设置：我们的APP内的所有请求都需要增加公共的头，像这种我们就可以直接通过NSURLProtocol来实现，当然实现的方式有很多种</li><li>自定义 Response （过滤敏感信息）</li><li>再比如我们需要将APP某个API进行一些访问的统计</li><li>再比如我们需要统计APP内的网络请求失败率</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/1%E8%AF%AD%E8%A8%80/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/1%E8%AF%AD%E8%A8%80/1%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-①语言"><a href="#必备知识架构-①语言" class="headerlink" title="必备知识架构-①语言"></a>必备知识架构-①语言</h1><p>[Toc]</p><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><p></p><p id="目录"></p><p></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#Objective-C">一、为什么说Objective-C是一门动态的语言？</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、为什么说Objective-C是一门动态的语言</span><br><span class="line">①、概念介绍</span><br><span class="line">②、Objective-c的动态性</span><br><span class="line">Objective-C 可以通过Runtime 这个运行时机制，在运行时动态的添加变量、方法、类等，所以说Objective-C 是一门动态的语言。</span><br><span class="line">ObjC之所以说是面向Runtime的语言，最重要的特征是其消息传递机制。</span><br><span class="line">Objective-C的动态性，主要体现在3个方面：动态类型、动态绑定、动态载入。</span><br><span class="line">&gt;</span><br><span class="line">2、消息转发</span><br><span class="line">3、为什么说 Objective-C 没有真正的私有方法和私有变量</span><br><span class="line">4、消息结构</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#Runtime">二、Runtime</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、浅谈runtime运行时机制</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><a href="KVC与KVO">三、KVC与KVO</a></p></li><li><p><a href="Objective-C与C++">四、Objective-C与C++</a></p></li><li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、#import、#include、@class](#import、#include、@class</span><br><span class="line">2、const 与define使用的区别</span><br><span class="line">3、==、 isEqualToString、isEqual区别</span><br><span class="line">4、字符串的比较</span><br><span class="line">5、isMemberOfClass 和 isKindOfClass 的联系和区别</span><br><span class="line">6、nil, Nil,NULL 与 NSNull 的区别</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p></p><p id="Objective-C"></p><p></p><h2 id="一、为什么说Objective-C是一门动态的语言？"><a href="#一、为什么说Objective-C是一门动态的语言？" class="headerlink" title="一、为什么说Objective-C是一门动态的语言？"></a>一、为什么说Objective-C是一门动态的语言？</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><h4 id="问：我们说的OC是动态运行时语言是什么意思？"><a href="#问：我们说的OC是动态运行时语言是什么意思？" class="headerlink" title="问：我们说的OC是动态运行时语言是什么意思？"></a>问：我们说的OC是动态运行时语言是什么意思？</h4><blockquote><p>1、之所以叫做动态，是因为必须到运行时(run time)才会做一些事情。主要是将数据类型的确定由编译时，【推迟到了运行时】。简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。</p><p><code>所以说NSString *obj = [[NSData alloc] init] 在编译时是NSString类型，在运行时是NSData类型。</code></p><p>2、另外，OC还可以通过Runtime 这个运行时机制，在运行时【动态的添加】变量、方法、类等。</p></blockquote><h4 id="1、Objective-C是一门”动态”的语言，动态语言是什么意思？"><a href="#1、Objective-C是一门”动态”的语言，动态语言是什么意思？" class="headerlink" title="1、Objective-C是一门”动态”的语言，动态语言是什么意思？"></a>1、Objective-C是一门”动态”的语言，动态语言是什么意思？</h4><p>OC中的对象，都是用指针表示<br>OC中方法的调用，是基于消息机制实现</p><h6 id="①、”动态”概念介绍"><a href="#①、”动态”概念介绍" class="headerlink" title="①、”动态”概念介绍"></a>①、”动态”概念介绍</h6><blockquote><p>（1）动态类型语言：动态类型语言是指<strong>在运行期间才去做数据类型检查</strong>的语言，Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。（自己概括为动态语言指的是不需要在编译时确定所有的东西，在运行时还可以动态的添加变量、方法和类，而<strong>Objective-C 可以通过Runtime 这个运行时机制，在运行时动态的添加变量、方法、类等，所以说Objective-C 是一门动态的语言</strong>）</p><p>（2）静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。</p><figure class="highlight plain"><figcaption><span>*obj </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">###### ②、Objective-c的动态性</span><br><span class="line">Objective-C的动态性，让程序在运行时判断其该有的行为，而不是像c等静态语言在编译构建时就确定下来。**Objective-C的动态性主要体现在3个方面：动态类型、动态绑定、动态载入**。</span><br><span class="line"></span><br><span class="line">&gt; 以下内容来自：[OC是动态运行时语言是什么意思？什么是动态识别，动态绑定？](https://www.cnblogs.com/dxb123456/p/5525343.html)</span><br><span class="line">&gt; </span><br><span class="line">* 1.动态类型：如id类型。</span><br><span class="line">  &gt;</span><br><span class="line">  简单点的如id类型在编译器编译的时候是不能被识别的，要等到运行时(run time)，即程序运行的时候才会根据语境来识别。</span><br></pre></td></tr></table></figure></blockquote><p>  id obj = someInstance;<br>  if ([obj isKindOfClass:someClass]) {<br>    someClass <em>classSpecifiedInstance = (someClass </em>)obj;<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 2.动态绑定：</span><br><span class="line">  &gt;在OC中，其实是没有函数的概念的，我们叫“消息机制”，所谓的函数调用就是给对象发送一条消息。</span><br><span class="line">  **OC可以先跳过编译，在运行时才决定要调用什么方法，需要传什么参数进去，这就是动态绑定**。要实现他就必须用SEL变量绑定一个方法。最终形成的这个SEL变量就代表一个方法的引用。(这里要注意一点：SEL并不是C里面的函数指针，虽然很像，但真心不是函数指针。SEL变量只是一个整数，他是该方法的ID，@selector()就是取类方法的编号。以前的函数调用，是根据函数名，也就是 字符串去查找函数体。但现在，我们是根据一个ID整数来查找方法，整数的查找字自然要比字符串的查找快得多！所以，动态绑定的特定不仅方便，而且效率更高。)</span><br><span class="line"></span><br><span class="line">* 3.动态载入。</span><br><span class="line">  </span><br><span class="line">  &gt;根据需求加载所需要的资源，这点很容易理解，对于iOS开发来说，基本就是根据不同的机型做适配。最经典的例子就是在Retina设备上加载@2x的图片，而在老一些的普通屏设备上加载原图。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">笔试题：对于语句`NSString *obj = [[NSData alloc] init];` obj在编译时和运行时分别是什么类型的对象?</span><br><span class="line"></span><br><span class="line">  &gt; 答:编译时是NSString的类型；运行时是NSData类型的对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2、怎么理解Objective-C&quot;运行时&quot;</span><br><span class="line"></span><br><span class="line">基于Runtime的消息传递机制</span><br><span class="line"></span><br><span class="line">**ObjC之所以说是面向Runtime的语言，最重要的特征是其消息传递机制。</span><br><span class="line">什么是消息传递？消息传递不就和C语言的函数调用一个意思么?**</span><br><span class="line"></span><br><span class="line">&gt;在C语言中，我们调用函数时，必须先声明函数（或者自上而下），而实际上，声明函数就是获取函数地址，调用函数就是直接跳到地址执行，代码在被编译器解析、优化后，便是成为一堆汇编代码，然后连接各种库，完了生成可执行的代码（即是静态的）。</span><br><span class="line">&gt;</span><br><span class="line">&gt;在ObjC中，首先要搞清楚为什么不用Function Call 而用 Messaging 呢？一般调用函数（方法），讲的就是object对象，</span><br><span class="line">&gt;</span><br><span class="line">&gt;事情证明，在编译阶段，oc可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错，而c语言在编译阶段或报错</span><br><span class="line"></span><br><span class="line">###### </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 1，给分类添加属性</span><br><span class="line"></span><br><span class="line">OC分类不能添加属性，如果你在分类中添加了属性，编译器就会报警告。（记得导入 #import &lt;objc/runtime.h&gt;）</span><br><span class="line"></span><br><span class="line">// UIButton+CJMoreProperty.h</span><br><span class="line"></span><br><span class="line">![runtime添加属性](1语言/runtime_add1.png)</span><br><span class="line"></span><br><span class="line">//  UIButton+CJMoreProperty.m</span><br><span class="line">![runtime添加属性](1语言/runtime_add2.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为分类添加属性，就用运用到OC的运行时来解决。</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line">// 设置关联</span><br><span class="line">objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,</span><br><span class="line">                         id _Nullable value, objc_AssociationPolicy policy)</span><br><span class="line">// 通过关联获取属性</span><br><span class="line">objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)</span><br><span class="line">    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);</span><br></pre></td></tr></table></figure></p><p><img src="/iOS/3必备知识架构/1语言/1语言/runtime_add3.png" alt="runtime添加属性"></p><h4 id="2、消息转发"><a href="#2、消息转发" class="headerlink" title="2、消息转发"></a>2、消息转发</h4><p><strong>ObjC之所以说是面向Runtime的语言，最重要的特征是其消息传递机制</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Runtime的特性主要是消息(方法)传递，如果消息(方法)在对象中找不到，就进行转发。</span><br><span class="line">1.1系统首先找到消息的接收对象，然后通过对象的isa找到它的类。</span><br><span class="line">1.2在它的类中查找method_list，是否有selector方法。</span><br><span class="line">1.3没有则查找父类的method_list。</span><br><span class="line">1.4找到对应的method，执行它的IMP。</span><br><span class="line">1.5转发IMP的return值。</span><br><span class="line"></span><br><span class="line">如果找遍了父类，仍没找到方法，则报错。当然我们也可以通过消息转发，去其他类中寻找。</span><br></pre></td></tr></table></figure><p>延展：消息转发机制</p><blockquote><p><strong>因为在运行期还可以继续向类中添加方法，所以编译器在编译时还无法确定类中是否有某个方法的实现。对于类无法处理一个消息就会触发消息转发机制。</strong></p></blockquote><p>消息转发步骤(如果前一套方案实现后一套方法就不会执行)</p><blockquote><p>内容来自：<a href="http://www.cocoachina.com/ios/20150604/12013.html" target="_blank" rel="noopener">轻松学习之 Objective-C消息转发</a></p><p>方案一：首先，系统会调用resolveInstanceMethod(当然，如果这个方法是一个类方法，就会调用resolveClassMethod)让你自己为这个方法增加实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">if (sel == @selector(run)) &#123;</span><br><span class="line">class_addMethod(self, sel, (IMP)run, @&quot;v@:&quot;);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel</span><br></pre></td></tr></table></figure><blockquote></blockquote><p>方案二：如果不去对方案一的resolveInstanceMethod做任何处理，直接调用父类方法。可以看到，系统已经来到了forwardingTargetForSelector方法，这个方法返回你需要转发消息的对象。</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//返回你需要转发消息的对象</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">return [[Car alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote></blockquote><p>方案三：如果如果我们也不实现forwardingTargetForSelector，系统就会调用方案三的两个方法methodSignatureForSelector和forwardInvocation。其中methodSignatureForSelector用来生成方法签名，这个签名就是给forwardInvocation中的参数NSInvocation调用的。</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//生成方法签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">NSString *sel = NSStringFromSelector(selector);</span><br><span class="line">//判断你要转发的SEL</span><br><span class="line">if ([sel isEqualToString:@&quot;run&quot;]) &#123;</span><br><span class="line">//为你的转发方法手动生成签名</span><br><span class="line">return [NSMethodSignature signatureWithObjCType:@&quot;v@:&quot;];</span><br><span class="line">&#125;</span><br><span class="line">return [super methodSignatureForSelector:selector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 附：关于生成签名的类型&quot;v@:&quot;解释一下。每一个方法会默认隐藏两个参数，self、_cmd，self代表方法调用者，_cmd代表这个方法的SEL，签名类型就是用来描述这个方法的返回值、参数的，v代表返回值为void，@表示self，:表示_cmd。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">SEL selector = [anInvocation selector];</span><br><span class="line">//新建需要转发消息的对象</span><br><span class="line">Car *car = [[Car alloc] init];</span><br><span class="line">if ([car respondsToSelector:selector]) &#123;</span><br><span class="line">//唤醒这个方法</span><br><span class="line">[invocation invokeWithTarget:car];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息转发分为两大阶段：</p><blockquote><p>“动态方法解析”：先征询接收者，所属的类，能否动态添加方法，来处理这个消息，若可以则结束，如不能则继续往下走 </p><p>“完整的消息转发机制”：<br>请接收者看看有没其他对象能处理这条消息，若有，就把这个消息转发给那个对象然后结束<br>运行时系统会把与消息有关细节全部封装到NSInvocation 对象中，再给对象最后一次机会，令其设法解决当前还未处理的这条消息</p></blockquote><p>其他文章：<a href="https://blog.csdn.net/onlyou930/article/details/7449102" target="_blank" rel="noopener">NSInvocation简单使用</a></p><blockquote><p>在 iOS中可以直接调用 某个对象的消息 方式有2中<br>一种是performSelector:withObject:<br>再一种就是NSInvocation<br>第一种方式比较简单，能完成简单的调用。但是对于&gt;2个的参数或者有返回值的处理，那就需要做些额外工作才能搞定。那么在这种情况下，我们就可以使用NSInvocation来进行这些相对复杂的操作。<br>NSInvocation可以处理参数、返回值。会java的人都知道凡是操作，其实NSInvocation就相当于反射操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//如果此消息有参数需要传入，那么就需要按照如下方法进行参数设置，需要注意的是，atIndex的下标必须从2开始。原因为：0 1 两个参数已经被target 和selector占用</span><br><span class="line">if (strcmp(retType, @encode(BOOL)) == 0) &#123;</span><br><span class="line">        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSig];</span><br><span class="line">        [invocation setArgument:&amp;params atIndex:2];</span><br><span class="line">        [invocation setSelector:action];</span><br><span class="line">        [invocation setTarget:target];</span><br><span class="line">        [invocation invoke];</span><br><span class="line">        BOOL result = 0;</span><br><span class="line">        [invocation getReturnValue:&amp;result];</span><br><span class="line">        return @(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3、为什么说-Objective-C-没有真正的私有方法和私有变量"><a href="#3、为什么说-Objective-C-没有真正的私有方法和私有变量" class="headerlink" title="3、为什么说 Objective-C 没有真正的私有方法和私有变量"></a>3、为什么说 Objective-C 没有真正的私有方法和私有变量</h4><blockquote><p>以下内容摘自：<a href="https://www.jianshu.com/p/ef25a31e3112" target="_blank" rel="noopener">为什么说 Objective-C 没有真正的私有方法和私有变量</a></p><p>私有的定义：私有是指只能够在本类内部使用或访问，但是不能在类的外部被访问。</p><p><strong>在 Objective-C 中，对象调用方法是以发送消息的形式实现的</strong>。所有方法的调用最终都会转化为发送消息的形式，原型如下：</p><p>id objc_msgSend(id self, SEL op, …)</p><p>Objective-C 为什么能够实现访问「私有方法」呢？其实这跟 Objective-C 语言的动态特性有密切的关系，对象在运行的时候才会去查找方法。Objective-C 对象有一个 isa 指针指向其父类，在向该实例发送消息的时候，若它自己不能识别回到父类中去查找该消息。</p><p>综上，OC中其实并无真正意义上的的私有方法和私有属性。但是在实际使用中，我们应遵守规则，不能调用的方法，不调用。</p></blockquote><h4 id="4、消息结构"><a href="#4、消息结构" class="headerlink" title="4、消息结构"></a>4、消息结构</h4><p>Objective-C 使用的是 “消息结构” 并非 “函数调用”。（使用消息结构的的语言，其运行时所应执行的代码由运行期决定；而使用函数调用的语言，则由编译器决定）</p><blockquote><p>以下内容摘自：<a href="https://blog.csdn.net/dan_163/article/details/38268957" target="_blank" rel="noopener">OC消息机制和动态运行时</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class</span><br><span class="line">&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class super_class;     //父类</span><br><span class="line">    const char* name;    //类名</span><br><span class="line">    long version;            //版本信息</span><br><span class="line">    long info;                 //类信息</span><br><span class="line">    long instance_size;                                    //实例大小</span><br><span class="line">    struct objc_ivar_list *ivars;                        //实例参数链表</span><br><span class="line">    struct objc_method_list *methodLists;     //方法链表</span><br><span class="line">    struct objc_cache *cache;                         //方法缓存</span><br><span class="line">    struct objc_protocol_list *protocols;        //协议链表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p id="Runtime"></p><p></p><h2 id="二、Runtime"><a href="#二、Runtime" class="headerlink" title="二、Runtime"></a>二、Runtime</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>Runtime 4种用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1)替换系统方法,[数组越界苹果就会直接crash](http://blog.csdn.net/u012103785/article/details/50817876)</span><br><span class="line">2)字典转model,</span><br><span class="line">3)归档, </span><br><span class="line">4)万能控制器跳转</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/zzzzzdddddxxxxx/article/details/53542441" target="_blank" rel="noopener">你会遇到的runtime面试题（详）</a></p><h6 id="OBJC-ASSOCIATION-ASSIGN造成的崩溃"><a href="#OBJC-ASSOCIATION-ASSIGN造成的崩溃" class="headerlink" title="OBJC_ASSOCIATION_ASSIGN造成的崩溃"></a>OBJC_ASSOCIATION_ASSIGN造成的崩溃</h6><p>objc_setAssociatedObject 关联对象的学习<br>为<code>CJKeyboardAvoidingTableView</code>增加<code>cjKeyboardAvoidingOffset</code>属性的时候，使用OBJC_ASSOCIATION_ASSIGN而造成崩溃，参考FDTemplateLayoutCell源码，改成使用OBJC_ASSOCIATION_RETAIN，问题解决。原因是</p><p>详情查询：<a href="https://www.cnblogs.com/someonelikeyou/p/7162613.html" target="_blank" rel="noopener">objc_setAssociatedObject 关联对象的学习</a></p><h4 id="1、浅谈runtime运行时机制"><a href="#1、浅谈runtime运行时机制" class="headerlink" title="1、浅谈runtime运行时机制"></a>1、浅谈runtime运行时机制</h4><p><a href="http://www.cnblogs.com/guoxiao/p/3583432.html" target="_blank" rel="noopener">浅谈runtime运行时机制02-runtime简单使用</a></p><p>OC是运行时语言，只有在程序运行时，才会去确定对象的类型，并调用类与对象相应的方法。利用runtime机制让我们可以在程序运行时动态修改类、对象中的所有属性、方法。</p><p><a href="http://blog.csdn.net/liujinlongxa/article/details/46293705" target="_blank" rel="noopener">iOS运行时初探-使用运行时机制向Category中添加属性</a></p><p>在一般情况下，我们是不能向Category中添加属性的，只能添加方法，但有些情况向，我们确实需要向Category中添加属性。而且很多系统的API也有一些在Category添加属性的情况，例如我们属性的UITableView的section和row属性，就是定义在一个名为NSIndexPath的分类里的，如下：<br><img src="http://img.blog.csdn.net/20150531230308155" alt="使用运行时机制向Category中添加属性"><br>那这到底是怎么实现的呢？</p><h1 id="load-initialize的区别"><a href="#load-initialize的区别" class="headerlink" title="+load +initialize的区别"></a>+load +initialize的区别</h1><p> \1. load方法只会调用一次</p><p> \2. +(void)load方法:程序一运行就会把所有的类加载进内存,调用这个方法</p><p>   (表叙:只要程序一运行,就会调用类的load方法,目的:把这个类加载进内存)</p><p> \3. <strong>load是只要类所在文件被引用就会被调用,而initialize是在类或者其子类的第一个方法被调用前调用,所以没有被引用进项目,就不会调用load方法,但即使类文件只被引用进来,而没有使用,那么initialize也不会被调用</strong></p><ul><li><p>+load方法的调用是在main() 函数之前。load 方法内部一般用来实现 Method Swizzle（面向切面AOP变成）</p><blockquote><p>调用main() 函数之前的什么时候？答：+load方法会再这个类或者其分类被添加到运行时的时候调用。</p><p>附：所有类的 load 方法都会被调用，先调用父类、再调用子类，多个分类会按照Compile Sources 顺序加载。</p></blockquote></li><li><p>initialize一般在main()函数之后。Initialize方法一般用来初始化全局变量或者静态变量。</p><blockquote><p>问是在main() 函数之后的什么时候？答：在第一次主动使用当前类的时候。</p><p>附：initialize一般在main()函数之后的情况是什么？A类的 load 方法中调用 B 类的类方法，导致在调用A的Load 方法之前，会先调用一下B类的initialize 方法，但是B类的load 方法还是按照 Compile Source 顺序进行加载</p><p>附2：Initialize 方法会被覆盖，子类父类分类中只会执行一个</p></blockquote></li><li><p>load和initialize都不能主动调用。</p></li><li><p>initialize不是init，initialize在程序运行过程中，它会在你程序中每个类调用仅一次initialize。这个调用的时间发生在你的类接收到消息之前，但是在它的父类接收到initialize之后。<br>init则是你手动初始化几次就调用几次，和普通方法一样</p></li></ul><p></p><p id="KVC与KVO"></p><p></p><h2 id="三、KVC与KVO"><a href="#三、KVC与KVO" class="headerlink" title="三、KVC与KVO"></a>三、KVC与KVO</h2><h3 id="1、KVO"><a href="#1、KVO" class="headerlink" title="1、KVO"></a>1、KVO</h3><p><a href="http://blog.csdn.net/yuquan0821/article/details/6646400/" target="_blank" rel="noopener">KVO的概述与使用</a>内容如下</p><p>一、概述</p><p>KVO,即键值观察者（key-value-observing），它提供一种观察者的机制，当指定的对象的属性被修改后，则对象就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了。</p><p>二、KVO原理</p><p>　　当某个类的对象第一次被观察时，系统在运行时会创建该类的派生类，该派生类中重写了该对象的setter方法，并且在setter方法中实现了通知的机制。派生类重写了class方法，以“欺骗”外部调用者他就是原先那个类。系统将这个类的isa指针指向新的派生类，因此改对象也就是新的派生类的对象了。因而该对象调用setter就会调用重写的setter，从而激活键值通知机制。此外派生类还重写了delloc方法来释放资源。</p><p>三、使用方法</p><p>系统框架已经支持KVO，所以程序员在使用的时候非常简单。</p><ol><li>注册，指定被观察者的属性，</li><li>实现回调方法</li><li>移除观察</li></ol><p>四，实例:</p><p>假设一个场景,股票的价格显示在当前屏幕上，当股票价格更改的时候，实时显示更新其价格。</p><h3 id="2、KVC"><a href="#2、KVC" class="headerlink" title="2、KVC"></a>2、KVC</h3><p> KVC 就是键值编码（key-value-coding)</p><p>KVC 的主要作用：</p><p>（1）通过键值路径为对象的属性赋值。主要是可以为私有的属性赋值。</p><p>（2）通过键值路径获取属性的值。主要是可以通过key获得私有属性的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// valueForKeyPath:（多级访问，不仅可以对当前对象属性进行赋值，也可以对“深层”对象的属性进行取值）</span><br><span class="line">Person *person1 = [[Person alloc] init];</span><br><span class="line">person1.name = @&quot;李四&quot;;</span><br><span class="line">person1.car.name = @&quot;BMW&quot;;</span><br><span class="line">NSString *carName = [person valueForKeyPath:@&quot;car.name&quot;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 当集合中元素类型一致，可以通过KVC的getter方法valueForKeyPath：来获取所有集合元素中的属性，生成一个新的元素属性集合。（这里的集合一般为NSArray，NSSet，不包括NSDictionary）</span><br><span class="line">  NSArray *personArray = [NSArray arrayWithObjects:person1, nil];</span><br><span class="line"></span><br><span class="line">NSArray *personNameArray = [personArray valueForKeyPath:@&quot;name&quot;];</span><br><span class="line">NSArray *carNameArray = [personArray valueForKeyPath:@&quot;car.name&quot;];</span><br></pre></td></tr></table></figure><p>其他参考资料：</p><ul><li><a href="https://www.cnblogs.com/huadeng/p/7064382.html" target="_blank" rel="noopener">KVC与KVO</a></li><li><a href="https://www.jianshu.com/p/45cbd324ea65" target="_blank" rel="noopener">KVC是怎么寻找Key的</a></li></ul><p></p><p id="Objective-C与C++"></p><p></p><h2 id="四、Objective-C和C"><a href="#四、Objective-C和C" class="headerlink" title="四、Objective-C和C++"></a>四、Objective-C和C++</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><h4 id="1、Objective-C与C-之间的差异"><a href="#1、Objective-C与C-之间的差异" class="headerlink" title="1、Objective-C与C++之间的差异"></a>1、Objective-C与C++之间的差异</h4><blockquote><p>最大的区别就是Objective C的成员函数调用是基于动态绑定的，类本身并没有限制对象可以有什么函数。相对于C++类会规定好成员有什么函数。这使得Objective C的灵活性很大，但是执行效率也很低。</p></blockquote><h4 id="2、Object-c的类可以多重继承么"><a href="#2、Object-c的类可以多重继承么" class="headerlink" title="2、Object-c的类可以多重继承么?"></a>2、Object-c的类可以多重继承么?</h4><p>答: Object-c的类不可以多重继承；</p><p>面向对象(OOP)</p><p>面向对象的三个特性：封装、继承和多态(没有继承就没有多态)。</p><blockquote><p>所谓封装，也就是把客观事物封装成抽象的类；</p><p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。</p></blockquote><p>没有继承就没有多态。代码的体现：父类类型的指针指向子类对象。</p><p>没使用多态前：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person.m</span><br><span class="line">- (<span class="keyword">void</span>)printWithBlack:(Printer *)printer &#123;  </span><br><span class="line">     [printer print];  </span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)printWithColor:(Printer *)printer &#123;</span><br><span class="line">     [printer print];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[person printWithBlack:blackPrint]; <span class="comment">//调用黑白打印机  </span></span><br><span class="line">[person printWithColor:colorPrint]; <span class="comment">//调用彩色打印机</span></span><br></pre></td></tr></table></figure><p>使用多态后：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person.m</span><br><span class="line">- (<span class="keyword">void</span>)print:(Printer *)printer &#123;  </span><br><span class="line">     [printer print];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时候：</span></span><br><span class="line">Printer *p1 = [[ColorPrinter alloc] init];  </span><br><span class="line">Printer *p2 = [[BlackPrinter alloc] init];  </span><br><span class="line"></span><br><span class="line">[person doPrint:p1];  </span><br><span class="line">[person doPrint:p2];</span><br></pre></td></tr></table></figure><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><h4 id="1、-import、-include、-class"><a href="#1、-import、-include、-class" class="headerlink" title="1、#import、#include、@class"></a>1、#import、#include、@class</h4><p>可参考：<a href="http://www.jianshu.com/p/7e0dee7f84b2" target="_blank" rel="noopener">#import、#include、@class、#import&lt;&gt;和#import””的区别</a></p><p>1、<code>#import</code>介绍：<br>In the C language, the #include pre-compile directive always causes a file’s contents to be inserted into the source. at that point, Objective-C has the equivalent #import directive except each file is included only once per compilation unit, obviating（去除） the need for include guards.</p><p>即在C语言中，<code>#include</code>预编译指令经常引起一个文件的被重复引用。基于这一点，OC有一个等价的预编译指令<code>#import</code>来防止文件重复导入。所以OC给出来的新的预处理指令import是防止重复导入，避免程序员去书写头文件卫士，降低程序员的负担。</p><p>2、#import和#include的异同点：</p><p>①#include是C语言中的，需要条件编译语句控制重复包含问题。</p><p>②在Objective-C中，#import是OC中对#include的改进版本，#import使得我们不需要写条件编译语句就可以确保引用的文件只会被包含一次，不会陷入递归版包含的问题。即<strong>import与#include比较的优点：会自动防止重复导入，使得不会引起交叉编译</strong></p><pre><code>#import不会引起交叉编译的问题。因为在Objective-C中会存在C/C++和Object-C混编的问题，如果用#include引入头文件，会导致交叉编译。</code></pre><p>举例：三个文件①文件A.h、②文件B.h、③文件C.h。其中文件C.h需要引入A.h、B.h,而文件B.h也需要引入文件A.h,这样在C.h中就重复引用了A.h两次，使用#import可以进行优化</p><p>3、#import和#include的相同点：</p><p>①都可以用在OC程序中起到导入文件的作用</p><p>②同样的 包含系统文件都是&lt;&gt;，是包本地文件都用””<br>例如：系统文件#import&lt;Foundation/Foundation.h&gt;, #include&lt;stdio.h&gt;<br>​     本地文件#import”test.h”, #include”test.h”</p><p>到底该如何选择使用呢<br>一般来说，你包含的是C语言中的文件就用#include，你用的是OC中的文件就用#import</p><p>4、<strong>#import与@class二者的区别</strong></p><blockquote><p>#import会链入该头文件的全部信息，包括实体变量和方法等；而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑。在头文件中， 一般只需要知道被引用的类的名称就可以了。不需要知道其内部的实体变量和方法，所以在头文件中一般使用@class来声明这个名称是类的名称。 而在实现类里面，因为会用到这个引用类的内部的实体变量和方法，所以需要使用#import来包含这个被引用类的头文件。</p></blockquote><p>附：@class能解决循环包含的问题：当两个类文件有循环依赖关系 (A引用B,B引用A)时，需要用@class</p><p>5、<strong>import&lt;&gt; 和 import””</strong><br>①&lt;&gt; : 引用系统文件，它用于对系统自带的头文件的引用，编译器会在系统文件目录下去查找该文件.</p><p>②””: 用户自定义的文件用双引号引用，编译器首先会在用户目录下查找，然后到安装目录中查</p><h4 id="4、字符串的比较"><a href="#4、字符串的比较" class="headerlink" title="4、字符串的比较"></a>4、字符串的比较</h4><blockquote><p><img src="/iOS/3必备知识架构/1语言/1语言/字符串compare.png" alt="字符串compare">;<br>字符串compare的比较是一个字符串一个字符串比较的，所以才会出现1814比860小的错误情况。</p></blockquote><h4 id="5、isMemberOfClass-和-isKindOfClass-的联系和区别"><a href="#5、isMemberOfClass-和-isKindOfClass-的联系和区别" class="headerlink" title="5、isMemberOfClass 和 isKindOfClass 的联系和区别"></a>5、isMemberOfClass 和 isKindOfClass 的联系和区别</h4><ul><li><p>联系:两者都能检测一个对象是不是某个类的成员</p></li><li><p>区别:isKindOfClass不仅能确定一个对象是不是某个类(即不算父类)的成员,也能确定一个对象是否是派生自该类的类的成员,而isMemberOfClass只能做到前者.</p></li></ul><p>a.为什么基本类型和C数据类型的修饰用assign？</p><p>因为基本数据类型不是对象，不需要引用计数，所以使用assign（附：在内存中创建和使用后，在一个方法体结束后就被删除。）。</p><h2 id="iOS-NS-CG-CF前缀代表什么意思"><a href="#iOS-NS-CG-CF前缀代表什么意思" class="headerlink" title="iOS NS/CG/CF前缀代表什么意思"></a>iOS NS/CG/CF前缀代表什么意思</h2><p>NS/CG/CF前缀代表什么意思。</p><p>回答：NS是前缀，代表它是来自Cocoa Foundation框架，这个框架是OC的基础库</p><blockquote><p>UI—UIKit框架，UI库<br>CF—Core Foundation框架<br>NS—Cocoa Foundation框架，OC的基础库。<br>CG—CoreGraphics.frameworks框架，用于渲染的库。<br>CA—CoreAnimation.frameworks框架</p></blockquote><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/10%E5%85%B6%E4%BB%96/%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84--%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/10%E5%85%B6%E4%BB%96/%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84--%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="知识架构–即时通信"><a href="#知识架构–即时通信" class="headerlink" title="知识架构–即时通信"></a>知识架构–即时通信</h1><p>以下内容摘自：<a href="https://blog.csdn.net/lybeen2007/article/details/49486439" target="_blank" rel="noopener">开发即时通信是选择UDP还是TCP协议</a></p><blockquote><p>大规模即时通讯软件的总体架构：</p><p>1。以UDP协议作为主要数据传输协议</p><p>2。服务端使用一个数据库保存信息（分布式数据库）</p><p>3。服务端是是分布式的，通过异步多线程技术，集群服务等 通过服务器集群共同运行服务端，对外进行海量信息处理（转发，暂存，广播消息）</p><p>4。客户端也属于分布式应用程序，具有一些服务端的功能 在进行语言，视频，文件传输的时候，可由服务端协调 在两个客户端直接进行点对点通信</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/0%E7%9B%AE%E5%BD%95/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/0%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构"><a href="#必备知识架构" class="headerlink" title="必备知识架构"></a>必备知识架构</h1><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><h1 id="2020年iOS面试反思总结–不断更新当中ing"><a href="#2020年iOS面试反思总结–不断更新当中ing" class="headerlink" title="2020年iOS面试反思总结–不断更新当中ing"></a>2020年iOS面试反思总结–不断更新当中ing</h1><p><a href="https://www.jianshu.com/p/c9b1c45f7c2a" target="_blank" rel="noopener">2020年iOS面试反思总结–不断更新当中ing</a></p><p></p><p id="目录"></p><p></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#Objective-C">一、为什么说Objective-C是一门动态的语言？</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><a href="#Runtime">二、Runtime</a></p></li><li><p><a href="#线程间的通信">一、谈谈你对线程间的通信的了解</a></p></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;线程间通信的体现:</span><br><span class="line">&gt;1. 一个线程传递数据给另一个线程</span><br><span class="line">&gt;2. 在一个线程中执行完特定任务后，转到另一个线程继续执行任务</span><br><span class="line">&gt;</span><br><span class="line">&gt;附：其他传值方法总结</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#二">二、线程等待(线程同步)、线程依赖问题</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、通常的做法/不合理的做法</span><br><span class="line">2、合理的做法（使用多线程异步执行）</span><br><span class="line">1)、先说说简单的多线程同步问题(异步线程里没有再开启异步线程)</span><br><span class="line">2)、真正的线程同步问题(异步线程里再开启异步线程)</span><br><span class="line">3)、其他补充</span><br><span class="line">附1：多个请求依次执行</span><br><span class="line">附2：并发数控制</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#三">三、线程安全问题</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#SDWebImage">四、多线程–第三方库SDWebImage</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、SDWebImage在图片下载及缓存的处理方法</span><br><span class="line">2、SDWebImageDownloader 异步的图片下载器</span><br><span class="line">3、SDWebImageDownloaderOperation 下载操作</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#HTTP请求">五、在一个https连接的网站里，输入账号密码点击登录后，到服务器返回这个请求前，中间经历了什么</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、一次完整的HTTP请求过程</span><br><span class="line">2、TCP三次握手</span><br><span class="line">3、TCP四次挥手</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#响应链及事件链">六、在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">附：整个响应链及事件链</span><br><span class="line">1、完善响应链查找知识点</span><br><span class="line">2、基础概念等详解</span><br><span class="line">2.1 响应者对象(UIResponder)</span><br><span class="line">2.2、UITouch(点击对象)</span><br><span class="line">2.2.1、UITouch的几个主要属性和方法</span><br><span class="line">2.2.2、UITouch的生成场景</span><br><span class="line">2.3、UIEvent(事件对象)</span><br><span class="line">3、响应链的应用</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#RunLoop">七、RunLoop</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、RunLoop概念</span><br><span class="line">&gt;</span><br><span class="line">2、RunLoop和线程的关系？</span><br><span class="line">&gt;</span><br><span class="line">3、RunLoop相关各类关系</span><br><span class="line">3.1 CFRunLoopSourceRef</span><br><span class="line">3.1.附 上题中button点击后，关于RunLoop的过程</span><br><span class="line">3.2 CFRunLoopTimerRef</span><br><span class="line">3.3 CFRunLoopObserverRef</span><br><span class="line">&gt;</span><br><span class="line">4、RunLoop的应用</span><br><span class="line">附：autoreleasepool 自动释放池</span><br><span class="line">runloop、autorelease pool以及线程之间的关系</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#内存">八、谈谈内存管理、内存泄露、循环引用</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、内存管理</span><br><span class="line">(1)、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？</span><br><span class="line">(2)、那怎么知道对象已经没有被引用了呢？</span><br><span class="line">(3)、autorelease、autoreleasepool(自动释放池)</span><br><span class="line">(4)、autoreleasepool(自动释放池)　</span><br><span class="line">(5)、autoreleasepool里面对象的内存什么时候释放? </span><br><span class="line">(6)、runloop、autorelease pool以及线程之间的关系</span><br><span class="line">(7)、自动释放池怎样创建</span><br><span class="line">(8)、自动释放池使用注意</span><br><span class="line">(9)、自动释放池的应用/什么时候要用@autoreleasepool</span><br><span class="line">&gt;</span><br><span class="line">2、如何监测内存泄漏</span><br><span class="line">&gt;</span><br><span class="line">3、循环引用</span><br><span class="line">(1)、NSTimer的循环引用</span><br><span class="line">(2)、block的循环引用</span><br><span class="line">(2.1)、Objective-C中block为何得用copy修饰，能否用其他</span><br><span class="line">(2.2)、block的循环引用</span><br><span class="line">(2.3)、判断该block是否会发生循环引用</span><br><span class="line">(2.4)、为什么masonry的block里引用self不需要weak？</span><br><span class="line">(3)、委托delegate的循环引用</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><a href="#NSTimer">九、NSTimer</a></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、NSTimer和NSRunLoop的关系？</span><br><span class="line">2、NSTimer使用细节</span><br><span class="line">3、NSTimer的创建</span><br><span class="line">4、NSTimer的循环引用</span><br><span class="line">5、NSTimer使用的优化</span><br><span class="line">6、NSTimer的销毁问题</span><br><span class="line">6.1子线程中NSTimer的创建和销毁问题</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>十一、谈谈设计模式</li><li>十二、如何优化过于臃肿的Controller</li><li>十三、谈谈性能优化(功耗)</li><li>十四、UITableView的优化、重用</li><li>十五、布局 layoutsubview、drawrect等</li><li>十六、有逼格的代码</li><li>十七、单元测试</li><li>十八、APP审核</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/10%E5%85%B6%E4%BB%96/10%E5%85%B6%E4%BB%962/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/10%E5%85%B6%E4%BB%96/10%E5%85%B6%E4%BB%962/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构"><a href="#必备知识架构" class="headerlink" title="必备知识架构"></a>必备知识架构</h1><ol><li><strong>CertificateSigningRequest</strong>：本地公钥。</li><li><strong>p12</strong>：本地私钥，可以导入到其他电脑。</li><li><strong>证书</strong>：内容是公钥或私钥，由其他机构对其签名组成的数据包。</li><li><strong>Entitlements</strong>：包含了 App 权限开关列表。</li><li><strong>Provisioning Profile</strong>：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。</li></ol><h1 id="iOS-App-签名的原理"><a href="#iOS-App-签名的原理" class="headerlink" title="iOS App 签名的原理"></a>iOS App 签名的原理</h1><ul><li><a href="http://blog.cnbang.net/tech/3386/" target="_blank" rel="noopener">iOS App 签名的原理</a> （非常好，非常详细的文章）</li></ul><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>四种方式安装一个APP的方式</p><ol><li>从 AppStore 下载</li><li>开发 App 时可以直接把开发中的应用安装进手机进行调试。</li><li>In-House 企业内部分发，可以直接安装企业证书签名后的 APP。</li><li>AD-Hoc 相当于企业分发的限制版，限制安装设备数量，较少用。</li></ol><p>区别：</p><p>App Store 下载的是Apple后台用私钥A对其进行重签名，</p><p>而其他的是用Xcode配置的对应该证书的本地私钥L对app进行签名。</p><h2 id="一、App-Store-下载的签名机制（最简单的签名）"><a href="#一、App-Store-下载的签名机制（最简单的签名）" class="headerlink" title="一、App Store 下载的签名机制（最简单的签名）"></a>一、App Store 下载的签名机制（最简单的签名）</h2><p>当App 提交审核通过后，Apple会对App重签名，所以从App Store下载的app都是苹果的官方签名。</p><p>流程如下：</p><p><img src="/iOS/3必备知识架构/10其他/10其他2/APP签名机制/APP签名机制1.png" alt="APP签名机制1" style="zoom:50%;"></p><p>1、Apple 官方有自己固定的一对公钥和私钥，私钥A存在Apple后台，公钥A存在iOS设备</p><p>2、app审核通过后，<strong>Apple后台用私钥A对其进行重签名</strong></p><p>3、app下载到iOS设备后，iOS设备内置的公钥A会对app的签名进行验证</p><p>4、如果验证通过，则可运行，否则不能</p><p>当然除了这个方式，还有一下三种方式安装一个app：</p><ol><li>开发时，直接通过USB将应用安装到手机进行调试；</li><li>In-House 企业内部分发，可直接安装企业证书签名的App；</li><li>Ad-Hoc 相当于企业分发的限制版，限制安装设备数量。</li></ol><p>①、KeyChain 里的“从证书颁发机构请求证书”，<strong>本地生成一对公私钥</strong>。（其中：公钥L是保存的CertificateSigningRequest(CSR)，而私钥L保存在电脑本地，可以导出为p12）</p><p>附：Apple 官方也有自己固定的一对公钥和私钥，私钥A存在Apple后台，公钥A内置在iOS设备</p><blockquote><p>（因为这里的这个私钥是本地Mac持有，所以团队开发时，可在KeyChain导出私钥，存为.p12文件，其他Mac即可导入这个私钥）</p></blockquote><p>2、在Member Center把CertificateSigningRequest上传到<strong>苹果后台生成证书</strong>（即上传之后Apple后台用Apple 官方自己固定的私钥A对我们上传的公钥L进行签名，将得到的<strong>签名+公钥L打包起来，称为证书</strong>），下载到本地。</p><blockquote><p>Apple 官方有自己固定的一对公钥和私钥，私钥A存在Apple后台，公钥A内置在iOS设备</p></blockquote><p>3、在Member Center配置AppID、添加设备UUID／Entitlements, <strong>生成app对应的 Provisioning Profile 文件</strong>，并下载到本地<br>4、在XCode中配置好证书，打包编译时，<strong>用Xcode配置的对应该证书的本地私钥L对app进行签名，并把 Provisioning Profile 文件一起打包进App去(文件名为 embedded.mobileprovision)</strong>。这里对App的签名数据分两部分，Mach-O 可执行文件把签名直接写进这个文件，其他资源文件则保存在_CodeSignature目录下</p><p>5、安装APP到手机上时，iOS设备内置的公钥A(指Apple官方自己固定的公钥)对embedded.mobileprovision的数字签名进行验证，同时对里面的证书的签名也会验证<br>如果验证通过，确保了embedded.mobileprovision的数据是苹果授权后，再取出里面数据做各种验证，包括公钥L对app签名进行验证，验证设备ID，AppID，权限开关。</p><h1 id="iOS-常见三种加密（MD5、非对称加密，对称加密）"><a href="#iOS-常见三种加密（MD5、非对称加密，对称加密）" class="headerlink" title="iOS-常见三种加密（MD5、非对称加密，对称加密）"></a>iOS-常见三种加密（MD5、非对称加密，对称加密）</h1><ul><li><a href="https://blog.csdn.net/ssy_1992/article/details/79094556" target="_blank" rel="noopener">iOS-常见三种加密（MD5、非对称加密，对称加密）</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/10%E5%85%B6%E4%BB%96/7%E5%85%B6%E4%BB%96/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/10%E5%85%B6%E4%BB%96/7%E5%85%B6%E4%BB%96/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构"><a href="#必备知识架构" class="headerlink" title="必备知识架构"></a>必备知识架构</h1><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><p></p><p id="目录"></p><p></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>十一、谈谈设计模式</li><li>十二、如何优化过于臃肿的Controller</li><li>十三、谈谈性能优化(功耗)</li><li>十四、UITableView的优化、重用</li><li>十五、布局 layoutsubview、drawrect等</li><li>十六、有逼格的代码</li><li>十七、单元测试</li><li><p>十八、APP审核</p></li><li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p></li><li><p><a href="#END">END</a></p></li></ul><p></p><p id="十一"></p><p></p><h2 id="十一、谈谈设计模式"><a href="#十一、谈谈设计模式" class="headerlink" title="十一、谈谈设计模式"></a>十一、谈谈设计模式</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote><p></p><p id="十二"></p><p></p><h2 id="十二、如何优化过于臃肿的Controller"><a href="#十二、如何优化过于臃肿的Controller" class="headerlink" title="十二、如何优化过于臃肿的Controller"></a>十二、如何优化过于臃肿的Controller</h2><blockquote><p>&lt; <a href="#目录">返回目录</a><br><a href="http://t.cn/REFMQaU" target="_blank" rel="noopener">如何优化过于臃肿的Controller</a></p></blockquote><p></p><p id="十三"></p><p></p><h2 id="十三、谈谈性能优化-功耗"><a href="#十三、谈谈性能优化-功耗" class="headerlink" title="十三、谈谈性能优化(功耗)"></a>十三、谈谈性能优化(功耗)</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote><ul><li><a href="http://www.cocoachina.com/ios/20171204/21413.html" target="_blank" rel="noopener">iOS进阶–App功耗优化看这篇就够了</a></li><li><a href="https://www.jianshu.com/p/4555704f9696" target="_blank" rel="noopener">iOS耗电量检测与优化</a></li></ul><h2 id="UITableView的优化、重用"><a href="#UITableView的优化、重用" class="headerlink" title="UITableView的优化、重用"></a>UITableView的优化、重用</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote><h2 id="布局-layoutsubview、drawrect等"><a href="#布局-layoutsubview、drawrect等" class="headerlink" title="布局 layoutsubview、drawrect等"></a>布局 layoutsubview、drawrect等</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote><h2 id="有逼格的代码"><a href="#有逼格的代码" class="headerlink" title="有逼格的代码"></a>有逼格的代码</h2><p><code>typedef NSString * NSRunLoopMode NS_EXTENSIBLE_STRING_ENUM;</code><br><a href="http://www.bubuko.com/infodetail-1899020.html" target="_blank" rel="noopener">提升自己逼格的编程之美之代码规范</a><br><a href="http://www.cocoachina.com/ios/20171123/21298.html" target="_blank" rel="noopener">iOS开发细节 | 通知怎么写？</a><br><a href="https://www.jianshu.com/p/6c44419eb059" target="_blank" rel="noopener">实现NS_ENUM的自定义反射</a></p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote><h2 id="APP审核"><a href="#APP审核" class="headerlink" title="APP审核"></a>APP审核</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote><p>如果一个页面被苹果拒回。那怎么通过审核。(参考<a href="http://www.cocoachina.com/bbs/read.php?tid=1731860" target="_blank" rel="noopener">金融类APP提交苹果审核，怎么避开5.2.1</a>)</p><p>答：</p><p>1.第一种是有后台控制壳什么时候出现。移动端传一个版本号给后台，后台根据版本号判断App否在审核，在审核就显示壳，不在审核就显示原生界面。</p><p>2.直接由移动端来切换界面。此时App需要登录才能看到主界面，对给苹果审核人员的测试账号做一个判断，如果是测试账号，就显示壳，非测试账号显示原生界面。 </p><p>其中：</p><p>第一种方式用户进来就可以看到主界面，更有利于吸引自然流量，但是如果苹果后期复查，发现了用户使用的App跟审核的不一样，会被下架。</p><p>第二种方式不利于吸引自然流量，但是被下架的风险很小，因为苹果的审核团队在美国，不可能自己去注册账号，复查也没关系，除非有人举报你的App。</p><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><h4 id="1、如何使用一个for循环输出九九乘法表"><a href="#1、如何使用一个for循环输出九九乘法表" class="headerlink" title="1、如何使用一个for循环输出九九乘法表"></a>1、<a href="http://blog.csdn.net/mbuger/article/details/60877188" target="_blank" rel="noopener">如何使用一个for循环输出九九乘法表</a></h4><h6 id="NSJSONSerialization"><a href="#NSJSONSerialization" class="headerlink" title="NSJSONSerialization"></a>NSJSONSerialization</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSData *data = [operation.responseString dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    NSMutableDictionary *responseObject_dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers | NSJSONReadingMutableLeaves error:nil];</span><br></pre></td></tr></table></figure><p>//NSJSONReadingMutableContainers的作用: <a href="http://blog.csdn.net/chenyong05314/article/details/45691041" target="_blank" rel="noopener">http://blog.csdn.net/chenyong05314/article/details/45691041</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSJSONReadingMutableContainers：返回可变容器，NSMutableDictionary或NSMutableArray。</span><br><span class="line">NSJSONReadingMutableLeaves：返回的JSON对象中字符串的值为NSMutableString</span><br><span class="line">NSJSONReadingAllowFragments：允许JSON字符串最外层既不是NSArray也不是NSDictionary，但必须是有效的JSON Fragment。例如使用这个选项可以解析 @“123” 这样的字符串。</span><br></pre></td></tr></table></figure><h3 id="iOS中常见Crash总结"><a href="#iOS中常见Crash总结" class="headerlink" title="iOS中常见Crash总结"></a>iOS中常见Crash总结</h3><ul><li><a href="http://www.cocoachina.com/articles/27227" target="_blank" rel="noopener">iOS中常见Crash总结</a></li><li><a href="https://blog.csdn.net/zhonggaorong/article/details/52022220" target="_blank" rel="noopener">iOS开发之调试技巧Xcode7中你一定要知道的炸裂调试神技、Address Sanitizer EXC_BAD_ACCESS</a></li></ul><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>类微信体验</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E7%B1%BB%E5%BE%AE%E4%BF%A1%E4%BD%93%E9%AA%8C/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E7%B1%BB%E5%BE%AE%E4%BF%A1%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="类微信体验"><a href="#类微信体验" class="headerlink" title="类微信体验"></a>类微信体验</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微信：</p><p>1、IM部分</p><p>2、发现（如”看一看”功能）</p><p>IM部分：</p><p>数据库：从数据库中取+新记录保存到数据库中</p><p>问题：</p><p>1、给人同步的感觉</p><p>2、不是每个调用失败，都要提示给用户</p><p>错误的请求，不弹toast</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Flutter/10%E4%B8%8E%E5%8E%9F%E7%94%9F%E7%9B%B8%E5%85%B3/Flutter%20%E4%B8%8E%E5%8E%9F%E7%94%9F%E7%9B%B8%E5%85%B3/"/>
      <url>/Flutter/10%E4%B8%8E%E5%8E%9F%E7%94%9F%E7%9B%B8%E5%85%B3/Flutter%20%E4%B8%8E%E5%8E%9F%E7%94%9F%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Flutter-与原生相关"><a href="#Flutter-与原生相关" class="headerlink" title="Flutter 与原生相关"></a>Flutter 与原生相关</h1><h2 id="一、使用与原生有关的三方库的注意点"><a href="#一、使用与原生有关的三方库的注意点" class="headerlink" title="一、使用与原生有关的三方库的注意点"></a>一、使用与原生有关的三方库的注意点</h2><h3 id="1、trying-to-create-a-view-with-an-unregistered-type-unregistered-view-type"><a href="#1、trying-to-create-a-view-with-an-unregistered-type-unregistered-view-type" class="headerlink" title="1、trying to create a view with an unregistered type, unregistered view type"></a>1、trying to create a view with an unregistered type, unregistered view type</h3><p>使用三方库的时候，如果该库与原生有关。如webview插件、百度地图插件等。如果直接使用，不对工程设置的话，则会报<code>trying to create a view with an unregistered type, unregistered view type:</code></p><p>解决方案：在info.plist加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;io.flutter.embedded_views_preview&lt;/key&gt;</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/169370922" target="_blank" rel="noopener">浅析 Flutter 与 iOS 的视图桥梁 PlatformView</a></li></ul><h3 id="2、启动的时候使用rootBundle-loadString加载本地配置json-百度地图，报错：Unhandled-Exception-Null-check-operator-used-on-a-null-value"><a href="#2、启动的时候使用rootBundle-loadString加载本地配置json-百度地图，报错：Unhandled-Exception-Null-check-operator-used-on-a-null-value" class="headerlink" title="2、启动的时候使用rootBundle.loadString加载本地配置json\百度地图，报错：Unhandled Exception: Null check operator used on a null value"></a>2、启动的时候使用rootBundle.loadString加载本地配置json\百度地图，报错：Unhandled Exception: Null check operator used on a null value</h3><p>启动的时候使用rootBundle.loadString 加载本地配置json，但是直接加载会报错：<br>[ERROR:flutter/lib/ui/ui_dart_state.cc(199)] Unhandled Exception: Null check operator used on a null value </p><p>解决办法：加载本地资源以前增加一行代码：</p><p><code>WidgetsFlutterBinding.ensureInitialized();</code> //解决加载json错误</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main() async &#123;</span><br><span class="line">WidgetsFlutterBinding.ensureInitialized(); //解决加载json错误</span><br><span class="line">globals.config = jsonDecode(await rootBundle.loadString(‘assets/config.json’));</span><br><span class="line">runApp(MyApp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、浅析-Flutter-与-iOS-的视图桥梁-PlatformView"><a href="#二、浅析-Flutter-与-iOS-的视图桥梁-PlatformView" class="headerlink" title="二、浅析 Flutter 与 iOS 的视图桥梁 PlatformView"></a>二、浅析 Flutter 与 iOS 的视图桥梁 PlatformView</h2><h2 id="三、百度地图"><a href="#三、百度地图" class="headerlink" title="三、百度地图"></a>三、百度地图</h2><h3 id="百度地图-Flutter插件"><a href="#百度地图-Flutter插件" class="headerlink" title="百度地图-Flutter插件"></a><a href="https://lbsyun.baidu.com/index.php?title=flutter/loc" target="_blank" rel="noopener">百度地图-Flutter插件</a></h3><p> 1)iOS权限问题可参照<a href="https://lbsyun.baidu.com/index.php?title=ios-locsdk/guide/create-project/manual-create" target="_blank" rel="noopener">iOS定位SDK手动部署说明</a>。<br>  2)iOS头文件错误：</p><p><img src="/Flutter/10与原生相关/Flutter 与原生相关/Flutter%20%E4%B8%8E%E5%8E%9F%E7%94%9F%E7%9B%B8%E5%85%B3/ios1.png" alt="ios1.png"></p><p><img src="/Flutter/10与原生相关/Flutter 与原生相关/Flutter%20%E4%B8%8E%E5%8E%9F%E7%94%9F%E7%9B%B8%E5%85%B3/ios2.png" alt="ios2.png"></p><p>解决办法：Xcode-TARGETS-build settings-Allow Non-modular Includes In Famework Modules设置为YES。</p><p>Allow Non-modular Includes In Famework Modules</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/Flutter%20iOS%20%E7%82%B9%E5%87%BB%E7%8A%B6%E6%80%81%E6%A0%8F%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8/"/>
      <url>/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/Flutter%20iOS%20%E7%82%B9%E5%87%BB%E7%8A%B6%E6%80%81%E6%A0%8F%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Flutter-iOS-点击状态栏回到顶部"><a href="#Flutter-iOS-点击状态栏回到顶部" class="headerlink" title="Flutter iOS 点击状态栏回到顶部"></a>Flutter iOS 点击状态栏回到顶部</h1><h2 id="一、会回到顶部的原理"><a href="#一、会回到顶部的原理" class="headerlink" title="一、会回到顶部的原理"></a>一、会回到顶部的原理</h2><p>ios中一个常见的交互是：点击顶部栏时，自动将当前的滚动区滚到顶部。在flutter中，大部分时候这件事是“自然完成”的，但是也有时候会遇到这个行为失效的情况。要解决这个问题首先自然是要看这个feature是如何实现的。<br> 其实大部分都是Scaffold里面干的事：<br> Scaffold里有这样一段代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (themeData.platform) &#123;</span><br><span class="line">  <span class="keyword">case</span> TargetPlatform.iOS:</span><br><span class="line">    _addIfNonNull(</span><br><span class="line">      children,</span><br><span class="line">      GestureDetector(</span><br><span class="line">        behavior: HitTestBehavior.opaque,</span><br><span class="line">        onTap: _handleStatusBarTap,</span><br><span class="line">        <span class="comment">// iOS accessibility automatically adds scroll-to-top to the clock in the status bar</span></span><br><span class="line">        excludeFromSemantics: <span class="literal">true</span>,</span><br><span class="line">      ),</span><br><span class="line">      _ScaffoldSlot.statusBar,</span><br><span class="line">      removeLeftPadding: <span class="literal">false</span>,</span><br><span class="line">      removeTopPadding: <span class="literal">true</span>,</span><br><span class="line">      removeRightPadding: <span class="literal">false</span>,</span><br><span class="line">      removeBottomPadding: <span class="literal">true</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> TargetPlatform.android:</span><br><span class="line">  <span class="keyword">case</span> TargetPlatform.fuchsia:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里命名很舒服，可以直接看出来在干什么：如果是ios的话，那就给Scaffold加一个在状态栏上的点击区，点击的话就会触发一个函数，这个函数干的事情如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ScrollController _primaryScrollController = ScrollController();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_handleStatusBarTap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_primaryScrollController.hasClients) &#123;</span><br><span class="line">    _primaryScrollController.animateTo(</span><br><span class="line">      <span class="number">0.0</span>,</span><br><span class="line">      duration: <span class="function"><span class="keyword">const</span> <span class="title">Duration</span><span class="params">(milliseconds: <span class="number">300</span>)</span>,</span></span><br><span class="line"><span class="function">      curve: Curves.linear, <span class="comment">// TODO(ianh): Use a more appropriate curve.</span></span></span><br><span class="line"><span class="function">    )</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是，Scaffold会提供一个默认的ScrollController，而点击顶部栏会使得这个controller滚到顶部，在ScrollView的build函数中则会取这个controller:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;Widget&gt; slivers = buildSlivers(context);</span><br><span class="line">  <span class="keyword">final</span> AxisDirection axisDirection = getDirection(context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意，此处的primary不是传入的primary，</span></span><br><span class="line">  <span class="comment">// primary = primary ?? controller == null &amp;&amp; identical(scrollDirection, Axis.vertical)</span></span><br><span class="line">  <span class="keyword">final</span> ScrollController scrollController = primary</span><br><span class="line">    ? PrimaryScrollController.of(context)</span><br><span class="line">    : controller;</span><br><span class="line">  <span class="keyword">final</span> Scrollable scrollable = Scrollable(</span><br><span class="line">    dragStartBehavior: dragStartBehavior,</span><br><span class="line">    axisDirection: axisDirection,</span><br><span class="line">    controller: scrollController,</span><br><span class="line">    physics: physics,</span><br><span class="line">    semanticChildCount: semanticChildCount,</span><br><span class="line">    viewportBuilder: (BuildContext context, ViewportOffset offset) &#123;</span><br><span class="line">      <span class="keyword">return</span> buildViewport(context, offset, axisDirection, slivers);</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> primary &amp;&amp; scrollController != <span class="literal">null</span></span><br><span class="line">    ? PrimaryScrollController.none(child: scrollable)</span><br><span class="line">    : scrollable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果指定controller的话，就不会使用PrimaryScrollview，如果不指定的话，则在primary为true时使用PrimaryController，而默认情况下controller为null，primary为true，因此一个裸体的ListView是会相应屏幕点击的。<br> 知道了原理，就很容易分析自己代码里出的问题是什么，常见的可能就是：<br> 1、没加Scaffold，这个其实并不常见（自相矛盾草），不过可以检查一下，一般总是会有Scaffold的<br> 2、真正常见的：指定了controller，如果自己创建了一个Controller丢给ScrollView，那必然是会失效的。但是使用controller又是一个很常见且重要的需求，怎么办呢？也很简单，就是不要自己创建新的ScrollController，而是直接取PrimaryScrollController.of(context)这个controller，对其进行自己要做的操作。<br> 3、相对不太常见且需要分析具体代码的：多个Scaffold导致的冲突。<br> 注意到其实flutter里的这个点击状态栏并不是真的点击了状态栏，而是点击了“Scaffold提供的位于状态栏的可点击区域”，也就是说，如果有多个Scaffold就会有多个这样的区域。实际情况是，只有最内部的Scaffold的状态栏会有响应，而如果ScrollView所处位置取到的和点击的Scaffold不一致，自然也就不会有滚动到顶部的feature</p><h2 id="二、错误示例"><a href="#二、错误示例" class="headerlink" title="二、错误示例"></a>二、错误示例</h2><p>今天遇到ios点击状态栏无法回到顶部（原理在文章后）的问题。研究后发现，Scaffold组件虽然会自带这个功能。但使用时候，必须遵循指定规则才行。</p><p>我们以点击 TapStatusNormalPage 上的状态栏返回顶部来举例。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tap_status_normal_page.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TapStatusNormalPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> TapStatusNormalPage(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;TapStatusNormalPage&gt; createState() =&gt; _TapStatusNormalPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TapStatusNormalPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TapStatusNormalPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold( <span class="comment">// 注意这个页面已经包了 Scaffold 了</span></span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: <span class="keyword">const</span> Text(<span class="string">'状态栏点击-Normal5'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: ListView.builder(</span><br><span class="line">        itemCount: <span class="number">200</span>,</span><br><span class="line">        itemBuilder: (context, index) &#123;</span><br><span class="line">          <span class="keyword">return</span> Text(<span class="string">'<span class="subst">$index<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">        &#125;,</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">      ),</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    );</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure><h3 id="错误一：如果Scaffold里面又套了一个Scaffold，那么这个回到顶部就会失效。"><a href="#错误一：如果Scaffold里面又套了一个Scaffold，那么这个回到顶部就会失效。" class="headerlink" title="错误一：如果Scaffold里面又套了一个Scaffold，那么这个回到顶部就会失效。"></a>错误一：如果Scaffold里面又套了一个Scaffold，那么这个回到顶部就会失效。</h3><p>失效示例1：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="title">extends</span> <span class="title">StatelessWidget</span> &#123;</span><br><span class="line">  @<span class="keyword">override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span>(<span class="params">BuildContext context</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: TapStatusNormalPage(), <span class="comment">// 失效原因：TapStatusNormalPage里已经有 Scaffold 了</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况，点击状态栏便不会回到顶部，我们需要保证的就是每个页面仅有一个Scaffold。</p><h3 id="错误二：app的builder的Widget生成，如果child再多余包Scaffold会导致点击状态栏无法回到顶部"><a href="#错误二：app的builder的Widget生成，如果child再多余包Scaffold会导致点击状态栏无法回到顶部" class="headerlink" title="错误二：app的builder的Widget生成，如果child再多余包Scaffold会导致点击状态栏无法回到顶部"></a>错误二：app的builder的Widget生成，如果child再多余包Scaffold会导致点击状态栏无法回到顶部</h3><p>失效示例2：</p><p>虽然home里只有一个 Scaffold ，但app的builder的Widget生成，如果child再多余包Scaffold会导致点击状态栏无法回到顶部</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ScreenUtilInit(</span><br><span class="line">    designSize: <span class="keyword">const</span> Size(<span class="number">375</span>, <span class="number">812</span>),</span><br><span class="line">    builder: () =&gt; MaterialApp(</span><br><span class="line">      navigatorKey: navigatorKey,</span><br><span class="line">      title: <span class="string">'wish'</span>,</span><br><span class="line">      home: TapStatusNormalPage(),</span><br><span class="line">      builder: EasyLoading.init(builder: (context, widget) &#123;</span><br><span class="line">        <span class="keyword">return</span> MediaQuery(</span><br><span class="line">          <span class="comment"><span class="markdown">///设置文字大小不随系统设置改变</span></span></span><br><span class="line">          data: MediaQuery.of(context).copyWith(textScaleFactor: <span class="number">1.0</span>),</span><br><span class="line">          <span class="comment">// child: Scaffold( // 注意：app的builder的Widget生成，如果child再多余包Scaffold会导致点击状态栏无法回到顶部</span></span><br><span class="line">          <span class="comment">//   resizeToAvoidBottomInset: false,</span></span><br><span class="line">          <span class="comment">//   body: widget,</span></span><br><span class="line">          <span class="comment">// ),</span></span><br><span class="line">          child: widget, <span class="comment">// OK</span></span><br><span class="line">        );</span><br><span class="line">      &#125;),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h3 id="错误三：一说要滚动就自定义controller"><a href="#错误三：一说要滚动就自定义controller" class="headerlink" title="错误三：一说要滚动就自定义controller"></a>错误三：一说要滚动就自定义controller</h3><p>点击页面上的某个按钮，让页面上的列表滚动到顶部（不需要自定义controller）。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PrimaryScrollController.of(context).jumpTo(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PrimaryScrollController.of(context).animateTo(</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">300</span>),</span><br><span class="line">            curve: Curves.linear,</span><br><span class="line">          );</span><br></pre></td></tr></table></figure><p>如果还要监听滚动</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"> <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">   <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (!_hasEverInitListener) &#123;</span><br><span class="line">     PrimaryScrollController.of(context).addListener(_handleScrollViewEvent);</span><br><span class="line">     _hasEverInitListener = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> <span class="keyword">void</span> deactivate() &#123;</span><br><span class="line">   <span class="keyword">super</span>.deactivate();</span><br><span class="line">   PrimaryScrollController.of(context).removeListener(_handleScrollViewEvent);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_handleScrollViewEvent() &#123;</span><br><span class="line">   <span class="comment">// 滚动距离</span></span><br><span class="line">   <span class="built_in">double</span> offsetY = PrimaryScrollController.of(context).offset;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="错误四：Another-exception-was-thrown-ScrollController-attached-to-multiple-scroll-views"><a href="#错误四：Another-exception-was-thrown-ScrollController-attached-to-multiple-scroll-views" class="headerlink" title="错误四：Another exception was thrown: ScrollController attached to multiple scroll views."></a>错误四：Another exception was thrown: ScrollController attached to multiple scroll views.</h3><p>问题：</p><p>flutter_swiper：Another exception was thrown: ScrollController attached to multiple scroll views</p><p>翻译一下：引发了另一个异常：ScrollController连接到多个滚动视图。</p><p>原因：</p><p>Flutter Swiper是一个轮播图组件，内部包含一个Widget List，当这个Widget List数量大于1，就可能会有这种情况</p><p>解决方案：给Swiper加一个Key即可解决</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">Container</span>(</span><br><span class="line">     <span class="attribute">child</span>: AspectRatio(</span><br><span class="line">       <span class="attribute">aspectRatio</span>: <span class="number">1.5</span> / <span class="number">1</span>, <span class="comment">// 宽高比450/300</span></span><br><span class="line">       <span class="attribute">child</span>: Swiper(</span><br><span class="line">         <span class="attribute">key</span>: UniqueKey(), <span class="comment">// 这个必须添加，代表唯一</span></span><br><span class="line">         <span class="attribute">itemBuilder</span>: (BuildContext context, int index) &#123;</span><br><span class="line">           return new Image.network(</span><br><span class="line">             imgList[index][<span class="string">'url'</span>],</span><br><span class="line">             <span class="attribute">fit</span>: BoxFit.fill,</span><br><span class="line">           );</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attribute">itemCount</span>: imgList.length,</span><br><span class="line">         <span class="attribute">pagination</span>: new SwiperPagination(),</span><br><span class="line">         <span class="attribute">control</span>: new SwiperControl(),</span><br><span class="line">         <span class="attribute">autoplay</span>: true,</span><br><span class="line">       ),</span><br><span class="line">     ),</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/Flutter%20MaterialApp/"/>
      <url>/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/Flutter%20MaterialApp/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Flutter-MaterialApp"><a href="#Flutter-MaterialApp" class="headerlink" title="Flutter MaterialApp"></a>Flutter MaterialApp</h1><h2 id="Flutter-MaterialApp的initialRoute属性和home属性的区别"><a href="#Flutter-MaterialApp的initialRoute属性和home属性的区别" class="headerlink" title="Flutter MaterialApp的initialRoute属性和home属性的区别"></a>Flutter MaterialApp的initialRoute属性和home属性的区别</h2><p>1、home 是应用程序默认的路由小部件，如果指定了 home，那么 route 中就不能包含 /，home 会取代 /。<br>2、除非指定了 initialRoute（会先执行home，再执行initialRoute，在initialRoute页返回会回到home页），否则应用程序会首先显示 home 对应的小部件，如果 initialRoute 不能正常显示，也会显示 home。<br>使用场景：<br>若APP启动时需要根据是否登录来决定首先显示的页面，可在路由监听中判断 token，若未登录，则 initialRoute 设置登录页对应的别名，则会打开登录页。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/Flutter%20%E6%8B%96%E6%9B%B3%E6%8E%92%E5%BA%8F/"/>
      <url>/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/Flutter%20%E6%8B%96%E6%9B%B3%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Flutter-拖曳排序"><a href="#Flutter-拖曳排序" class="headerlink" title="Flutter 拖曳排序"></a>Flutter 拖曳排序</h1><p>参考文章：</p><ul><li><a href="https://www.jianshu.com/p/924428a31b6b" target="_blank" rel="noopener">Flutter使用Draggable实现可拖拽GridView</a></li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/UI+App%20demo/"/>
      <url>/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/UI+App%20demo/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="UI-App-demo"><a href="#UI-App-demo" class="headerlink" title="UI+App demo"></a>UI+App demo</h1><ul><li><p><a href="https://blog.csdn.net/xhmj12/article/details/107273449/" target="_blank" rel="noopener">推荐四个Flutter重磅开源APP项目！</a></p><blockquote><ul><li><a href="https://github.com/mjl0602/flutter_tiktok" target="_blank" rel="noopener">精仿抖音</a></li><li><a href="https://github.com/yukilzw/dy_flutter" target="_blank" rel="noopener">斗鱼APP</a></li><li><a href="https://github.com/kaina404/FlutterDouBan" target="_blank" rel="noopener">豆瓣客户端</a></li><li></li></ul></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/Flutter%20%E6%9C%80%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/"/>
      <url>/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/Flutter%20%E6%9C%80%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Flutter-最常出现的错误"><a href="#Flutter-最常出现的错误" class="headerlink" title="Flutter 最常出现的错误"></a>Flutter 最常出现的错误</h1><h2 id="典型错误一：无法掌握的Future"><a href="#典型错误一：无法掌握的Future" class="headerlink" title="典型错误一：无法掌握的Future"></a>典型错误一：无法掌握的Future</h2><p>典型错误信息：<code>NoSuchMethodError: The method &#39;markNeedsBuild&#39; was called on null.</code></p><p>这个错误常出现在异步任务（Future）处理，比如某个页面请求一个网络API数据，根据数据刷新 Widget State。</p><p>异步任务结束在页面被pop之后，但没有检查State 是否还是 <code>mounted</code>，继续调用 <code>setState</code> 就会出现这个错误。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>一段很常见的获取网络数据的代码，调用 <code>requestApi()</code>，等待Future从中获取<code>response</code>，进而<code>setState</code>刷新 Widget：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class AWidgetState extends State&lt;AWidget&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> data;</span><br><span class="line">  void loadData() async &#123;</span><br><span class="line">    <span class="keyword">var</span> response = await requestApi(...);</span><br><span class="line">    setState(()&#123;</span><br><span class="line">      this.data = response.data;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p><code>response</code> 的获取为<code>async-await</code>异步任务，完全有可能在<code>AWidgetState</code>被 <code>dispose</code>之后才等到返回，那时候和该<code>State</code> 绑定的 <code>Element</code> 已经不在了。故而在<code>setState</code>时需要容错。</p><h3 id="解决办法：-setState之前检查是否-mounted"><a href="#解决办法：-setState之前检查是否-mounted" class="headerlink" title="解决办法： setState之前检查是否 mounted"></a>解决办法： <code>setState</code>之前检查是否 <code>mounted</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class AWidgetState extends State &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> data;</span><br><span class="line">  void loadData() async &#123;</span><br><span class="line">    <span class="keyword">var</span> response = await requestApi(...);</span><br><span class="line">    <span class="keyword">if</span> (mounted) &#123;</span><br><span class="line">      setState(()&#123;</span><br><span class="line">        this.data = response.data;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>mounted</code>检查很重要，其实只要涉及到异步还有各种回调(callback)，都不要忘了检查该值。</p><p>比如，在 <code>FrameCallback</code>里执行一个动画(AnimationController)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState()&#123;</span><br><span class="line">  WidgetsBinding.instance.addPostFrameCallback((_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mounted) _animationController.forward();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AnimationController</code>有可能随着 State 一起 <code>dispose</code>了，但是<code>FrameCallback</code>仍然会被执行，进而导致异常。</p><p>又比如，在动画监听的回调里搞点事：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState()&#123;</span><br><span class="line">  _animationController.animation.addListener(_handleAnimationTick);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void _handleAnimationTick() &#123;</span><br><span class="line">  <span class="keyword">if</span> (mounted) updateWidget(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的在<code>_handleAnimationTick</code>被回调前，State 也有可能已经被<code>dispose</code>了。</p><p>如果你还不理解为什么，请仔细回味一下<code>Event loop</code> 还有复习一下 Dart 的线程模型。</p><h2 id="典型错误二：Navigator-of-context-是个-null"><a href="#典型错误二：Navigator-of-context-是个-null" class="headerlink" title="典型错误二：Navigator.of(context) 是个 null"></a>典型错误二：Navigator.of(context) 是个 null</h2><p>典型错误信息：<code>NoSuchMethodError: The method &#39;pop&#39; was called on null.</code></p><p>常在 <code>showDialog</code> 后处理 dialog 的 pop() 出现。</p><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>在某个方法里获取网络数据，为了更好的提示用户，会先弹一个 loading 窗，之后再根据数据执行别的操作…</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// show loading dialog on request data</span></span><br><span class="line">showDialog&lt;void&gt;(</span><br><span class="line">  context: context,</span><br><span class="line">  barrierDismissible: <span class="literal">false</span>,</span><br><span class="line">  builder: (_) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: CircularIndicator(),</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> data = (await requestApi(...)).data;</span><br><span class="line"><span class="comment">// got it, pop dialog</span></span><br><span class="line">Navigator.of(context).pop();</span><br></pre></td></tr></table></figure><h3 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h3><p>出错的原因在于—— Android 原生的返回键：虽然代码指定了<code>barrierDismissible: false</code>，用户不可以点半透明区域关闭弹窗，但当用户点击返回键时，Flutter 引擎代码会调用 <code>NavigationChannel.popRoute()</code>，最终这个 loading dialog 甚至包括页面也被关掉，进而导致<code>Navigator.of(context)</code>返回的是<code>null</code>，因为该<code>context</code>已经被<code>unmount</code>，从一个已经凋零的树叶上是找不到它的根的，于是错误出现。</p><p>另外，代码里的<code>Navigator.of(context)</code> 所用的<code>context</code>也不是很正确，它其实是属于<code>showDialog</code>调用者的而非 dialog 所有，理论上应该用<code>builder</code>里传过来的<code>context</code>，沿着错误的树干虽然也能找到根，但实际上不是那么回事，特别是当你的APP里有<code>Navigator</code>嵌套时更应该注意。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>首先，确保 <code>Navigator.of(context)</code> 的 <code>context</code> 是 dialog 的<code>context</code>；其次，检查 <code>null</code>，以应对被手动关闭的情况。</p><p><code>showDialog</code> 时传入 <code>GlobalKey</code>，通过 <code>GlobalKey</code>去获取正确的<code>context</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GlobalKey key = GlobalKey();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">showDialog&lt;void&gt;(</span><br><span class="line">  context: context,</span><br><span class="line">  barrierDismissible: <span class="literal">false</span>,</span><br><span class="line">  builder: (_) &#123;</span><br><span class="line">    <span class="keyword">return</span> KeyedSubtree(</span><br><span class="line">      key: key,</span><br><span class="line">      child: Center(</span><br><span class="line">        child: CircularIndicator(),</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> data = (await requestApi(...)).data;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (key.currentContext != null) &#123;</span><br><span class="line">  Navigator.of(key.currentContext)?.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>key.currentContext</code> 为<code>null</code>意为着该 dialog 已经被<code>dispose</code>，亦即已经从 WidgetTree 中<code>unmount</code>。</p><p>其实，类似的<code>XXX.of(context)</code>方法在 Flutter 代码里很常见，比如 <code>MediaQuery.of(context)</code>、<code>Theme.of(context)</code>、<code>DefaultTextStyle.of(context)</code>，<code>DefaultAssetBundle.of(context)</code>等等，都要注意传入的<code>context</code>是来自正确节点的，否则会有惊喜在等你。</p><p>写 Flutter 代码时，脑海里一定要对<code>context</code>的树干脉络有清晰的认知，如果你还不是很理解<code>context</code>，可以看看 《深入理解BuildContext》 - Vadaski。</p><h2 id="典型错误三：ScrollController-里薛定谔的-position"><a href="#典型错误三：ScrollController-里薛定谔的-position" class="headerlink" title="典型错误三：ScrollController 里薛定谔的 position"></a>典型错误三：ScrollController 里薛定谔的 position</h2><p>在获取<code>ScrollController</code>的<code>position</code>、<code>offset</code>，或者调用<code>jumpTo()</code>等方法时，常出现<code>StateError</code>错误。</p><p>错误信息：<code>StateError Bad state: Too many elements</code>，<code>StateError Bad state: No element</code></p><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><p>在某个按钮点击后，通过<code>ScrollController</code> 控制<code>ListView</code>滚动到开头：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final ScrollController _primaryScrollController = ScrollController();</span><br><span class="line"><span class="comment">// 回到开头</span></span><br><span class="line">void _handleTap() &#123;</span><br><span class="line">  <span class="keyword">if</span>(_primaryScrollController.offset &gt; <span class="number">0</span>) _primaryScrollController.jumpTo(<span class="number">0.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h3><p>先看<code>ScrollController</code>的源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ScrollController extends ChangeNotifier &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  @protected</span><br><span class="line">  Iterable&lt;ScrollPosition&gt; get positions =&gt; _positions;</span><br><span class="line">  final List&lt;ScrollPosition&gt; _positions = &lt;ScrollPosition&gt;[];</span><br><span class="line"> </span><br><span class="line">  double get offset =&gt; position.pixels;</span><br><span class="line"> </span><br><span class="line">  ScrollPosition get position &#123;</span><br><span class="line">    assert(_positions.isNotEmpty, <span class="string">'ScrollController not attached to any scroll views.'</span>);</span><br><span class="line">    assert(_positions.length == <span class="number">1</span>, <span class="string">'ScrollController attached to multiple scroll views.'</span>);</span><br><span class="line">    <span class="keyword">return</span> _positions.single;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，<code>ScrollController</code> 的 <code>offest</code> 是从 <code>position</code> 中获得，而<code>position</code> 则是来自变量 <code>_positions</code>。</p><p><code>StateError</code>错误，就是<code>_positions.single</code> 这一行抛出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract class Iterable&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  E get single &#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator;</span><br><span class="line">    <span class="keyword">if</span> (!it.moveNext()) throw IterableElementError.noElement();</span><br><span class="line">    E result = it.current;</span><br><span class="line">    <span class="keyword">if</span> (it.moveNext()) throw IterableElementError.tooMany();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，这个<code>_positions</code> 为什么忽而一滴不剩，忽而却嫌它给的太多了呢？ˊ_&gt;ˋ</p><p>还是要回到 <code>ScrollController</code> 的源码里找找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ScrollController extends ChangeNotifier &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  void attach(ScrollPosition position) &#123;</span><br><span class="line">    assert(!_positions.contains(position));</span><br><span class="line">    _positions.add(position);</span><br><span class="line">    position.addListener(notifyListeners);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  void detach(ScrollPosition position) &#123;</span><br><span class="line">    assert(_positions.contains(position));</span><br><span class="line">    position.removeListener(notifyListeners);</span><br><span class="line">    _positions.remove(position);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>为什么没有数据(No element)： <code>ScrollController</code>还没有 <code>attach</code> 一个 <code>position</code>。原因有两个：一个可能是还没被 mount 到树上(没有被<code>Scrollable</code>使用到)；另外一个就是已经被 <code>detach</code>了。</p></li><li><p>为什么多了(Too many elements)： <code>ScrollController</code>还没来得及 <code>detach</code>旧的 <code>position</code>，就又<code>attach</code>了一个新的。原因多半是因为<code>ScrollController</code>的用法不对，同一时间被多个 <code>Scrollable</code>关注到了。</p></li></ol><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p>针对 No element 错误，只需判断一下 <code>_positions</code>是不是空的就行了，即<code>hasClients</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final ScrollController _primaryScrollController = ScrollController();</span><br><span class="line"><span class="comment">// 回到开头</span></span><br><span class="line">void _handleTap() &#123;</span><br><span class="line">  <span class="keyword">if</span>(_primaryScrollController.hasClients &amp;&amp; _primaryScrollController.offset &gt; <span class="number">0</span>) _primaryScrollController.jumpTo(<span class="number">0.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对 Too many elements 错误，确保<code>ScrollController</code>只会被一个 <code>Scrollable</code>绑定，别让它劈腿了，且被正确 <code>dispose()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class WidgetState extends State &#123;</span><br><span class="line">  final ScrollController _primaryScrollController = ScrollController();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder(</span><br><span class="line">      controller: _primaryScrollController,</span><br><span class="line">      itemCount: _itemCount,</span><br><span class="line">      itemBuilder: _buildItem,</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> get _itemCount =&gt; ...;</span><br><span class="line">  Widget _buildItem(context, index) =&gt; ...;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    super.dispose();</span><br><span class="line">    _primaryScrollController.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="典型错误四：四处碰壁-null"><a href="#典型错误四：四处碰壁-null" class="headerlink" title="典型错误四：四处碰壁 null"></a>典型错误四：四处碰壁 null</h2><p>Dart 这个语言可静可动，类型系统也独树一帜。万物都可以赋值<code>null</code>，就导致写惯了 Java 代码的同志们常常因为<code>bool</code> <code>int</code> <code>double</code>这种看起来是”primitive”的类型被<code>null</code>附体而头晕。</p><p>典型错误信息：</p><ul><li><code>Failed assertion: boolean expression must not be null</code></li><li><code>NoSuchMethodError: The method &#39;&gt;&#39; was called on null.</code></li><li><code>NoSuchMethodError: The method &#39;+&#39; was called on null.</code></li><li><code>NoSuchMethodError: The method &#39;*&#39; was called on null.</code></li></ul><h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><p>这种错误，较常发生在使用服务端返回的数据model时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class StyleItem &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final <span class="keyword">int</span> id;</span><br><span class="line">  final <span class="keyword">bool</span> hasNew;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  StyleItem.fromJson(Map&lt;String, dynamic&gt; json):</span><br><span class="line">    this.name = json[<span class="string">'name'</span>],</span><br><span class="line">    this.id = json[<span class="string">'id'</span>],</span><br><span class="line">    this.hasNew = json[<span class="string">'has_new'</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">StyleItem item = StyleItem.fromJson(jsonDecode(...));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Widget build(StyleItem item) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item.hasNew &amp;&amp; item.id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Text(item.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> SizedBox.shrink();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原因分析-2"><a href="#原因分析-2" class="headerlink" title="原因分析"></a>原因分析</h3><p><code>StyleItem.fromJson()</code> 对数据没有容错处理，应当认为 map 里的value都有可能是 <code>null</code>。</p><h3 id="解决办法：容错"><a href="#解决办法：容错" class="headerlink" title="解决办法：容错"></a>解决办法：容错</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class StyleItem &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final <span class="keyword">int</span> id;</span><br><span class="line">  final <span class="keyword">bool</span> hasNew;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  StyleItem.fromJson(Map&lt;String, dynamic&gt; json):</span><br><span class="line">    this.name = json[<span class="string">'name'</span>],</span><br><span class="line">    this.id = json[<span class="string">'id'</span>] ?? <span class="number">0</span>,</span><br><span class="line">    this.hasNew = json[<span class="string">'has_new'</span>] ?? <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要习惯 Dart 的类型系统，什么都有可能是<code>null</code>，比如下面一段代码，你细品有几处可能报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">  double fraction(Rect boundsA, Rect boundsB) &#123;</span><br><span class="line">    double areaA = boundsA.width * boundsA.height;</span><br><span class="line">    double areaB = boundsB.width * boundsB.height;</span><br><span class="line">    <span class="keyword">return</span> areaA / areaB;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  void requestData(params, void onDone(data)) &#123;</span><br><span class="line">    _requestApi(params).then((response) =&gt; onDone(response.data));</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  Future&lt;dynamic&gt; _requestApi(params) =&gt; ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小提示，<code>onDone()</code>也可以是<code>null</code> ＞﹏＜。</p><p>在和原生用 <code>MethodChannel</code>传数据时更要特别注意，小心驶得万年船。</p><h2 id="典型错误五：泛型里的-dynamic-一点也不-dynamic"><a href="#典型错误五：泛型里的-dynamic-一点也不-dynamic" class="headerlink" title="典型错误五：泛型里的 dynamic 一点也不 dynamic"></a>典型错误五：泛型里的 dynamic 一点也不 dynamic</h2><p>典型错误信息：</p><ul><li><code>type &#39;List&lt;dynamic&gt;&#39; is not a subtype of type &#39;List&lt;int&gt;&#39;</code></li><li><code>type &#39;_InternalLinkedHashMap&lt;dynamic, dynamic&gt;&#39; is not a subtype of type &#39;Map&lt;String, String&gt;&#39;</code></li></ul><p>常发生在给某个List、Map 变量赋值时。</p><h3 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h3><p>这种错误，也较常发生在使用服务端返回的数据model时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Model &#123;</span><br><span class="line">  final List&lt;<span class="keyword">int</span>&gt; ids;</span><br><span class="line">  final Map&lt;String, String&gt; ext;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  Model.fromJson(Map&lt;String, dynamic&gt; json):</span><br><span class="line">    this.ids = json[<span class="string">'ids'</span>],</span><br><span class="line">    this.ext= json[<span class="string">'ext'</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> json = jsonDecode(<span class="string">""</span><span class="string">"&#123;"</span>ids<span class="string">": [1,2,3], "</span>ext<span class="string">": &#123;"</span>key<span class="string">": "</span>value<span class="string">"&#125;&#125;"</span><span class="string">""</span>);</span><br><span class="line">Model m = Model.fromJson(json);</span><br></pre></td></tr></table></figure><h3 id="原因分析-3"><a href="#原因分析-3" class="headerlink" title="原因分析"></a>原因分析</h3><p><code>jsonDecode()</code>这个方法转换出来的map的泛型是<code>Map&lt;String, dynamic&gt;</code>，意为 value 可能是任何类型(dynamic)，当 value 是容器类型时，它其实是<code>List&lt;dynamic&gt;</code>或者<code>Map&lt;dynamic, dynamic&gt;</code>等等。</p><p>而 Dart 的类型系统中，虽然<code>dynamic</code>可以代表所有类型，在赋值时，如果数据类型事实上匹配（运行时类型相等）是可以被自动转换，但泛型里 <code>dynamic</code> 是不可以自动转换的。可以认为 <code>List&lt;dynamic&gt;</code> 和 <code>List&lt;int&gt;</code>是两种运行时类型。</p><h3 id="解决办法：使用-List-from-Map-from"><a href="#解决办法：使用-List-from-Map-from" class="headerlink" title="解决办法：使用 List.from, Map.from"></a>解决办法：使用 List.from, Map.from</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Model &#123;</span><br><span class="line">  final List&lt;<span class="keyword">int</span>&gt; ids;</span><br><span class="line">  final Map&lt;String, String&gt; ext;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  Model.fromJson(Map&lt;String, dynamic&gt; json):</span><br><span class="line">    this.ids = List.from(json[<span class="string">'ids'</span>] ?? <span class="keyword">const</span> []),</span><br><span class="line">    this.ext= Map.from(json[<span class="string">'ext'</span>] ?? <span class="keyword">const</span> &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
      <url>/Flutter/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="开发随笔"><a href="#开发随笔" class="headerlink" title="开发随笔"></a>开发随笔</h1><p>带皇冠的头像优化：</p><p><a href="https://blog.csdn.net/lqw200931116/article/details/123372095" target="_blank" rel="noopener">https://blog.csdn.net/lqw200931116/article/details/123372095</a></p><ul><li><strong>clipBehavior：此属性决定如何显示超出Stack的子组件是否被剪切；值为Clip.hardEdge时，超出部分会被剪裁（隐藏），值为Clip.none 时则不会，超出部分会显示</strong></li></ul><ul><li><a href="https://www.kancloud.cn/alex_wsc/flutter_demo/1559549" target="_blank" rel="noopener">Flutter核心技术与实战</a></li></ul><ul><li><p><a href="https://www.jianshu.com/p/e0321ccb6e1c" target="_blank" rel="noopener">Flutter Package 涉及关键字的探究</a></p></li><li><p><a href="https://www.jianshu.com/p/1a7cca6230a5" target="_blank" rel="noopener">flutter 文件与库的引用导出（import、import as、import show、part、part of、library）</a></p></li><li><p><a href="https://www.jianshu.com/p/af78b5f359f4" target="_blank" rel="noopener">Flutter 中extends、implements、with</a></p><blockquote><p>implements：类似面向协议</p></blockquote></li><li><p><a href="https://www.jianshu.com/p/d45cf49f2245" target="_blank" rel="noopener">Futter 屏幕适配框架flutter_ScreenUtil 用法</a></p></li><li><p><a href="https://juejin.cn/post/6904604605028990983" target="_blank" rel="noopener">为什么<code>Overlay</code>插入的<code>OverlayEntry</code>会在页面上面悬浮呢</a></p></li><li><p><a href="https://blog.csdn.net/ma1756295644/article/details/103011896" target="_blank" rel="noopener">Flutter - Stream基础知识</a></p></li><li><p><a href="https://blog.csdn.net/weixin_44492423/article/details/104388056" target="_blank" rel="noopener">Flutter EasyLoading的实现原理</a></p></li></ul><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><ul><li><a href="https://bbs.huaweicloud.com/blogs/317278" target="_blank" rel="noopener">如何在 Flutter 中使用MemoryImage【Flutter专题】</a></li></ul><p>为什么 Button 里 不要再设置颜色。猜测是由于<a href="https://blog.csdn.net/jungle_pig/article/details/94383759" target="_blank" rel="noopener">DefaultTextStyle</a></p><p>[flutter 解决：setState() called after dispose()]</p><h4 id="防止页面关闭执行setState-方法"><a href="#防止页面关闭执行setState-方法" class="headerlink" title="防止页面关闭执行setState()方法"></a>防止页面关闭执行setState()方法</h4><p>解决方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> updateState(fn)&#123;</span><br><span class="line">  <span class="keyword">if</span> (mounted) &#123;</span><br><span class="line">    setState(fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/63621f29eced" target="_blank" rel="noopener">Flutter：获取状态state的几种方式</a></p><p>baseui_kit中的 data_util.dart</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="comment">// import 'dart:ui';</span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">///枚举类型转string</span></span></span><br><span class="line"><span class="built_in">String</span> enumToString(o) =&gt; o.toString().split(<span class="string">'.'</span>).last;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">///string转枚举类型</span></span></span><br><span class="line">T enumFromString&lt;T&gt;(<span class="built_in">Iterable</span>&lt;T&gt; values, <span class="built_in">String</span> value) &#123;</span><br><span class="line">  <span class="keyword">return</span> values.firstWhere((type) =&gt; type.toString().split(<span class="string">'.'</span>).last == value,</span><br><span class="line">      orElse: () =&gt; <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串与日期相互转换</p><p>String–&gt;DateTime</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DateTime</span>.parse(<span class="built_in">String</span>)；</span><br></pre></td></tr></table></figure><p>DateTime –&gt;formatString</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:date_format/date_format.dart'</span>;</span><br><span class="line"></span><br><span class="line">formatDate(<span class="built_in">DateTime</span>(<span class="number">2020</span>, <span class="number">12</span>, <span class="number">23</span>) ,[<span class="string">'yyyy'</span>, <span class="string">'-'</span>, <span class="string">'mm'</span>, <span class="string">'-'</span>, <span class="string">'dd'</span>]);</span><br><span class="line">formatDate(<span class="built_in">DateTime</span>(<span class="number">2020</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">10</span>), [‘HH’, <span class="string">':'</span>, ‘nn’, <span class="string">':'</span>, ‘ss’])</span><br><span class="line"></span><br><span class="line">这里使用了日期格式化库：date_format。</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u011578734/article/details/111816323" target="_blank" rel="noopener">Flutter 日期格式化库 date_format</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">flutter sdk 版本升级到2.0或者更高的版本后就发现运行时会报错：</span><br><span class="line">Error: Cannot run with sound null safety, because the following dependencies</span><br><span class="line">don&apos;t support null safety:</span><br><span class="line"></span><br><span class="line"> - package:loading_indicator_view</span><br><span class="line"> - package:flutter_swiper</span><br><span class="line"> - package:flutter_page_indicator</span><br><span class="line"> - package:transformer_page_view</span><br><span class="line"></span><br><span class="line">For solutions, see https://dart.dev/go/unsound-null-safety</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">也就是说以上有些包不支持 safety模式。</span><br><span class="line"></span><br><span class="line">解决方案：--no-sound-null-safety</span><br><span class="line">run</span><br><span class="line">flutter run --no-sound-null-safety</span><br><span class="line">build</span><br><span class="line">flutter build apk --no-sound-null-safety</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/mixin716/article/details/119762233" target="_blank" rel="noopener">Flutter Error: Cannot run with sound null safety, because the following dependencies don‘t support</a></p><p><a href="https://www.jianshu.com/p/7ad5dddf0549" target="_blank" rel="noopener">Flutter2 的 Sound null safety 是个什么鬼？！</a></p><p><a href="http://findsrc.com/flutter/detail/8713" target="_blank" rel="noopener">flutter_webview_plugin和webview_flutter</a></p><p><a href="https://www.jianshu.com/p/6cce42245c58?from=timeline@" target="_blank" rel="noopener">iOS中WKWebView加载网页失败或者无网络状态判断</a></p><p><a href="https://blog.csdn.net/weixin_42134878/article/details/117781623" target="_blank" rel="noopener">flutter嵌入HTML5页面,Flutter加载Html并实现与JS 的双向调用</a></p><p><a href="https://songshizhao.com/blog/blogpage/1367.html" target="_blank" rel="noopener">几种常见视频格式ContentType和FileType对照表</a></p><p>Content-Type的格式</p><p>Content-Type：type/subtype ;parameter</p><p>type：主类型，任意的字符串，如text，如果是<em>号代表所有；<br>subtype：子类型，任意的字符串，如html，如果是</em>号代表所有，用“/”与主类型隔开；<br>parameter：可选参数，如charset，boundary等。<br>例如：</p><p>Content-Type: text/html;<br>Content-Type: application/json;charset:utf-8;<br>Content-Type: application/x-www-form-urlencoded;charset:utf-8;</p><h2 id="Flutter-Fix"><a href="#Flutter-Fix" class="headerlink" title="Flutter Fix"></a>Flutter Fix</h2><ul><li><p><a href="https://flutter.cn/docs/development/tools/flutter-fix" target="_blank" rel="noopener">Flutter Fix</a></p></li><li><p><a href="https://www.jianshu.com/p/bcf1afc61a3e" target="_blank" rel="noopener">Flutter 升级空安全攻略</a></p></li></ul><h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><ul><li><a href="https://book.flutterchina.club/chapter7/inherited_widget.html#_7-2-1-inheritedwidget" target="_blank" rel="noopener">7.2 数据共享（InheritedWidget）</a></li></ul><h2 id="三方库"><a href="#三方库" class="headerlink" title="三方库"></a>三方库</h2><ul><li><p><a href="https://github.com/justsoft/video_thumbnail" target="_blank" rel="noopener">Flutter使用第三方库video_thumbnail获取视频缩略图</a></p></li><li><p><a href="https://www.jianshu.com/p/c079347c9486" target="_blank" rel="noopener">常用的Flutter第三方库 2022-05-17 周二</a></p><blockquote><p>从字符串提取链接：linkify</p></blockquote></li></ul><ul><li><a href="https://blog.csdn.net/weixin_38912070/article/details/112690614" target="_blank" rel="noopener">Flutter 高性能、多功能的全场景滚动容器，一定要看！</a></li></ul><h1 id="flutter-SliverAppBar"><a href="#flutter-SliverAppBar" class="headerlink" title="flutter SliverAppBar"></a>flutter SliverAppBar</h1><ul><li><p><a href="http://www.javashuo.com/article/p-wavghldk-ws.html" target="_blank" rel="noopener">Flutter 滑动体系</a></p></li><li><p><a href="https://blog.csdn.net/u011272795/article/details/82740389?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-82740389-blog-104031790.pc_relevant_antiscanv2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" target="_blank" rel="noopener">flutter SliverAppBar</a></p></li><li><p><a href="https://blog.csdn.net/mengks1987/article/details/104031790?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-104031790-blog-122330541.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" target="_blank" rel="noopener">Flutter之SliverAppBar</a></p></li><li><a href="https://blog.csdn.net/nicepainkiller/article/details/122330541" target="_blank" rel="noopener">SliverAppBar</a></li><li><a href="https://wenku.baidu.com/view/0d0e891480c4bb4cf7ec4afe04a1b0717fd5b399.html" target="_blank" rel="noopener">FlutterSliverAppBar全解析，你要的效果都在这了！</a></li><li><a href="http://www.javashuo.com/article/p-quluupvq-kp.html" target="_blank" rel="noopener">Flutter 实现相似美团外卖店铺页面滑动效果</a></li><li><a href="https://github.com/CyJaySong/flutter_meituan_shop" target="_blank" rel="noopener">flutter_meituan_shop</a></li><li><a href="https://blog.csdn.net/weixin_34379433/article/details/91460115" target="_blank" rel="noopener">Flutter的滚动以及sliver约束</a></li></ul><h2 id="埋点"><a href="#埋点" class="headerlink" title="埋点"></a>埋点</h2><ul><li><p><a href="https://manual.sensorsdata.cn/sa/latest/ios-1573995.html" target="_blank" rel="noopener">神策全埋点 (iOS)</a></p></li><li><p><a href="https://github.com/sensorsdata" target="_blank" rel="noopener">神策数据github官网 Sensors Data</a></p></li><li><p><a href="https://juejin.cn/post/6892371163859976199" target="_blank" rel="noopener">Flutter之全埋点思考与实现</a></p></li></ul><p>曝光</p><ul><li><a href="https://www.jianshu.com/p/31f362fb9113" target="_blank" rel="noopener">Flutter 如何优雅的实现滑动元素曝光</a></li></ul><p><a href="https://www.jianshu.com/p/721672352d4a" target="_blank" rel="noopener">Flutter 解决TextOverflow.ellipsis截断字符</a></p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><ul><li><a href="https://blog.csdn.net/computerclass/article/details/118142471" target="_blank" rel="noopener">flutter 之AspectRatio 按比例显示</a></li></ul><h2 id="布局的性能优化"><a href="#布局的性能优化" class="headerlink" title="布局的性能优化"></a>布局的性能优化</h2><ul><li><a href="https://blog.csdn.net/sinat_37255207/article/details/107233657" target="_blank" rel="noopener">flutter 页面频繁刷新节省页面性能的组件RepaintBoundary</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/Git-Flow/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/Git-Flow/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h1><h2 id="分支类型"><a href="#分支类型" class="headerlink" title="分支类型"></a>分支类型</h2><ul><li>master</li><li>dev</li><li>feature</li><li>hotfix</li><li>preproduct</li></ul><h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><p>线上代码分支。</p><p>【创建】在创建 repo 的时候创建 <code>master</code> 分支。</p><p>【命名】master</p><p>【描述】所有 release 的 tag 都打在 <code>master</code>，并且 <code>master</code> 不能直接 commit，只能通过 merge 来完成代码提交。</p><p>【输入】合并自 <code>preproduct</code> <code>hotfix</code></p><p>【输出】<code>hotfix</code></p><p>【销毁】master 分支是恒定存在的</p><h3 id="dev"><a href="#dev" class="headerlink" title="dev"></a>dev</h3><p>稳定开发分支</p><p>【创建】在创建 <code>master</code> 分支时，立即创建 <code>dev</code> 分支</p><p>【命名】dev</p><p>【描述】新版本需求来的时候管理员会从 <code>dev</code> 中拉出一条版本分支。<code>dev</code> 分支里保存完整的版本迭代和测试环境下已经修复的 bug。</p><p>【输入】合并自 <code>feature</code> <code>hotfix</code> <code>preproduct</code></p><p>【输出】版本 release 时并入 <code>master</code></p><p>【销毁】dev 分支是恒定存在的</p><h3 id="feature-version"><a href="#feature-version" class="headerlink" title="feature / version"></a>feature / version</h3><p>功能分支、新版本分支</p><p>【创建】当有新版本计划时，从 <code>dev</code> 中拉取</p><p>【命名】dev_1.0.0</p><p>【描述】存放某个版本的集成代码，包括这个版本在内测环境下的 bug 修复代码</p><p>【输入】开发人员 commit</p><p>【输出】版本结束后并入 <code>dev</code></p><p>【销毁】并入后销毁</p><h3 id="preproduct"><a href="#preproduct" class="headerlink" title="preproduct"></a>preproduct</h3><p>某版本预生产分支</p><p>【创建】当某个版本的测试环境通过后，从 feature 分支并入 dev 分支时，从 dev 分支拉取出的分支</p><p>【命名】pre_1.0.0</p><p>【描述】存放某个版本的预生产代码，修复预生产时候的 bug</p><p>【输入】从 <code>dev</code> 中拉取，开发人员 commit</p><p>【输出】版本结束后同时并入 <code>master</code> 和 <code>dev</code>（不是并入 <code>dev</code> 再从 <code>dev</code> 并入 <code>master</code>）</p><p>【销毁】并入后销毁</p><h3 id="hotfix"><a href="#hotfix" class="headerlink" title="hotfix"></a>hotfix</h3><p>热补丁分支</p><p>【创建】从 <code>master</code> 拉取。</p><p>【命名】hotfix/新版本号</p><p>【描述】需要紧急上线一个补丁版本，且已有新版本的 <code>feature</code> 分支时，需要创建该分支。如果当前没有新版本的 <code>feature</code> 分支，则按正常开发逻辑走流程。</p><p>【输入】开发人员 commit</p><p>【输出】先并入 <code>master</code>；判断 <code>preproduct</code> 是否存在 ？ 并入 <code>preproduct</code> : 并入 <code>dev</code></p><p>【销毁】并入后销毁</p><h2 id="提交格式"><a href="#提交格式" class="headerlink" title="提交格式"></a>提交格式</h2><p>使用 SourceTree 完成 commit，message 可以换行。</p><p>大致格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【信息分类】简略描述</span><br><span class="line">详细描述</span><br><span class="line">【URL】bugly 地址，或者 JIRA 地址</span><br></pre></td></tr></table></figure><h3 id="信息分类"><a href="#信息分类" class="headerlink" title="信息分类"></a>信息分类</h3><h4 id="Bugfix"><a href="#Bugfix" class="headerlink" title="Bugfix"></a>Bugfix</h4><p>【修复】修复自己开发过程中自测出来的问题</p><p>【修复-jira-{id}】修复 jira 上的问题，附带 bug id</p><p>【修复-bugly-{id}】修复 bugly 上的问题，附带 bug id</p><h3 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h3><p>【新增】增加新的功能</p><h3 id="Optmize"><a href="#Optmize" class="headerlink" title="Optmize"></a>Optmize</h3><p>【优化】优化某些代码</p><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>【资源】资源文件的修改，不涉及代码</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>【配置】修改版本号，修改打包脚本，修改工程配置，不涉及代码</p><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>增加文件会更改到工程文件，此部分更改属于 Feature 的内容。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>增加某个功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【新增】购物车一键清空功能</span><br><span class="line">批量删除购物车内的商品。</span><br></pre></td></tr></table></figure><p>修复了某个自测 bug</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【修复】清空购物车的时跳出支付页面</span><br><span class="line">清空购物车的时候并没有删除商品，而是全选并支付。</span><br></pre></td></tr></table></figure><p>修复了某个内测 bug</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修复-jira-10019】清空购物车按钮点击无效果</span><br><span class="line">selector 编辑错误，导致 controller 没有响应事件。</span><br><span class="line">【URL】http://jira.luckincoffee.com/products/luckincoffee/id_xxxxxx.html</span><br></pre></td></tr></table></figure><p>修复了某个线上 bug</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修复-bugly-1191】WebView 闪退</span><br><span class="line">对 WebView 中的编辑框操作（复制、全选、粘贴）时会闪退。</span><br><span class="line">【URL】http://bugly.qq.com/luckincoffee/id_xxxxxx.html</span><br></pre></td></tr></table></figure><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/Architecture架构/Git-Flow/gitflow-feature.png" alt="feature"></p><p><img src="/Architecture架构/Git-Flow/gitflow-hotfix.png" alt="feature"></p><h2 id="GitFlow-alfredsnippets-使用"><a href="#GitFlow-alfredsnippets-使用" class="headerlink" title="GitFlow.alfredsnippets 使用"></a>GitFlow.alfredsnippets 使用</h2><p>电脑安装 Alfred 3</p><p>双击 <em>GitFlow.alfredsnippets</em> 文件，导入到 Alfred 中</p><blockquote><p>GitFlow.alfredsnippets 文件在此 repo 的 /page/iOS-Git-Flow 文件夹下可以找到</p></blockquote><p>光标选中 SourceTree 的 commit 信息编辑框</p><p><img src="/Architecture架构/Git-Flow/sourcetree.png" style="zoom: 50%;"></p><p>激活 Alfred 窗口（ 默认快捷键是 <code>Option</code> + <code>Space</code> ），输入 <code>snip git</code> 即可出现 commit 模板。</p><p><img src="/Architecture架构/Git-Flow/alfred.png" alt=""></p><p>选中想要提交的内容，按 <code>cmd + 数字</code> 即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C%E7%AE%A1%E7%90%86/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>各位需要安装app的苹果手机用户们，晚上好。如您在通过如下地址：<br><a href="https://www.pgyer.com/kKTt" target="_blank" rel="noopener">https://www.pgyer.com/kKTt</a><br>下载愿望屋app的时候，发现无法安装，则可能是您的设备未进行证书注册(如果您可以安装则证明已注册，请忽略本消息)。<br>如您对安装有需求，则可通过如下地址<br><a href="https://www.pgyer.com/tools/udid" target="_blank" rel="noopener">https://www.pgyer.com/tools/udid</a><br>将您的苹果手机udid告知我们，我们为您添加后。当我们打新包的时候，就可以安装上app啦。<br>因证书注册设备只能添加100台，即使添加上去之后，再删除也算是一台。所以如果您非必要安装，请忽略本消息。<br>最后，提前祝大家节日快乐！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/%E6%97%A7%E7%94%B5%E8%84%91%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86/"/>
      <url>/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/%E6%97%A7%E7%94%B5%E8%84%91%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="旧电脑-Mac-数据清理"><a href="#旧电脑-Mac-数据清理" class="headerlink" title="旧电脑(Mac)数据清理"></a>旧电脑(Mac)数据清理</h1><p>[TOC]</p><h2 id="清理项"><a href="#清理项" class="headerlink" title="清理项"></a>清理项</h2><p>系统偏好设置-用户与群组，左下角解锁点击加号添加一个新的管理员账号 点击左上角苹果图标，注销登陆新账号 同一个位置选择之前的账号点击减号删除 删除的时候选择删除文件就可以了</p><ul><li><p>AppleID(涉及appstore)</p><ul><li style="list-style: none"><input type="checkbox"> 系统设置里退出</li><li style="list-style: none"><input type="checkbox"> appStore –&gt; 商店 –&gt; 退出登录</li></ul></li><li><p>iCloud账号(涉及备忘录、提醒事项、Safari等)</p></li></ul><ul><li style="list-style: none"><input type="checkbox"> 设置 –&gt; iCloud</li></ul><ul><li><p>邮件、备忘录、提醒事项 清理</p><ul><li><p>[ ] 清理系统邮箱内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入 ~/Library/Containers/com.apple.mail/Data/Library/Mail Downloads</span><br><span class="line">请不要在终端用open命令，因为Mail Downloads这个有空格。</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li style="list-style: none"><input type="checkbox"> 备忘录、提醒事项</li></ul><ul><li>钥匙串</li></ul><ul><li style="list-style: none"><input type="checkbox"> 清除系统钥匙串中的密码等相关</li></ul><ul><li><p>浏览器</p><ul><li style="list-style: none"><input type="checkbox"> Safari、Chrome账号&amp;密码</li></ul><blockquote><p>附：<a href="https://jingyan.baidu.com/article/e3c78d649cfbdd3c4c85f5af.html" target="_blank" rel="noopener">Mac如何查看Safari保存的密码</a></p></blockquote><ul><li style="list-style: none"><input type="checkbox"> Safari、Chrome浏览记录</li><li style="list-style: none"><input type="checkbox"> Safari、Chrome个人收藏</li></ul></li><li><p>微信记录<br>在输入框中输入 <code>~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/</code>，然后找到<code>com.tencent.xinWeChat</code>删除整个文件夹即可。</p></li><li><p>QQ记录<br>在输入框输入<code>~/Library/Containers/com.tencent.qq</code>，删除整个文件即可。</p></li><li><p>Keynote、Page等清除打开的文件记录</p><ul><li style="list-style: none"><input type="checkbox"> 打开软件 –&gt; 文件 –&gt; 打开最近使用 –&gt; 清除菜单</li></ul></li><li><p>应用软件账号删除(百度网盘、Evernote、SourceTree等)</p></li><li><p>其他</p><ul><li><p>iPhone模拟器重置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">顶部 -&gt; Erase All Content And Setting</span><br></pre></td></tr></table></figure></li></ul></li><li><p>应用软件删除</p></li><li><p>应用软件账号删除(百度网盘、Evernote、SourceTree等)</p></li><li><p>文件夹删除(文稿、图片、下载内容等)</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/%E6%96%B0%E7%94%B5%E8%84%91%E5%88%9D%E5%A7%8B%E5%AE%89%E8%A3%85/"/>
      <url>/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/%E6%96%B0%E7%94%B5%E8%84%91%E5%88%9D%E5%A7%8B%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="新电脑-Mac-初始安装"><a href="#新电脑-Mac-初始安装" class="headerlink" title="新电脑(Mac)初始安装"></a>新电脑(Mac)初始安装</h1><p>[TOC]</p><h2 id="一、系统设置"><a href="#一、系统设置" class="headerlink" title="一、系统设置"></a>一、系统设置</h2><ul><li><p>[x] <a href="https://jingyan.baidu.com/article/0bc808fc5bceb21bd485b98e.html" target="_blank" rel="noopener">mac三指拖动设置</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">系统设置 --&gt; 辅助功能 --&gt; 鼠标与触控板 --&gt; 触控板选项 --&gt; 三指拖移</span><br></pre></td></tr></table></figure></li><li><p>[x] <a href="https://jingyan.baidu.com/article/e8cdb32beec90337052bad89.html" target="_blank" rel="noopener">mac显示隐藏文件</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -boolean true;killall Finder</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、搜狗输入法、QQ、微信、Wps"><a href="#二、搜狗输入法、QQ、微信、Wps" class="headerlink" title="二、搜狗输入法、QQ、微信、Wps"></a>二、搜狗输入法、QQ、微信、Wps</h2><ul><li style="list-style: none"><input type="checkbox" checked> <a href="https://pinyin.sogou.com/mac/" target="_blank" rel="noopener">搜狗输入法</a></li><li style="list-style: none"><input type="checkbox" checked> <a href="https://im.qq.com" target="_blank" rel="noopener">QQ</a></li><li style="list-style: none"><input type="checkbox" checked> <a href="https://weixin.qq.com" target="_blank" rel="noopener">微信</a></li><li style="list-style: none"><input type="checkbox" checked> <a href="https://www.google.cn/chrome/" target="_blank" rel="noopener">chrome</a>、<a href="http://www.firefox.com.cn/" target="_blank" rel="noopener">Firefox</a> 显示书签栏</li><li style="list-style: none"><input type="checkbox" checked> <a href="https://www.macbl.com/app/system/the-unarchiver" target="_blank" rel="noopener">解压工具 unarchiver</a></li><li style="list-style: none"><input type="checkbox" checked> Wps(AppStore)</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.zoom.cn/download/" target="_blank" rel="noopener">zoom</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://sslvpn.zjweu.edu.cn/com/installClient.html" target="_blank" rel="noopener">Easy Connect</a></li></ul><h2 id="三、琐事记录-amp-计划"><a href="#三、琐事记录-amp-计划" class="headerlink" title="三、琐事记录&amp;计划"></a>三、琐事记录&amp;计划</h2><h3 id="1、开始记录各种琐事：个人博客Git"><a href="#1、开始记录各种琐事：个人博客Git" class="headerlink" title="1、开始记录各种琐事：个人博客Git"></a>1、开始记录各种琐事：个人博客Git</h3><ul><li style="list-style: none"><input type="checkbox" checked> <a href="https://github.com/dvlproad/dvlproadHexo" target="_blank" rel="noopener">个人博客Git</a></li></ul><h3 id="2、找到对应的文件：Alfred"><a href="#2、找到对应的文件：Alfred" class="headerlink" title="2、找到对应的文件：Alfred"></a>2、找到对应的文件：Alfred</h3><ul><li style="list-style: none"><input type="checkbox" checked> <a href="https://www.alfredapp.com" target="_blank" rel="noopener">Alfred</a></li></ul><h3 id="3、编辑：Typora、SublimeText、截图xnip、翻译Bob"><a href="#3、编辑：Typora、SublimeText、截图xnip、翻译Bob" class="headerlink" title="3、编辑：Typora、SublimeText、截图xnip、翻译Bob"></a>3、编辑：Typora、SublimeText、截图xnip、翻译Bob</h3><ul><li><p>[x] <a href="http://www.sublimetext.com" target="_blank" rel="noopener">sublimetext</a></p></li><li><p>[x] <a href="https://www.typora.io" target="_blank" rel="noopener">Typora</a>  顶部 显示-&gt; 文件树</p><p><img src="/电脑使用/新电脑初始安装/typora1.png" alt="image-20201103140501382"></p></li><li><p>[x] <a href="https://zh.xnipapp.com" target="_blank" rel="noopener">xnip</a></p></li><li><p>[x] <a href="https://github.com/ripperhe/Bob" target="_blank" rel="noopener">Bob</a></p><p>Bob需要的权限设置</p><p><img src="/电脑使用/新电脑初始安装/Bob_setting1.png" alt="Bob需要的权限设置"></p></li></ul><h3 id="4、列计划：omniplan、Xmind"><a href="#4、列计划：omniplan、Xmind" class="headerlink" title="4、列计划：omniplan、Xmind"></a>4、列计划：omniplan、Xmind</h3><ul><li><p>[ ] <a href="https://www.macbl.com/app/utilities/omniplan-pro" target="_blank" rel="noopener">omniplan-pro</a></p></li><li><p>[x] Xmind Zen(AppStore)</p></li></ul><h2 id="四、代码相关"><a href="#四、代码相关" class="headerlink" title="四、代码相关"></a>四、代码相关</h2><h3 id="1、Sourcetree、gitlab、github项目、ssh"><a href="#1、Sourcetree、gitlab、github项目、ssh" class="headerlink" title="1、Sourcetree、gitlab、github项目、ssh"></a>1、Sourcetree、gitlab、github项目、ssh</h3><ul><li><p>[x] <a href="https://www.sourcetreeapp.com" target="_blank" rel="noopener">Sourcetree</a></p></li><li><p>[x] <a href="https://git-scm.com/book/zh/v2/服务器上的-Git-生成-SSH-公钥" target="_blank" rel="noopener">生成ssh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看是已有</span></span><br><span class="line">cd ~/.ssh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有则执行生成</span></span><br><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成后，拷贝id_rsa.pub中的秘钥到git的ssh配置中</span></span><br></pre></td></tr></table></figure></li><li><p>[x] gitlab</p></li><li><p>[x] <a href="https://github.com" target="_blank" rel="noopener">github</a></p><p>mac中用sourcetree下载clone代码，结果出错：<code>warning: templates not found in /usr/local/git/share/git-core/templates</code></p><p><img src="/电脑使用/新电脑初始安装/sourcetree_github1.png" alt="image-20201103134013411"></p><p>解决办法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/git/share/git-core/templates</span><br><span class="line">sudo chmod -R 755 /usr/local/git/share/git-core/templates</span><br></pre></td></tr></table></figure><p><img src="/电脑使用/新电脑初始安装/sourcetree_github2.png" alt="image-20201103135013020"></p></li></ul><h3 id="2、Cocoapods、Spec"><a href="#2、Cocoapods、Spec" class="headerlink" title="2、Cocoapods、Spec"></a>2、Cocoapods、Spec</h3><ul><li><p>[x] <a href="https://cocoapods.org" target="_blank" rel="noopener">Cocoapods官网</a></p><p>1、安装Cocoapods</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p>2、拷贝cocoapods的Spec</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pod repo # 找到pod库的路径</span><br><span class="line">cd 到上述路径</span><br><span class="line">拷贝cocoapods的Spec，并重命名该仓库名字</span><br><span class="line">pod repo update master # 将指定的仓库更新</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、go2sheell"><a href="#3、go2sheell" class="headerlink" title="3、go2sheell"></a>3、go2sheell</h3><ul><li style="list-style: none"><input type="checkbox" checked> <a href="https://zipzapmac.com/go2shell" target="_blank" rel="noopener">go2sheell</a></li></ul><h2 id="五、iOS编码工具"><a href="#五、iOS编码工具" class="headerlink" title="五、iOS编码工具"></a>五、iOS编码工具</h2><h3 id="1、Xcode"><a href="#1、Xcode" class="headerlink" title="1、Xcode"></a>1、Xcode</h3><ul><li style="list-style: none"><input type="checkbox" checked> Xcode</li></ul><h3 id="2、CodeSnippets"><a href="#2、CodeSnippets" class="headerlink" title="2、CodeSnippets"></a>2、CodeSnippets</h3><p>  1、进入 <a href="https://gitee.com/dvlproad/BlackMagic" target="_blank" rel="noopener">BlackMagic</a> Git工程中的 <a href="https://gitee.com/dvlproad/BlackMagic/tree/master/1.①快速编码/CodeSnippets" target="_blank" rel="noopener">CodeSnippets</a> 并下载</p><p>  2、CodeSnippets所在位置</p><p>  ①自己定义的代码块是在以下目录下：<br>  ~/Library/Developer/Xcode/UserData/CodeSnippets/</p><h3 id="3、iSwift破解版"><a href="#3、iSwift破解版" class="headerlink" title="3、iSwift破解版"></a>3、<a href="https://www.macbl.com/app/development/iswift" target="_blank" rel="noopener">iSwift破解版</a></h3><h3 id="4、其他-cocoapods-APP"><a href="#4、其他-cocoapods-APP" class="headerlink" title="4、其他 cocoapods APP"></a>4、其他 cocoapods APP</h3><ul><li><a href="https://cocoapods.org/app" target="_blank" rel="noopener">cocoapods APP</a></li></ul><h2 id="六、Android"><a href="#六、Android" class="headerlink" title="六、Android"></a>六、Android</h2><h3 id="1、Android-Studio"><a href="#1、Android-Studio" class="headerlink" title="1、Android Studio"></a>1、Android Studio</h3><ul><li><p>[x] <a href="https://developer.android.google.cn/studio" target="_blank" rel="noopener">Android Studio</a>、<a href="http://mumu.163.com" target="_blank" rel="noopener">MuMu模拟器</a>、gradle</p><p><img src="/电脑使用/新电脑初始安装/AndroidStudio_Gradle.png" alt="AndroidStudio_Gradle"></p></li></ul><h2 id="七、WebStrom"><a href="#七、WebStrom" class="headerlink" title="七、WebStrom"></a>七、WebStrom</h2><h3 id="1、WebStrom-APP"><a href="#1、WebStrom-APP" class="headerlink" title="1、WebStrom APP"></a>1、WebStrom APP</h3><ul><li><p>[x] WebStrom</p><p>激活码：<a href="http://idea.medeming.com/jet/" target="_blank" rel="noopener">http://idea.medeming.com/jet/</a></p></li></ul><h3 id="2、WebStorm细节配置"><a href="#2、WebStorm细节配置" class="headerlink" title="2、WebStorm细节配置"></a>2、WebStorm细节配置</h3><h4 id="2-1、WebStorm-gt-Editor-gt-Live-Templates-gt-Copyright"><a href="#2-1、WebStorm-gt-Editor-gt-Live-Templates-gt-Copyright" class="headerlink" title="2.1、WebStorm -&gt; Editor -&gt; Live Templates -&gt; Copyright"></a>2.1、WebStorm -&gt; Editor -&gt; Live Templates -&gt; Copyright</h4><ul><li><p>[x] Copyright</p></li><li><p>[x] demoCopyright</p></li><li><p>[x] companyCopyright</p><p>具体操作请查看：<a href="../../编程工具/WebStorm/WebStorm的使用技巧.md">WebStorm的使用技巧</a></p></li></ul><h4 id="2-2、WebStorm配置直接运行RN项目"><a href="#2-2、WebStorm配置直接运行RN项目" class="headerlink" title="2.2、WebStorm配置直接运行RN项目"></a>2.2、WebStorm配置直接运行RN项目</h4><p>​        具体操作请查看：<a href="../../ReactNative/1入门/ReactNative开发环境搭建与运行.md">ReactNative开发环境搭建与运行</a></p><h2 id="八、抓包-Charles"><a href="#八、抓包-Charles" class="headerlink" title="八、抓包 Charles"></a>八、抓包 Charles</h2><ul><li><p>Charles 下载</p><blockquote><p>进入百度网盘，搜索Charles，目前实用4.5.5版本</p><p><img src="/电脑使用/新电脑初始安装/Charles.png" alt="Charles"></p></blockquote></li><li><p><a href="../实用工具/Charles/Charles.md">Charles.md</a></p></li></ul><h2 id="九、brew、yarn、npm"><a href="#九、brew、yarn、npm" class="headerlink" title="九、brew、yarn、npm"></a>九、brew、yarn、npm</h2><ul><li><p>[ ] <a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">brew</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure></li><li><p>[ ] <a href="https://yarnpkg.com/zh-Hans/docs/install#mac-stable" target="_blank" rel="noopener">yarn</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install yarn</span><br></pre></td></tr></table></figure></li><li><p>[ ] npm</p></li></ul><h2 id="十、个人娱乐类"><a href="#十、个人娱乐类" class="headerlink" title="十、个人娱乐类"></a>十、个人娱乐类</h2><ul><li style="list-style: none"><input type="checkbox" checked> <a href="https://v.qq.com" target="_blank" rel="noopener">腾讯视频</a></li><li style="list-style: none"><input type="checkbox" checked> <a href="https://y.qq.com" target="_blank" rel="noopener">QQ音乐</a></li><li style="list-style: none"><input type="checkbox" checked> <a href="https://www.cr173.com/soft/54136.html" target="_blank" rel="noopener">爱奇艺V5.4.10无广告版</a></li></ul><h2 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a>十一、其他</h2><h3 id="1、APP网站macbl"><a href="#1、APP网站macbl" class="headerlink" title="1、APP网站macbl"></a>1、APP网站macbl</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.macbl.com/" target="_blank" rel="noopener">下载mac应用的好网址 https://www.macbl.com/</a></li></ul><h3 id="2、APP安装问题"><a href="#2、APP安装问题" class="headerlink" title="2、APP安装问题"></a>2、APP安装问题</h3><ul><li><p>[x] <a href="https://jingyan.baidu.com/article/9f63fb9162e3e6c8400f0e30.html" target="_blank" rel="noopener">mac安全与隐私开启任何来源</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure></li><li><p>[x] <a href="https://www.macbl.com/article/how-to/1387" target="_blank" rel="noopener"> <em>XXX.app 已损坏，打不开。您应该将它移到废纸篓</em></a></p><blockquote><p>1、在系统的“安全与隐私”中允许“任何来源”，再打开终端。<br>2、输入以下命令；</p><p><code>sudo xattr -d com.apple.quarantine /Applications/xxxx.app</code></p><p>注意：/Applications/xxxx.app 换成你的App路径或在sudo xattr -d com.apple.quarantine 后将软件拖进去即可。<br>3、最后，重启App即可。</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/%E8%BF%9C%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
      <url>/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/%E8%BF%9C%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h1><p>[TOC]</p><h2 id="一、MacBook-Pro-怎么设置smb共享文件夹"><a href="#一、MacBook-Pro-怎么设置smb共享文件夹" class="headerlink" title="一、MacBook Pro 怎么设置smb共享文件夹"></a>一、MacBook Pro 怎么设置smb共享文件夹</h2><p>在Mac要设置smb的共享文件夹，那么如何设置的好的呢？如何去设置一共享文件夹？</p><p><img src="https://exp-picture.cdn.bcebos.com/30601b6104a355e9acb59562d22ae3efe17868b0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p><h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h2><ol><li><p>右键一个桌面新建文件夹，然后点击新建文件夹。</p><p><img src="https://exp-picture.cdn.bcebos.com/e1390a31dfb6326c607de47a89532f63228560b0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p><p><img src="https://exp-picture.cdn.bcebos.com/22c4fe36e29147e80cfb44c7b603bbea3f8658b0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p></li><li><p>把要共享文件，拖入新建文件夹，然后点击logo。</p><p><img src="https://exp-picture.cdn.bcebos.com/6002c9d4483104ebbfbc22ba092b74ee1d324eb0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p><p><img src="https://exp-picture.cdn.bcebos.com/8db0c6a72633488499f83699ddee7b7f870e45b0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p></li><li><p>点击设置，点击共享。</p><p><img src="https://exp-picture.cdn.bcebos.com/e4b5e2f5ee0d3acef4cc0fde87e265e7350fbbb0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p><p><img src="https://exp-picture.cdn.bcebos.com/1562a0b9763e21c2d3cd9c65e6e89a618725b1b0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p></li><li><p>文件共享勾上，点击加。</p><p><img src="https://exp-picture.cdn.bcebos.com/87645f93cee8b0042400acba79260d9a300ea9b0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p><p><img src="https://exp-picture.cdn.bcebos.com/304f0999e92abab83a5b174b4814f1c594eea1b0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p></li><li><p>然后点击桌面选择新建文件夹添加，右边默认的读权限，如果要写的，那么该为读写。</p><p><img src="https://exp-picture.cdn.bcebos.com/f0848bee41c1b727d3487b3d1a2ca5cadde898b0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p><p><img src="https://exp-picture.cdn.bcebos.com/a48bc2e8904800fcf1ece5bbd42043715edb93b0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p></li><li><p>之后点击用户，点击锁。</p><p><img src="https://exp-picture.cdn.bcebos.com/5e615d715fdb36203521b03cabc5260f89358db0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p><p><img src="https://exp-picture.cdn.bcebos.com/2184380f8835dd8acbc538b203013870d44187b0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p></li><li><p>输入密码解锁，然后把两个允许勾上。</p><p><img src="https://exp-picture.cdn.bcebos.com/444696013870d541ad97dbbd2e0f94fc518c80b0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p><p><img src="https://exp-picture.cdn.bcebos.com/d400248ca608a50f0ee72d3910cec7f88b77ffb0.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80" alt="MacBook Pro 怎么设置smb共享文件夹"></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5/"/>
      <url>/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h1><p>[TOC]</p><h2 id="一、mac被远程连接"><a href="#一、mac被远程连接" class="headerlink" title="一、mac被远程连接"></a>一、mac被远程连接</h2><p>1、先请在苹果 Mac 电脑上的“系统偏好设置”窗口中打开“共享”功能</p><p><a href="https://iknow-pic.cdn.bcebos.com/dc54564e9258d109bcbb14d4df58ccbf6c814d7f" target="_blank" rel="noopener"><img src="https://iknow-pic.cdn.bcebos.com/dc54564e9258d109bcbb14d4df58ccbf6c814d7f?x-bce-process%3Dimage%2Fresize%2Cm_lfit%2Cw_600%2Ch_800%2Climit_1%2Fquality%2Cq_85%2Fformat%2Cf_jpg" alt="img"></a></p><p>2、接着在共享窗口中的左侧点击启用“屏幕共享”选项</p><p><a href="https://iknow-pic.cdn.bcebos.com/55e736d12f2eb9387627c794db628535e5dd6f0a" target="_blank" rel="noopener"><img src="https://iknow-pic.cdn.bcebos.com/55e736d12f2eb9387627c794db628535e5dd6f0a?x-bce-process%3Dimage%2Fresize%2Cm_lfit%2Cw_600%2Ch_800%2Climit_1%2Fquality%2Cq_85%2Fformat%2Cf_jpg" alt="img"></a></p><p>3、当屏幕共享功能打开以后，请点击“电脑设置”按钮</p><p><a href="https://iknow-pic.cdn.bcebos.com/9345d688d43f87949e97f548dc1b0ef41bd53a6f" target="_blank" rel="noopener"><img src="https://iknow-pic.cdn.bcebos.com/9345d688d43f87949e97f548dc1b0ef41bd53a6f?x-bce-process%3Dimage%2Fresize%2Cm_lfit%2Cw_600%2Ch_800%2Climit_1%2Fquality%2Cq_85%2Fformat%2Cf_jpg" alt="img"></a></p><p>4、随后请勾选二个选项： VNC 显示程序可以使用密码控制屏幕，并且设置一个连接密码</p><p><a href="https://iknow-pic.cdn.bcebos.com/50da81cb39dbb6fd173058400724ab18972b3768" target="_blank" rel="noopener"><img src="https://iknow-pic.cdn.bcebos.com/50da81cb39dbb6fd173058400724ab18972b3768?x-bce-process%3Dimage%2Fresize%2Cm_lfit%2Cw_600%2Ch_800%2Climit_1%2Fquality%2Cq_85%2Fformat%2Cf_jpg" alt="img"></a></p><p>5、随后会提示我们是否真的要连接此电脑，点击 Continue 按钮继续。</p><p><a href="https://iknow-pic.cdn.bcebos.com/9922720e0cf3d7cad0928210fc1fbe096b63a974" target="_blank" rel="noopener"><img src="https://iknow-pic.cdn.bcebos.com/9922720e0cf3d7cad0928210fc1fbe096b63a974?x-bce-process%3Dimage%2Fresize%2Cm_lfit%2Cw_600%2Ch_800%2Climit_1%2Fquality%2Cq_85%2Fformat%2Cf_jpg" alt="img"></a></p><h2 id="二、mac连接已设置允许远程连接的mac"><a href="#二、mac连接已设置允许远程连接的mac" class="headerlink" title="二、mac连接已设置允许远程连接的mac"></a>二、mac连接已设置允许远程连接的mac</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/npmjs/npm%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/npmjs/npm%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>参考文章：<a href="https://segmentfault.com/q/1010000017860880" target="_blank" rel="noopener">https://segmentfault.com/q/1010000017860880</a></p><h2 id="安装类库"><a href="#安装类库" class="headerlink" title="安装类库"></a><code>安装类库</code></h2><p>某一语法：npm install [&lt;@scope&gt;/]<name>@<version><br>某些示例：<br>//安装某一指定版本<br>npm install <a href="mailto:test@0.0.2" target="_blank" rel="noopener">test@0.0.2</a><br>//安装指定范围版本<br>//安装指定范围版本（大于）<br>npm install test@”&gt;0.0.1”<br>//安装指定范围版本（小于）<br>npm install test@”&lt;0.0.1”<br>//安装指定范围版本（之间）<br>npm install test@”^0.0.2”<br>npm install test@”&gt;=0.0.2 &lt;0.0.3”</version></name></p><h2 id="更新类库"><a href="#更新类库" class="headerlink" title="更新类库"></a><code>更新类库</code></h2><p>某一语法：npm update [-g] [<pkg>…]<br>某些示例：</pkg></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//更新到最新版本</span><br><span class="line">npm update test</span><br><span class="line">//更新到某一版本</span><br><span class="line">npm update test@&quot;0.0.2&quot;</span><br><span class="line">//更新到某范围版</span><br><span class="line">npm update test@&quot;^0.0.2&quot; //即等于npm update test@&quot;&gt;=0.0.2 &lt;0.0.3&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/CocoaPods/CocoaPods/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/CocoaPods/CocoaPods/</url>
      
        <content type="html"><![CDATA[<h1 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>最新ruby源<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gem sources --remove https://gems.ruby-china.org</span><br><span class="line">gem sources -l</span><br><span class="line">gem sources --add https://gems.ruby-china.com</span><br></pre></td></tr></table></figure></p><h2 id="一、cocoapods-的安装和升级"><a href="#一、cocoapods-的安装和升级" class="headerlink" title="一、cocoapods 的安装和升级"></a>一、cocoapods 的安装和升级</h2><p>1、查看pod版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod --version</span><br></pre></td></tr></table></figure><p>2、安装 CocoaPods</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install -n /usr/local/bin cocoapods  # OS X 版本大于 10.11，使用此命令安装</span><br><span class="line">sudo gem install cocoapods # OS X 版本小于等于 10.11，使用此命令安装</span><br></pre></td></tr></table></figure><p>其他参考：<a href="https://lbsyun.baidu.com/index.php?title=iossdk/guide/create-project/cocoapods" target="_blank" rel="noopener">百度地图中的CocoaPods文章</a></p><p>3、升级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo gem update cocoapods</span><br><span class="line">// 以下该行命令可升级cocoapods</span><br><span class="line">gem install cocoapods</span><br><span class="line"></span><br><span class="line">// 移除现有pod</span><br><span class="line">rm -rf /usr/local/bin/pod</span><br><span class="line">// 重新下载pod</span><br><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure><h2 id="五、创建spec-repo"><a href="#五、创建spec-repo" class="headerlink" title="五、创建spec repo"></a>五、创建spec repo</h2><ul><li><p>进入文件夹<code>cd ~/.cocoapods/repos</code>可以查看本地<code>spec repo</code></p></li><li><p>指定管理 <code>lib repo</code>的 <code>specs repo</code>的 <code>url</code><br><code>pod repo add dvlproad https://gitee.com/dvlproad/dvlproadSpecs.git</code><br>注意 此处地址是<code>spec</code>仓库地址</p></li></ul><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/CocoaPods/podspec%E5%86%99%E6%B3%95%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/CocoaPods/podspec%E5%86%99%E6%B3%95%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="podspec写法"><a href="#podspec写法" class="headerlink" title="podspec写法"></a>podspec写法</h2><p>Podspec编辑方法：<br>首先确认编辑环境，podspec的引号”是否正确</p><p>如果Podspec有依赖的系统库，则添加方法如下：<br>s.libraries = “sqlite3”</p><p>如果Podspec有依赖的第三方库，则添加方法如下：<br>s.dependency ‘FMDB’, ‘~&gt; 2.5’</p><p>如果Podspec有依赖的资源，则添加方法如下：<br>s.resources = “CJSliderViewController/*<em>/</em>.png”</p><h2 id="podspec常见错误"><a href="#podspec常见错误" class="headerlink" title="podspec常见错误"></a>podspec常见错误</h2><p><img src="/代码管理/库管理/CocoaPods/podspec写法及常见错误/./podspec常见错误/podspec常见错误1.png" alt="SVN配置代码库1"></p><p>解答：参考<a href="http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed4fece76310579135480ddd276b97844b22918448e435061e5a25a4ec66644b598f84616706a5435beef4346f665e71eac88ad51ccabbe47972d7656f2e4fc01a4f8f0eafbd12769a7ed14de9d95cbdedac2593d88c8e8c02089606127af6bad00a1714bc3bab4a66f7e3c408435057e6be603ba84e7758d97e57b636b9a76e7907f0a78003139076867611e6b835c12913c552e25f406653a13ced53013130911e7fe8454d45ccb00bb06a6e4153f213e4fcd6b79b19d180ac71c5a495f86f826196d2ea8e6643000ea175a9abcca53d155203a9ddde60d332cdbcb6e10dfe14a6560ffa0821697cce1acbd9&amp;p=9f7aca16d9c116bc08e291784408&amp;newp=857ac316d9c11fff57e892371b0a92695803ed6337d4d34b&amp;user=baidu&amp;fm=sc&amp;query=Unable+to+run+command+%27StripNIB+CJSliderViewController%2Enib%27+%2D+this+target+might+include+its+own+prod&amp;qid=90bdb8ed0002f11f&amp;p1=1" target="_blank" rel="noopener">Cocoapod compilation fails when loading .xib file</a><br>即错误原因为：把非.h.m的文件都放到resouces中，而不要放到soucres中</p><p>完！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/CocoaPods/Cocoapod%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/CocoaPods/Cocoapod%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Cocoapod常见问题"><a href="#Cocoapod常见问题" class="headerlink" title="Cocoapod常见问题"></a>Cocoapod常见问题</h2><h2 id="iOS-Xcode-14-创建新项目Pod-init及Pod-install-报错"><a href="#iOS-Xcode-14-创建新项目Pod-init及Pod-install-报错" class="headerlink" title="iOS Xcode 14 创建新项目Pod init及Pod install 报错"></a>iOS Xcode 14 创建新项目Pod init及Pod install 报错</h2><blockquote><p>in `initialize_from_file’: [Xcodeproj] Unknown object version (56). (RuntimeError)</p></blockquote><p>原因：Xcode与cocoapods不兼容。</p><p>解决：修改<code>compatibilityVersion</code>，将<code>Project Format</code> 改为<code>Xcode 13.0-compatible</code></p><ul><li><a href="https://blog.csdn.net/weixin_36162680/article/details/126959349?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126959349%22%2C%22source%22%3A%22weixin_36162680%22%7D&amp;fromshare=blogdetail" target="_blank" rel="noopener">iOS Xcode 14 创建新项目Pod init及Pod install 报错</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/SVN/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/SVN/</url>
      
        <content type="html"><![CDATA[<h1 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>1.Mac下搭建SVN服务器</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p><a href="http://www.cnblogs.com/dafozhang/archive/2012/06/28/2567769.html" target="_blank" rel="noopener">SVN中trunk,branches,tags用法详解</a></p><p>svn://proj/|+-trunk+-branches+-tags<br>这是一个标准的布局，trunk为主开发目录，branches为分支开发目录，tags为tag存档目录（不允许修改）。但是具体这几个目录应该如何使用，svn并没有明确的规范，更多的还是用户自己的习惯。</p><p>对于这几个开发目录，一般的使用方法有两种。我更多的是从软件产品的角度出发（比如freebsd），因为互联网的开发模式是完全不一样的。 1.第一种方法，使用trunk作为主要的开发目录<br>一般的，我们的所有的开发都是基于trunk进行开发，当一个版本/release开发告一段落（开发、测试、文档、制作安装程序、打包等）结束后，代码处于冻结状态（人为规定，可以通过hook来进行管理）。此时应该基于当前冻结的代码库，打tag。当下一个版本/阶段的开发任务开始，继续在trunk进行开发。<br>此时，如果发现了上一个已发行版本（Released Version）有一些bug，或者一些很急迫的功能要求，而正在开发的版本（Developing Version）无法满足时间要求，这时候就需要在上一个版本上进行修改了。应该基于发行版对应的tag，做相应的分支（branch）进行开发。<br>例如，刚刚发布1.0，正在开发2.0，此时要在1.0的基础上进行bug修正。</p><p><a href="http://blog.csdn.net/lilongsheng1125/article/details/8742200" target="_blank" rel="noopener">SVN 中trunk、tags、branches使用</a></p><p><a href="http://blog.csdn.net/njuitjf/article/details/7546189" target="_blank" rel="noopener">svn中的revert和update</a></p><p><a href="http://blog.csdn.net/gf771115/article/details/41008853" target="_blank" rel="noopener">iOS 用CornerStone配置SVN，HTTP及svn简单使用说明</a></p><h3 id="Mac下搭建SVN服务器"><a href="#Mac下搭建SVN服务器" class="headerlink" title="Mac下搭建SVN服务器"></a>Mac下搭建SVN服务器</h3><p>有些MAC用户想在自己的电脑中建立一个SVN服务器，那么该怎么做呢？<br>具体步骤：</p><ul><li>第一步，启动终端。命令如下：<code>svnadmin create /Users/lichaoqian/Project/SVN</code>，这样我们就在自己的主目录下建立了一个名为“SVN”的代码库。 得到的目录为：<br><img src="/代码管理/SVN/./Screenshots/SVN/SVN create catalog.png" alt="SVN创建后的目录结构"></li><li>第二步，配置这个代码仓库。</li><li>①首先修改conf文件夹中的svnserve.conf文件，只要把<code>#password-db = passwd</code>这句话的#去掉，使得这个配置项生效即可。保存退出。<br><img src="/代码管理/SVN/./Screenshots/SVN/SVN create updateFile1.png" alt="SVN配置代码库1"></li><li>②接着修改passwd文件，这个里面存着这个代码库接受的用户名和密码<br>　　采用的形式是［用户名］=［密码］。可以增加一个用户“user”，密码“pass”，形如：<code>user=pass</code>,<br>　　<img src="/代码管理/SVN/./Screenshots/SVN/SVN create updateFile2.png" alt="SVN配置代码库2"><br>　　这里改为只接受用户名为lichaoqian,密码也为lichaoqian的用户。<br>　　<img src="/代码管理/SVN/./Screenshots/SVN/SVN create updateFile3.png" alt="SVN配置代码库3"><br>　　保存退出。</li><li>第三步，启动服务器。终端中继续，命令如下：<br><code>svnserve -d -r /Users/lichaoqian/Project/SVN</code><br>没有任何提示就说明启动成功了。附停止服务器：<code>killall -9 svnserve</code><br>以上就是在MAC中建立SVN服务器的具体步骤了，想要自己建立SVN服务器的用户，快来看看吧</li></ul><h3 id="CornerStone的使用"><a href="#CornerStone的使用" class="headerlink" title="CornerStone的使用"></a>CornerStone的使用</h3><p><a href="http://blog.csdn.net/keda8997110/article/details/21813035" target="_blank" rel="noopener">svn的merge使用例子</a><br><a href="http://www.jianshu.com/p/d97b1d82d6cf" target="_blank" rel="noopener">Cornerstone Merge操作详解</a><br><a href="http://blog.csdn.net/qq_30513483/article/details/52219036" target="_blank" rel="noopener">CornerStone的使用</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%E4%BD%BF%E7%94%A8/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><p>详细而全的文档：<a href="http://git.oschina.net/progit/" target="_blank" rel="noopener">Pro Git（中文版）</a></p><h4 id="Git回滚代码到某个commit"><a href="#Git回滚代码到某个commit" class="headerlink" title="Git回滚代码到某个commit"></a>Git回滚代码到某个commit</h4><p>回退命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在git push的时候，有时候我们会想办法撤销git commit的内容 </span><br><span class="line">1、找到之前提交的git commit的id </span><br><span class="line">git log </span><br><span class="line">找到想要撤销的id </span><br><span class="line">2、git reset –hard id </span><br><span class="line">完成撤销,同时将代码恢复到前一commit_id 对应的版本 </span><br><span class="line">3、git reset id </span><br><span class="line">完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改</span><br></pre></td></tr></table></figure><ul><li><a href="https://blog.csdn.net/YoungStunner/article/details/78696763" target="_blank" rel="noopener">Git-撤销（回退）已经add，commit或push的提交</a></li><li><a href="https://blog.csdn.net/youshaoduo/article/details/52755573" target="_blank" rel="noopener">SourceTree超前一个版本，落后N个版本</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD^         回退到上个版本，代码还在</span><br><span class="line"></span><br><span class="line">注意：如果加上使用--hard会导致这里虽然回到了上个版本，但是commit上去，未push出去的就没法找回了</span><br><span class="line">$ git reset --hard HEAD^         回退到上个版本</span><br><span class="line">$ git reset --hard HEAD~3        回退到前3次提交之前，以此类推，回退到n次提交之前</span><br><span class="line">$ git reset --hard commit_id     退到/进到 指定commit的sha码</span><br></pre></td></tr></table></figure><p>当你有多处备份的时候，你可以强制性的执行</p><p>git reset –hard HEAD^ </p><p>但是你刚commit上去，未push出去的就没法找回了。</p><h4 id="pod-install报错：ArgumentError-Malformed-version-number-string"><a href="#pod-install报错：ArgumentError-Malformed-version-number-string" class="headerlink" title="pod install报错：ArgumentError - Malformed version number string"></a>pod install报错：ArgumentError - Malformed version number string</h4><p>网上的参考：<a href="https://www.jianshu.com/p/3155a187f884" target="_blank" rel="noopener">pod install报错：ArgumentError - Malformed version number string</a></p><p>实际：通过执行<code>sudo gem install cocoapods</code>命令重装cocoapods即解决了。</p><p>其他<a href="https://www.jianshu.com/p/af554a4cc335" target="_blank" rel="noopener">CocoaPods那些错</a></p><h4 id="GitHub-出现-POST-git-receive-pack-chunked-解决方案详解"><a href="#GitHub-出现-POST-git-receive-pack-chunked-解决方案详解" class="headerlink" title="GitHub 出现 POST git-receive-pack (chunked) 解决方案详解"></a>GitHub 出现 POST git-receive-pack (chunked) 解决方案详解</h4><p>出现 POST git-receive-pack (chunked) 的原因就是 当使用 HTTPS 提交到 Git 上时使用不检查加密要是东西过多将导致提交停止。</p><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方案1&gt;  使用 Git 提交代码</span><br><span class="line">进入到要提交的代码的目录，里面包含 .git 文件夹，输入指令 git config http.postBuffer 524288000</span><br><span class="line"></span><br><span class="line">方案2&gt; 使用 SourceTreee 提交代码</span><br><span class="line">如图按照顺序依次点击在最后一步增加</span><br><span class="line">[http] </span><br><span class="line">    postBuffer = 524288000</span><br></pre></td></tr></table></figure><blockquote><p><img src="/代码管理/Git使用/POST git-receive-pack (chunked" alt="POST git-receive-pack (chunked)">.png)</p></blockquote><p>再次提交将会成功。</p><p>相关参考：<a href="https://www.cnblogs.com/gongyuhonglou/p/8671200.html" target="_blank" rel="noopener">GitHub 出现 POST git-receive-pack (chunked) 解决方案详解</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%20Permission/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%20Permission/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-Permission"><a href="#Git-Permission" class="headerlink" title="Git Permission"></a>Git Permission</h1><h2 id="一、git分支添加访问权限"><a href="#一、git分支添加访问权限" class="headerlink" title="一、git分支添加访问权限"></a>一、git分支添加访问权限</h2><p><img src="/代码管理/Git Permission/image-20220303102746825.png" alt="image-20220303102746825" style="zoom:50%;"></p><h2 id="二、Gitlab仓库管理-设置保护分支"><a href="#二、Gitlab仓库管理-设置保护分支" class="headerlink" title="二、Gitlab仓库管理 设置保护分支"></a>二、<a href="https://www.cnblogs.com/mingerlcm/p/12602425.html" target="_blank" rel="noopener">Gitlab仓库管理 设置保护分支</a></h2><h3 id="设置保护分支"><a href="#设置保护分支" class="headerlink" title="设置保护分支"></a>设置保护分支</h3><p>把认为哪个个分支不想让别人动，就把这个分支设置为保护分支，并且只有授权的用户才可以向这个分支推送代码</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git2/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git2/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>一、https 和 SSH 的区别</li><li>二、在 github 上添加 SSH key 的步骤</li><li>三、git撤销</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>很多朋友在用github管理项目的时候，都是直接使用https url克隆到本地，当然也有有些人使用 SSH url 克隆到本地。然而，为什么绝大多数人会使用https url克隆呢？</p></blockquote><p>这是因为，使用https url克隆对初学者来说会比较方便，复制https url 然后到 git Bash 里面直接用clone命令克隆到本地就好了。而使用 SSH url 克隆却需要在克隆之前先配置和添加好 SSH key 。</p><p>因此，如果你想要使用 SSH url 克隆的话，你必须是这个项目的拥有者。否则你是无法添加 SSH key 的。</p><h2 id="一、https-和-SSH-的区别："><a href="#一、https-和-SSH-的区别：" class="headerlink" title="一、https 和 SSH 的区别："></a>一、https 和 SSH 的区别：</h2><p>1、前者可以随意克隆github上的项目，而不管是谁的；而后者则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key ，否则无法克隆。</p><p>2、https url 在push的时候是需要验证用户名和密码的；而 SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入密码的。</p><h2 id="二、在-github-上添加-SSH-key-的步骤："><a href="#二、在-github-上添加-SSH-key-的步骤：" class="headerlink" title="二、在 github 上添加 SSH key 的步骤："></a>二、在 github 上添加 SSH key 的步骤：</h2><h4 id="1、首先需要检查你电脑是否已经有-SSH-key"><a href="#1、首先需要检查你电脑是否已经有-SSH-key" class="headerlink" title="1、首先需要检查你电脑是否已经有 SSH key"></a>1、首先需要检查你电脑是否已经有 SSH key</h4><p>进入<code>~/.ssh</code>目录，检查是否已经存在 <code>id_rsa.pub</code> 或 <code>id_dsa.pub</code> 文件，如果文件已经存在，那么你可以跳过步骤2，直接进入步骤3。</p><h4 id="2、创建一个-SSH-key"><a href="#2、创建一个-SSH-key" class="headerlink" title="2、创建一个 SSH key"></a>2、创建一个 SSH key</h4><p><code>$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代码参数含义：</span><br><span class="line">-t 指定密钥类型，默认是 rsa ，可以省略。</span><br><span class="line">-C 设置注释文字，比如邮箱。</span><br><span class="line">-f 指定密钥文件存储文件名。</span><br></pre></td></tr></table></figure><p>以上代码省略了 -f 参数，因此，运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的 SSH key 代码，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line"># Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</span><br></pre></td></tr></table></figure><p>当然，你也可以不输入文件名，使用默认文件名（推荐），那么就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。</p><p>接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码），</p><p>当然，你也可以不输入密码，直接按回车。那么push的时候就不需要输入密码，直接提交到github上了，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line"># Enter same passphrase again:</span><br></pre></td></tr></table></figure><p>接下来，就会显示如下代码提示，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved in /c/Users/you/.ssh/id_rsa.</span><br><span class="line"># Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.</span><br><span class="line"># The key fingerprint is:</span><br><span class="line"># 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com</span><br></pre></td></tr></table></figure><p>当你看到上面这段代码的收，那就说明，你的 SSH key 已经创建成功，你只需要添加到github的SSH key上就可以了。</p><h4 id="3、添加你的-SSH-key-到-github上面去"><a href="#3、添加你的-SSH-key-到-github上面去" class="headerlink" title="3、添加你的 SSH key 到 github上面去"></a>3、添加你的 SSH key 到 github上面去</h4><p>进入账号的SSH key添加处，将<code>id_rsa.pub</code> 文件的内容复制上去添加即可。(记得 SSH key 代码的前后不要留有空格或者回车。)</p><h4 id="4、测试一下该SSH-key"><a href="#4、测试一下该SSH-key" class="headerlink" title="4、测试一下该SSH key"></a>4、测试一下该SSH key</h4><p>在git Bash 中输入以下代码</p><p>$ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a><br>当你输入以上代码时，会有一段警告代码，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</span><br><span class="line"># RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line"># Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这是正常的，你输入 yes 回车既可。如果你创建 SSH key 的时候设置了密码，接下来就会提示你输入密码，如：</p><p>Enter passphrase for key ‘/c/Users/Administrator/.ssh/id_rsa’:<br>当然如果你密码输错了，会再要求你输入，知道对了为止。</p><p>注意：输入密码时如果输错一个字就会不正确，使用删除键是无法更正的。</p><p>密码正确后你会看到下面这段话，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi username! You&apos;ve successfully authenticated, but GitHub does not</span><br><span class="line"># provide shell access.</span><br></pre></td></tr></table></figure><p>如果用户名是正确的,你已经成功设置SSH密钥。如果你看到 “access denied” ，者表示拒绝访问，那么你就需要使用 https 去访问，而不是 SSH 。</p><h2 id="github上如何修改别人的开源项目并提交"><a href="#github上如何修改别人的开源项目并提交" class="headerlink" title="github上如何修改别人的开源项目并提交"></a>github上如何修改别人的开源项目并提交</h2><p>github上的开源项目是人人都可download下来修改，并贡献源码的，但不是无原则的，如果开源作者提交的代码，被任何人都download下来修改并且随意提交的话，那会有很多恶意修改源码的行为出现，也就没有github良好的开源生态, 那么github上是怎么修改别人的源码并且提交，让自己成为同一项目的源码贡献者呢。有一下三种机制：</p><h4 id="1-开源作者把你加入项目合作者里面"><a href="#1-开源作者把你加入项目合作者里面" class="headerlink" title="1. 开源作者把你加入项目合作者里面"></a>1. 开源作者把你加入项目合作者里面</h4><p>首先他会进入自己项目的settings里，如下：</p><blockquote><p><img src="/代码管理/Git2/./Screenshots/gitOpen-Collaborators.png" alt="Collaborators"><br>然后在Collaborators里面搜索你的github用户名，add进去，之后你会在github上受到一个invitation提示，确认一下之后，你就可以在任何IDE里面用git clone到本地，URI选择这个github的开源地址就行，相当于这个github地址作为一个git的远程代码服务器。</p></blockquote><h4 id="2-第二种方法是fork到本地，然后pull-request"><a href="#2-第二种方法是fork到本地，然后pull-request" class="headerlink" title="2. 第二种方法是fork到本地，然后pull request"></a>2. 第二种方法是fork到本地，然后pull request</h4><p>找到这个开源项目，点击右上角fork按钮，然后在你自己的github里面就会出现这个项目，修改完之后，在你的github里点击pull request, 之后原作者会收到这个请求，通过之后你就贡献了自己的源码</p><blockquote><p><img src="/代码管理/Git2/./Screenshots/gitOpen-Fork&amp;pull request.png" alt="Fork&amp;pull request"></p></blockquote><h4 id="3-建立organization"><a href="#3-建立organization" class="headerlink" title="3. 建立organization"></a>3. 建立organization</h4><p>登录自己github账号后，进入github.com, 点击右上角，创建一个开源项目组织，人人都可贡献源码</p><blockquote><p><img src="/代码管理/Git2/./Screenshots/gitOpen-Organization.png" alt="Organization"></p></blockquote><h2 id="三、git撤销"><a href="#三、git撤销" class="headerlink" title="三、git撤销"></a>三、git撤销</h2><p><code>git reset HEAD^</code><br>拉取最近一次提交到版本库的文件到暂存区  改操作不影响工作区</p><h2 id="四、git删除远程提交"><a href="#四、git删除远程提交" class="headerlink" title="四、git删除远程提交"></a>四、git删除远程提交</h2><p>这是一个之后需要删除掉的远程commit</p><p>在需要删除掉的远程commit后，我又提交了一个commit</p><p>在需要删除掉的远程commit后，我又提交了第二个commit</p><p><a href="https://blog.csdn.net/Milk_o3o/article/details/79450631" target="_blank" rel="noopener">git 删除远程仓库的某次提交</a></p><blockquote><p><img src="/代码管理/Git2/./Screenshots/git remove remote commit 2.png" alt="git删除远程提交"></p></blockquote><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">删除上一次远程仓库的提交，修改上次提交的代码，做一次更完美的commit。</span><br><span class="line">&gt;</span><br><span class="line">git reset commitId （注：不要带–hard）到上个版本</span><br><span class="line">&gt;</span><br><span class="line">git stash 暂存修改</span><br><span class="line">&gt;</span><br><span class="line">git push --force 强制push，远程的最新的一次commit被删除</span><br><span class="line">&gt;</span><br><span class="line">git stash pop 释放暂存的修改，开始修改代码</span><br><span class="line">&gt;</span><br><span class="line">git add . -&gt; git commit -m &quot;massage&quot; -&gt; git push</span><br></pre></td></tr></table></figure><blockquote><p><img src="/代码管理/Git2/./Screenshots/git remove remote commit 1.png" alt="git删除远程提交"></p></blockquote><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Github-Push-失败问题"><a href="#Github-Push-失败问题" class="headerlink" title="Github Push 失败问题"></a>Github Push 失败问题</h1><p>[toc]</p><p>参考文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/414028184" target="_blank" rel="noopener">关于Support for password authentication was removed on August 13, 2021报错的解决方案</a></li></ul><h2 id="github-push代码不成功"><a href="#github-push代码不成功" class="headerlink" title="github push代码不成功"></a>github push代码不成功</h2><h3 id="问题一：Support-for-password-authentication-was-removed-on-August-13-2021-Please-use-a-personal-access-token-instead"><a href="#问题一：Support-for-password-authentication-was-removed-on-August-13-2021-Please-use-a-personal-access-token-instead" class="headerlink" title="问题一：Support for password authentication was removed on August 13, 2021. Please use a personal access token instead."></a>问题一：Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</h3><p><img src="/代码管理/Github Push 失败问题/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220423220008550.png" alt="image-20220423220008550"></p><blockquote><p>remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</p><p>remote: Please see <a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/" target="_blank" rel="noopener">https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/</a> for more information.</p></blockquote><p>意思就是你原先的密码凭证从2021年8月13日开始就不能用了，要使用个人访问令牌（personal access token），就是把你的密码替换成token。</p><h4 id="解决：github-push更新token验证方式。"><a href="#解决：github-push更新token验证方式。" class="headerlink" title="解决：github push更新token验证方式。"></a>解决：github push更新token验证方式。</h4><h5 id="1、Please-use-a-personal-access-token-instead-（密码方式不适用了，需改使用token方式登录）"><a href="#1、Please-use-a-personal-access-token-instead-（密码方式不适用了，需改使用token方式登录）" class="headerlink" title="1、Please use a personal access token instead.（密码方式不适用了，需改使用token方式登录）"></a>1、Please use a personal access token instead.（密码方式不适用了，需改使用token方式登录）</h5><p>1、登录github官网进入setting</p><p><img src="https:////upload-images.jianshu.io/upload_images/8106190-1ad586260a692345.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/476" alt="img" style="zoom:33%;"></p><p>2.页面拉到底 找到 Developer Setting</p><p>3.右侧菜单栏找到Personal access tokens 点击后 找到右上角的Generate new token</p><p><img src="https:////upload-images.jianshu.io/upload_images/8106190-bd00cafaa195f83a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200" alt="img"></p><p>4、token的使用</p><p>在终端上cd到要项目中，然后执行git pull。</p><p><img src="/代码管理/Github Push 失败问题/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220423223148829.png" alt="image-20220423223148829"></p><p>此时弹出</p><p>Username for ‘<a href="https://github.com&#39;" target="_blank" rel="noopener">https://github.com&#39;</a>: 此处输入你github 用户名</p><p>Password for ‘https://用户名@github.com’:把复制的token粘贴到此处（<strong>这里原先是输入密码的现在改成token</strong>）回车就好了</p><h5 id="2、Failed-to-connect-to-github-com-443（登录方式是token了，但连接失败。）"><a href="#2、Failed-to-connect-to-github-com-443（登录方式是token了，但连接失败。）" class="headerlink" title="2、Failed to connect to github.com 443（登录方式是token了，但连接失败。）"></a>2、Failed to connect to github.com 443（登录方式是token了，但连接失败。）</h5><p><img src="/代码管理/Github Push 失败问题/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220423221025009.png" alt="image-20220423221025009"></p><p><img src="/代码管理/Github Push 失败问题/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220423221809343.png" alt="image-20220423221809343" style="zoom: 67%;"></p><p>解决方式，终端输入如下命令：</p><blockquote><p>git config –global http.proxy</p></blockquote><h5 id="3、remote-Write-access-to-repository-not-granted-connect上了，但其他操作失败，需指定token的权限"><a href="#3、remote-Write-access-to-repository-not-granted-connect上了，但其他操作失败，需指定token的权限" class="headerlink" title="3、remote: Write access to repository not granted.(connect上了，但其他操作失败，需指定token的权限)"></a>3、remote: Write access to repository not granted.(connect上了，但其他操作失败，需指定token的权限)</h5><p><img src="/代码管理/Github Push 失败问题/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220423222009245.png" alt="image-20220423222009245"></p><p>解决：</p><p><img src="/代码管理/Github Push 失败问题/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220423222457565.png" alt="image-20220423222457565"></p><p>创建的时候下面的权限和是否设置过期时间(我是吧所有权限都勾选了) 根据自己情况选择 最后创建完后 吧token复制下来</p><h5 id="4、LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443"><a href="#4、LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443" class="headerlink" title="4、LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443"></a>4、LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</h5><p><img src="/代码管理/Github Push 失败问题/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220423224215251.png" alt="image-20220423224215251"></p><blockquote><p>fatal: unable to access ‘<a href="https://github.com/dvlproad/001-UIKit-CQDemo-Flutter.git/&#39;" target="_blank" rel="noopener">https://github.com/dvlproad/001-UIKit-CQDemo-Flutter.git/&#39;</a>: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 </p></blockquote><p><img src="/代码管理/Github Push 失败问题/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220423223640807.png" alt="image-20220423223640807"></p><p>解决：终端输入</p><blockquote><p>git config http.sslVerify “false”</p><p>git config –global http.sslVerify “false”</p></blockquote><h2 id="三、访问GitHub遇到SSL-ERROR-SYSCALL错误解决方法"><a href="#三、访问GitHub遇到SSL-ERROR-SYSCALL错误解决方法" class="headerlink" title="三、访问GitHub遇到SSL_ERROR_SYSCALL错误解决方法"></a>三、访问GitHub遇到SSL_ERROR_SYSCALL错误解决方法</h2><p>其他参考文章：<a href="https://www.jianshu.com/p/9cf537b3b8d5" target="_blank" rel="noopener">访问GitHub遇到SSL_ERROR_SYSCALL错误解决方法</a></p><p>检查1：电脑上是否有<code>curl-openssl</code>（一般都有）</p><p>openssl version</p><p><img src="/代码管理/Github Push 失败问题/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220423232921517.png" alt="image-20220423232921517"></p><p>如果没有，则安装<code>curl-openssl</code>。安装方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install curl-openssl</span><br></pre></td></tr></table></figure><p><img src="/代码管理/Github Push 失败问题/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220423233608415.png" alt="image-20220423233608415"></p><h3 id="2、安装xxx时候失败，Error-No-such-file-or-directory-rb-sysopen"><a href="#2、安装xxx时候失败，Error-No-such-file-or-directory-rb-sysopen" class="headerlink" title="2、安装xxx时候失败，Error: No such file or directory @ rb_sysopen"></a>2、安装xxx时候失败，Error: No such file or directory @ rb_sysopen</h3><h4 id="1、原因"><a href="#1、原因" class="headerlink" title="1、原因"></a>1、原因</h4><p>原来是一个依赖包下载不成功（harfbuzz-3.1.1.arm64_monterey）</p><h4 id="解决-使用brew单独安装即可，然后再就是再次下载之前的包"><a href="#解决-使用brew单独安装即可，然后再就是再次下载之前的包" class="headerlink" title="解决:使用brew单独安装即可，然后再就是再次下载之前的包"></a>解决:使用brew单独安装即可，然后再就是再次下载之前的包</h4><p>用brew单独下载依赖包，就避免了找不到依赖版本的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install zstd</span><br></pre></td></tr></table></figure><p><img src="/代码管理/Github Push 失败问题/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220423234308334.png" alt="image-20220423234308334"></p><p>之后再返回继续执行之前的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install curl-openssl</span><br></pre></td></tr></table></figure><p><img src="/代码管理/Github Push 失败问题/Github%20Push%20%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220423234350492.png" alt="image-20220423234350492"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Github%20Push%20%E6%96%B9%E5%BC%8F/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Github%20Push%20%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Github-Push-方式"><a href="#Github-Push-方式" class="headerlink" title="Github Push 方式"></a>Github Push 方式</h1><p>[toc]</p><p>Git的其他参考文章：</p><ul><li><p><a href="https://gitbook.tw/interview" target="_blank" rel="noopener">Git 面試題</a></p></li><li><p><a href="https://gitbook.tw/interview" target="_blank" rel="noopener">問：用一般方式的合併，跟使用 <code>rebase</code> 方式合併，有什麼不同？各有何優缺點？</a></p><blockquote><p>一般的合併方式，有些情況（非快轉合併）會產生一個額外的 commit 來接合兩邊分支，而 rebase 合併分支跟一般的合併分支的明顯差別，就是使用 rebase 方式合併分支不會有這個合併的 Commit。</p><p>如果就以最後的的結果來說，檔案內容來說是沒什麼差別，但在 Git 的歷史紀錄上來說就有一些差別，誰 rebase 誰，會造成歷史紀錄上先後順序不同的差別。例如 <code>cat</code> 分支 rebase 到 <code>dog</code> 分支的話，表示 <code>cat</code> 分支會被接到 <code>dog</code> 分支的後面；反之如果是 <code>dog</code> 分支 rebase 到 <code>cat</code> 上的話，表示 <code>dog</code>分支 會被接到 <code>cat</code> 分支的後面。</p><p>使用 rebase 的好處，是整理出來的歷史紀錄不會有合併用的 commit，看起來比較乾淨（也是有些人不覺得這乾淨多少），另外歷史紀錄的順序可以依照誰 rebase 誰而決定先後關係（不過這點不一定是優點或缺點，端看整理的人而定）；缺點就是它相對的比一般的合併來得沒那麼直覺，一個不小心可能會弄壞掉而且還不知道怎麼 reset 回來，或是發生衝突的時候就會停在一半，對不熟悉 rebase 的人來說也許是個困擾。</p><p>通常在還沒有推出去但感覺得有點亂（或太瑣碎）的 commit，我會先使用 rebase 來整理分支後再推出去。rebase 等於是在修改歷史，這個行為會做出平行時空，修改已經推出去的歷史可能會對其它人帶來困擾，所以對於已經推出去的內容，請不要任意使用 rebase。</p></blockquote></li></ul><h1 id="【狀況題】怎麼有時候推不上去…"><a href="#【狀況題】怎麼有時候推不上去…" class="headerlink" title="【狀況題】怎麼有時候推不上去…"></a>【狀況題】怎麼有時候推不上去…</h1><p>偶爾在執行 Push 指令的時候會出現這個錯誤訊息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line">To https://github.com/eddiekao/dummy-git.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &apos;https://github.com/eddiekao/dummy-git.git&apos;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure><p>這段訊息的意思是線上版本的內容比你電腦裡這份還要新，所以 Git 不讓你推上去。</p><h2 id="怎麼造成的？"><a href="#怎麼造成的？" class="headerlink" title="怎麼造成的？"></a>怎麼造成的？</h2><p>通常這個狀況會發生在多人一起開發的時候，想像一下這個情境：</p><p><img src="/代码管理/Github Push 方式/Github%20Push%20%E6%96%B9%E5%BC%8F/fail1.png" alt="new repository"></p><ol><li>Sherly 跟 Eddie 兩個人在差不多的時間都從 Git Server 上拉了一份資料下來準備進行開發。</li><li>Sherly 手腳比較快，先完成了，於是先把做好的成果推一份上去。</li><li>Eddie 不久後也完成了，但當他要推上去的時候發現推不上去了…</li></ol><h2 id="怎麼解決？"><a href="#怎麼解決？" class="headerlink" title="怎麼解決？"></a>怎麼解決？</h2><p>解決方法算是有兩招</p><h3 id="第一招：先拉再推"><a href="#第一招：先拉再推" class="headerlink" title="第一招：先拉再推"></a>第一招：先拉再推</h3><p>因為你電腦裡的內容是比較舊的，所以你應該先拉一份線上版本的回來更新，然後再推一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --rebase</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://github.com/eddiekao/dummy-git</span><br><span class="line">   37aaef6..bab4d89  master     -&gt; origin/master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: update index</span><br></pre></td></tr></table></figure><p>這裡加了 <code>--rebase</code> 參數是表示「內容抓下來之後請使用 Rebase 方式合併」，當然你想用一般的合併方式也沒問題。合併如果沒發生衝突，接著應該就可以順利往上推了。</p><h3 id="第二招：無視規則，總之就是聽我的！（誤）"><a href="#第二招：無視規則，總之就是聽我的！（誤）" class="headerlink" title="第二招：無視規則，總之就是聽我的！（誤）"></a>第二招：無視規則，總之就是聽我的！（誤）</h3><p>凡事總有先來後到，在上面的例子中，Sherly 先推上去的內容，後推的人就是應該拉一份下來更新，不然照規定是推不上去的。不過這規則也是有例外，只要加上了 <code>--force</code> 或是 <code>-f</code> 參數，它就會強迫硬推上去，把 Sherly 之前的內容蓋掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push -f</span><br><span class="line">Counting objects: 19, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (17/17), done.</span><br><span class="line">Writing objects: 100% (19/19), 2.16 KiB | 738.00 KiB/s, done.</span><br><span class="line">Total 19 (delta 6), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (6/6), done.</span><br><span class="line">To https://github.com/eddiekao/dummy-git.git</span><br><span class="line"> + 6bf3967...c4ea775 master -&gt; master (forced update)</span><br></pre></td></tr></table></figure><p>雖然這樣一定會成功，但接下來你就要去面對 Sherly，跟她解釋為什麼你把她的進度蓋掉了。更多關於 Force Push 的說明，可參考「<a href="https://gitbook.tw/chapters/github/using-force-push.html" target="_blank" rel="noopener">【狀況題】聽說 git push -f 這個指令很可怕，什麼情況可以用它呢？</a>」章節介紹。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93FMDB/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93FMDB/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-数据库"><a href="#必备知识架构-数据库" class="headerlink" title="必备知识架构-数据库"></a>必备知识架构-数据库</h1><h5 id="2、面试题：用一条sql语句查询出“每门”课程都大于80分的学生姓名"><a href="#2、面试题：用一条sql语句查询出“每门”课程都大于80分的学生姓名" class="headerlink" title="2、面试题：用一条sql语句查询出“每门”课程都大于80分的学生姓名"></a>2、<a href="http://blog.csdn.net/u012110719/article/details/47138477" target="_blank" rel="noopener">面试题：用一条sql语句查询出“每门”课程都大于80分的学生姓名</a></h5><p>select distinct name from aa where name not in (select distinct name from aa where fengshu&lt;=80)<br>或写成</p><p><a href="http://www.cnblogs.com/hongyan5682/p/4816444.html" target="_blank" rel="noopener">select distinct A.name from Student A<br>where not exists (select 1 from Student S Where  S.score &lt;80 AND S.name =A.name)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/4%E7%98%A6%E8%BA%AB/%E7%98%A6%E8%BA%AB-%E2%91%A0UIViewController/"/>
      <url>/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/4%E7%98%A6%E8%BA%AB/%E7%98%A6%E8%BA%AB-%E2%91%A0UIViewController/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-瘦身-①UIViewController"><a href="#必备知识架构-瘦身-①UIViewController" class="headerlink" title="必备知识架构-瘦身-①UIViewController"></a>必备知识架构-瘦身-①UIViewController</h1><p><a href="https://mp.weixin.qq.com/s/3csN2hTIHezZNm8-49jsGQ" target="_blank" rel="noopener">UIViewController的瘦身计划（iOS架构思想篇）</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/4%E7%98%A6%E8%BA%AB/%E7%98%A6%E8%BA%AB-%E2%91%A1AppDelegate%E7%98%A6%E8%BA%AB/"/>
      <url>/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/4%E7%98%A6%E8%BA%AB/%E7%98%A6%E8%BA%AB-%E2%91%A1AppDelegate%E7%98%A6%E8%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-框架设计模式-⑥AppDelegate瘦身"><a href="#必备知识架构-框架设计模式-⑥AppDelegate瘦身" class="headerlink" title="必备知识架构-框架设计模式-⑥AppDelegate瘦身"></a>必备知识架构-框架设计模式-⑥AppDelegate瘦身</h1><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CJModuleManager：CJUIKitDemo-CJBaseUtil-CJModuleManager</p><h3 id="1、AppDelegate瘦身"><a href="#1、AppDelegate瘦身" class="headerlink" title="1、AppDelegate瘦身"></a>1、AppDelegate瘦身</h3><p>举个更实际的例子，就是你在为AppDelegate瘦身的时候，将AppDelegate上的方法，分散到各自的Manager(UserManager、PushManager、LocationManager等)的时候，就肯定会需要处理这些dele</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// AppDelegate.m</span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    // Override point for customization after application launch.</span><br><span class="line">    </span><br><span class="line">    [[CJModuleManager sharedInstance] application:application didFinishLaunchingWithOptions:launchOptions];//即一启动，就会去执行所有添加到ModuleManager中所有的 application:application didFinishLaunchingWithOptions:launchOptions 方法</span><br><span class="line">    </span><br><span class="line">    // 设置主窗口,并设置根控制器</span><br><span class="line">    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">    </span><br><span class="line">    UIViewController *viewController = [[CTMediator sharedInstance] BBXPLogin_loginViewControllerWithLoginSuccessBlock:loginSuccessBlock getUserInfoSuccessBlock:getUserInfoSuccessBlock];</span><br><span class="line">    </span><br><span class="line">    self.window.rootViewController = [[UINavigationController alloc] initWithRootViewController:viewController];</span><br><span class="line">    </span><br><span class="line">    [self.window makeKeyAndVisible];</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 附:上述AppDelegete.m执行的CJModuleManager.m中方法为</span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    for (id&lt;CJModule&gt; module in self.modules) &#123;</span><br><span class="line">        if ([module respondsToSelector:_cmd]) &#123;</span><br><span class="line">            [module application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/2%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A1%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/2%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A1%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-框架设计模式-②单例模式"><a href="#必备知识架构-框架设计模式-②单例模式" class="headerlink" title="必备知识架构-框架设计模式-②单例模式"></a>必备知识架构-框架设计模式-②单例模式</h1><p>–</p><h2 id="精选文章"><a href="#精选文章" class="headerlink" title="精选文章"></a>精选文章</h2><p>以下目录内容全部摘自：<a href="http://www.cocoachina.com/ios/20171123/21300.html" target="_blank" rel="noopener">iOS中的单例模式</a></p><p></p><p id="目录"></p><p></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><p><a href="#">一、什么是单例模式</a></p></li><li><p><a href="#">二、如何实现基本的单例模式？</a></p></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><a href="#">三、多线程怎么办？</a></p></li><li><p><a href="#">四、Objective-C的坑</a></p></li><li><p><a href="#">五、可不可以再方便点？</a></p></li><li><p><a href="#">六、单例模式潜在的问题</a></p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、内存问题</span><br><span class="line">2、循环依赖问题</span><br></pre></td></tr></table></figure></li><li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p></li><li><p><a href="#END">END</a></p></li></ul><p></p><p id=""></p><p></p><h2 id="一、单例"><a href="#一、单例" class="headerlink" title="一、单例"></a>一、单例</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>1、单例：dispatch_once （使用dispatch_once时，不用使用@synchronized）<br>单例是一种用于实现单例的数学概念，即将类的实例化限制成仅一个对象的设计模式。<br>或者我的理解是：单例是一种类，该类只能实例化一个对象。</p><p>实现单例模式的函数就是void dispatch_once( dispatch_once_t *predicate, dispatch_block_t block);<br>该函数接收一个dispatch_once用于检查该代码块是否已经被调度的谓词（是一个长整型，实际上作为BOOL使用）。它还接收一个希望在应用的生命周期内仅被调度一次的代码块，对于本例就用于shared实例的实例化。<br>dispatch_once不仅意味着代码仅会被运行一次，而且还是线程安全的，这就意味着你不需要使用诸如@synchronized之类的来防止使用多个线程或者队列时不同步的问题。<br>Apple的GCD Documentation证实了这一点:<br>如果被多个线程调用，该函数会同步等等直至代码块完成。</p><p>示例：在整个应用中访问某个类的共享实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (NetworkManager *)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    static NetworkManager *sharedManager;</span><br><span class="line"></span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedManager = [[NetworkManager alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return sharedManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这些，你现在在应用中就有一个共享的实例，该实例只会被创建一次。<br>下次你任何时候访问共享实例，需要做的仅是：NetworkManager *networkManager = [NetworkManager sharedInstance];</p><p>2、线程的同步执行@synchronized<br>为了防止多个线程同时执行同一个代码块，OC提供了@synchronized()指令。使用@synchronized()指令可以锁住在线程中执行的某一个代码块。存在被保护（即被锁住）的代码块的其他线程，将被阻塞，这也就意味着，他们将在@synchronized()代码块的最后一条语句执行结束后才能继续执行。<br>@synchronized()指令的唯一参数可以使用任何OC对象，包括self。这个对象就是我们所谓的信号量。</p><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/2%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A2%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F(KVO&amp;Notification)/"/>
      <url>/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/2%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A2%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F(KVO&amp;Notification)/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-框架设计模式-③观察者模式-KVO-amp-Notification"><a href="#必备知识架构-框架设计模式-③观察者模式-KVO-amp-Notification" class="headerlink" title="必备知识架构-框架设计模式-③观察者模式(KVO&amp;Notification)"></a>必备知识架构-框架设计模式-③观察者模式(KVO&amp;Notification)</h1><h2 id="精选文章"><a href="#精选文章" class="headerlink" title="精选文章"></a>精选文章</h2><p>以下目录全部摘自：<a href="https://www.jianshu.com/p/e59bb8f59302" target="_blank" rel="noopener">iOS开发 – KVO的实现原理与具体应用</a></p><ul><li><a href="https://blog.csdn.net/chy305chy/article/details/51793373" target="_blank" rel="noopener">iOS学习——KVO底层实现机制探究</a></li><li><a href="https://blog.csdn.net/u014247354/article/details/78403567" target="_blank" rel="noopener">KVO原理及自定义KVO</a></li><li><a href="https://www.jianshu.com/p/aa996ddc0e85" target="_blank" rel="noopener">教你一行代码使用 KVO（Facebook 出品 FBKVOController 源码使用及解读）</a></li></ul><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/3%E7%BB%84%E4%BB%B6%E5%8C%96/5%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A6%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
      <url>/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/3%E7%BB%84%E4%BB%B6%E5%8C%96/5%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A6%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-框架设计模式-⑦组件化"><a href="#必备知识架构-框架设计模式-⑦组件化" class="headerlink" title="必备知识架构-框架设计模式-⑦组件化"></a>必备知识架构-框架设计模式-⑦组件化</h1><p>[toc]</p><p>好文分享：</p><ul><li><p><a href="https://www.cnblogs.com/dins/p/ios-zu-jian-hua-fang-an.html" target="_blank" rel="noopener">iOS 组件化方案</a></p></li><li><p><a href="https://www.jianshu.com/p/67a6004f6930" target="_blank" rel="noopener">组件化架构漫谈</a></p></li></ul><h2 id="一、产生背景"><a href="#一、产生背景" class="headerlink" title="一、产生背景"></a>一、产生背景</h2><p>1、产生背景：</p><p>所有模块代码都编写在一个项目中，在项目越来越大后，<strong>测试/使用某个模块或功能，需要编译运行整个项目，麻烦</strong>。</p><p>2、组件化思路：</p><p>将每个模块作为一个组件，加一个<strong>中间层</strong>来协调各个模块间的调用，<strong>所有的模块间的调用都会经过中间层中转。</strong>（<strong>只让其他模块对中间层产生耦合关系，中间层不对其他模块发生耦合</strong>。）</p><p>3、组件化好处：</p><blockquote><p>业务划分更佳清晰，新人接手更佳容易，可以按组件分配开发任务。</p><p>项目可维护性更强，提高开发效率。</p><p>更好排查问题，某个组件出现问题，直接对组件进行处理。</p><p>开发测试过程中，可以只编译自己那部分代码，不需要编译整个项目代码。</p><p>方便集成，项目需要哪个模块直接通过<code>CocoaPods</code>集成即可。</p></blockquote><h2 id="二、架构设计"><a href="#二、架构设计" class="headerlink" title="二、架构设计"></a>二、架构设计</h2><h3 id="1、架构封层"><a href="#1、架构封层" class="headerlink" title="1、架构封层"></a>1、架构封层</h3><p>整个APP架构上从上到下分为<strong>三层</strong>，独立于APP的通用层，通用业务层，业务层。</p><p><img src="/iOS/架构相关/3组件化/5框架设计模式-⑦组件化/架构分层1.png" alt="架构分层1" style="zoom: 33%;"></p><h4 id="1-1、独立于APP的通用层"><a href="#1-1、独立于APP的通用层" class="headerlink" title="1.1、独立于APP的通用层"></a>1.1、独立于APP的通用层</h4><p>此层常为：一些Cocoapods公有库或者自己编写的独立于APP的库。</p><p>举例：MJExtension、CJNetwork、分享、CJOverlayKit(Toast、HUD、ActionSheet)、CJShareList</p><h4 id="1-2、每个APP自己的通用层"><a href="#1-2、每个APP自己的通用层" class="headerlink" title="1.2、每个APP自己的通用层"></a>1.2、每个APP自己的通用层</h4><p>此层常为：前面的独立于APP的通用层的二次封装。若公司内部引用了第三方库，按照依赖倒置的原则，建议封装一层之后放到Basic Specs供业务方使用。好处：跟外部环境有效隔离，第三方库发生问题，公司内部可控。</p><p>如：CQNetwork、CQOverlayKit、CQShareKit、网络库CQNetwork、数据库(FMDB/WCDB)、缓存库等</p><p>依赖倒置原则告诉我们要面向接口编程；通过抽象（接口或抽象类）使各个类或模块实现彼此独立，互不影响，实现模块间的松耦合。</p><h4 id="1-3、业务模块"><a href="#1-3、业务模块" class="headerlink" title="1.3、业务模块"></a>1.3、业务模块</h4><p>业务层的模块应该按照模块化的设计思想，尽量做到高度的“高内聚，低耦合”。</p><p>因模块高度独立，且高频使用，若公司内部有多个App同时需要依赖，建议单独创建私有库Specs。</p><h4 id="1、组件化"><a href="#1、组件化" class="headerlink" title="1、组件化"></a>1、组件化</h4><blockquote><p>​    就是<strong>“基础库”</strong>或者<strong>“基础组件”，</strong>意思是把代码重复的部分提炼出一个个组件供给功能使用。</p><p>​    使用：Dialog，各种自定义的UI控件、能在项目或者不同项目重复应用的代码等等。</p><p>​    目的：复用，解耦。</p><p>​    依赖：组件之间低依赖，比较独立。</p><p>​    架构定位：纵向分层（位于架构底层，被其他层所依赖）。</p></blockquote><h4 id="2、模块化"><a href="#2、模块化" class="headerlink" title="2、模块化"></a>2、模块化</h4><blockquote><p>​    就是<strong>“业务框架”</strong>或者<strong>“业务模块”</strong>，也可以理解为“框架”，意思是把功能进行划分，将同一类型的代码整合在一起，所以模块的功能相对复杂，但都同属于一个业务。</p><p>​    使用：按照项目功能需求划分成不同类型的业务框架（例如：注册、登录、外卖、直播…..）</p><p>​    目的：隔离/封装 （高内聚）。</p><p>​    依赖：模块之间有依赖的关系，可通过路由器进行模块之间的耦合问题。</p><p>​    架构定位：横向分块（位于架构业务框架层）。</p></blockquote><h4 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h4><p>​      其实组件相当于<strong>库</strong>，把一些能在<strong>项目里或者不同类型项目中</strong>可复用的代码进行工具性的封装。</p><p>​      而模块相应于<strong>业务逻辑模块</strong>，把<strong>同一类型项目里</strong>的功能逻辑进行进行需求性的封装。</p><h2 id="iOS端APP架构设计心得"><a href="#iOS端APP架构设计心得" class="headerlink" title="iOS端APP架构设计心得"></a>iOS端APP架构设计心得</h2><ul><li><a href="https://www.jianshu.com/p/0ea6b72ea1a3" target="_blank" rel="noopener">iOS端APP架构设计心得</a></li><li><a href="https://mobile.51cto.com/hot-600305.htm" target="_blank" rel="noopener">对于App架构和组件化的思考</a></li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/2%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A4%E5%A4%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/2%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A4%E5%A4%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-框架设计模式-⑤多代理模式"><a href="#必备知识架构-框架设计模式-⑤多代理模式" class="headerlink" title="必备知识架构-框架设计模式-⑤多代理模式"></a>必备知识架构-框架设计模式-⑤多代理模式</h1><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="1、什么是多代理"><a href="#1、什么是多代理" class="headerlink" title="1、什么是多代理"></a>1、什么是多代理</h3><h4 id="引文①、环信SDK"><a href="#引文①、环信SDK" class="headerlink" title="引文①、环信SDK"></a>引文①、环信SDK</h4><p>用过环信SDK的同学应该对多代理不陌生了，请看下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> @method</span><br><span class="line"> @brief 注册一个监听对象到监听列表中</span><br><span class="line"> @discussion 把监听对象添加到监听列表中准备接收相应的事件</span><br><span class="line"> @param delegate 需要注册的监听对象</span><br><span class="line"> @param queue 通知监听对象时的线程</span><br><span class="line"> @result</span><br><span class="line"> */</span><br><span class="line">- (void)addDelegate:(id&lt;EMChatManagerDelegate&gt;)delegate delegateQueue:(dispatch_queue_t)queue;</span><br></pre></td></tr></table></figure><p>平时我们写得比较多的代理: <code>@property (nonatomic,weak) id&lt;EMChatManagerDelegate&gt;delegate;</code> 写了上面属性后系统会默认生成set方法: <code>- (void)setDelegate:(id&lt;EMChatManagerDelegate&gt;)delegate;</code>通过对两个接口的比较就不难看出：<code>单代理只能设置一个，而多代理可以设置多个，准确来说应该是多代理可以添加多个</code>。</p><p>以上摘自：<a href="https://github.com/chengpengfei1993/Multi-Delegate" target="_blank" rel="noopener">iOS 实现多代理的方法及实例代码</a></p><h4 id="引文②、XMPP"><a href="#引文②、XMPP" class="headerlink" title="引文②、XMPP"></a>引文②、XMPP</h4><p>XMPP以及类似IM框架里通常会有这种需求：打开多个聊天窗口，和多个人聊天。然鹅框架底层消息转发管理器却只有一个。通常是这两个窗口都要收到消息回调，然后取自己有用的消息。。。<br>大概就这么个意思，我两年前用了下，具体也解释不清楚，欢迎指点交流，反正就是有一个需求需要多代理回调，这种IM框架通常有这种方法<br><code>[xmppRoom addDelegate:self delegateQueue:dispatch_get_main_queue()];</code></p><p>以上摘自：<a href="https://www.jianshu.com/p/79c5da4fe198" target="_blank" rel="noopener">iOS 多代理的实现</a></p><h4 id="引文③、类似IM库，当接受到消息，在几个不同地方做回调，比如改变消息数，显示小红点等"><a href="#引文③、类似IM库，当接受到消息，在几个不同地方做回调，比如改变消息数，显示小红点等" class="headerlink" title="引文③、类似IM库，当接受到消息，在几个不同地方做回调，比如改变消息数，显示小红点等"></a>引文③、类似IM库，当接受到消息，在几个不同地方做回调，比如改变消息数，显示小红点等</h4><p>参考文章：<a href="https://www.jianshu.com/p/f7e768a21ab2" target="_blank" rel="noopener">iOS实现多重代理及应用场景</a></p><h3 id="2、为什么不用NSNotificationCenter"><a href="#2、为什么不用NSNotificationCenter" class="headerlink" title="2、为什么不用NSNotificationCenter"></a>2、为什么不用NSNotificationCenter</h3><p>系统不是已经有通知中心NSNotificationCenter了吗？为什么还要自己实现一个呢？</p><p>举个例子，现在我们有一个模块需要抛一个通知出来，通知其它模块用户名改变了，我们来看代码大致是怎么写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">发通知一方</span><br><span class="line">NSString *const kUserNameChangedNotification = @&quot;UserNameChangedNotification&quot;;</span><br><span class="line"></span><br><span class="line">NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];</span><br><span class="line">[notificationCenter postNotificationName:UserNameChangedNotification object:nil </span><br><span class="line"> userInfo:@&#123;@&quot;oldName&quot;:@&quot;zhangsan&quot;,&quot;newName&quot;:&quot;lisi&quot;&#125;];</span><br><span class="line"></span><br><span class="line">接收通知的一方可以是</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(UserNameChanged1:) </span><br><span class="line">  name:kUserNameChangedNotification object:nil];</span><br><span class="line">也可以是</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(UserNameChanged2:) </span><br><span class="line">  name:kUserNameChangedNotification object:nil];</span><br></pre></td></tr></table></figure><p>从例子中可以看到有的缺点:<br>1.对于接收同一个事件的通知，不同的人可能会用不同的方法名来执行（例子中是<code>UserNameChanged1</code>和<code>UserNameChanged1</code>)，无法统一。<br>2.对于多参数支持不方便。</p><h2 id="项目背景举例："><a href="#项目背景举例：" class="headerlink" title="项目背景举例："></a>项目背景举例：</h2><p>背景描述如下：</p><p>vc中所做的某个操作(指一个操作)，想要发送给多个人，让他们接收到信息后，自己处理。</p><p>我们假设接收者为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DelegateReceivedViewModel1 *delegateReceiver1 = [[DelegateReceivedViewModel1 alloc] init];</span><br><span class="line">DelegateReceivedViewModel2 *delegateReceiver2 = [[DelegateReceivedViewModel2 alloc] init];</span><br><span class="line">self.delegateReceiver1 = delegateReceiver1;</span><br><span class="line">self.delegateReceiver2 = delegateReceiver2;</span><br></pre></td></tr></table></figure><h2 id="一、正常操作"><a href="#一、正常操作" class="headerlink" title="一、正常操作"></a>一、正常操作</h2><p>①发送状态变化的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// OneToManyDelegateNormalViewController1.h</span><br><span class="line">#import &quot;CJUIKitBaseHomeViewController.h&quot;</span><br><span class="line">#import &quot;TSDelegate.h&quot;</span><br><span class="line"></span><br><span class="line">@interface OneToManyDelegateNormalViewController1 : CJUIKitBaseHomeViewController &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, weak) id&lt;TSDelegate&gt; delegate1;// 提供给外部设置</span><br><span class="line">@property (nonatomic, weak) id&lt;TSDelegate&gt; delegate2;// 提供给外部设置</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">// OneToManyDelegateNormalViewController1.m</span><br><span class="line">loginModule.actionBlock = ^&#123;</span><br><span class="line">  [self.delegate1 delegate_didUpdateLoginState:YES];</span><br><span class="line">  [self.delegate2 delegate_didUpdateLoginState:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②设置代理的地方会是如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OneToManyDelegateNormalViewController1 *viewController = [[OneToManyDelegateNormalViewController1 alloc] init];</span><br><span class="line">viewController.delegate1 = delegateReceiver1;</span><br><span class="line">viewController.delegate2 = delegateReceiver2;</span><br><span class="line">[self.navigationController pushViewController:viewController animated:YES];</span><br></pre></td></tr></table></figure><h2 id="二、优化delegate"><a href="#二、优化delegate" class="headerlink" title="二、优化delegate"></a>二、优化delegate</h2><h3 id="1、优化思路一：从vc中抽离delegate到Mediator"><a href="#1、优化思路一：从vc中抽离delegate到Mediator" class="headerlink" title="1、优化思路一：从vc中抽离delegate到Mediator"></a>1、优化思路一：从vc中抽离delegate到Mediator</h3><p>为了优化代码，我们从vc中抽离delegate，则此时</p><p>①设置代理的地方会是如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OneToManyDelegateNormalMediator21 *delegateMediator = [[OneToManyDelegateNormalMediator21 alloc] init];</span><br><span class="line">delegateMediator.delegate1 = self.delegateReceiver1;</span><br><span class="line">delegateMediator.delegate2 = self.delegateReceiver2;</span><br><span class="line"></span><br><span class="line">OneToManyDelegateNormalViewController21 *viewController = [[OneToManyDelegateNormalViewController21 alloc] init];</span><br><span class="line">viewController.delegateMediator = delegateMediator;</span><br><span class="line">[self.navigationController pushViewController:viewController animated:YES];</span><br></pre></td></tr></table></figure><p>②发送状态变化的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// OneToManyDelegateNormalViewController21.m</span><br><span class="line">loginModule.actionBlock = ^&#123;</span><br><span class="line">  //[self.delegate1 delegate_didUpdateLoginState:YES];</span><br><span class="line">  //[self.delegate2 delegate_didUpdateLoginState:YES];</span><br><span class="line">  [self.delegateMediator delegate_didUpdateLoginState:YES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>③此时<code>delegateMediator</code>中的<code>delegate_didUpdateLoginState:</code>方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - TSDelegate</span><br><span class="line">- (void)delegate_didUpdateLoginState:(BOOL)loginState &#123;</span><br><span class="line">    if (self.delegate1 &amp;&amp; [self.delegate1 respondsToSelector:@selector(delegate_didUpdateLoginState:)]) &#123;</span><br><span class="line">        [self.delegate1 delegate_didUpdateLoginState:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.delegate2 &amp;&amp; [self.delegate2 respondsToSelector:@selector(delegate_didUpdateLoginState:)]) &#123;</span><br><span class="line">        [self.delegate2 delegate_didUpdateLoginState:YES];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、优化思路二：在Mediator中管理delegate数组"><a href="#2、优化思路二：在Mediator中管理delegate数组" class="headerlink" title="2、优化思路二：在Mediator中管理delegate数组"></a>2、优化思路二：在Mediator中管理delegate数组</h3><p>为了减少设置代理的变量，我们使用delegate数组，则此时</p><p>①设置代理的地方会是如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OneToManyDelegateArrayMediator31 *delegateMediator = [[OneToManyDelegateArrayMediator31 alloc] init];</span><br><span class="line">[delegateMediator addDelegate:self.delegateReceiver1];</span><br><span class="line">[delegateMediator addDelegate:self.delegateReceiver2];</span><br><span class="line"></span><br><span class="line">OneToManyDelegateArrayViewController31 *viewController = [[OneToManyDelegateArrayViewController31 alloc] init];</span><br><span class="line">viewController.delegateMediator = delegateMediator;</span><br><span class="line">[self.navigationController pushViewController:viewController animated:YES];</span><br></pre></td></tr></table></figure><p>②发送状态变化的信息如下：不变</p><p>③此时<code>delegateMediator</code>中的<code>delegate_didUpdateLoginState:</code>方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//  OneToManyDelegateArrayMediator31.m</span><br><span class="line"></span><br><span class="line">- (void)addDelegate:(id)delegate &#123;</span><br><span class="line">    [_delegates addPointer:(__bridge void*)delegate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - TSDelegate</span><br><span class="line">- (void)delegate_didUpdateLoginState:(BOOL)loginState &#123;</span><br><span class="line">    for (NSUInteger i = 0; i &lt; self.delegates.count; i++) &#123;</span><br><span class="line">        id delegate = (__bridge id)[self.delegates pointerAtIndex:i];</span><br><span class="line">        if (delegate &amp;&amp; [delegate respondsToSelector:@selector(delegate_didUpdateLoginState:)]) &#123;</span><br><span class="line">            [delegate delegate_didUpdateLoginState:YES];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说说上面我们应该用什么来管理遵守协议的类-NSHashTable"><a href="#说说上面我们应该用什么来管理遵守协议的类-NSHashTable" class="headerlink" title="说说上面我们应该用什么来管理遵守协议的类(NSHashTable)?"></a>说说上面我们应该用什么来管理遵守协议的类(NSHashTable)?</h3><p>这边用了NSHashTable来存储遵守协议的类,NSHashTable和NSSet类似,但又有所不同,总的来说有这几个特点:</p><p>NSHashTable中的元素可以通过Hashable协议来判断是否相等.</p><p>NSHashTable中的元素如果是弱引用,对象销毁后会被移除,可以避免循环引用.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">masterOrderDelegateManager</span> : <span class="title">MasterOrderDelegate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> multiDelegate: <span class="type">NSHashTable</span>&lt;<span class="type">AnyObject</span>&gt; = <span class="type">NSHashTable</span>.weakObjects()</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> delegates: [<span class="type">MasterOrderDelegate</span>]) &#123;</span><br><span class="line">    delegates.forEach(multiDelegate.add)</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 协议中的方法,可以有多个</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">toEat</span><span class="params">(<span class="number">_</span> food: String)</span></span> &#123;</span><br><span class="line">    invoke &#123; $<span class="number">0</span>.toEat(food) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 添加遵守协议的类</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> delegate: MasterOrderDelegate)</span></span> &#123;</span><br><span class="line">    multiDelegate.add(delegate)</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 删除指定遵守协议的类</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> delegateToRemove: MasterOrderDelegate)</span></span> &#123;</span><br><span class="line">    invoke &#123;</span><br><span class="line">      <span class="keyword">if</span> $<span class="number">0</span> === delegateToRemove <span class="keyword">as</span> <span class="type">AnyObject</span> &#123;</span><br><span class="line">        multiDelegate.remove($<span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 删除所有遵守协议的类</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">removeAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">    multiDelegate.removeAllObjects()</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 遍历所有遵守协议的类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(<span class="number">_</span> invocation: <span class="params">(MasterOrderDelegate)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> delegate <span class="keyword">in</span> multiDelegate.allObjects.reversed() &#123;</span><br><span class="line">      invocation(delegate <span class="keyword">as</span>! <span class="type">MasterOrderDelegate</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附：不常见集合NSHashTable和NSMapTable"><a href="#附：不常见集合NSHashTable和NSMapTable" class="headerlink" title="附：不常见集合NSHashTable和NSMapTable"></a>附：不常见集合NSHashTable和NSMapTable</h2><p><a href="https://www.jianshu.com/p/ea1f261f71f7" target="_blank" rel="noopener">不常见集合NSHashTable和NSMapTable</a></p><h2 id="三、优化状态变化的发送方法"><a href="#三、优化状态变化的发送方法" class="headerlink" title="三、优化状态变化的发送方法"></a>三、优化状态变化的发送方法</h2><h3 id="1、未优化时候："><a href="#1、未优化时候：" class="headerlink" title="1、未优化时候："></a>1、未优化时候：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// vc.m</span><br><span class="line">loginModule.actionBlock = ^&#123;</span><br><span class="line">  if (self.delegateMediator &amp;&amp; [self.delegateMediator respondsToSelector:@selector(delegate_didUpdateLoginState:)]) &#123;</span><br><span class="line">      [self.delegateMediator delegate_didUpdateLoginState:YES];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Mediator.m</span><br><span class="line">#pragma mark - TSDelegate</span><br><span class="line">- (void)delegate_didUpdateLoginState:(BOOL)loginState &#123;</span><br><span class="line">    for (NSUInteger i = 0; i &lt; self.delegates.count; i++) &#123;</span><br><span class="line">        id delegate = (__bridge id)[self.delegates pointerAtIndex:i];</span><br><span class="line">        if (delegate &amp;&amp; [delegate respondsToSelector:@selector(delegate_didUpdateLoginState:)]) &#123;</span><br><span class="line">            [delegate delegate_didUpdateLoginState:YES];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够在Mediator中减少我们要实现每个代理的每个方法，我们进行如下优化：</p><h3 id="2、增加个发送的封装方法，将协议要执行的方法改为参数等传进去"><a href="#2、增加个发送的封装方法，将协议要执行的方法改为参数等传进去" class="headerlink" title="2、增加个发送的封装方法，将协议要执行的方法改为参数等传进去"></a>2、增加个发送的封装方法，将协议要执行的方法改为参数等传进去</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// vc.m</span><br><span class="line">loginModule.actionBlock = ^&#123;</span><br><span class="line">  [self.delegateMediator broadcastProtocol:@protocol(TSDelegate)</span><br><span class="line">   selector:@selector(delegate_didUpdateLoginState:)</span><br><span class="line">    responder:^(id&lt;TSDelegate&gt; delegateReceiver) &#123;</span><br><span class="line">     [delegateReceiver delegate_didUpdateLoginState:YES];</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Mediator.m</span><br><span class="line">- (void)broadcastProtocol:(Protocol * _Nonnull)protocol selector:(SEL _Nullable)selector responder:(void (^_Nonnull)(id _Nonnull delegateReceiver))block &#123;</span><br><span class="line">    NSAssert(protocol, @&quot;Protocol is nil.&quot;);</span><br><span class="line">    NSAssert(block, @&quot;Block is nil.&quot;);</span><br><span class="line">    </span><br><span class="line">    for (NSUInteger i = 0; i &lt; self.delegates.count; i++) &#123;</span><br><span class="line">        id delegateReceiver = (__bridge id)[self.delegates pointerAtIndex:i];</span><br><span class="line">        if (!selector || [delegateReceiver respondsToSelector:selector]) &#123;</span><br><span class="line">            block(delegateReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、如果你不用上述的封装方法，你还可以利用消息转发"><a href="#3、如果你不用上述的封装方法，你还可以利用消息转发" class="headerlink" title="3、如果你不用上述的封装方法，你还可以利用消息转发"></a>3、如果你不用上述的封装方法，你还可以利用消息转发</h3><p>对Mediator对象调用<code>delegate_didUpdateLoginState</code>方法时，因为<code>含delegates的Mediator对象</code>并没有实现协议中的方法，如<code>delegate_didUpdateLoginState</code>，所以，我们只能要么补充实现，要么不实现的话，就<strong>利用消息转发，将协议中的方法转发到自己delegate链中的对象</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// vc.m</span><br><span class="line">loginModule.actionBlock = ^&#123;</span><br><span class="line">  if (self.delegateMediator &amp;&amp; [self.delegateMediator respondsToSelector:@selector(delegate_didUpdateLoginState:)]) &#123;</span><br><span class="line">      [self.delegateMediator delegate_didUpdateLoginState:YES];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Mediator.m</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    if (signature) &#123;</span><br><span class="line">        return signature;</span><br><span class="line">    &#125;</span><br><span class="line">  [_delegates addPointer:nil]; //不加上这句的话，直接调用compact，并不能清除 _delegates 数组中的 nil 对象。</span><br><span class="line">    [_delegates compact];   //注意 [_delegates compact]，这个方法可以帮助你去掉数组里面的野指针，避免你在快速遍历的时候拿到一个指向不存在对象的地址</span><br><span class="line"></span><br><span class="line">    for (id delegate in _delegates) &#123;</span><br><span class="line">        if (!delegate) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        signature = [delegate methodSignatureForSelector:aSelector];</span><br><span class="line">        if (signature) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    SEL selector = [anInvocation selector];</span><br><span class="line">    BOOL responded = NO;</span><br><span class="line">    for (id delegate in _delegates) &#123;</span><br><span class="line">        if (delegate &amp;&amp; [delegate respondsToSelector:selector]) &#123;</span><br><span class="line">            [anInvocation invokeWithTarget:delegate];</span><br><span class="line">            responded = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!responded) &#123;</span><br><span class="line">        [self doesNotRecognizeSelector:selector];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方式的问题：由于<code>[self.delegateMediator delegate_didUpdateLoginState:YES];</code>，所以delegateMediator需要在@interface支持<xxdelegate>，同样的因为这个支持，我们需要在.m文件中去实现它里面的方法，否则会有警告。除非说协议里的那些方法全部都是设置为了<code>@optional</code>。</xxdelegate></p><p>结论：基于此方式的问题，所以为了减少对其他的约束，我们这里最后采用2的优化方式。</p><h2 id="四、发现潜在问题"><a href="#四、发现潜在问题" class="headerlink" title="四、发现潜在问题"></a>四、发现潜在问题</h2><h3 id="1、如果两个protocal中有同名方法怎么办？"><a href="#1、如果两个protocal中有同名方法怎么办？" class="headerlink" title="1、如果两个protocal中有同名方法怎么办？"></a>1、如果两个protocal中有同名方法怎么办？</h3><p>举例：在vc.m中想要告诉大家去实现协议1中的<code>showMessage</code>方法，但是如果不说明是协议1中的方法，可能有个协议2也有同样的方法，导致执行的方法错了。</p><p>分析：这种情况是可能出现的，但是这种情况出现的时候，不会被引用到同一个监听者，不然分不清delegateReceiver中现在执行的是哪一个。</p><p>如原本名字不一样，我们区分得开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// viewModel.m</span><br><span class="line">#pragma mark - TSUserDelegate</span><br><span class="line">- (void)userDelegate_didUpdateLoginState:(BOOL)loginState &#123;</span><br><span class="line">    NSLog(@&quot;vm收到userDelegate:登录状态发生变化，您已%@&quot;, loginState ? @&quot;登录&quot; : @&quot;登出&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - TSMessageDelegate</span><br><span class="line">- (void)messageDelegate_didUpdateMessageState:(BOOL)messageState &#123;</span><br><span class="line">    NSLog(@&quot;vm收到messageDelegate:信息状态发生变化&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接在上述原本实现的基础上看问题，修改后为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// vc.m</span><br><span class="line">loginModule.actionBlock = ^&#123;</span><br><span class="line">  [self.delegateMediator broadcastProtocol:@protocol(TSDelegate)</span><br><span class="line">   selector:@selector(delegate_didUpdateLoginState:)</span><br><span class="line">    responder:^(id&lt;TSDelegate&gt; delegateReceiver) &#123;</span><br><span class="line">     [delegateReceiver delegate_didUpdateLoginState:YES];</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Mediator.m</span><br><span class="line">- (void)broadcastProtocol:(Protocol * _Nonnull)protocol selector:(SEL _Nullable)selector responder:(void (^_Nonnull)(id _Nonnull delegateReceiver))block &#123;</span><br><span class="line">    NSAssert(protocol, @&quot;Protocol is nil.&quot;);</span><br><span class="line">    NSAssert(block, @&quot;Block is nil.&quot;);</span><br><span class="line">    </span><br><span class="line">    for (NSUInteger i = 0; i &lt; self.delegates.count; i++) &#123;</span><br><span class="line">        id delegateReceiver = (__bridge id)[self.delegates pointerAtIndex:i];</span><br><span class="line">      </span><br><span class="line">      if (![delegateReceiver conformsToProtocol:protocol]) &#123;  // 处理多个protocal中有同名方法,通过传进来的protocol参数，我们在判断接收者有我们想要的方法前，先找到有实现我们想要协议的那个接收者</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        if (!selector || [delegateReceiver respondsToSelector:selector]) &#123;</span><br><span class="line">            block(delegateReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理：添加delegate的时候，也</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (![delegateReceiver conformsToProtocol:protocol]) &#123;  // 处理多个protocal中有同名方法,通过传进来的protocol参数，我们在判断接收者有我们想要的方法前，先找到有实现我们想要协议的那个接收者</span><br><span class="line">        // continue or return or ...;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2、如何保证delegates操作的数据安全"><a href="#2、如何保证delegates操作的数据安全" class="headerlink" title="2、如何保证delegates操作的数据安全"></a>2、如何保证delegates操作的数据安全</h3><p>场景：B页面发送一个信号，B页面的viewModel会去执行，当然还有其他地方也有可能执行。</p><p>那么当B发送信号出去，还在遍历执行的时候，突然某个从B页面返回A页面，B页面释放，B的viewModel也跟着释放，即这个信号的其中一个接收者B的viewModel被释放了，那么当执行的时候相当于给nil发送信息，不会崩溃。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for (NSUInteger i = 0; i &lt; self.delegates.count; i++) &#123;</span><br><span class="line">       id delegateReceiver = (__bridge id)[self.delegates pointerAtIndex:i];</span><br><span class="line">     </span><br><span class="line">     if (![delegateReceiver conformsToProtocol:protocol]) &#123;  // 处理多个protocal中有同名方法,通过传进来的protocol参数，我们在判断接收者有我们想要的方法前，先找到有实现我们想要协议的那个接收者</span><br><span class="line">           continue;</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       if (!selector || [delegateReceiver respondsToSelector:selector]) &#123;</span><br><span class="line">           block(delegateReceiver);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>需要注意数据安全的地方，应该是避免重复添加和重复删除。</p><p>所以，我们使用@synchronized来保护。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@synchronized(xxx) &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="五、delegateMediator升级为中心单例"><a href="#五、delegateMediator升级为中心单例" class="headerlink" title="五、delegateMediator升级为中心单例"></a>五、delegateMediator升级为中心单例</h2><p>发送时候的核心代码，大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// vc.m</span><br><span class="line">loginModule.actionBlock = ^&#123;</span><br><span class="line">  [[TSNotificationCenter defaultCenter] broadcastProtocol:@protocol(TSDelegate)</span><br><span class="line">    selector:@selector(delegate_didUpdateLoginState:)</span><br><span class="line">                            responder:^(id&lt;TSDelegate&gt; delegateReceiver) &#123;</span><br><span class="line">  [delegateReceiver delegate_didUpdateLoginState:YES];</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 该发送方法在`TSNotificationCenter.m`中的代码如下</span><br><span class="line">- (void)broadcastProtocol:(Protocol * _Nonnull)protocol selector:(SEL _Nullable)selector responder:(void (^_Nonnull)(id _Nonnull delegateReceiver))block &#123;</span><br><span class="line">    NSAssert(protocol, @&quot;Protocol is nil.&quot;);</span><br><span class="line">    NSAssert(block, @&quot;Block is nil.&quot;);</span><br><span class="line">    </span><br><span class="line">    for (NSUInteger i = 0; i &lt; self.delegates.count; i++) &#123;</span><br><span class="line">        id delegateReceiver = (__bridge id)[self.delegates pointerAtIndex:i];</span><br><span class="line">      </span><br><span class="line">      if (![delegateReceiver conformsToProtocol:protocol]) &#123;  // 处理多个protocal中有同名方法,通过传进来的protocol参数，我们在判断接收者有我们想要的方法前，先找到有实现我们想要协议的那个接收者</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        if (!selector || [delegateReceiver respondsToSelector:selector]) &#123;</span><br><span class="line">            block(delegateReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收时候的核心代码，大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// receiver.m</span><br><span class="line">[[TSNotificationCenter defaultCenter] addDelegate:self.diffDelegateReceiver</span><br><span class="line">                                      forProtocol:@protocol(TSUserDelegate)];</span><br><span class="line">[[TSNotificationCenter defaultCenter] addDelegate:self.diffDelegateReceiver</span><br><span class="line"> forProtocol:@protocol(TSMessageDelegate)];</span><br><span class="line"></span><br><span class="line">// 该添加方法在`TSNotificationCenter.m`中的代码如下</span><br><span class="line">- (void)addDelegate:(id __nonnull)listener forProtocol:(Protocol * _Nonnull )protocol &#123;</span><br><span class="line">    NSAssert(listener, @&quot;listener is nil&quot;);</span><br><span class="line">    NSAssert(protocol, @&quot;Protocol is nil&quot;);</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">    NSAssert([listener conformsToProtocol:protocol], @&quot;This listener does not conform to the protocol&quot;);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    @synchronized(protocol) &#123;</span><br><span class="line">        [self.hashTable addObject:listener];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>其他参考文章：</p><p><a href="https://www.jb51.net/article/94596.htm" target="_blank" rel="noopener">iOS 实现多代理的方法及实例代码</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/1%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E2%91%A3MVC%E4%B8%8EMVVM/"/>
      <url>/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/1%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E2%91%A3MVC%E4%B8%8EMVVM/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-架构模式-④MVC与MVVM"><a href="#必备知识架构-架构模式-④MVC与MVVM" class="headerlink" title="必备知识架构-架构模式-④MVC与MVVM"></a>必备知识架构-架构模式-④MVC与MVVM</h1><p>[toc]</p><p></p><p id="框架"></p><p></p><h2 id="一、框架"><a href="#一、框架" class="headerlink" title="一、框架"></a>一、框架</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><h1 id="MVC，MVP-和-MVVM-的图示"><a href="#MVC，MVP-和-MVVM-的图示" class="headerlink" title="MVC，MVP 和 MVVM 的图示"></a>MVC，MVP 和 MVVM 的图示</h1><p><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC，MVP 和 MVVM 的图示</a></p><h2 id="三、MVC与MVVM"><a href="#三、MVC与MVVM" class="headerlink" title="三、MVC与MVVM"></a>三、MVC与MVVM</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><h4 id="1、MVC的开发模式"><a href="#1、MVC的开发模式" class="headerlink" title="1、MVC的开发模式"></a>1、MVC的开发模式</h4><p>MVC是模型、视图、控制器开发模式，对于iOS SDK，所有的View都是视图层的，它应该独立于模型层，由视图器来控制。所有的用户数据都是模型层，它应该独立于视图。所有的ViewController都是视图器，由它负责控制视图，访问模型数据。</p><h4 id="3、关于MVC-和-MVVM-的区别"><a href="#3、关于MVC-和-MVVM-的区别" class="headerlink" title="3、关于MVC 和 MVVM 的区别"></a>3、关于MVC 和 MVVM 的区别</h4><p><a href="https://objccn.io/issue-13-1/" target="_blank" rel="noopener">MVVM 介绍</a></p><p>设有如下原始Model</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">- (instancetype)initwithSalutation:(NSString *)salutation firstName:(NSString *)firstName lastName:(NSString *)lastName birthdate:(NSDate *)birthdate;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) NSString *salutation;</span><br><span class="line">@property (nonatomic, readonly) NSString *firstName;</span><br><span class="line">@property (nonatomic, readonly) NSString *lastName;</span><br><span class="line">@property (nonatomic, readonly) NSDate *birthdate;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>则如果仅有此Model的话，我们在PersonViewController中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSString *nameText = nil;</span><br><span class="line">    if (self.personModel.salutation.length &gt; 0) &#123;</span><br><span class="line">        nameText = [NSString stringWithFormat:@&quot;%@ %@ %@&quot;, self.personModel.salutation, self.personModel.firstName, self.personModel.lastName];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        nameText = [NSString stringWithFormat:@&quot;%@ %@&quot;, self.personModel.firstName, self.personModel.lastName];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self.nameLabel.text = nameText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果我们进而增加一个ViewModel，则如果我们PersonViewController中可以简化成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@implementation PersonViewModel</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithPerson:(Person *)person &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) return nil;</span><br><span class="line"></span><br><span class="line">    _person = person;</span><br><span class="line">    if (person.salutation.length &gt; 0) &#123;</span><br><span class="line">        _nameText = [NSString stringWithFormat:@&quot;%@ %@ %@&quot;, self.person.salutation, self.person.firstName, self.person.lastName];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _nameText = [NSString stringWithFormat:@&quot;%@ %@&quot;, self.person.firstName, self.person.lastName];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 此时我们PersonViewController中可以简化成</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    self.nameLabel.text = self.personViewModel.nameText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/1%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/5%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE/"/>
      <url>/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/1%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/5%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-编程思想-面向协议"><a href="#必备知识架构-编程思想-面向协议" class="headerlink" title="必备知识架构-编程思想-面向协议"></a>必备知识架构-编程思想-面向协议</h1><p>[toc]</p><p>好文分享：</p><ul><li><a href="https://www.cnblogs.com/dins/p/ios-zu-jian-hua-fang-an.html" target="_blank" rel="noopener">iOS 组件化方案</a></li></ul><h2 id="一、产生背景"><a href="#一、产生背景" class="headerlink" title="一、产生背景"></a>一、产生背景</h2><h4 id="1-1-传统面向对象编程（OOP）的弊端-继承的痛点："><a href="#1-1-传统面向对象编程（OOP）的弊端-继承的痛点：" class="headerlink" title="1.1 传统面向对象编程（OOP）的弊端/继承的痛点："></a>1.1 传统面向对象编程（OOP）的弊端/继承的痛点：</h4><p><strong>继承的痛点</strong>：滥用继承的话，后面如果要抽离功能就会牵一发而动全身。即抽离一个功能会导致也要把继承链上涉及的功能都抽出来。显然太麻烦了。</p><p><strong>痛点的解决</strong>：使用面向协议，将每个单独功能一个协议，复杂功能将协议组合起来即可。如此后续抽离时，抽单独协议和实现类即可（swift中可以将实现写在扩展中，可能不涉及实现类）。</p><p>我们将网络库<a href="https://github.com/dvlproad/CJNetwork" target="_blank" rel="noopener">CJNetwork</a>使用面向协议编程后</p><p>1、定义协议CQNetworkRequestCompletionClientProtocal.h</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CQNetworkRequestCompletionClientProtocal</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param model            请求相关的信息(包含请求方法、请求地址、请求参数等)real\simulate\local</span></span><br><span class="line"><span class="comment"> *  @param completeBlock    请求结束的回调(为方便接口的重复利用回调中的responseModel使用id类型)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 执行请求的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)requestModel:(__kindof <span class="built_in">NSObject</span>&lt;CJRequestModelProtocol&gt; *)model</span><br><span class="line">                         completeBlock:(<span class="keyword">void</span> (^)(CJResponeFailureType failureType, CJResponseModel *responseModel))completeBlock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure><p>2、使用CQNetworkRequestCompletionClientProtocal</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CJNetworkClient</span> (<span class="title">Completion</span>) &lt;<span class="title">CQNetworkRequestCompletionClientProtocal</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure><h4 id="1-2-什么是面向协议编程-POP"><a href="#1-2-什么是面向协议编程-POP" class="headerlink" title="1.2 什么是面向协议编程(POP)?"></a>1.2 什么是面向协议编程(POP)?</h4><p>这个问题，我感觉比较明确的定义就是2015年Apple WWDC中说的一句话很直了的解释了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Don't start with a <span class="class"><span class="keyword">class</span>.</span></span><br><span class="line"><span class="class"><span class="title">Start</span> <span class="title">with</span> <span class="title">a</span> <span class="title">protocol</span>.</span></span><br></pre></td></tr></table></figure><p>即在程序设计中，不要以一个类开始设计，应该从一个协议开始，应抛弃之前OOP的对象设计理念，设计协议，这样不同的继承链之间也可以使用同一个协议。可以将协议看做一个组件，哪里需要哪里继承协议即可，而且协议是可以多继承的，iOS中的类只能单继承，这也是面向协议相对面向对象的一大优势。</p><h4 id="1-3-Objective-C-和Swift的面向协议编程区别"><a href="#1-3-Objective-C-和Swift的面向协议编程区别" class="headerlink" title="1.3 Objective-C 和Swift的面向协议编程区别"></a>1.3 Objective-C 和Swift的面向协议编程区别</h4><p>OC和swift面向协议编程一个最大区别是OC的 <strong>Protocol</strong> 没有默认的实现，需要依赖具体的实现类实现协议定义的方法，而Swift2.0开始提供了<strong>Protocol + Extension</strong>，协议可以再 Extension中提供默认的实现，这样上层调用可以直接调用协议的默认实现。</p><p>严谨来说，OC不是一门面向协议编程的语言，因为 <strong>Protocol</strong> 只提供定义，而不提供实现，所以叫他 <strong>面向接口编程</strong> 更合适一些。</p><p>面向协议和依赖注入</p><p>依赖注入要求我们传入的参数遵循协议，这样做的好处是：</p><ul><li>我们可以在外部注入一个通用类，只要它遵循协议。</li><li>也可以注入一个可测试的模拟类，便于测试。</li></ul><p>参考文章：<a href="https://www.jianshu.com/p/1a47f5e0f1b5" target="_blank" rel="noopener">iOS-面向协议编程(POP)</a></p><h2 id="二、替代继承的方式"><a href="#二、替代继承的方式" class="headerlink" title="二、替代继承的方式"></a>二、替代继承的方式</h2><p>参考文章：</p><ul><li><a href="https://www.jianshu.com/p/39e6a8409476" target="_blank" rel="noopener">继承和面向接口（iOS架构思想篇）</a></li></ul><p>1、协议</p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// 在屏幕中间弹出</span></span><br><span class="line">&gt; <span class="class"><span class="keyword">@protocol</span> <span class="title">ShowInCenterProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">&gt; - (<span class="keyword">void</span>)show;</span><br><span class="line">&gt; <span class="keyword">@end</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 在屏幕底部弹出</span></span><br><span class="line">&gt; <span class="class"><span class="keyword">@protocol</span> <span class="title">ShowInBottomProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">&gt; - (<span class="keyword">void</span>)show;</span><br><span class="line">&gt; <span class="keyword">@end</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">@class</span> <span class="title">NormalVoicePlayer</span> : <span class="title">NSObject</span> &lt;<span class="title">ShowInCenterProtocol</span>&gt;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">@end</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>2、用组合替代继承</p><blockquote><p>eg1:想要为一个视图做一个show操作。（设想这个show方法后面可能随时会变，比如show的位置，或者动画）</p><p>AlertUtil：使用由AlertView/PopupView+PopupAction来组合，而不使用继承AlertView+为其添加show方法。</p><p>eg2：常见的举例还有，文本框TextField的根据历史记录填充、根据@邮箱填充。</p></blockquote><p>3、类别category</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface NSArray (OBJExtras)</span><br><span class="line">- (void)removingFirstObject;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="三、使用面向协议为视图添加抖动功能"><a href="#三、使用面向协议为视图添加抖动功能" class="headerlink" title="三、使用面向协议为视图添加抖动功能"></a>三、使用面向协议为视图添加抖动功能</h2><p>举例：为UIImageView和UIButton等添加视图的抖动</p><h3 id="1、方法1：添加Category方式"><a href="#1、方法1：添加Category方式" class="headerlink" title="1、方法1：添加Category方式"></a>1、方法1：添加Category方式</h3><p>如果你写过 Objective-C, 你很可能会把 <strong>shake()</strong> 写到一个 UIView 的分类（Category) 中（也就是 Swift 中的拓展 (extension)）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  UIViewExtension.swift</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">shake</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> animation = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"position"</span>)</span><br><span class="line">        animation.duration = <span class="number">0.05</span></span><br><span class="line">        animation.repeatCount = <span class="number">5</span></span><br><span class="line">        animation.autoreverses = <span class="literal">true</span></span><br><span class="line">        animation.fromValue = <span class="type">NSValue</span>(<span class="type">CGPoint</span>: <span class="type">CGPointMake</span>(<span class="keyword">self</span>.center.x - <span class="number">4.0</span>, <span class="keyword">self</span>.center.y))</span><br><span class="line">        animation.toValue = <span class="type">NSValue</span>(<span class="type">CGPoint</span>: <span class="type">CGPointMake</span>(<span class="keyword">self</span>.center.x + <span class="number">4.0</span>, <span class="keyword">self</span>.center.y))</span><br><span class="line">        layer.addAnimation(animation, forKey: <span class="string">"position"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、方法2：面向协议方式"><a href="#2、方法2：面向协议方式" class="headerlink" title="2、方法2：面向协议方式"></a>2、方法2：面向协议方式</h3><p>但在swift里，我们除了对UIView添加extension外，其实还有另一种更好的方式：创建面向协议的视图</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoodImageView</span>: <span class="title">UIImageView</span>, <span class="title">Shakeable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他自定义写在这儿</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionButton</span>: <span class="title">UIButton</span>, <span class="title">Shakeable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他自定义写在这儿</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> foodImageView: <span class="type">FoodImageView</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> actionButton: <span class="type">ActionButton</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">onShakeButtonTap</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        foodImageView.shake()</span><br><span class="line">        actionButton.shake()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上述面向协议的视图里所对的<strong>Shakeable</strong> 协议如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Shakeable.swift</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Shakeable</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以只为 UIView 添加 shake 方法！</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Shakeable</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// shake 方法的默认实现</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">shake</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> animation = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"position"</span>)</span><br><span class="line">        animation.duration = <span class="number">0.05</span></span><br><span class="line">        animation.repeatCount = <span class="number">5</span></span><br><span class="line">        animation.autoreverses = <span class="literal">true</span></span><br><span class="line">        animation.fromValue = <span class="type">NSValue</span>(<span class="type">CGPoint</span>: <span class="type">CGPointMake</span>(<span class="keyword">self</span>.center.x - <span class="number">4.0</span>, <span class="keyword">self</span>.center.y))</span><br><span class="line">        animation.toValue = <span class="type">NSValue</span>(<span class="type">CGPoint</span>: <span class="type">CGPointMake</span>(<span class="keyword">self</span>.center.x + <span class="number">4.0</span>, <span class="keyword">self</span>.center.y))</span><br><span class="line">        layer.addAnimation(animation, forKey: <span class="string">"position"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：</p><ul><li><p><a href="https://swift.gg/2016/06/01/protocol-oriented-views-in-swift/" target="_blank" rel="noopener">用 Swift 编写面向协议的视图</a> 一定要看</p></li><li><p><a href="https://blog.csdn.net/weixin_43194732/article/details/83380486" target="_blank" rel="noopener">Swift面向协议编程</a></p></li></ul><h2 id="四、使用面向协议处理reuseIdentifier"><a href="#四、使用面向协议处理reuseIdentifier" class="headerlink" title="四、使用面向协议处理reuseIdentifier"></a>四、使用面向协议处理reuseIdentifier</h2><p>tableView的cell注册的基本代码如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foodCellNib = <span class="type">UINib</span>(<span class="type">NibName</span>: <span class="string">"FoodTableViewCell"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">tableView.registerNib(foodCellNib, forCellReuseIdentifier: <span class="string">"FoodTableViewCell"</span>)</span><br></pre></td></tr></table></figure><p>改进1：FoodTableViewCell字符串改成由类获得</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foodCellNib = <span class="type">UINib</span>(<span class="type">NibName</span>: <span class="type">String</span>(<span class="type">FoodTableViewCell</span>), bundle: <span class="literal">nil</span>)</span><br><span class="line">tableView.registerNib(foodCellNib, forCellReuseIdentifier: <span class="type">String</span>(<span class="type">FoodTableViewCell</span>))</span><br></pre></td></tr></table></figure><p>改进2：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ReusableView</span>: <span class="title">class</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 你可以只为 UIView 添加 ReusableView 方法！</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ReusableView</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> reuseIdentifier: <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITableViewCell</span>: <span class="title">ReusableView</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foodCellNib = <span class="type">UINib</span>(<span class="type">NibName</span>: “<span class="type">FoodTableViewCell</span>”, bundle: <span class="literal">nil</span>)</span><br><span class="line">tableView.registerNib(foodCellNib, forCellReuseIdentifier:<span class="type">FoodTableViewCell</span>.reuseIdentifier)</span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/1%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E2%91%A0%E6%A6%82%E8%A7%88/"/>
      <url>/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/1%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E2%91%A0%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-架构模式-①概览"><a href="#必备知识架构-架构模式-①概览" class="headerlink" title="必备知识架构-架构模式-①概览"></a>必备知识架构-架构模式-①概览</h1><p>[Toc]</p><p>–</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><ul><li><a href="https://casatwy.com/zen-yao-mian-shi-jia-gou-shi.html" target="_blank" rel="noopener">casatwy 怎么面试架构师</a></li></ul><p>好文分享：</p><ul><li><a href="https://www.jianshu.com/p/0d5f95135b5c" target="_blank" rel="noopener">iOS架构模式(MVC/MVCS/MVP/MVVM/VIPER)</a></li></ul><h3 id="面向对象、面向接口、面向方法编程的区别"><a href="#面向对象、面向接口、面向方法编程的区别" class="headerlink" title="面向对象、面向接口、面向方法编程的区别"></a>面向对象<em>、</em>面向接口、面向方法编程的区别</h3><h2 id="一、架构模式、框架、设计模式的概念"><a href="#一、架构模式、框架、设计模式的概念" class="headerlink" title="一、架构模式、框架、设计模式的概念"></a>一、架构模式、框架、设计模式的概念</h2><p><a href="https://blog.csdn.net/timtian008/article/details/69949031" target="_blank" rel="noopener">iOS—架构模式、框架、设计模式的理解</a></p><p><strong>架构模式</strong>：架构模式的出现是为了管理复杂的应用程序，这样可以在一个时间内专门关注一个方面。例如，您可以在不依赖业务逻辑的情况下专注于视图设计。同时也让应用程序的测试更加容易。同时也简化了分组开发。不同的开发人员可同时开发视图、控制器逻辑和业务逻辑。我们经常说的<strong>MVC架构</strong>、<strong>MVVM架构</strong>属于此类。</p><p><strong>框架</strong>：这个最好理解了，通常是代码重用。框架与设计模式的概念容易弄混，两者有相似之处，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述规范，它比框架更抽象；框架为已经解决问题的具体实现方法，能直接执行或复用；设计模式是比框架更小的元素，一个框架中往往含有一种或多种设计模式。Xcode自带的<strong>Foundation</strong>、<strong>UIKit</strong>，以及我们经常使用的<strong>AFNetworking</strong>，<strong>MJExtension</strong>，<strong>SVProgressHUD</strong>就属于这一类。</p><p><strong>设计模式</strong>：设计模式可以通俗的理解为实现/解决某些问题，而形成的解决方案规范。增加代码的可重用性，让代码能更容易理解和可靠。我们通常说所的<strong>代理模式</strong>、<strong>迭代器模式</strong>、<strong>策略模式</strong>就属于这一类。对各种设计模式的了解可以帮助我们更快的解决编程过程中遇到的问题。</p><blockquote><p>三者关系：架构（动词）&gt;框架&gt;设计模式。</p><p>软件通过架构，可以设计出很多不同的框架。在一个框架中，也可以使用很多的设计模式。设计模式不是哪儿哪儿都可以用的，只有当出现了某一特定的问题时，才利用设计模式去解决。设计模式不是用的越多越好，在维护的时候，过多的设计模式会极大的增添维护成本。</p></blockquote><p>MVC</p><p>1、架构的设计其实是为了更好的维护和迭代，而不是只考虑眼前当下的开发。</p><p>2、最基本的架构是MVC，试想下如果我一个应用的所有功能都是像”关于“功能的，那我还需要其他架构干嘛？显然MVC就已经很足够，而且还显得不冗余（这里指的是设计或者粒度不冗余）。</p><p>3、其他的架构都是从MVC演变而来。再讲其他架构的演变之前，我们先明确最原始的MVC代码是如何的。</p><p>①、首先M主要负责数据、V主要负责视图、C主要负责数据的视图显示。而这里的M是原始的<strong>瘦Model</strong>。</p><p>所以，我们拿常见的”我的”页面来举例，部分原始的MVC代码一般为如下样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UserModel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">View</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ViewController</span><br><span class="line">self.userInfoView.name = user.name;</span><br><span class="line">self.userInfoView.sexString = user.sex == 1? &quot;女&quot; :&quot;男&quot;;</span><br></pre></td></tr></table></figure><p>4、在<strong>MVC+瘦Model</strong>的演变下，还有<strong>MVC+胖Model</strong></p><p>胖Model就是瘦Model+部分<strong>弱业务逻辑</strong>（这些弱业务重复一般都是经常出现，或者说是要求可复用性的，如根据枚举获取性别字符串）。它使得Controller可以从胖Model这里拿到数据之后，不用额外做操作或者只要做非常少的操作，就能够将数据直接应用在View上.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UserModel</span><br><span class="line">+ (NSString *)sexStringFrom:(int)sex;</span><br><span class="line"></span><br><span class="line">View</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ViewController</span><br><span class="line">self.userInfoView.name = user.name;</span><br><span class="line">self.userInfoView.sexString = [UserModel sexStringFrom:user.sex];</span><br></pre></td></tr></table></figure><p>5、有时候在<strong>MVC+瘦Model</strong>的演变下，不是转成<strong>MVC+胖Model</strong>，而是<strong>MVC+瘦Model+Helper</strong></p><p>MVP?</p><p>其实这个思路已经很接近MVP了、但是还差提点。MVP还需要为View提供数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UserModel</span><br><span class="line"></span><br><span class="line">View</span><br><span class="line"></span><br><span class="line">UserHelper</span><br><span class="line">+ (NSString *)sexStringFrom:(int)sex;</span><br><span class="line"></span><br><span class="line">ViewController</span><br><span class="line">self.userInfoView.name = user.name;</span><br><span class="line">self.userInfoView.sexString = [UserHelper sexStringFrom:user.sex];</span><br></pre></td></tr></table></figure><p>6、关于<strong>MVC+瘦Model+Helper</strong>，还可以改为<strong>MVC+瘦Model+ViewModel</strong></p><p>MVVM</p><p>刚才的胖Model只从Controller移植走了一些简单的弱业务。</p><p>而ViewModel则干脆把数据的处理全部从Controller移植了出去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UserModel</span><br><span class="line"></span><br><span class="line">View</span><br><span class="line"></span><br><span class="line">UserViewModel</span><br><span class="line">name</span><br><span class="line">sexString</span><br><span class="line">- (id)initWithName:(NSString *)name sex:(int)sex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ViewController</span><br><span class="line">self.userInfoView.name = userViewModel.name;</span><br><span class="line">self.userInfoView.sexString = userViewModel.sexString;</span><br></pre></td></tr></table></figure><p>拿有数据操作的”购物车“页面来说，</p><p>假设其除了有网络数据请求外，还有本地数据库处理。（附：<strong>购物车是否需要本地数据库</strong>，个人认为是基于服务端的压力来考虑，不然一般是放在服务端合适点。压力设想如下，千万级用户，购物车加减商品频繁，假设放在后台，则操作和计算也就频繁，压力也就大了。如果放在前端，则后台只需要负责是否可加减商品的检验，而不用再建购物车数据表和计算价格等，压力就小了。）</p><p>每个页面一般都会有网络请求，这些网络请求最原始的时候，是放在ViewController，也就是MVC的C中。</p><p>为了避免MVC中的ViewController后期变得十分臃肿。我们肯定要在MVC的基础上额外增加一层来处理这个。</p><p>综合考虑后，我们选用<strong>MVCS</strong>来处理。</p><p>其中S代表着Store，且我们这里的S代表着是整个模块的S，而不是每个页面都有一个S。其下层又包含着Storage和Service，即 <em>数据库DB部分</em> 和 <em>网络Network部分</em> 。</p><p>Store类名，个人习惯是使用Manager来命令。如UserManager。</p><p><img src="/iOS/架构相关/1架构模式/架构模式-①概览/MVCS1.png" alt="MVCS1"></p><p>所以，最终我们选用的是 MVCS+MVVM 或者说 MVVM+S。</p><p>S层（service 层）提供一种和外界(比如远程服务 API 或文件系统)交互的独立机制。</p><p>MVVM+S 纵向的数据流就不用多说，横向的数据流，我们采用自定义的类系统通知。区别在于它有着系统Notification的一对多方便，又有着delegate的接口对接方便。</p><p><img src="/iOS/架构相关/1架构模式/架构模式-①概览/MVCS2.png" alt="image-20200917024611311"></p><p>抛开数据共享问题（如每个请求都要带userToken），每个页面</p><h2 id="二、常见的项目目录结构"><a href="#二、常见的项目目录结构" class="headerlink" title="二、常见的项目目录结构"></a>二、常见的项目目录结构</h2><p>常见的项目目录结构：</p><p><img src="/iOS/架构相关/1架构模式/架构模式-①概览/框架①项目目录结构.jpg" alt="框架①项目目录结构"></p><p id="常见的设计模式"></p><p id="MVC与MVVM"></p><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter组件化框架</title>
      <link href="/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/Flutter%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6/"/>
      <url>/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/Flutter%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Flutter组件化框架"><a href="#Flutter组件化框架" class="headerlink" title="Flutter组件化框架"></a>Flutter组件化框架</h1><ul><li><a href="https://www.jianshu.com/p/2b49517500bd" target="_blank" rel="noopener">Flutter组件化框架</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第九章：框架升级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统控制</title>
      <link href="/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/"/>
      <url>/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="系统控制"><a href="#系统控制" class="headerlink" title="系统控制"></a>系统控制</h1><p>为了统一，各视图分别使用如下组件</p><h2 id="一、键盘遮挡问题"><a href="#一、键盘遮挡问题" class="headerlink" title="一、键盘遮挡问题"></a>一、键盘遮挡问题</h2><p>方案一:设置resizeToAvoidBottomPadding 为false</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">  resizeToAvoidBottomPadding: <span class="literal">false</span>, <span class="comment">//输入框抵住键盘</span></span><br><span class="line">  appBar: AppBar(</span><br><span class="line">    elevation: <span class="number">0.0</span>,</span><br><span class="line">    title: Text(<span class="string">"登陆"</span>),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>方案二:在界面的body上用SingleChildScrollView包裹一下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>: <span class="selector-tag">SingleChildScrollView</span>(</span><br><span class="line">              <span class="selector-tag">child</span><span class="selector-pseudo">:...</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第九章：框架升级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter空安全</title>
      <link href="/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/Flutter%E7%A9%BA%E5%AE%89%E5%85%A8/"/>
      <url>/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/Flutter%E7%A9%BA%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Flutter空安全"><a href="#Flutter空安全" class="headerlink" title="Flutter空安全"></a>Flutter空安全</h1><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/happiness365/article/details/121845627?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-3-121845627.pc_agg_new_rank&amp;utm_term=flutter中的+late是什么类型&amp;spm=1000.2123.3001.4430" target="_blank" rel="noopener">Flutter入门系列-Flutter空安全</a></li></ul><h2 id="一、进行空安全适配"><a href="#一、进行空安全适配" class="headerlink" title="一、进行空安全适配"></a>一、进行空安全适配</h2><p>当开启空安全之后，然后运行下项目你会看到很多的报错，然后定位到报错的文件，大体有三类文件需要修改：</p><ol><li>自定义Widget  </li><li>数据模型（Model）</li><li>单例</li></ol><p>详细看上面的参考文章。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第九章：框架升级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件的使用-Cache</title>
      <link href="/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8-Cache/"/>
      <url>/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8-Cache/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="组件的使用-Cache"><a href="#组件的使用-Cache" class="headerlink" title="组件的使用-Cache"></a>组件的使用-Cache</h1><p>初始化：init</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_cache_kit/flutter_cache_kit.dart'</span>;</span><br><span class="line"></span><br><span class="line">LocalStorage.init();</span><br></pre></td></tr></table></figure><p>Flutter 类型数据保存和获取方法：save/get</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_cache_kit/flutter_cache_kit.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存方法:支持bool\int\double\String\List&lt;String&gt;</span></span><br><span class="line">LocalStorage.save(<span class="string">'test_string'</span>, string);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法:支持bool\int\double\String\List&lt;String&gt;</span></span><br><span class="line"><span class="built_in">String</span> string = LocalStorage.<span class="keyword">get</span>(<span class="string">'test_string'</span>);</span><br></pre></td></tr></table></figure><p>自定义的类的保存和获取方法：saveCustomBean\getCustomBean</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_cache_kit/flutter_cache_kit.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存</span></span><br><span class="line">TSCustomBean customBean = TSCustomBean(</span><br><span class="line">                  proxyId: <span class="string">'1001'</span>,</span><br><span class="line">                  proxyIp: <span class="string">'192.168.1.1'</span>,</span><br><span class="line">                  name: <span class="string">'代理'</span>,</span><br><span class="line">                );</span><br><span class="line">LocalStorage.saveCustomBean(</span><br><span class="line">                  <span class="string">'test_custom'</span>,</span><br><span class="line">                  customBean,</span><br><span class="line">                  itemToJson: (TSCustomBean bItem) &#123;</span><br><span class="line">                    <span class="keyword">return</span> bItem.toJson();</span><br><span class="line">                  &#125;,</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line">TSCustomBean customBean = LocalStorage.getCustomBean(</span><br><span class="line">                  <span class="string">'test_custom'</span>,</span><br><span class="line">                  fromJson: (bMap) &#123;</span><br><span class="line">                    <span class="keyword">return</span> TSCustomBean.fromJson(bMap);</span><br><span class="line">                  &#125;,</span><br><span class="line">                );</span><br></pre></td></tr></table></figure><p>自定义的数组类的保存和获取方法：saveCustomBeans\getCustomBeans</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_cache_kit/flutter_cache_kit.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存</span></span><br><span class="line">LocalStorage.saveCustomBeans(</span><br><span class="line">                  <span class="string">'test_customBeans'</span>,</span><br><span class="line">                  customBeans,</span><br><span class="line">                  itemToJson: (TSCustomBean bItem) &#123;</span><br><span class="line">                    <span class="keyword">return</span> bItem.toJson();</span><br><span class="line">                  &#125;,</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="built_in">List</span>&lt;TSCustomBean&gt; customBeans = LocalStorage.getCustomBeans(</span><br><span class="line">                  <span class="string">'test_customBeans'</span>,</span><br><span class="line">                  fromJson: (bMap) &#123;</span><br><span class="line">                    <span class="keyword">return</span> TSCustomBean.fromJson(bMap);</span><br><span class="line">                  &#125;,</span><br><span class="line">                );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第九章：框架升级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件的使用</title>
      <link href="/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8-Picker/"/>
      <url>/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8-Picker/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="组件的使用-Picker"><a href="#组件的使用-Picker" class="headerlink" title="组件的使用-Picker"></a>组件的使用-Picker</h1><p>为了统一，各视图分别使用如下组件</p><h2 id="二、选择器Picker"><a href="#二、选择器Picker" class="headerlink" title="二、选择器Picker"></a>二、选择器Picker</h2><h3 id="1、事项选择器：ItemPickerUtil"><a href="#1、事项选择器：ItemPickerUtil" class="headerlink" title="1、事项选择器：ItemPickerUtil"></a>1、事项选择器：ItemPickerUtil</h3><p><img src="/Flutter/9框架升级/组件的使用-Picker/组件的使用/image-ItemPicker.png" alt="事项选择器" style="zoom:33%;"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_datepicker/flutter_datepicker.dart'</span>;</span><br><span class="line"></span><br><span class="line">ItemPickerUtil.chooseItem(</span><br><span class="line">      context,</span><br><span class="line">      title: <span class="string">'更换头像'</span>,</span><br><span class="line">      itemTitles: [<span class="string">'拍照上传'</span>, <span class="string">'从相册选择'</span>],</span><br><span class="line">      onConfirm: (<span class="built_in">int</span> selectedIndex) &#123;</span><br><span class="line">        dealAvatar(selectedIndex);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h3 id="2、日期选择器DatePickerUtil"><a href="#2、日期选择器DatePickerUtil" class="headerlink" title="2、日期选择器DatePickerUtil"></a>2、日期选择器DatePickerUtil</h3><p><img src="/Flutter/9框架升级/组件的使用-Picker/组件的使用/image-DatePicker.png" alt="日期选择器" style="zoom: 33%;"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_datepicker/flutter_datepicker.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> currentBirthday = <span class="string">'2000-01-01'</span>;</span><br><span class="line"></span><br><span class="line">DatePickerUtil.chooseBirthday(context,</span><br><span class="line">        title: <span class="string">'选择你的生日'</span>, selectedyyyyMMddDateString: currentBirthday,</span><br><span class="line">        onConfirm: (<span class="built_in">String</span> yyyyMMddDateStirng) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        currentBirthday = yyyyMMddDateStirng;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第九章：框架升级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件的使用-Button</title>
      <link href="/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8-Button/"/>
      <url>/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8-Button/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="组件的使用-Button"><a href="#组件的使用-Button" class="headerlink" title="组件的使用-Button"></a>组件的使用-Button</h1><p>为了统一，各视图分别使用如下组件</p><h2 id="一、按钮Button"><a href="#一、按钮Button" class="headerlink" title="一、按钮Button"></a>一、按钮Button</h2><p>不用再写一堆嵌套地狱代码。（支持高亮效果，目前app按钮点击效果不佳，后续可能需要加，提前避免）</p><p>按钮的分类：</p><table><thead><tr><th>编号</th><th>类名</th><th>样式举例</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>纯背景的按钮：<br>ThemeBGButton</td><td><img src="/Flutter/9框架升级/组件的使用-Button/组件的使用/image-ThemeBGButton.png" alt="纯背景的按钮" style="zoom: 33%;"></td><td></td></tr><tr><td>2</td><td>有边框的按钮：<br>ThemeBorderButton</td><td><img src="/Flutter/9框架升级/组件的使用-Button/组件的使用/image-ThemeBorderButton.png" alt="有边框的按钮" style="zoom:33%;"></td><td></td></tr><tr><td>3</td><td>切状态的按钮：<br>ThemeStateButton</td><td><img src="/Flutter/9框架升级/组件的使用-Button/组件的使用/image-ThemeStateButtonNormal.png" alt="状态按钮之未选中状态">未选中状态(selected=false)<br><img src="/Flutter/9框架升级/组件的使用-Button/组件的使用/image-ThemeStateButtonSelected.png" alt="状态按钮之已选中状态" style="zoom: 80%;">已选中状态(selected=true)</td></tr></tbody></table><h3 id="1、纯背景的按钮：ThemeBGButton"><a href="#1、纯背景的按钮：ThemeBGButton" class="headerlink" title="1、纯背景的按钮：ThemeBGButton"></a>1、纯背景的按钮：ThemeBGButton</h3><p><img src="/Flutter/9框架升级/组件的使用-Button/组件的使用/image-ThemeBGButton.png" alt="纯背景的按钮" style="zoom: 33%;"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_baseui_kit/flutter_baseui_kit.dart'</span>;</span><br><span class="line"></span><br><span class="line">ThemeBGButton(</span><br><span class="line">          <span class="comment">//width: 300, // 不设置会根据内容自适应</span></span><br><span class="line">          <span class="comment">//height: 80, // 不设置会根据内容自适应</span></span><br><span class="line">          bgColorType: ThemeBGType.pink,</span><br><span class="line">          needHighlight: <span class="keyword">true</span>,<span class="comment">// 默认false,不需要高亮</span></span><br><span class="line">          title: <span class="string">'红底白字的按钮'</span>,</span><br><span class="line">          titleStyle: ButtonBoldTextStyle(fontSize: <span class="number">18.0</span>),</span><br><span class="line">          cornerRadius: <span class="number">20</span>,</span><br><span class="line">          <span class="comment">//enable: true, // 不设置,默认true</span></span><br><span class="line">          onPressed: () &#123;&#125;,</span><br><span class="line">        ),</span><br></pre></td></tr></table></figure><p>如果你还需要在文字前添加图片，</p><p><img src="/Flutter/9框架升级/组件的使用-Button/组件的使用/image-ThemeBGButtonWithImage.png" alt="纯背景并带有图片的按钮" style="zoom:33%;"></p><p>可以通过 imageWidget 添加</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_baseui_kit/flutter_baseui_kit.dart'</span>;</span><br><span class="line"></span><br><span class="line">ThemeBGButton(</span><br><span class="line">          ...</span><br><span class="line">          title: <span class="string">'以主题色(红色)为背景的按钮'</span>,</span><br><span class="line">          titleStyle: ButtonBoldTextStyle(fontSize: <span class="number">18.0</span>),</span><br><span class="line">          imageWidget: ImageAsset(<span class="string">'images/xx.jpg'</span>, width: <span class="number">22</span>, height: <span class="number">22</span>,),</span><br><span class="line">          <span class="comment">//imageTitleGap: 5, // 默认5</span></span><br><span class="line">          ...</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h3 id="2、有边框的按钮：ThemeBorderButton"><a href="#2、有边框的按钮：ThemeBorderButton" class="headerlink" title="2、有边框的按钮：ThemeBorderButton"></a>2、有边框的按钮：ThemeBorderButton</h3><p><img src="/Flutter/9框架升级/组件的使用-Button/组件的使用/image-ThemeBorderButton.png" alt="有边框的按钮" style="zoom:33%;"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_baseui_kit/flutter_baseui_kit.dart'</span>;</span><br><span class="line"></span><br><span class="line">ThemeBorderButton(</span><br><span class="line">          <span class="comment">//width: 300, // 不设置会根据内容自适应</span></span><br><span class="line">          <span class="comment">//height: 80, // 不设置会根据内容自适应</span></span><br><span class="line">          borderColorType: ThemeBGType.pink,</span><br><span class="line">          title: <span class="string">'白底红字红框的按钮'</span>,</span><br><span class="line">          titleStyle: ButtonBoldTextStyle(fontSize: <span class="number">18.0</span>),</span><br><span class="line">          cornerRadius: <span class="number">20</span>,</span><br><span class="line">          <span class="comment">//enable: true, // 不设置,默认ture</span></span><br><span class="line">          onPressed: () &#123;&#125;,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h3 id="3、状态切换按钮：ThemeStateButton"><a href="#3、状态切换按钮：ThemeStateButton" class="headerlink" title="3、状态切换按钮：ThemeStateButton"></a>3、状态切换按钮：ThemeStateButton</h3><p>未选中状态(selected=false)：<img src="/Flutter/9框架升级/组件的使用-Button/组件的使用/image-ThemeStateButtonNormal.png" alt="状态按钮之未选中状态"><br>已选中状态(selected=true)：<img src="/Flutter/9框架升级/组件的使用-Button/组件的使用/image-ThemeStateButtonSelected.png" alt="状态按钮之已选中状态" style="zoom:90%;"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_baseui_kit/flutter_baseui_kit.dart'</span>;</span><br><span class="line"></span><br><span class="line">ThemeStateButton(</span><br><span class="line">          <span class="comment">//width: 300, // 不设置会根据内容自适应</span></span><br><span class="line">          <span class="comment">//height: 80, // 不设置会根据内容自适应</span></span><br><span class="line">          normalBGColorType: ThemeBGType.pink,</span><br><span class="line">          normalTitle: <span class="string">'修改'</span>,</span><br><span class="line">          selectedTitle: <span class="string">'提交'</span>,</span><br><span class="line">          titleStyle: ButtonBoldTextStyle(fontSize: <span class="number">18.0</span>),</span><br><span class="line">          cornerRadius: <span class="number">20</span>,</span><br><span class="line">          selected: <span class="keyword">false</span>,</span><br><span class="line">          <span class="comment">//enable: true, // 不设置,默认ture</span></span><br><span class="line">          onPressed: () &#123;&#125;,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>其他按钮样式：</p><p><img src="/Flutter/9框架升级/组件的使用-Button/组件的使用/image-20211217121410240.png" alt="image-20211217121410240" style="zoom:33%;"></p><p><img src="/Flutter/9框架升级/组件的使用-Button/组件的使用/image-20211218024015942.png" alt="image-20211218024015942" style="zoom:33%;"></p><p><img src="/Flutter/9框架升级/组件的使用-Button/组件的使用/image-20211218024157575.png" alt="image-20211218024157575" style="zoom:33%;"></p><p><img src="/Flutter/9框架升级/组件的使用-Button/组件的使用/image-20211218024244344.png" alt="image-20211218024244344" style="zoom:33%;"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第九章：框架升级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类</title>
      <link href="/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E6%95%B0%E6%8D%AE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E6%95%B0%E6%8D%AE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h1><p>为了统一，各数据类(包含宏)分别使用如下：</p><h2 id="一、颜色"><a href="#一、颜色" class="headerlink" title="一、颜色"></a>一、颜色</h2><p>暂无</p><h2 id="二、TextStyle"><a href="#二、TextStyle" class="headerlink" title="二、TextStyle"></a>二、TextStyle</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_effect/flutter_effect.dart'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(</span><br><span class="line">            <span class="string">'Bold'</span>,</span><br><span class="line">            style: BoldTextStyle(fontSize: <span class="number">17</span>, color: Colors.red), <span class="comment">// bold</span></span><br><span class="line">          ),</span><br><span class="line">        Text(</span><br><span class="line">            <span class="string">'Medium'</span>,</span><br><span class="line">            style: MediumTextStyle(fontSize: <span class="number">17</span>, color: Colors.red), <span class="comment">// medium</span></span><br><span class="line">          ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第九章：框架升级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件的使用-Overlay</title>
      <link href="/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8-Overlay/"/>
      <url>/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8-Overlay/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="组件的使用-Overlay"><a href="#组件的使用-Overlay" class="headerlink" title="组件的使用-Overlay"></a>组件的使用-Overlay</h1><p>为了统一，各视图分别使用如下组件</p><h2 id="一、ToastUtil"><a href="#一、ToastUtil" class="headerlink" title="一、ToastUtil"></a>一、ToastUtil</h2><p>弹出toast：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_overlay_kit/flutter_overlay_kit.dart'</span>;</span><br><span class="line"></span><br><span class="line">ToastUtil.showMessage(<span class="string">'登录成功'</span>);</span><br></pre></td></tr></table></figure><p>开发卡在<strong>产品</strong>或<strong>h5</strong>的时候，请使用如下弹出提示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_overlay_kit/flutter_overlay_kit.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要产品补充完善需求</span></span><br><span class="line">ToastUtil.showNeedProduct(</span><br><span class="line">message: <span class="string">'我的首页中的愿望即将实现'</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要H5补充url</span></span><br><span class="line">ToastUtil.showNeedH5(</span><br><span class="line">message: <span class="string">'登录页面中的用户协议'</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="二、AlertUtil"><a href="#二、AlertUtil" class="headerlink" title="二、AlertUtil"></a>二、AlertUtil</h2><p>弹窗</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_overlay_kit/flutter_overlay_kit.dart'</span>;</span><br><span class="line"></span><br><span class="line">AlertUtil.showCancelOKAlert(</span><br><span class="line">      context: context,</span><br><span class="line">      title: <span class="string">"退出登录"</span>,</span><br><span class="line">      message: <span class="string">"您确定要退出登录吗?"</span>,</span><br><span class="line">      cancelHandle: <span class="keyword">null</span>,</span><br><span class="line">      okHandle: () &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'点击确认按钮'</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第九章：框架升级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件设计规范</title>
      <link href="/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
      <url>/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="组件设计规范"><a href="#组件设计规范" class="headerlink" title="组件设计规范"></a>组件设计规范</h1><p>为了统一，各视图分别使用如下组件</p><h2 id="一、样式设计规范"><a href="#一、样式设计规范" class="headerlink" title="一、样式设计规范"></a>一、样式设计规范</h2><p>在第六章进阶<a href="../6进阶/Flutter控件的封装">Flutter控件的封装</a>一文中，我们已经知道<strong>使用<code>继承父类式封装</code>这种方式，不管在封装时候，还是在使用时候，写的代码都是最简洁的。而且后期如果要直接使用系统样式，也只需要改回类名，其他结构和属性都不用动即可</strong>。</p><p>所以，<strong>即使是你所定义的类只有一个入参，也一定要遵守使用<code>继承父类式封装</code>的设计规范。</strong></p><p>以下以按钮中 textStyle 的传值为例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_baseui_kit/flutter_baseui_kit.dart'</span>;</span><br><span class="line"></span><br><span class="line">ThemeBGButton(</span><br><span class="line">          <span class="comment">//width: 300, // 不设置会根据内容自适应</span></span><br><span class="line">          <span class="comment">//height: 80, // 不设置会根据内容自适应</span></span><br><span class="line">          bgColorType: ThemeBGType.pink,</span><br><span class="line">          title: <span class="string">'红底白字的按钮'</span>,</span><br><span class="line">          <span class="comment">//titleStyle: ButtonThemeUtil.PingFang_FontSize_Bold(18.0),// bad</span></span><br><span class="line">          titleStyle: ButtonBoldTextStyle(fontSize: <span class="number">18.0</span>), <span class="comment">// good</span></span><br><span class="line">          cornerRadius: <span class="number">20</span>,</span><br><span class="line">          <span class="comment">//enable: true, // 不设置,默认true</span></span><br><span class="line">          onPressed: () &#123;&#125;,</span><br><span class="line">        ),</span><br></pre></td></tr></table></figure><p>good:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// medium 的文本样式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButtonMediumTextStyle</span> <span class="keyword">extends</span> <span class="title">TextStyle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> fontSize;</span><br><span class="line">  <span class="comment">// final Color color;</span></span><br><span class="line"></span><br><span class="line">  ButtonMediumTextStyle(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.fontSize,</span><br><span class="line">    <span class="comment">// this.color,</span></span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(fontSize != <span class="keyword">null</span>),</span><br><span class="line">        <span class="comment">// assert(color != null),</span></span><br><span class="line">        <span class="keyword">super</span>(</span><br><span class="line">          fontFamily: <span class="string">'PingFang SC'</span>,</span><br><span class="line">          fontSize: fontSize,</span><br><span class="line">          fontWeight: FontWeight.w500,</span><br><span class="line">          <span class="comment">// color: color,</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第九章：框架升级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件的使用</title>
      <link href="/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/"/>
      <url>/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h1><table><thead><tr><th>编号</th><th>场景</th><th>官网</th><th>key/id信息</th><th>注册的账号</th><th>续费时间</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>app发布</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td>微信登录</td><td><a href="https://open.weixin.qq.com" target="_blank" rel="noopener">https://open.weixin.qq.com</a></td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>Bugly</td><td><a href="https://bugly.qq.com/v2/" target="_blank" rel="noopener">https://bugly.qq.com/v2/</a></td><td>appid<br>iOS:xxx<br>Android:xxx</td><td></td><td>无</td><td>个人账号</td></tr><tr><td>4</td><td>百度地图</td><td><a href="https://lbsyun.baidu.com" target="_blank" rel="noopener">https://lbsyun.baidu.com</a></td><td>iOS：xxx<br>Android：</td><td></td><td>无</td><td>个人账号</td></tr><tr><td>5</td><td>极光一键登录</td><td><a href="https://www.jiguang.cn" target="_blank" rel="noopener">https://www.jiguang.cn</a></td><td>appkey<br></td><td></td><td>无</td><td>公司账号</td></tr><tr><td>6</td><td>xxx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td>xxxx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>8</td><td>xxxx</td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第九章：框架升级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面多入口优化</title>
      <link href="/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E9%A1%B5%E9%9D%A2%E5%A4%9A%E5%85%A5%E5%8F%A3%E4%BC%98%E5%8C%96/"/>
      <url>/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E9%A1%B5%E9%9D%A2%E5%A4%9A%E5%85%A5%E5%8F%A3%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="页面多入口优化"><a href="#页面多入口优化" class="headerlink" title="页面多入口优化"></a>页面多入口优化</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WishPublishPage</span> <span class="keyword">extends</span> <span class="title">BJHBasePage</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> isUpdateBusiness;</span><br><span class="line">  Wish_detail_model wishDetailModel;</span><br><span class="line"></span><br><span class="line">  WishPublishPage(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.isUpdateBusiness = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.wishDetailModel,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  WishPublishPage.fromTemplatePage(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.isUpdateBusiness = <span class="keyword">false</span>,</span><br><span class="line">    WishTemplateModel templateModel,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key) &#123;</span><br><span class="line">    wishDetailModel =</span><br><span class="line">        Wish_detail_model.fromTemplateJson(templateModel.toJson());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  WishPublishPage.fromOtherUser(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="built_in">List</span>&lt;Items&gt; selectGoodsList,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key) &#123;</span><br><span class="line">    isUpdateBusiness = <span class="keyword">false</span>;</span><br><span class="line">    wishDetailModel.items = selectGoodsList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _WishPublishPageState createState() =&gt; _WishPublishPageState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第九章：框架升级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架的重要性</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E6%A1%86%E6%9E%B6%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E6%A1%86%E6%9E%B6%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="框架的重要性"><a href="#框架的重要性" class="headerlink" title="框架的重要性"></a>框架的重要性</h1><h2 id="一、ppt"><a href="#一、ppt" class="headerlink" title="一、ppt"></a>一、ppt</h2><p>详看：<a href="./框架的重要性.pptx">框架的重要性</a></p><h2 id="二、内容说明"><a href="#二、内容说明" class="headerlink" title="二、内容说明"></a>二、内容说明</h2><p>框架是什么？</p><p>框架是解决问题的具体实现方法，能直接执行或复用。</p><p>为什么需要框架？</p><p>简单的讲是为了约束和统一。</p><p>举个例子：我们想要让所有的页面支持在无网络的时候，都有个缺省页。</p><p>如果没有一个框架，则我们每个页面都得进行很多判断和视图操作。</p><p>且后期如果需要修改，也会导致工作量巨大。</p><p>框架的好处是什么？</p><p>我们先从常见的几个工作中实际场景介绍：</p><p>网络请求：不进行框架/封装处理的话，可能遇到的问题：</p><p>①、每次进行网络请求，都得写一堆代码才能完成最基础的请求操作；</p><p>②、如果还要求对每个请求都添加一些公共参数、错误码处理，则又得每个请求添加一遍；</p><p>页面的缺省：不进行框架/封装处理的话，可能遇到的问题：</p><p>①、无网络等状态下，直接无缺省页，显示成白屏，体验极差；</p><p>②、有设置缺省页，但无进行框架化，导致每个页面都得堆一堆代码来实现缺省页功能；</p><p>③、有设置缺省页，但无进行框架化，后期需要修改时候，每个页面都修改，维护成本巨大；</p><p>视图控件(如按钮)：不进行框架/封装处理的话，可能遇到的问题：</p><p>①、代码实现特长；</p><p>②、还没有点击效果，如果要添加又要一堆代码；</p><p>③、后期需要修改时候，每个页面都修改，维护成本巨大；</p><p>测试框架：</p><p>①、开发联调接口，无法设置代理抓包查看；</p><p>②、用户反馈问题，无法提供问题出现的版本等信息；</p><p>③、已发布包程序出现异常，开发无法定位；</p><p>场景问题解决要点/框架能解决的问题：</p><p>①、不用堆一堆类似代码，几行代码就实现</p><p>②、规范变化的时候，不要我关心和修改</p><p>③、增加通用功能的时候，不需要自己再去实现一遍</p><p>④、app异常时候的监测和反馈</p><p>框架化后，以上这些问题都能够得到解决。</p><p>所以，框架的好处有统一设计，</p><p>建立框架的意义：</p><p>好的框架能够保证和提升项目的可维护性，扩展性，健壮性。</p><p>能够提高工作效率</p><p>能够让风格更统一</p><p>各框架提供的功能</p><p>缺省页框架：</p><p>解决可能的初始”白屏”</p><p>无网络情况下的”空白页”</p><p>无数据情况下的”空白页”</p><p>为页面提供网络异常页并伴有刷新恢复重试</p><p>测试框架：</p><p>新增抓包设置(代理)</p><p>新增查看版本页面，方便对应反馈的问题出现的版本(防止是旧包)。</p><p>程序异常(上报+提示)</p><p>视图控件框架：</p><p>定义加载动画loading</p><p>愿望灯动画效果优化(底部下沉)</p><p>框架的使用</p><p><img src="/Architecture架构/框架的重要性/image-20211219225300200.png" alt="image-20211219225300200"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector(</span><br><span class="line">                          onTap: () =&gt; _shareWechatfriend(),</span><br><span class="line">                          child: Container(</span><br><span class="line">                            height: <span class="number">38.</span>h,</span><br><span class="line">                            width: <span class="number">260.</span>w,</span><br><span class="line">                            decoration: BoxDecoration(</span><br><span class="line">                              color: color_theme,</span><br><span class="line">                              borderRadius: BorderRadius.circular(<span class="number">19.</span>h),</span><br><span class="line">                              border: Border.all(color: Colors.white, width: <span class="number">1</span>),</span><br><span class="line">                            ),</span><br><span class="line">                            child: Center(</span><br><span class="line">                              child: Row(</span><br><span class="line">                                crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">                                mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">                                children: [</span><br><span class="line">                                  Image.asset(</span><br><span class="line">                                    <span class="string">"images/wish/yaoqing_icon.png"</span>,</span><br><span class="line">                                    width: <span class="number">18.</span>w,</span><br><span class="line">                                    height: <span class="number">18.</span>h,</span><br><span class="line">                                  ),</span><br><span class="line">                                  SizedBox(</span><br><span class="line">                                    width: <span class="number">5.</span>w,</span><br><span class="line">                                  ),</span><br><span class="line">                                  Text(</span><br><span class="line">                                    <span class="string">"邀请好友许愿"</span>,</span><br><span class="line">                                    style: TextStyle(color: Colors.white, fontSize: <span class="number">15.</span>sp),</span><br><span class="line">                                  )</span><br><span class="line">                                ],</span><br><span class="line">                              ),</span><br><span class="line">                            ),</span><br><span class="line">                          ),</span><br><span class="line">                        ),</span><br></pre></td></tr></table></figure><p>框架化后：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ThemeBGButton(</span><br><span class="line">      width: <span class="number">260</span>,</span><br><span class="line">      height: <span class="number">38</span>,</span><br><span class="line">      bgColorType: ThemeBGType.pink, <span class="comment">// 此参数，让你可以直接切换到其他主题样式</span></span><br><span class="line">      needHighlight: <span class="keyword">true</span>, <span class="comment">// 添加此参数即会有高亮效果，而不需要再写一堆代码</span></span><br><span class="line">      title: <span class="string">'邀请好友许愿'</span>,</span><br><span class="line">      titleStyle: ButtonThemeUtil.PingFang_FontSize_Bold(<span class="number">15.0</span>),</span><br><span class="line">      imageWidget: ImageAsset(<span class="string">'images/wish/yaoqing_icon.png'</span>, width: <span class="number">18</span>, height: <span class="number">18</span>),</span><br><span class="line">      cornerRadius: <span class="number">19</span>,</span><br><span class="line">      onPressed: () =&gt; _shareWechatfriend(),</span><br><span class="line">    ),</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础框架</title>
      <link href="/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/"/>
      <url>/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="框架优化-升级方案"><a href="#框架优化-升级方案" class="headerlink" title="框架优化/升级方案"></a>框架优化/升级方案</h1><p>为了有更好的用户体验，我们提出以下优化和升级方案。</p><p>白屏体验</p><p>网络恢复</p><h2 id="一、可能的初始”白屏”-可选"><a href="#一、可能的初始”白屏”-可选" class="headerlink" title="一、可能的初始”白屏”(可选)"></a>一、可能的初始”白屏”(可选)</h2><h3 id="1、场景"><a href="#1、场景" class="headerlink" title="1、场景"></a>1、场景</h3><p>页面无任何占位视图。如页面本身就是一个列表。</p><p>页面数据来源于网络，网络请求回来前，空。</p><h3 id="2、处理方案及实现方式"><a href="#2、处理方案及实现方式" class="headerlink" title="2、处理方案及实现方式"></a>2、处理方案及实现方式</h3><p>主要有以下两种方案，各自独立，分场景使用。</p><p>①界面框架预染页(美团/饿了么的灰底效果)</p><p>②数据预加载(首页)</p><h4 id="2-1、处理方案：界面框架的预染页：美团-饿了么的灰底效果-如商品详情页"><a href="#2-1、处理方案：界面框架的预染页：美团-饿了么的灰底效果-如商品详情页" class="headerlink" title="2.1、处理方案：界面框架的预染页：美团/饿了么的灰底效果(如商品详情页)"></a>2.1、处理方案：界面框架的预染页：美团/饿了么的灰底效果(如商品详情页)</h4><h5 id="2-1-1、方案描述"><a href="#2-1-1、方案描述" class="headerlink" title="2.1.1、方案描述"></a>2.1.1、方案描述</h5><p>美团/饿了么的灰底效果(如商品详情页)</p><h5 id="2-1-2、实现方式"><a href="#2-1-2、实现方式" class="headerlink" title="2.1.2、实现方式"></a>2.1.2、实现方式</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">return</span> realWidgets(data: netdata); <span class="comment">// netdata 可能为空，导致页面空白</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> nodataWidgets();<span class="comment">// 页面预览页</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> withdataWidgets(data: data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2、数据预加载（根据需要）"><a href="#2-2、数据预加载（根据需要）" class="headerlink" title="2.2、数据预加载（根据需要）"></a>2.2、数据预加载（根据需要）</h4><p>当realWidgets中的数据全部来自网络时候，也有白屏的可能，如列表，如需确实有界面框架显示，使用如下方式：</p><ul><li><p>初次冷启动：</p><p>使用与产品约定的默认数据来加载</p></li><li><p>其他：</p><p>保存缓存数据，下次使用缓存数据来加载</p></li></ul><h3 id="3、工期预算"><a href="#3、工期预算" class="headerlink" title="3、工期预算"></a>3、工期预算</h3><p>框架接入 2d</p><h2 id="二、请求结束后的”白屏”-必须"><a href="#二、请求结束后的”白屏”-必须" class="headerlink" title="二、请求结束后的”白屏”(必须)"></a>二、请求结束后的”白屏”(必须)</h2><h3 id="1、场景-1"><a href="#1、场景-1" class="headerlink" title="1、场景"></a>1、场景</h3><p>②处理请求后的场景：文字提示+页面展示(无数据+无网络)</p><h3 id="2、处理方案及实现方式-1"><a href="#2、处理方案及实现方式-1" class="headerlink" title="2、处理方案及实现方式"></a>2、处理方案及实现方式</h3><p>2、网络异常：</p><p>为页面提供网络异常页并伴有刷新恢复重试</p><h3 id="3、工期预算-1"><a href="#3、工期预算-1" class="headerlink" title="3、工期预算"></a>3、工期预算</h3><p>框架接入 2d</p><h2 id="三、网络异常-提示-恢复"><a href="#三、网络异常-提示-恢复" class="headerlink" title="三、网络异常(提示+恢复)"></a>三、网络异常(提示+恢复)</h2><h4 id="2-1、文字提示"><a href="#2-1、文字提示" class="headerlink" title="2.1、文字提示"></a>2.1、文字提示</h4><p>根据情况，弹出易于用户理解的错误提示</p><ul><li>接口问题：服务器开小差了，请稍后重试</li></ul><h4 id="2-2、界面提示（实现网络恢复后能再显示正确界面）"><a href="#2-2、界面提示（实现网络恢复后能再显示正确界面）" class="headerlink" title="2.2、界面提示（实现网络恢复后能再显示正确界面）"></a>2.2、界面提示（实现网络恢复后能再显示正确界面）</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">return</span> successWidget();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (ApiResult.type == error) &#123;</span><br><span class="line">  <span class="keyword">return</span> errorWidget();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ApiResult.type == nodata) &#123;</span><br><span class="line">  <span class="keyword">return</span> nodataWidget();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> successWidget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、程序异常-上报-提示"><a href="#四、程序异常-上报-提示" class="headerlink" title="四、程序异常(上报+提示)"></a>四、程序异常(上报+提示)</h2><p>接入bugly服务+自定义异常页</p><p>接入第三方<a href="https://pub.dev/packages/flutter_bugly" target="_blank" rel="noopener">bugly</a> 或<a href="http://blog.itpub.net/69970551/viewspace-2749757/" target="_blank" rel="noopener">华为AGC的崩溃服务</a></p><p>默认的程序异常页 VS 处理后的程序异常页</p><p><img src="/Flutter/9框架升级/基础框架/image-apperror-defalut.png" alt="默认的程序异常页" style="zoom: 25%;">          <img src="/Flutter/9框架升级/基础框架/image-apperror-new.png" alt="处理后的程序异常页" style="zoom: 25%;"></p><p>程序异常上报后的后台：</p><p><img src="/Flutter/9框架升级/基础框架/image-apperror-backstage.png" alt="程序异常上报后的后台" style="zoom: 33%;"></p><h3 id="工期预算"><a href="#工期预算" class="headerlink" title="工期预算"></a>工期预算</h3><p>异常上报 1d</p><h2 id="五、测试问题反馈与排查优化"><a href="#五、测试问题反馈与排查优化" class="headerlink" title="五、测试问题反馈与排查优化"></a>五、测试问题反馈与排查优化</h2><h3 id="1、新增查看版本页面"><a href="#1、新增查看版本页面" class="headerlink" title="1、新增查看版本页面"></a>1、新增查看版本页面</h3><p>新增查看版本页面，方便对应反馈的问题出现的版本(防止是旧包)。</p><h3 id="2、新增抓包设置-代理"><a href="#2、新增抓包设置-代理" class="headerlink" title="2、新增抓包设置(代理)"></a>2、新增抓包设置(代理)</h3><p>新增代理设置，方便接口人员抓包排查</p><h2 id="六、视觉体验优化"><a href="#六、视觉体验优化" class="headerlink" title="六、视觉体验优化"></a>六、视觉体验优化</h2><p>定义加载动画loading</p><p>愿望灯动画效果优化(底部下沉)</p><h3 id="1、Loading自定义"><a href="#1、Loading自定义" class="headerlink" title="1、Loading自定义"></a>1、Loading自定义</h3><p>UI提供 images 或 json，自定义loading动画</p><h3 id="2、愿望灯"><a href="#2、愿望灯" class="headerlink" title="2、愿望灯"></a>2、愿望灯</h3><p>采用上层愿望灯不变，底部进行下沉动画来实现愿望灯上飘的效果</p><h3 id="3、Toast自定义"><a href="#3、Toast自定义" class="headerlink" title="3、Toast自定义"></a>3、Toast自定义</h3><p>图层</p><h2 id="七、开发规范优化"><a href="#七、开发规范优化" class="headerlink" title="七、开发规范优化"></a>七、开发规范优化</h2><h3 id="1、用户操作-页面形态展示优化"><a href="#1、用户操作-页面形态展示优化" class="headerlink" title="1、用户操作/页面形态展示优化"></a>1、用户操作/页面形态展示优化</h3><h3 id="1、入口的点击"><a href="#1、入口的点击" class="headerlink" title="1、入口的点击"></a>1、入口的点击</h3><p>内部界面</p><ul><li><p>开发中/已实现：</p><p>点击后直接进入，并展示</p></li><li><p>待开发：</p><p>点击后，弹出”将进入XXX功能，其待开发中”</p></li><li><p>产品未规划：</p><p>不显示该入口</p></li></ul><h3 id="2、h5白屏"><a href="#2、h5白屏" class="headerlink" title="2、h5白屏"></a>2、h5白屏</h3><p>重定向</p><p>域名切换：tke</p><h2 id="八、接口请求优化：接口拆分"><a href="#八、接口请求优化：接口拆分" class="headerlink" title="八、接口请求优化：接口拆分"></a>八、接口请求优化：接口拆分</h2><p>通过页面分析，与产品和后台确认哪些页面需要进行接口拆分。</p><p>目前可能需要处理的有：</p><ul><li>商品详情页</li></ul><h2 id="框架实现拆分项"><a href="#框架实现拆分项" class="headerlink" title="框架实现拆分项"></a>框架实现拆分项</h2><h3 id="1、是否显示加载动画isLoading"><a href="#1、是否显示加载动画isLoading" class="headerlink" title="1、是否显示加载动画isLoading"></a>1、是否显示加载动画isLoading</h3><h4 id="1-1、loading动画-images-或-json"><a href="#1-1、loading动画-images-或-json" class="headerlink" title="1.1、loading动画(images 或 json)"></a>1.1、loading动画(images 或 json)</h4><p>使用 image 或 json 实现loading动画</p><h4 id="1-2、含loading显示控制的页面组件"><a href="#1-2、含loading显示控制的页面组件" class="headerlink" title="1.2、含loading显示控制的页面组件"></a>1.2、含loading显示控制的页面组件</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> showLoading(<span class="built_in">bool</span> show);</span><br></pre></td></tr></table></figure><h3 id="2、页面状态PageType"><a href="#2、页面状态PageType" class="headerlink" title="2、页面状态PageType"></a>2、页面状态PageType</h3><h4 id="2-1、加载结束不同页面状态页面组件"><a href="#2-1、加载结束不同页面状态页面组件" class="headerlink" title="2.1、加载结束不同页面状态页面组件"></a>2.1、加载结束不同页面状态页面组件</h4><table><thead><tr><th>编号</th><th>页面状态PageType</th><th>功能</th><th>人日</th><th></th></tr></thead><tbody><tr><td>1</td><td>加载失败</td><td>errorWidget</td><td>0.25</td><td></td></tr><tr><td>2</td><td>加载成功，但无数据</td><td>nodataWidget（含”重新加载”操作)</td><td>0.5</td><td></td></tr><tr><td>3</td><td>加载成功，且有数据</td><td>successWidget</td><td>0</td></tr></tbody></table><h4 id="2-2、含页面状态控制的视图组件"><a href="#2-2、含页面状态控制的视图组件" class="headerlink" title="2.2、含页面状态控制的视图组件"></a>2.2、含页面状态控制的视图组件</h4><p>通过传入不同的状态，显示不同状态下的页面</p><h3 id="3、请求"><a href="#3、请求" class="headerlink" title="3、请求"></a>3、请求</h3><p>5、含状态管理的页面基类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> currentPageType = successWidget; <span class="comment">// 默认的状态页面</span></span><br><span class="line"><span class="built_in">bool</span> showLoading = <span class="keyword">false</span>;<span class="comment">// 是否显示加载动画</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pageTypeWidget(pageType: currentPageType, showLoading: showLoading);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始请求</span></span><br><span class="line">showLoading = <span class="keyword">true</span>;</span><br><span class="line">setState(() &#123;&#125;);</span><br><span class="line">apiRequest.then((value) &#123;</span><br><span class="line">      _xxxBean = value;</span><br><span class="line">  showLoading = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        currentPageType = nodata;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentPageType = success;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//      setState(() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      &#125;);</span></span><br><span class="line">      disabledLoading();</span><br><span class="line">    &#125;).catchError((onError) &#123;</span><br><span class="line">      currentPageType = error;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求结束</span></span><br><span class="line">showLoading = <span class="keyword">false</span></span><br><span class="line"><span class="keyword">if</span> (ApiResult.type == error) &#123;</span><br><span class="line">  currentPageType = error;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ApiResult.type == nodata) &#123;</span><br><span class="line">  currentPageType = nodata;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  currentPageType = success;</span><br><span class="line">&#125;</span><br><span class="line">setState(() &#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="待安排优化"><a href="#待安排优化" class="headerlink" title="待安排优化"></a>待安排优化</h2><h3 id="1、网络库升级"><a href="#1、网络库升级" class="headerlink" title="1、网络库升级"></a>1、网络库升级</h3><p>重构及增加错误码友好提示处理  1d</p><h3 id="2、基类新增处理"><a href="#2、基类新增处理" class="headerlink" title="2、基类新增处理"></a>2、基类新增处理</h3><ul><li><p>[x] 键盘收起</p></li><li><p>[ ] 默认颜色+自定义背景颜色</p></li><li><p>[x] 状态获取</p></li><li><p>[x] 导航栏重用success上添加的</p><p><a href="https://www.jianshu.com/p/5cc7762b8443" target="_blank" rel="noopener">Flutter 显示/隐藏控件（性能优化）</a></p></li></ul><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;  Visibility 隐藏/可见，能保存组件的状态；Offstate不能保存组件的状态，组件重新加载</span><br><span class="line">&gt;  * 控制child是否显示</span><br><span class="line">&gt;  *</span><br><span class="line">&gt;     当offstage为<span class="literal">true</span>，控件隐藏； 当offstage为<span class="literal">false</span>，显示；</span><br><span class="line">&gt;     当Offstage不可见的时候，如果child有动画等，需要手动停掉，Offstage并不会停掉动画等操作。</span><br><span class="line">&gt; </span><br><span class="line">&gt;     const Offstage(&#123; Key key, this.offstage = <span class="literal">true</span>, Widget child &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li style="list-style: none"><input type="checkbox"> 网页加载库替换，新增错误码监听，统一js</li><li style="list-style: none"><input type="checkbox"> 基础框架新增背景设置及修复有背景时候界面显示问题，error/nodata新增color设置，用于设置透明</li><li style="list-style: none"><input type="checkbox"> 基础框架新增unkonw类型，兼容有无初始显示界面的设置</li><li style="list-style: none"><input type="checkbox"> 基础框架优化appbar设置，及提供最简易常用的导航栏</li><li style="list-style: none"><input type="checkbox"> Mock api 新增缓存功能</li><li style="list-style: none"><input type="checkbox"> Bruno接入及编译修复</li><li style="list-style: none"><input type="checkbox"> 版本升级管理</li><li style="list-style: none"><input type="checkbox"> 数据缓存处理</li><li style="list-style: none"><input type="checkbox"> 精选愿望单原型开发完成，待联调</li><li style="list-style: none"><input type="checkbox"> 新增百愿清单原型开发完成，待联调</li></ul><h3 id="3、App快速实现置灰样式"><a href="#3、App快速实现置灰样式" class="headerlink" title="3、App快速实现置灰样式"></a>3、App快速实现置灰样式</h3><p><a href="App快速实现置灰样式">App快速实现置灰样式</a></p><p><a href="https://www.jb51.net/article/205303.htm" target="_blank" rel="noopener">iOS整个APP实现灰色主题的示例代码</a></p><p>白屏：</p><p>①处理请求前的场景：数据预加载+框架预染页(美团/饿了么的灰底效果)</p><p>②处理请求后的场景：文字提示+页面展示(无数据+无网络)</p><p>2、网络异常：</p><p>为页面提供网络异常页并伴有刷新恢复重试</p><p>3、程序异常(上报+提示)：</p><p>接入bugly服务+自定义异常页</p><p>4、视觉体验优化</p><p>定义加载动画loading</p><p>愿望灯动画效果优化(底部下沉)</p><p>5、测试优化</p><p>新增查看版本页面，方便对应反馈的问题</p><p>新增代理设置，方便接口人员抓包排查</p><p>6、其他</p><p>AA送礼：提测，待测试验证后，如有问题修复</p><p>开发者账号申请审核未通过，正在处理。 （因为域名问题被拒，新域名已经准备好了，在跟apple沟通中）</p><p>下周：</p><p>继续我的模块开发，联调接口。</p><p>在完成”我的”模块或等待接口情况下，评估及开发产品规划的其他功能。</p><p>目前：</p><p>框架升级（白屏、预览页灰底、网络刷新恢复页，异常上报及异常页）：今天</p><p>愿望灯 ok<br>许个愿 ok<br>我的：部分在联调，部分在等接口<br>AA送礼：提测，待测试验证后，如有问题修复</p><p>loading<br>开发者账号申请审核未通过，正在处理。 （因为域名问题被拒，新域名已经准备好了，在跟apple沟通中）</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第九章：框架升级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础框架</title>
      <link href="/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6BasePage/"/>
      <url>/Flutter/9%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6BasePage/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="框架的接入"><a href="#框架的接入" class="headerlink" title="框架的接入"></a>框架的接入</h1><p>为了有更好的用户体验，我们对页面框架进行如下优化。</p><h2 id="页面框架"><a href="#页面框架" class="headerlink" title="页面框架"></a>页面框架</h2><h3 id="1、页面头appbar、页面身successWidget"><a href="#1、页面头appbar、页面身successWidget" class="headerlink" title="1、页面头appbar、页面身successWidget"></a>1、页面头appbar、页面身successWidget</h3><p>1、错误页和空白页的页面，需要自定义</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_effect/flutter_effect.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改地方1.1继承: BJHBasePage</span></span><br><span class="line"><span class="comment">//class TSBasePage extends StatefulWidget &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TSBasePage</span> <span class="keyword">extends</span> <span class="title">BJHBasePage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改地方1.2继承: BJHBasePageState</span></span><br><span class="line"><span class="comment">//class _TSBasePageState extends State&lt;TSBasePage&gt; &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TSBasePageState</span> <span class="keyword">extends</span> <span class="title">BJHBasePageState</span>&lt;<span class="title">TSBasePage</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 修改地方2.0:删除/注释掉原来的 Widget build(BuildContext context)&#123;&#125;</span></span><br><span class="line">    <span class="comment">//@override</span></span><br><span class="line">    <span class="comment">//Widget build(BuildContext context) &#123;</span></span><br><span class="line">    <span class="comment">//  return Scaffold(</span></span><br><span class="line">    <span class="comment">//    backgroundColor: Color(0xffF0F0F0),</span></span><br><span class="line">  <span class="comment">//  appBar: appBarWidget,</span></span><br><span class="line">    <span class="comment">//    body: bodyWidgets,</span></span><br><span class="line">    <span class="comment">//  );</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">  <span class="comment">// 修改地方2.1:将其中的导航栏 appBarWidget 通过 PreferredSizeWidget appBar() &#123;&#125; 返回</span></span><br><span class="line">  <span class="comment">// 当你的导航栏是使用系统的AppBar时候，重写appBar()方法，如</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">    PreferredSizeWidget appBar() &#123;</span><br><span class="line">      <span class="keyword">return</span> AppBar(</span><br><span class="line">        title: Text(<span class="string">"导航栏标题"</span>),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 当你的导航栏不是使用系统的AppBar，而是自己在page上添加的Widget的时候，重写 Widget appBarWidget(BuildContext context)方法，如</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget appBarWidget(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">return</span> EasyAppBar(</span><br><span class="line">        title: <span class="string">'我是成功页面的标题'</span>,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> CommonAppBar(</span><br><span class="line">        title: AppBarTitleWidget(text: <span class="string">'我是成功页面的标题'</span>),</span><br><span class="line">        leading: AppBarBackWidget(</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            Navigator.pop(context);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// @override</span></span><br><span class="line">    <span class="comment">// Color backgroundColor() &#123;</span></span><br><span class="line">    <span class="comment">//   return Color(0xFFF0F0F0);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改地方2.2:将其中的 bodyWidgets 通过 Widget buildSuccessWidget(BuildContext context) &#123;&#125; 返回，则当前调用 updateWidgetType(WidgetType.SuccessWithData); 的时候，其会将视图更新为该方法返回的样式</span></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget buildSuccessWidget(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">return</span> bodyWidgets;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 修改地方2.2:自定义【请求成功，但无数据】的界面</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">    Widget buildNodataWidget(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">return</span> StateNodataWidget(</span><br><span class="line">        image: AssetImage(<span class="string">'assets/images/nodata.png'</span>)</span><br><span class="line">        mainTitle: <span class="string">'我是【请求成功，但无数据】的界面'</span>,</span><br><span class="line">        subTitle: <span class="string">''</span>,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改地方2.3:自定义【请求失败】的界面</span></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget buildErrorWidget(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">return</span> StateErrorWidget(</span><br><span class="line">        <span class="comment">//color: Colors.transparent, //可设置背景色，常用语本page有设置背景图片的时候</span></span><br><span class="line">        errorRetry: getData,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 请求网络的方法名可任意（不再需要保证为getData,因为错误页和空白页的重新加载需要在本dart文件设置)</span></span><br><span class="line">  <span class="keyword">void</span> getData() &#123;</span><br><span class="line">...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改地方4:对返回的数据进行判空及更新状态</span></span><br><span class="line">        Api.getGoodsInfoList(&#123;&#125;).then((ResultData data) &#123;</span><br><span class="line">          <span class="keyword">if</span> (data.isSuccess) &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改地方4.1:对请求到数据，且状态正确的数据进行判空及更新状态</span></span><br><span class="line">            <span class="keyword">if</span> (bean == <span class="keyword">null</span>) &#123;</span><br><span class="line">              updateWidgetType(WidgetType.SuccessNoData);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              updateWidgetType(WidgetType.SuccessWithData);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 修改地方4.2:对请求到数据，但状态错误的处理</span></span><br><span class="line">            <span class="comment">//updateWidgetType(WidgetType.ErrorBusiness);</span></span><br><span class="line">          &#125;</span><br><span class="line">    &#125;).catchError(onError) &#123;</span><br><span class="line">          <span class="comment">// 修改地方4.3:对请求失败，如服务器崩溃，无网络等的处理</span></span><br><span class="line">          updateWidgetType(WidgetType.ErrorNetwork);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、初始界面buildInitWidget"><a href="#2、初始界面buildInitWidget" class="headerlink" title="2、初始界面buildInitWidget"></a>2、初始界面<code>buildInitWidget</code></h3><p>其他，如果你还想设置初始页面，目前初始视图默认是空白视图</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"> Widget buildInitWidget(BuildContext context) &#123;</span><br><span class="line">   <span class="keyword">return</span> Container(</span><br><span class="line">     color: Colors.green,</span><br><span class="line">     height: <span class="number">100</span>,</span><br><span class="line">     child: Text(</span><br><span class="line">       <span class="string">'我是初始视图...'</span>,</span><br><span class="line">       style: TextStyle(color: Colors.blue, fontSize: <span class="number">24</span>),</span><br><span class="line">       textAlign: TextAlign.center,</span><br><span class="line">     ),</span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3、背景色、背景图片"><a href="#3、背景色、背景图片" class="headerlink" title="3、背景色、背景图片"></a>3、背景色、背景图片</h3><p>设置背景图片</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 背景视图(常用来设置背景图片)</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"> Widget backgroundWidget(BuildContext context) &#123;</span><br><span class="line">   <span class="comment">// 设置背景色</span></span><br><span class="line">   <span class="keyword">return</span> Container(</span><br><span class="line">     color: Color(<span class="number">0xFFF0F0F0</span>),</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   <span class="comment">// eg1:设置铺满的背景图片</span></span><br><span class="line">   <span class="comment">// return Container(</span></span><br><span class="line">   <span class="comment">//   alignment: Alignment.topCenter,</span></span><br><span class="line">   <span class="comment">//   //color: Colors.yellow,</span></span><br><span class="line">   <span class="comment">//   constraints: const BoxConstraints(</span></span><br><span class="line">   <span class="comment">//     minWidth: double.infinity,</span></span><br><span class="line">   <span class="comment">//     minHeight: double.infinity,</span></span><br><span class="line">   <span class="comment">//   ),</span></span><br><span class="line">   <span class="comment">//   child: Image.asset(</span></span><br><span class="line">   <span class="comment">//     "images/wish/bg_icon.png",</span></span><br><span class="line">   <span class="comment">//     fit: BoxFit.fitWidth,</span></span><br><span class="line">   <span class="comment">//   ),</span></span><br><span class="line">   <span class="comment">// );</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// eg2:设置绝对定位的背景图片</span></span><br><span class="line">   <span class="comment">// return Positioned(</span></span><br><span class="line">   <span class="comment">//   top: 0,</span></span><br><span class="line">   <span class="comment">//   right: 0,</span></span><br><span class="line">   <span class="comment">//   left: 0,</span></span><br><span class="line">   <span class="comment">//   height: Adapt.px(678),</span></span><br><span class="line">   <span class="comment">//   child: Image.asset(</span></span><br><span class="line">   <span class="comment">//     "images/wish/bg_icon.png",</span></span><br><span class="line">   <span class="comment">//     fit: BoxFit.fitWidth,</span></span><br><span class="line">   <span class="comment">//   ),</span></span><br><span class="line">   <span class="comment">// );</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第九章：框架升级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态管理-框架对比</title>
      <link href="/Flutter/8%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/"/>
      <url>/Flutter/8%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>待整理文章：</p><ul><li><p><a href="https://www.jianshu.com/p/324d7387aac5" target="_blank" rel="noopener">Flutter分享 : 状态管理</a>：有必要看下来了解为什么我们需要状态管理</p></li><li><p><a href="https://www.jianshu.com/p/41ac6dd57f5e" target="_blank" rel="noopener">Flutter 状态管理框架对比</a></p></li><li><a href="https://www.jiqizhixin.com/articles/2019-03-06-3" target="_blank" rel="noopener">来了！闲鱼技术团队开源Flutter应用框架Fish Redux</a></li><li><a href="https://blog.csdn.net/CNAD666/article/details/113498392" target="_blank" rel="noopener">Flutter GetX使用—简洁的魅力</a></li><li><a href="https://juejin.cn/post/6905367558008078350" target="_blank" rel="noopener">Flutter状态管理终极方案GetX第一篇——路由</a></li><li><a href="https://juejin.cn/post/6907622450151096334" target="_blank" rel="noopener">Flutter状态管理终极方案GetX第二篇——状态管理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第八章：状态管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译优化hmap</title>
      <link href="/iOS/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3/%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96-hmap/"/>
      <url>/iOS/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3/%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96-hmap/</url>
      
        <content type="html"><![CDATA[<h1 id="编译优化hmap"><a href="#编译优化hmap" class="headerlink" title="编译优化hmap"></a>编译优化hmap</h1><p>[toc]</p><h2 id="一、查看编译时间"><a href="#一、查看编译时间" class="headerlink" title="一、查看编译时间"></a>一、查看编译时间</h2><p>Clean后，执行Command+B，查看编译时间为24.0seconds</p><p><img src="/iOS/性能相关/编译优化-hmap/image-20211124154515792.png" alt="image-20211124154515792" style="zoom: 33%;"></p><p>而如果编译后，不Clean，继续执行编译，即使用之前的编译缓存，得到的新的编译时间为0.6seconds</p><p><img src="/iOS/性能相关/编译优化-hmap/image-20211124154752653.png" alt="image-20211124154752653"></p><h2 id="二、hmap优化的结果"><a href="#二、hmap优化的结果" class="headerlink" title="二、hmap优化的结果"></a>二、hmap优化的结果</h2><p>系统的Pods中Headers里有Public和Private目录：</p><p><img src="/iOS/性能相关/编译优化-hmap/image-20211124155017822.png" alt="image-20211124155017822"></p><p>使用 plugin ‘cocoapods-hmap-prebuilt’ 后</p><p><img src="/iOS/性能相关/编译优化-hmap/image-20211124155617317.png" alt="image-20211124155617317" style="zoom: 50%;"></p><p>在Pods中Headers里会多出一个HMap目录，里面的文件为hamp，如下截图所示：</p><p><img src="/iOS/性能相关/编译优化-hmap/image-20211124155527016.png" alt="image-20211124155527016"></p><p>此时，我们重新Clean，然后编译，得到的优化后的编译时间为16.8seconds</p><p><img src="/iOS/性能相关/编译优化-hmap/image-20211124155414548.png" alt="image-20211124155414548"></p><p>如果编译后，不Clean，继续执行编译，得到的时间为0.5seconds，也比之前的0.6seconds短</p><p><img src="/iOS/性能相关/编译优化-hmap/image-20211124155945171.png" alt="image-20211124155945171"></p><h2 id="三、hmap优化怎么使用"><a href="#三、hmap优化怎么使用" class="headerlink" title="三、hmap优化怎么使用"></a>三、hmap优化怎么使用</h2><p>我们直接使用 <a href="https://rubygems.org/gems/cocoapods-hmap-prebuilt/" target="_blank" rel="noopener">cocoapods-hmap-prebuilt</a></p><h3 id="1、cocoapods-hmap-prebuilt的使用方法"><a href="#1、cocoapods-hmap-prebuilt的使用方法" class="headerlink" title="1、cocoapods-hmap-prebuilt的使用方法"></a>1、cocoapods-hmap-prebuilt的使用方法</h3><p>直接在你的Podfile中，添加以下一行代码就行</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># this is part of Podfile</span></span><br><span class="line">target <span class="string">'XXX'</span> <span class="keyword">do</span></span><br><span class="line">  plugin <span class="string">'cocoapods-hmap-prebuilt'</span><span class="comment"># 添加此行代码就行</span></span><br><span class="line">  pod <span class="string">'XXX'</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>之后，你和平时一样执行pod install就行。</p><h3 id="2、安装cocoapods-hmap-prebuilt"><a href="#2、安装cocoapods-hmap-prebuilt" class="headerlink" title="2、安装cocoapods-hmap-prebuilt"></a>2、安装cocoapods-hmap-prebuilt</h3><p>如果你没安装<code>cocoapods-hmap-prebuilt</code>，则会在执行pod install的时候，发生如下错误：</p><p><img src="/iOS/性能相关/编译优化-hmap/image-20211124161907639.png" alt="image-20211124161907639"></p><p>所以请先安装，安装方法如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install cocoapods-hmap-prebuilt</span><br></pre></td></tr></table></figure><p><img src="/iOS/性能相关/编译优化-hmap/image-20211124162055386.png" alt="image-20211124162055386"></p><p>之后，你和平时一样执行pod install就行，执行过程中，会多出如下输出：</p><p><img src="/iOS/性能相关/编译优化-hmap/image-20211124165627186.png" alt="image-20211124165627186"></p><h3 id="三、coapods-hmap-prebuilt介绍"><a href="#三、coapods-hmap-prebuilt介绍" class="headerlink" title="三、coapods-hmap-prebuilt介绍"></a>三、coapods-hmap-prebuilt介绍</h3><p>以下内容摘自：<a href="https://tech.meituan.com/2021/02/25/cocoapods-hmap-prebuilt.html" target="_blank" rel="noopener">一款可以让大型iOS工程编译速度提升50%的工具</a></p><blockquote><p>cocoapods-hmap-prebuilt 是美团平台迭代组自研的一款 cocoapods 插件，以 <a href="https://clang.llvm.org/doxygen/classclang_1_1HeaderMap.html" target="_blank" rel="noopener">Header Map 技术</a> 为基础，进一步提升代码的编译速度，完善头文件的搜索机制。</p></blockquote><h2 id="四、Header-Map-是个啥？"><a href="#四、Header-Map-是个啥？" class="headerlink" title="四、Header Map 是个啥？"></a>四、Header Map 是个啥？</h2><p>Header Map是二进制文件，其包含头文件和头文件路径的映射表。</p><p>其核心功能是让编译器能够找到相应的头文件的位置，相较于使用header search path提供的路径查找会快很多</p><h3 id="1、Hmap在编译后的文件路径"><a href="#1、Hmap在编译后的文件路径" class="headerlink" title="1、Hmap在编译后的文件路径"></a>1、Hmap在编译后的文件路径</h3><p>我们编译后，通过Products，找到生成的app的目录，如下图：</p><p><img src="/iOS/性能相关/编译优化-hmap/image-20211124165159982.png" alt="image-20211124165159982"></p><p>在其中，我们找到<strong>Intermediates.noindex目录</strong>下的<strong>Pod.build</strong></p><p><img src="/iOS/性能相关/编译优化-hmap/image-20211124165909673.png" alt="image-20211124165909673"></p><h3 id="2、hmap查看工具"><a href="#2、hmap查看工具" class="headerlink" title="2、hmap查看工具"></a>2、hmap查看工具</h3><p>我们通过<a href="https://github.com/milend/hmap" target="_blank" rel="noopener">hmap查看工具</a>来输出下hmap文件的内容。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmap print Masonry-all-target-headers.hmap</span><br></pre></td></tr></table></figure><p>输出内容如下：</p><p><img src="/iOS/性能相关/编译优化-hmap/image-20211124170212021.png" alt="image-20211124170212021"></p><p>附：该hmap工具的安装方法，如其github上的How to use一样，使用如下一行命令，在终端中执行即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install milend/taps/hmap</span><br></pre></td></tr></table></figure><h2 id="五、Xcode-编译的其他相关知识"><a href="#五、Xcode-编译的其他相关知识" class="headerlink" title="五、Xcode 编译的其他相关知识"></a>五、Xcode 编译的其他相关知识</h2><p><a href="http://events.jianshu.io/p/4e0a5a18f150" target="_blank" rel="noopener">Xcode 编译相关</a></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS功能-Transform</title>
      <link href="/iOS/%E5%8A%9F%E8%83%BD%E6%80%A7%E6%8A%80%E6%9C%AF/iOS%E5%8A%9F%E8%83%BD-Transform/"/>
      <url>/iOS/%E5%8A%9F%E8%83%BD%E6%80%A7%E6%8A%80%E6%9C%AF/iOS%E5%8A%9F%E8%83%BD-Transform/</url>
      
        <content type="html"><![CDATA[<h1 id="关于CATransform3D"><a href="#关于CATransform3D" class="headerlink" title="关于CATransform3D"></a>关于CATransform3D</h1><p>参考文章：<a href="https://www.jianshu.com/p/69ba0a4b2df9" target="_blank" rel="noopener">关于CATransform3D</a></p><h1 id="CATransform3DMakeRotation的使用"><a href="#CATransform3DMakeRotation的使用" class="headerlink" title="CATransform3DMakeRotation的使用"></a>CATransform3DMakeRotation的使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Returns a transform that rotates by &apos;angle&apos; radians about the vector</span><br><span class="line"> * &apos;(x, y, z)&apos;. If the vector has length zero the identity transform is</span><br><span class="line"> * returned. */</span><br><span class="line"></span><br><span class="line">CA_EXTERN CATransform3D CATransform3DMakeRotation (CGFloat angle, CGFloat x,</span><br><span class="line">    CGFloat y, CGFloat z)</span><br><span class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br></pre></td></tr></table></figure><p>angle:旋转角度<br>后面的x,y,z三个值组合表示坐标系里面的一个点（x,y,z)，由原点和该点(x,y,z)形成一条旋转轴</p><p>CATransform3DMakeRotation是按最短路径来选择的</p><p>示例：<a href="https://www.jianshu.com/p/c2ff7cccbd7d" target="_blank" rel="noopener">CATransform3DMakeRotation逆时针</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iconFont</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/iconFont/iconFont/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/iconFont/iconFont/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Iconfont"><a href="#一、Iconfont" class="headerlink" title="一、Iconfont"></a>一、Iconfont</h2><p>阿里巴巴矢量图库：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></p><p>设计师将图标上传到Iconfont平台，用户可以自定义下载多种格式的icon，平台也可将图标转换为字体，便于前端工程师自由调整与调用。</p><h3 id="1、iconfont-VS-图片-优势"><a href="#1、iconfont-VS-图片-优势" class="headerlink" title="1、iconfont VS 图片 优势"></a>1、iconfont VS 图片 优势</h3><p>iconfont和图片相比有如下优势：</p><ul><li>1.体积小：可以减小安装包大小。 </li><li>2.矢量的：iconfont都是矢量图标，放大不会影响其清晰度。 </li><li>3.可以应用文本样式：可以像文本一样改变字体图标的颜色、大小对齐等。 </li><li>4.可以通过TextSpan和文本混用。</li></ul><p>iconfont即“字体图标”，它是将图标做成字体文件，然后通过指定不同的字符而显示不同的图片。</p><p>效果如下图：控制不同颜色和大小的icon。</p><p><img src="/实用工具/iconFont/iconFont/image-20220318235832369.png" alt="image-20220318235832369"></p><h3 id="2、iconfont-资源下载方式"><a href="#2、iconfont-资源下载方式" class="headerlink" title="2、iconfont 资源下载方式"></a>2、iconfont 资源下载方式</h3><p>Iconfont 图标需要使用SVG资源，获取资源的几种方式</p><ul><li><a href="https://blog.csdn.net/chuyouyinghe/article/details/111771042" target="_blank" rel="noopener">13个免费下载 SVG 图标网站</a></li><li><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a> 加入需要的图片到购物车并选择下载代码</li></ul><p>下载选择图片</p><p><img src="/实用工具/iconFont/iconFont/webp" alt="img"></p><h2 id="二、iconfont在Flutter中的使用"><a href="#二、iconfont在Flutter中的使用" class="headerlink" title="二、iconfont在Flutter中的使用"></a>二、iconfont在Flutter中的使用</h2><p>Flutter中，可以像Web开发一样使用iconfont。</p><p>1、下载iconfont</p><p>2、将文件中的 .json .ttf 添加到项目中</p><p>实际建议将整个iconfont解压出来的文件都添加到项目中。主要原因有：</p><p>①更新时候，直接整个覆盖，避免内部子文件不对等</p><p>②设置icon时候，除了打开json看到图标名，还可以打开html，看到所有图片的整体。</p><p><img src="/实用工具/iconFont/iconFont/webp-20220318234647902" alt="img"></p><p>3.配置（配置时候注意格式）</p><p>这里 family后面的IconFont是自定义的名字，可以自行改成想要的，后续需要用到这个family。</p><p><img src="/实用工具/iconFont/iconFont/webp-20220318234719545" alt="img"></p><h3 id="4-生成dart文件"><a href="#4-生成dart文件" class="headerlink" title="4.生成dart文件"></a>4.生成dart文件</h3><h4 id="1、手动方式："><a href="#1、手动方式：" class="headerlink" title="1、手动方式："></a>1、手动方式：</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppIcon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> __FONT_NAME__ = <span class="string">'iconfont'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> IconData icon_dianzan = IconData(<span class="number">0xe612</span>, fontFamily: __FONT_NAME__); <span class="comment">// 点赞</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> IconData icon_zhuanfa = IconData(<span class="number">0xe60c</span>, fontFamily: __FONT_NAME__); <span class="comment">// 转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中 IconData(0x 后的 e612 的这个值可以从json或html文件中或取</span></span><br></pre></td></tr></table></figure><h4 id="2、自动方式（脚本）："><a href="#2、自动方式（脚本）：" class="headerlink" title="2、自动方式（脚本）："></a>2、自动方式（脚本）：</h4><h5 id="①、脚本内容"><a href="#①、脚本内容" class="headerlink" title="①、脚本内容"></a>①、脚本内容</h5><p>iconfont_dart.py(其中变量IconDart，IconCss 根据实际情况可做更改)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: u8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">ROOT = Path(__file__).resolve().parent</span><br><span class="line">MAIN = ROOT</span><br><span class="line"><span class="comment"># 生成的IconFont.dart 文件路径</span></span><br><span class="line">IconDart = <span class="string">'lib/common/style/IconFont.dart'</span></span><br><span class="line"><span class="comment"># iconfont css 文件存放路径</span></span><br><span class="line"><span class="comment">#IconCss = 'assets/iconfont/iconfont.css'</span></span><br><span class="line">IconDart = <span class="string">'IconFont.dart'</span></span><br><span class="line">IconCss = <span class="string">'iconfont.css'</span></span><br><span class="line"><span class="comment"># 将 iconfont 的 css 自动转换为 dart 代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Begin translate...'</span>)</span><br><span class="line">    </span><br><span class="line">    code = <span class="string">"""</span></span><br><span class="line"><span class="string">        import 'package:flutter/widgets.dart';</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        /// @author:  hsc</span></span><br><span class="line"><span class="string">        /// @date: &#123;date&#125;</span></span><br><span class="line"><span class="string">        /// @description  代码由程序自动生成。请不要对此文件做任何修改。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        class IconFont &#123;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        static const String FONT_FAMILY = 'IconFont';</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        &#123;icon_codes&#125;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        """</span>.strip()</span><br><span class="line">    strings = []</span><br><span class="line">    content = open(MAIN / IconCss).read().replace(<span class="string">'\n  content'</span>, <span class="string">'content'</span>)</span><br><span class="line">    matchObj = re.finditer( <span class="string">r'.icon-(.*?):(.|\n)*?"\\(.*?)";'</span>, content)</span><br><span class="line">    <span class="keyword">for</span> match <span class="keyword">in</span> matchObj:</span><br><span class="line">        name = match.group(<span class="number">1</span>)</span><br><span class="line">        name = name.replace(<span class="string">"-"</span>,<span class="string">"_"</span>)</span><br><span class="line">        string = <span class="string">f'  static const IconData <span class="subst">&#123;name&#125;</span> = const IconData(0x<span class="subst">&#123;match.group(<span class="number">3</span>)&#125;</span>, fontFamily: IconFont.FONT_FAMILY);'</span></span><br><span class="line">        strings.append(string)</span><br><span class="line">    strings = <span class="string">'\n'</span>.join(strings)</span><br><span class="line">    code = code.replace(<span class="string">'&#123;icon_codes&#125;'</span>, strings)</span><br><span class="line">    code = code.replace(<span class="string">'&#123;date&#125;'</span>, time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime()))</span><br><span class="line">    open(MAIN / IconDart, <span class="string">'w'</span>).write(code)</span><br><span class="line">    print(<span class="string">'Finish translate...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    translate()</span><br></pre></td></tr></table></figure><h5 id="②、脚本执行python3-iconfont-dart-py"><a href="#②、脚本执行python3-iconfont-dart-py" class="headerlink" title="②、脚本执行python3 iconfont_dart.py"></a>②、脚本执行<code>python3 iconfont_dart.py</code></h5><p><img src="/实用工具/iconFont/iconFont/image-20220319012403867.png" alt="image-20220319012403867"></p><p>执行结果如下，生成了IconFont.dart文件：</p><p><img src="/实用工具/iconFont/iconFont/image-20220319012857584.png" alt="image-20220319012857584"></p><p>其他脚本参考：</p><ul><li><a href="https://github.com/ymzuiku/iconfont_builder" target="_blank" rel="noopener">iconfont_builder</a></li></ul><h1 id="二、png转svg格式并上传至iconfont"><a href="#二、png转svg格式并上传至iconfont" class="headerlink" title="二、png转svg格式并上传至iconfont"></a>二、png转svg格式并上传至iconfont</h1><p>实现方案：</p><ol><li>下载转换工具inkscape</li><li>登录阿里图标上传svg</li></ol><h3 id="一、inkscape"><a href="#一、inkscape" class="headerlink" title="一、inkscape"></a>一、inkscape</h3><p><a href="https://inkscape.org" target="_blank" rel="noopener">https://inkscape.org</a></p><p><img src="/实用工具/iconFont/iconFont/image-20220318192601125.png" alt="image-20220318192601125"></p><p><img src="/实用工具/iconFont/iconFont/image-20220318192634755.png" alt="image-20220318192634755"></p><p><img src="/实用工具/iconFont/iconFont/image-20220318192650833.png" alt="image-20220318192650833"></p><p><img src="/实用工具/iconFont/iconFont/image-20220318204002050.png" alt="image-20220318204002050"></p><p><img src="/实用工具/iconFont/iconFont/image-20220318205057886.png" alt="image-20220318205057886"></p><p><img src="/实用工具/iconFont/iconFont/image-20220318205202062.png" alt="image-20220318205202062"></p><p><img src="/实用工具/iconFont/iconFont/image-20220318205304361.png" alt="image-20220318205304361"></p><p><img src="/实用工具/iconFont/iconFont/image-20220318205348852.png" alt="image-20220318205348852"></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 文档管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mock基础知识</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/Mock%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/Mock%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Mock基础知识"><a href="#Mock基础知识" class="headerlink" title="Mock基础知识"></a>Mock基础知识</h1><h2 id="一、常用整理"><a href="#一、常用整理" class="headerlink" title="一、常用整理"></a>一、常用整理</h2><p>常用整理</p><table><thead><tr><th>类型</th><th>占位符</th><th>输出值</th></tr></thead><tbody><tr><td>生日</td><td>@date</td><td>1990-01-01</td></tr><tr><td>性别</td><td>@integer(0,2)</td><td>0-2之间的随机值</td></tr><tr><td>身高</td><td>@float(140,220,1,1)</td><td>小数位数为1个的140-220之间的随机值</td></tr><tr><td>学校</td><td>@pick([‘清华大学’, ‘北京大学’, ‘哈尔滨工业大学’, ‘国防科技大学’])</td><td></td></tr><tr><td>家乡</td><td>@city(true)</td><td>省+市</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="二、常用占位符功能详述"><a href="#二、常用占位符功能详述" class="headerlink" title="二、常用占位符功能详述"></a>二、常用占位符功能详述</h2><h4 id="integer-min-max"><a href="#integer-min-max" class="headerlink" title="@integer(min?, max?)"></a>@integer(min?, max?)</h4><p>返回一个随机的整数。</p><ul><li>min：可选参数，整数最小值。</li><li>max：可选参数，整数最大值。</li></ul><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@integer</span><br><span class="line">//--&gt; 1686805249110932</span><br><span class="line">@integer(10,100)</span><br><span class="line">//--&gt; 26</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><h4 id="float-min-max-dmin-dmax"><a href="#float-min-max-dmin-dmax" class="headerlink" title="@float( min?, max?, dmin?, dmax? )"></a>@float( min?, max?, dmin?, dmax? )</h4><p>返回一个随机浮点数。</p><ul><li>min：可选，整数部分最小值。</li><li>max：可选，整数部分最大值。</li><li>dmin：可选，小数部分最小长度。</li><li>dmax:可选，小数部分最大长度。</li></ul><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@float</span><br><span class="line">//--&gt; 1924364975802932.5</span><br><span class="line">@float(60, 100, 2, 6)</span><br><span class="line">//--&gt; 68.1258</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><h4 id="string"><a href="#string" class="headerlink" title="@string"></a>@string</h4><p>返回随机字串，有如下几种使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@string</span><br><span class="line">@string(length)</span><br><span class="line">@string(pool, length)</span><br><span class="line">@string(min, max)</span><br><span class="line">@string(pool, min, max)</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><ul><li>length: 字串长度</li><li>min: 字串最短长度</li><li>max: 字串最大长度</li><li>pool：表示字符池。如果传入 ‘lower’、‘upper’、‘number’或’symbol’，表示从内置的字符池从选取。对应关系如下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lower: &quot;abcdefghijklmnopqrstuvwxyz&quot;,</span><br><span class="line">upper: &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;,</span><br><span class="line">number: &quot;0123456789&quot;,</span><br><span class="line">symbol: &quot;!@#$%^&amp;*()[]&quot;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@string(6)</span><br><span class="line">//--&gt; kV(qj4</span><br><span class="line">@string(&apos;upper&apos;,2,6)</span><br><span class="line">//--&gt; NJKU</span><br><span class="line">@string(&apos;123abc!@#&apos;, 2,6)</span><br><span class="line">//--&gt; #ab!21</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><h4 id="url-protocol-host"><a href="#url-protocol-host" class="headerlink" title="@url(protocol?, host?)"></a>@url(protocol?, host?)</h4><p>随机生成一个 URL。</p><ul><li>protocol：指定 URL 协议。例如 http。</li><li>host：指定URL域名和端口号。</li></ul><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@url(&apos;https&apos;, &apos;123.sogou.com&apos;)</span><br><span class="line">//--&gt; https://123.sogou.com/ccdkttr</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h4 id="ip"><a href="#ip" class="headerlink" title="@ip"></a>@ip</h4><p>随机生成一个IP地址。</p><h4 id="timestamp"><a href="#timestamp" class="headerlink" title="@timestamp"></a>@timestamp</h4><p>返回当前unix时间戳</p><h4 id="datetime-format"><a href="#datetime-format" class="headerlink" title="@datetime(format?)"></a>@datetime(format?)</h4><p>返回一个随机的日期和时间字符串。</p><ul><li>format:生成的日期和时间字符串的格式。默认值为yyyy-MM-dd HH:mm:ss。</li></ul><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@datetime()</span><br><span class="line">//--&gt; 1977-11-17 03:50:15</span><br><span class="line">@datetime(&apos;y-M-d H:m:s&apos;)</span><br><span class="line">//--&gt; 02-4-23 2:49:40</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><h4 id="pick-arr"><a href="#pick-arr" class="headerlink" title="@pick(arr)"></a>@pick(arr)</h4><p>从数组中随机选取一个元素，并返回。</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@pick([&apos;this&apos;, &apos;is&apos;, &apos;picker&apos;, &apos;test&apos;])</span><br><span class="line">//--&gt; picker</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yapi的使用之入门篇</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%85%A5%E9%97%A8%E7%AF%87/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%85%A5%E9%97%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="yapi的使用之入门篇"><a href="#yapi的使用之入门篇" class="headerlink" title="yapi的使用之入门篇"></a>yapi的使用之入门篇</h1><h2 id="一、模拟接口"><a href="#一、模拟接口" class="headerlink" title="一、模拟接口"></a>一、模拟接口</h2><p>如果你已在<a href="http://121.41.91.92:3000/" target="_blank" rel="noopener">http://121.41.91.92:3000/</a>上创建了对应接口，直接在接口path后，添加<code>.toSimulateApi()</code>实现，你重新请求的时候调用的是你模拟的api。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">String</span> getVirtualList = <span class="string">"/account/wallet/virtualAsset/page"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟时候，在字符串尾部加上`.toSimulateApi()`即可</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">String</span> getVirtualList = <span class="string">"/account/wallet/virtualAsset/page"</span>.toSimulateApi();</span><br></pre></td></tr></table></figure><p>如果你未创建过接口，请查看如下接口的创建方法</p><h2 id="二、新建接口"><a href="#二、新建接口" class="headerlink" title="二、新建接口"></a>二、新建接口</h2><ul><li>点击左侧接口分组右侧的菜单按钮，选择 <code>添加接口</code>，或者点击接口列表右上角的 <code>添加接口</code>。</li></ul><p><img src="https://hellosean1025.github.io/yapi/documents/images/usage/api_add_btn.png" alt="img"></p><ul><li>选择接口分类，输入接口名称和接口路径，点击 <code>提交</code>。</li></ul><p><img src="https://hellosean1025.github.io/yapi/documents/images/usage/api_add_panel.png" alt="img"></p><ul><li>恭喜你！创建了第一个YApi的接口，你可以看到在左侧看到接口名称，右侧有该接口的信息预览。</li></ul><h2 id="三、注册"><a href="#三、注册" class="headerlink" title="三、注册"></a>三、注册</h2><p>登录<a href="http://121.41.91.92:3000/" target="_blank" rel="noopener">http://121.41.91.92:3000/</a>进行注册，注册成功，管理员添加项目权限后，即可查看对应接口列表。如：</p><p><img src="/实用工具/yapi/yapi的使用之入门篇/yapi的使用之入门/image-20211222151919051.png" alt="image-20211222151919051"></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yapi的使用之Mock篇</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8BMock%E7%AF%872-%E7%B1%BB%E5%9E%8B%E4%BF%AE%E6%94%B9/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8BMock%E7%AF%872-%E7%B1%BB%E5%9E%8B%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="yapi的使用之Mock篇2-类型修改"><a href="#yapi的使用之Mock篇2-类型修改" class="headerlink" title="yapi的使用之Mock篇2-类型修改"></a>yapi的使用之Mock篇2-类型修改</h1><h2 id="一、时间"><a href="#一、时间" class="headerlink" title="一、时间"></a>一、时间</h2><table><thead><tr><th>编号</th><th>接口</th><th>变量</th><th>变量含义</th><th>原来为</th><th>修改为</th><th>备注</th><th></th></tr></thead><tbody><tr><td>1</td><td>order/orderList<br>订单列表</td><td>orderTime</td><td>下单时间</td><td>string</td><td>integer @timestamp</td><td></td><td></td></tr><tr><td>2</td><td>order/orderDetail<br>订单详情</td><td>deliveryTime<br>gmtCreate 2处<br>sendTime<br>orderTime<br>overTime<br>payTime<br></td><td>送达时间<br>创建时间<br>送出时间<br>下单时间<br>超时时间<br>付款时间<br></td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>product/getGoodsDetailInfo<br>获取商品详情(包含爆品、精品)</td><td>homeRecoTime</td><td>首页推荐时间</td><td>string</td><td>integer @timestamp</td><td></td><td></td></tr><tr><td>4</td><td>member/getMemberInfo<br>获取会员信息</td><td>startTime<br>endTime</td><td>会员有效期 - 开始时间<br>会员有效期 - 开始时间</td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>wish/listByBuyId<br>用户心愿单列表查询</td><td>gmtCreate</td><td>创建时间</td><td></td><td></td><td></td><td></td></tr><tr><td>6</td><td>wish/listWatchWish<br>查询好友的心愿单列表</td><td>gmtCreate</td><td>创建时间</td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td>wish/getDetail<br>心愿单详情页</td><td>gmtCreate 2处<br>gmtModify 2处<br>statusUpdateTime<br>topTime 2处</td><td>创建时间<br>记录更新时间<br>状态更新时间<br>置顶时间</td><td></td><td></td><td></td><td></td></tr><tr><td>8</td><td>/user/queryUserWishCollect<br>查询愿望单收藏</td><td>gmtCreate</td><td>创建时间</td><td></td><td></td><td></td><td></td></tr><tr><td>9</td><td>product/getGoodsInfoList<br>获取商品列表(包含推荐，收藏，愿望，搜索推荐，分类)</td><td>categoryRecoTime<br>homeRecoTime</td><td>分类推荐时间<br>首页推荐时间</td><td></td><td></td><td></td></tr></tbody></table><h2 id="二、数字字符串"><a href="#二、数字字符串" class="headerlink" title="二、数字字符串"></a>二、数字字符串</h2><table><thead><tr><th>编号</th><th>接口</th><th>变量</th><th>变量含义</th><th>原来为</th><th>修改为</th><th>备注</th><th></th></tr></thead><tbody><tr><td>1</td><td>wish/getDetail<br>心愿单详情页</td><td>progress.rate</td><td>愿望达成率</td><td>string</td><td>string 40只能数字字符串</td><td></td><td></td></tr><tr><td>2</td><td>wish/listByBuyId<br>用户心愿单列表查询</td><td>progress.rate</td><td>愿望达成率</td><td>string</td><td>string 40只能数字字符串</td><td></td><td></td></tr><tr><td>3</td><td>wish/listWatchWish<br>查询好友的心愿单列表</td><td>progress.rate</td><td>愿望达成率</td><td>string</td><td>string 40只能数字字符串</td><td></td><td></td></tr><tr><td>4</td><td>/wish/listRecommendWish<br>查询推荐的心愿单列表</td><td>wishProgress.rate</td><td>愿望达成率</td><td>string</td><td>string 40只能数字字符串</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>若非数字字符串，则会报以下错误：</p><p><img src="/实用工具/yapi/yapi的使用之Mock篇2-类型修改/yapi_mockjson_error1.png" alt="yapi_mockjson_error1"></p><h2 id="三、Raw"><a href="#三、Raw" class="headerlink" title="三、Raw"></a>三、Raw</h2><p>用户心愿单列表查询</p><table><thead><tr><th>编号</th><th>接口</th><th>Raw旧值</th><th>Raw新值</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>1</td><td>user/saveUserLookTrack<br>保存用户足迹接口</td><td>OK</td><td>{“type”:”object”,”title”:”empty object”,”properties”:{}}</td><td></td><td></td><td></td></tr><tr><td>2</td><td>social/operateFriend<br>关注/取消关注好友操作接口</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="四、Type-Mock"><a href="#四、Type-Mock" class="headerlink" title="四、Type Mock"></a>四、Type Mock</h2><p>用户心愿单列表查询</p><table><thead><tr><th>编号</th><th>接口</th><th>变量</th><th>变量含义</th><th>Mock值</th><th>备注</th><th></th></tr></thead><tbody><tr><td>1</td><td>order/orderList<br>订单列表</td><td>orderInfoAndPayInfoDetailResps.orderInfoDetails.status</td><td>订单状态</td><td>@cjtsOrderType</td><td></td><td></td></tr><tr><td>2</td><td>order/orderDetail<br>订单详情</td><td>orderInfoDetails.status</td><td>订单状态</td><td>@cjtsOrderType</td><td></td><td></td></tr><tr><td>3</td><td>/social/pageWatched<br>分页查询已关注列表</td><td>watchStatus</td><td>关注方向</td><td>@cjtsFriendshipeType</td><td></td><td></td></tr><tr><td>4</td><td>product/getGoodsInfoList<br>获取商品列表(包含推荐，收藏，愿望，搜索推荐，分类)</td><td>businessType</td><td>商品类型</td><td>@goodBusinessType</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yapi的使用之Mock篇</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8BMock%E7%AF%87/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8BMock%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="yapi的使用之Mock篇"><a href="#yapi的使用之Mock篇" class="headerlink" title="yapi的使用之Mock篇"></a>yapi的使用之Mock篇</h1><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/qmhball/article/details/86719671" target="_blank" rel="noopener">yapi中使用json-schema mock数据</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mock基础知识请查看<a href="./Mock基础知识.md">本网站中的Mock知识篇</a></p><p>更多mock语法：请查看<a href="http://mockjs.com/examples.html#Text" target="_blank" rel="noopener">官网mock.js中的示例</a></p><h2 id="一、Mock数据个数"><a href="#一、Mock数据个数" class="headerlink" title="一、Mock数据个数"></a>一、Mock数据个数</h2><p>指定数组返回的最小和最大个数：</p><p><img src="/实用工具/yapi/yapi的使用之Mock篇/yapi_mock_arraycount1.png" alt="yapi_mock_arraycount1" style="zoom: 33%;"></p><p><img src="/实用工具/yapi/yapi的使用之Mock篇/yapi_mock_arraycount2.png" alt="yapi_mock_arraycount2" style="zoom:33%;"></p><h2 id="二、Mock值"><a href="#二、Mock值" class="headerlink" title="二、Mock值"></a>二、Mock值</h2><h3 id="1、名字"><a href="#1、名字" class="headerlink" title="1、名字"></a>1、名字</h3><p>定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中文名</span></span><br><span class="line">Random.extend(&#123;</span><br><span class="line">    cjtsName: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Random.cname();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">或者直接 @cname</span><br></pre></td></tr></table></figure><h3 id="2、Type-Mock"><a href="#2、Type-Mock" class="headerlink" title="2、Type Mock"></a>2、Type Mock</h3><p>定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重要日子的信息内容</span></span><br><span class="line"><span class="keyword">var</span> allFestival =</span><br><span class="line">        <span class="string">'1.1元旦、1.23春节、2.14情人节、3.8 妇女节、5.1 劳动节、5.4青年节、6.1儿童节、7.1建党节、8.1建军节、9.10教师节、10.1国庆节、12.25圣诞节'</span>;</span><br><span class="line"><span class="keyword">var</span> festivals = allFestival.split(<span class="string">'、'</span>);</span><br><span class="line"></span><br><span class="line">Random.extend(&#123;</span><br><span class="line">  <span class="comment">// 重要日子的信息内容</span></span><br><span class="line">    cjtsFestivaDateMessage: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pick(festivals)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> allImportantDay =</span><br><span class="line">        <span class="string">'1.1元旦、7天后生日、1.23春节、2.14情人节、3.8 妇女节、5.1 劳动节、5.4青年节、6.1儿童节、7.1建党节、8.1建军节、9.10教师节、10.1国庆节、12.25圣诞节'</span>;</span><br></pre></td></tr></table></figure><p>常规：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性别类型</span></span><br><span class="line"><span class="keyword">var</span> sexTypes = [</span><br><span class="line">    <span class="number">0</span>, <span class="comment">// 未知/未设置</span></span><br><span class="line">    <span class="number">1</span>, <span class="comment">// 男</span></span><br><span class="line">    <span class="number">2</span>, <span class="comment">// 女</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单状态</span></span><br><span class="line"><span class="keyword">var</span> orderTypes = [</span><br><span class="line">    <span class="number">10</span>, <span class="comment">// 待付款(取消订单+付款)</span></span><br><span class="line">    <span class="number">11</span>, <span class="comment">// 待送达(取消订单)</span></span><br><span class="line">    <span class="number">12</span>, <span class="comment">// 待送出(取消订单+催一下)</span></span><br><span class="line">    <span class="number">13</span>, <span class="comment">// 好礼在途(好礼进度)</span></span><br><span class="line">    <span class="number">14</span>, <span class="comment">// 好礼在途(好礼进度)</span></span><br><span class="line">  <span class="number">15</span>, <span class="comment">// 好礼送达(申请售后+晒单)</span></span><br><span class="line">  <span class="number">16</span>, <span class="comment">// 交易关闭(删除订单)</span></span><br><span class="line">    <span class="number">17</span>, <span class="comment">// 好礼送达(申请售后+晒单)</span></span><br><span class="line">  <span class="number">18</span>, <span class="comment">// 交易关闭(删除订单)</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关注方向</span></span><br><span class="line"><span class="keyword">var</span> friendshipeTypes = [</span><br><span class="line">    <span class="number">0</span>, <span class="comment">// 未关注</span></span><br><span class="line">    <span class="number">1</span>, <span class="comment">// 已关注</span></span><br><span class="line">    <span class="number">2</span>, <span class="comment">// 互相关注</span></span><br><span class="line">    <span class="number">3</span>, <span class="comment">// 悄悄关注</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">// 重要日子类型</span></span><br><span class="line"><span class="keyword">var</span> importantDateTypes = [</span><br><span class="line">  <span class="string">'marry'</span>, <span class="comment">// 结婚</span></span><br><span class="line">  <span class="string">'birthday'</span>, <span class="comment">//生日</span></span><br><span class="line">  <span class="string">'festival'</span>, <span class="comment">//节日</span></span><br><span class="line">  <span class="string">'anniversaryDay'</span>, <span class="comment">//纪念日</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 商品类型</span></span><br><span class="line"><span class="keyword">var</span> goodBusinessTypes = [</span><br><span class="line">    <span class="string">'goods'</span>, <span class="comment">// 正常的商品</span></span><br><span class="line">    <span class="string">'wish'</span>, <span class="comment">// 许愿商品</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Random.extend(&#123;</span><br><span class="line">  <span class="comment">// 性别类型</span></span><br><span class="line">    cjtsSexType: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pick(sexTypes)</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 订单状态</span></span><br><span class="line">    cjtsOrderType: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pick(orderTypes)</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="comment">// 商品类型</span></span><br><span class="line">    goodBusinessType: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pick(goodBusinessTypes)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 好友关系</span></span><br><span class="line">  cjtsFriendshipeType: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pick(friendshipeTypes)</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="comment">// 重要日子类型关系</span></span><br><span class="line">  cjtsImportantDateType: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pick(importantDateTypes)</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 价格(string或float):60.111/88.12345</span></span><br><span class="line">    cjtsIPrice: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Random.float( min, max, dmin, dmax )</span></span><br><span class="line">        <span class="keyword">return</span> Random.float(<span class="number">60</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 数量(string或float):0-100000</span></span><br><span class="line">    cjtsICount: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Random.integer( min, max )</span></span><br><span class="line">        <span class="keyword">return</span> Random.integer(<span class="number">0</span>, <span class="number">100000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3、图片Mock"><a href="#3、图片Mock" class="headerlink" title="3、图片Mock"></a>3、图片Mock</h3><p>定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imageUrls = [</span><br><span class="line">    <span class="string">"https://cdn3-banquan.ituchong.com/weili/l/903088213443084399.jpeg"</span>,</span><br><span class="line">    <span class="string">"https://cdn3-banquan.ituchong.com/weili/l/902924454934609986.jpeg"</span>,</span><br><span class="line">  <span class="string">"https://cdn9-banquan.ituchong.com/weili/l/914495302984269898.jpeg"</span>,</span><br><span class="line">  <span class="string">"https://cdn6-banquan.ituchong.com/weili/l/1113166746308968471.jpeg"</span>,</span><br><span class="line">  <span class="string">"https://cdn9-banquan.ituchong.com/weili/l/1113170740519632955.jpeg"</span>,</span><br><span class="line">  <span class="string">"https://cdn3-banquan.ituchong.com/weili/l/1068890057315319833.jpeg"</span>,</span><br><span class="line">  <span class="string">"https://cdn9-banquan.ituchong.com/weili/l/1016768155267367042.jpeg"</span>,</span><br><span class="line">  <span class="string">"https://cdn9-banquan.ituchong.com/weili/l/1026741765014028478.jpeg"</span>,</span><br><span class="line">  <span class="string">"https://cdn9-banquan.ituchong.com/weili/l/967833239214751792.jpeg"</span>,</span><br><span class="line">  <span class="string">"https://cdn6-banquan.ituchong.com/weili/l/966827220441759777.jpeg"</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="string">"https://cdn6-banquan.ituchong.com/weili/l/919795258271596547.jpeg"</span>,</span><br><span class="line">  <span class="string">"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=355970603,3245667099&amp;fm=26&amp;gp=0.jpg"</span>,</span><br><span class="line">  <span class="string">"https://cdn3-banquan.ituchong.com/weili/l/1073188615191658529.jpeg"</span>,</span><br><span class="line">  <span class="string">"https://cdn6-banquan.ituchong.com/weili/l/57461353849430061.jpeg"</span>,</span><br><span class="line">  <span class="string">"https://cdn6-banquan.ituchong.com/weili/l/1017308169985458197.jpeg"</span>,</span><br><span class="line">  <span class="string">"https://img1.droitstock.com/middleW/0a/3c/373880000.jpg"</span>,</span><br><span class="line">  <span class="string">"https://img1.droitstock.com/middleW/76/d4/324995286.jpg"</span>,</span><br><span class="line">  <span class="string">"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1892357736,3979425284&amp;fm=26&amp;gp=0.jpg"</span>,</span><br><span class="line">  <span class="string">"https://img1.droitstock.com/middleW/bd/f0/241894345.jpg"</span>,</span><br><span class="line">  <span class="string">"https://img1.droitstock.com/middleW/41/4f/134317211.jpg"</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="string">"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3155622504,3922873140&amp;fm=26&amp;gp=0.jpg"</span>,</span><br><span class="line">  <span class="string">"https://img1.droitstock.com/middleW/5b/9c/824812856.jpg"</span>,</span><br><span class="line">  <span class="string">"https://img1.droitstock.com/middleW/5a/8d/381503287.jpg"</span>,</span><br><span class="line">  <span class="string">"https://img1.droitstock.com/middleW/b6/22/164126642.jpg"</span>,</span><br><span class="line">  <span class="string">"https://img1.droitstock.com/middleW/df/26/271782228.jpg"</span>,</span><br><span class="line">  <span class="string">"https://alifei04.cfp.cn/creative/vcg/veer/800water/veer-163722653.jpg"</span>,</span><br><span class="line">  <span class="string">"https://alifei01.cfp.cn/creative/vcg/veer/800water/veer-132426620.jpg"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Random.extend(&#123;</span><br><span class="line">    cjtsImageUrl: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// return "http://1.jpg"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pick(imageUrls)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>特别注意，不能有下划线等特殊符号，如定义为cjts_imageUrl，使用@cjts_imageUrl，则不能够正确使用到。应该为定义为cjtsImageUrl，使用@cjtsImageUrl。</strong></p><p><img src="/实用工具/yapi/yapi的使用之Mock篇/yapi_mock_imageUrl.png" alt="image-20201121190315325"></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yapi的使用之设置篇</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E8%AE%BE%E7%BD%AE%E7%AF%87/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E8%AE%BE%E7%BD%AE%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="yapi的使用之设置篇"><a href="#yapi的使用之设置篇" class="headerlink" title="yapi的使用之设置篇"></a>yapi的使用之设置篇</h1><h2 id="一、禁止注册"><a href="#一、禁止注册" class="headerlink" title="一、禁止注册"></a>一、禁止注册</h2><p><img src="/实用工具/yapi/yapi的使用之设置篇/yapi_prohibit_regist.png" alt="image-20201121024134502"></p><h2 id="二、swagger的接口同步"><a href="#二、swagger的接口同步" class="headerlink" title="二、swagger的接口同步"></a>二、swagger的接口同步</h2><p>使用方法如下：</p><p><img src="/实用工具/yapi/yapi的使用之设置篇/yapi_swagger_1.png" alt="image-20220111173613924" style="zoom:33%;"></p><p>在url处，填入从 swagger 中渠道的地址(<strong>建议http支持的情况下，填http，而不是https</strong>)</p><p><img src="/实用工具/yapi/yapi的使用之设置篇/yapi_swagger_2.png" alt="image-20220111173348600" style="zoom: 33%;"></p><p>然后点击上传即可。</p><p>同步后注意，接口的基本路径是否有发生变更。</p><h3 id="1、同步过程中的问题"><a href="#1、同步过程中的问题" class="headerlink" title="1、同步过程中的问题"></a>1、同步过程中的问题</h3><h4 id="1-1、上传失败，出现error-getaddrinfo-ENOTFOUND"><a href="#1-1、上传失败，出现error-getaddrinfo-ENOTFOUND" class="headerlink" title="1.1、上传失败，出现error:getaddrinfo ENOTFOUND"></a>1.1、上传失败，出现<code>error:getaddrinfo ENOTFOUND</code></h4><p>如果上传失败，即上传过程中出现<code>error:getaddrinfo ENOTFOUND</code>的错误提示。只需要重启阿里云服务器即解决了。</p><p>附重试执行getaddrinfo也没用，如下：所以，还是重启服务器好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to install packages: cannot download packages/p/perl-Socket-GetAddrInfo</span><br></pre></td></tr></table></figure><p><img src="/实用工具/yapi/yapi的使用之设置篇/yapi_swagger_3.png" alt="image-20220110165950164" style="zoom: 33%;"></p><h4 id="1-2、Error-ERR-TLS-CERT-ALTNAME-INVALID-Hostname-IP-does-not-match-certificate’s-altnames-Host-dev2-api-xxx-com-is-not-in-the-cert’s-altnames-DNS-dev-api-xxx-com"><a href="#1-2、Error-ERR-TLS-CERT-ALTNAME-INVALID-Hostname-IP-does-not-match-certificate’s-altnames-Host-dev2-api-xxx-com-is-not-in-the-cert’s-altnames-DNS-dev-api-xxx-com" class="headerlink" title="1.2、Error [ERR_TLS_CERT_ALTNAME_INVALID]: Hostname/IP does not match certificate’s altnames: Host: dev2.api.xxx.com. is not in the cert’s altnames: DNS:dev.api.xxx.com"></a>1.2、Error [ERR_TLS_CERT_ALTNAME_INVALID]: Hostname/IP does not match certificate’s altnames: Host: dev2.api.xxx.com. is not in the cert’s altnames: DNS:dev.api.xxx.com</h4><p><img src="/实用工具/yapi/yapi的使用之设置篇/yapi_swagger_certificate.png" alt="image-20220125101801211"></p><p>解决方法：将原本的swagger地址，从https改为http</p><blockquote><p>这个问题是因为请求的目标地址是非信任的地址（比如不是 HTTPS）导致的，可以通过在环境变量里加入下面的变量解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; process.env.NODE_TLS_REJECT_UNAUTHORIZED = &apos;0&apos;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><a href="https://www.cnblogs.com/yinyuxing/p/15602725.html" target="_blank" rel="noopener">解决 Webpack devServer 请求时发生 Hostname/IP does not match certificate’s altnames 错误</a></p></blockquote><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDWebImage③解码</title>
      <link href="/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A2%E8%A7%A3%E7%A0%81/"/>
      <url>/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A2%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="SDWebImage③解码"><a href="#SDWebImage③解码" class="headerlink" title="SDWebImage③解码"></a>SDWebImage③解码</h1><h2 id="一、为什么图像在显示到屏幕上之前要进行解码"><a href="#一、为什么图像在显示到屏幕上之前要进行解码" class="headerlink" title="一、为什么图像在显示到屏幕上之前要进行解码"></a>一、为什么图像在显示到屏幕上之前要进行解码</h2><p>我们知道，一般我们都是使用形如以下方式加载图片:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageNamed:(<span class="built_in">NSString</span> *)name;      <span class="comment">// load from main bundle // 通过图片的文件名从bundle 获取这个图片，注意该图片已经导入到工程中</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageWithContentsOfFile:(<span class="built_in">NSString</span> *)path; <span class="comment">// 通过文件加载指定路径下的文件内容创建图片</span></span><br></pre></td></tr></table></figure><h3 id="问1：不自己解码，直接使用上面的方式进行图片的加载显示可以吗？"><a href="#问1：不自己解码，直接使用上面的方式进行图片的加载显示可以吗？" class="headerlink" title="问1：不自己解码，直接使用上面的方式进行图片的加载显示可以吗？"></a>问1：不自己解码，直接使用上面的方式进行图片的加载显示可以吗？</h3><p>答案是：可以，而且大概我们编码都是使用上面的两种方式直接在主线程加载图片，然后显示在UIImageView上，并且并没有发现什么问题。所以其实我们自己不解码图片我们也是可以直接使用的，但那是因为系统会为我们进行解码的操作。所以，解码图片的工作比不可少。</p><h3 id="问2：系统是在什么时候为我们进行图片的解码操作的？图片加载的工作流？"><a href="#问2：系统是在什么时候为我们进行图片的解码操作的？图片加载的工作流？" class="headerlink" title="问2：系统是在什么时候为我们进行图片的解码操作的？图片加载的工作流？"></a>问2：系统是在什么时候为我们进行图片的解码操作的？图片加载的工作流？</h3><p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。</p><p>概括来说，从磁盘中加载一张图片，并将它显示到屏幕上，中间的<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fpath%2FFastImageCache%23the-problem" target="_blank" rel="noopener">主要工作流/图片加载的工作流</a>如下：</p><ol><li>假设我们使用 +imageWithContentsOfFile: 方法从磁盘中加载一张图片，这个时候的图片并没有解压缩；</li><li>然后将生成的 UIImage 赋值给 UIImageView ；</li><li>接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化；</li><li>在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction ，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤：</li><li><ol><li>分配内存缓冲区用于管理文件 IO 和解压缩操作；</li><li>将文件数据从磁盘读到内存中；</li><li>将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作；</li><li>最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层。</li></ol></li></ol><h3 id="问3：那解码是个啥，为啥即使是系统也要自己解码图片？"><a href="#问3：那解码是个啥，为啥即使是系统也要自己解码图片？" class="headerlink" title="问3：那解码是个啥，为啥即使是系统也要自己解码图片？"></a>问3：那解码是个啥，为啥即使是系统也要自己解码图片？</h3><p>答：那是因为一般下载的图片或者我们手动拖进主bundle 的图片都是PNG 或者JPG 其他格式的图片，这些图片都是经过编码压缩后的图片数据，并不是控件可以直接显示的位图。所以需要先将它解码转成位图数据，然后才能把位图渲染到屏幕上。这就是解码！（附：图像可以分为矢量图和位图，我们通常使用的图像为位图格式）</p><p><a href="https://honglu.me/2016/09/02/一张图片引发的深思/" target="_blank" rel="noopener">一张图片引发的深思</a></p><h3 id="问4：使用系统解码有什么问题？或者说SDWebImage还要对图片进行解码是为了什么？"><a href="#问4：使用系统解码有什么问题？或者说SDWebImage还要对图片进行解码是为了什么？" class="headerlink" title="问4：使用系统解码有什么问题？或者说SDWebImage还要对图片进行解码是为了什么？"></a>问4：使用系统解码有什么问题？或者说SDWebImage还要对图片进行解码是为了什么？</h3><h4 id="①、使用系统解码有什么问题？"><a href="#①、使用系统解码有什么问题？" class="headerlink" title="①、使用系统解码有什么问题？"></a>①、使用系统解码有什么问题？</h4><p>答：如果我们直接使用 <code>+ (nullable UIImage *)imageNamed:(NSString *)name</code> 来加载图片，系统默认会在主线程立即进行图片的解码工作，这个过程就是把图片数据解码成可供控件直接显示的位图数据。<strong>由于这个解码/解压缩操作是一个比较耗时的CPU操作，并且默认是在主线程进行的。所以当在主线程调用了大量的 <code>+ (nullable UIImage *)imageNamed:(NSString *)name</code> 方法后就会产生卡顿，尤其是在快速滑动的列表上，这个问题会表现得更加突出。</strong></p><h4 id="②、SDWebImage还要对图片进行解码的目的是"><a href="#②、SDWebImage还要对图片进行解码的目的是" class="headerlink" title="②、SDWebImage还要对图片进行解码的目的是"></a>②、SDWebImage还要对图片进行解码的目的是</h4><p>优化1：默认是在主线程解码，SDWebImage将解码这个过程放到子线程。</p><p>图片解码是耗时的，而且iOS系统默认是在主线程执行解码，所以业界通常有一种做法是，异步强制解压，也就是在异步线程主动将二进制图片数据解压成位图数据，使用CGBitmapContextCreate(…)系列方法就能实现。<br>该处理方式在众多图片处理框架下都有体现。</p><p>所以<strong>SDWebImage 为了提高图片的加载效率，会提前去进行解码图片到内存，即把图片数据解码成可供控件直接显示的位图数据。同时由于位图体积较大，所以在磁盘缓存中不会直接缓存位图数据，而是编码压缩过的PNG 或者JPG 数据。</strong></p><p>在我们使用 UIImage 的时候，创建的图片通常不会直接加载到内存，而是在渲染的时候再进行解压并加载到内存。这就会导致 UIImage 在渲染的时候效率上不是那么高效。为了提高效率通过 <code>decodedImageWithImage</code>方法把图片提前解压加载到内存，这样这张新图片就不再需要重复解压了，提高了渲染效率。这是一种空间换时间的做法。</p><h3 id="问5：SDWebImage解压的策略是怎样的？"><a href="#问5：SDWebImage解压的策略是怎样的？" class="headerlink" title="问5：SDWebImage解压的策略是怎样的？"></a>问5：SDWebImage解压的策略是怎样的？</h3><p>SDWebImage中使用以下策略：</p><ol><li>当图片从网络中获取到的时候就进行解压缩。</li><li>当图片从磁盘缓存中获取到的时候立即解压缩。</li></ol><h2 id="二、SDWebImage是怎么进行图片Decoder解码的UIImage-ForceDecode-h"><a href="#二、SDWebImage是怎么进行图片Decoder解码的UIImage-ForceDecode-h" class="headerlink" title="二、SDWebImage是怎么进行图片Decoder解码的UIImage+ForceDecode.h"></a>二、SDWebImage是怎么进行图片Decoder解码的<code>UIImage+ForceDecode.h</code></h2><h3 id="1、UIImage-ForceDecode-h-的-sd-decodedImageWithImage"><a href="#1、UIImage-ForceDecode-h-的-sd-decodedImageWithImage" class="headerlink" title="1、UIImage+ForceDecode.h 的 sd_decodedImageWithImage:"></a>1、UIImage+ForceDecode.h 的 sd_decodedImageWithImage:</h3><p>下面首先看解码的方法，UIImage+ForceDecode.h</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)sd_decodedImageWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)sd_decodedAndScaledDownImageWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image limitBytes:(<span class="built_in">NSUInteger</span>)bytes;</span><br></pre></td></tr></table></figure><p><img src="/iOS/第三方库/图片库SDWebImage/SDWebImage③解码/image-20211201013634575.png" alt="image-20211201013634575" style="zoom:50%;"></p><p>其实现为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)sd_decodedImageWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [SDImageCoderHelper decodedImageWithImage:image];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、-SDImageCoderHelper-decodedImageWithImage-image"><a href="#2、-SDImageCoderHelper-decodedImageWithImage-image" class="headerlink" title="2、[SDImageCoderHelper decodedImageWithImage:image]"></a>2、[SDImageCoderHelper decodedImageWithImage:image]</h3><p>SDImageCoderHelper中的实现代码：</p><p><img src="/iOS/第三方库/图片库SDWebImage/SDWebImage③解码/image-20211201014559478.png" alt="image-20211201014559478"></p><p>这个方法传入一副图片对该图片进行<strong>解码</strong>，解码结果是另一幅图片。</p><h4 id="2-1、-SDImageCoderHelper-shouldDecodeImage-image"><a href="#2-1、-SDImageCoderHelper-shouldDecodeImage-image" class="headerlink" title="2.1、[SDImageCoderHelper shouldDecodeImage:image]"></a>2.1、[SDImageCoderHelper shouldDecodeImage:image]</h4><p><code>[SDImageCoderHelper shouldDecodeImage:image]</code>用来判断要不要解码，并不是所有的image 都要解码。其函数实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - Helper Function</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)shouldDecodeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="comment">// Prevent "CGBitmapContextCreateImage: invalid context 0x0" error</span></span><br><span class="line">    <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Avoid extra decode</span></span><br><span class="line">    <span class="keyword">if</span> (image.sd_isDecoded) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do not decode animated images</span></span><br><span class="line">    <span class="keyword">if</span> (image.sd_isAnimated) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do not decode vector images</span></span><br><span class="line">    <span class="keyword">if</span> (image.sd_isVector) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.如果 image 等于 nil，返回 NO。 // 防止 “CGBitmapContextCreateImage: invalid context 0X0” 的错误</p><p>2.如果已经解码过，返回NO。</p><p>3.如果 image 是动效图片，返回 NO。// 不要解码动画图像</p><p>4.如果sd_isVector，返回NO。</p><h4 id="2-2、-SDImageCoderHelper-CGImageCreateDecoded-cgImage"><a href="#2-2、-SDImageCoderHelper-CGImageCreateDecoded-cgImage" class="headerlink" title="2.2、[SDImageCoderHelper CGImageCreateDecoded:cgImage]"></a>2.2、[SDImageCoderHelper CGImageCreateDecoded:cgImage]</h4><p>其中<code>+ (CGImageRef)CGImageCreateDecoded:(CGImageRef)cgImage</code>的实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">CGImageRef</span>)<span class="built_in">CGImageCreateDecoded</span>:(<span class="built_in">CGImageRef</span>)cgImage &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="built_in">CGImageCreateDecoded</span>:cgImage orientation:kCGImagePropertyOrientationUp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CGImageRef</span>)<span class="built_in">CGImageCreateDecoded</span>:(<span class="built_in">CGImageRef</span>)cgImage orientation:(<span class="built_in">CGImagePropertyOrientation</span>)orientation &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cgImage) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t width = <span class="built_in">CGImageGetWidth</span>(cgImage);</span><br><span class="line">    size_t height = <span class="built_in">CGImageGetHeight</span>(cgImage);</span><br><span class="line">    <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    size_t newWidth;</span><br><span class="line">    size_t newHeight;</span><br><span class="line">    <span class="keyword">switch</span> (orientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> kCGImagePropertyOrientationLeft:</span><br><span class="line">        <span class="keyword">case</span> kCGImagePropertyOrientationLeftMirrored:</span><br><span class="line">        <span class="keyword">case</span> kCGImagePropertyOrientationRight:</span><br><span class="line">        <span class="keyword">case</span> kCGImagePropertyOrientationRightMirrored: &#123;</span><br><span class="line">            <span class="comment">// These orientation should swap width &amp; height</span></span><br><span class="line">            newWidth = height;</span><br><span class="line">            newHeight = width;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            newWidth = width;</span><br><span class="line">            newHeight = height;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> hasAlpha = [<span class="keyword">self</span> <span class="built_in">CGImageContainsAlpha</span>:cgImage];</span><br><span class="line">    <span class="comment">// iOS prefer BGRA8888 (premultiplied) or BGRX8888 bitmapInfo for screen rendering, which is same as `UIGraphicsBeginImageContext()` or `- [CALayer drawInContext:]`</span></span><br><span class="line">    <span class="comment">// Though you can use any supported bitmapInfo (see: https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-BCIBHHBB ) and let Core Graphics reorder it when you call `CGContextDrawImage`</span></span><br><span class="line">    <span class="comment">// But since our build-in coders use this bitmapInfo, this can have a little performance benefit</span></span><br><span class="line">    <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">    bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, newWidth, newHeight, <span class="number">8</span>, <span class="number">0</span>, [<span class="keyword">self</span> colorSpaceGetDeviceRGB], bitmapInfo);</span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Apply transform</span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform = SDCGContextTransformFromOrientation(orientation, <span class="built_in">CGSizeMake</span>(newWidth, newHeight));</span><br><span class="line">    <span class="built_in">CGContextConcatCTM</span>(context, transform);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), cgImage); <span class="comment">// The rect is bounding box of CGImage, don't swap width &amp; height</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> newImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newImageRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3、解码的核心代码"><a href="#2-3、解码的核心代码" class="headerlink" title="2.3、解码的核心代码"></a>2.3、解码的核心代码</h4><p><img src="/iOS/第三方库/图片库SDWebImage/SDWebImage③解码/image-20211201023244869.png" alt="image-20211201023244869"></p><ul><li><p>使用<code>CGBitmapContextCreate()</code>创建图片上下文</p></li><li><p>使用<code>CGContextDrawImage()</code>将图片绘制到上下文中</p></li><li><p>使用<code>CGBitmapContextCreateImage()</code>通过上下文生成图片</p><p>其他参考：<a href="https://www.jianshu.com/p/4dc2154254fc" target="_blank" rel="noopener">SDWebImage 中的图片解码</a></p></li></ul><h3 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h3><h4 id="3-1、两个静态不可变的类型是-size-t-的变量"><a href="#3-1、两个静态不可变的类型是-size-t-的变量" class="headerlink" title="3.1、两个静态不可变的类型是 size_t 的变量"></a>3.1、两个静态不可变的类型是 size_t 的变量</h4><h5 id="①、kBytesPerPixel：每个像素占内存多少字节（Byte），赋值为4，表示每个像素占4个字节。"><a href="#①、kBytesPerPixel：每个像素占内存多少字节（Byte），赋值为4，表示每个像素占4个字节。" class="headerlink" title="①、kBytesPerPixel：每个像素占内存多少字节（Byte），赋值为4，表示每个像素占4个字节。"></a>①、kBytesPerPixel：每个像素占内存多少字节（Byte），赋值为4，表示每个像素占4个字节。</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> size_t kBytesPerPixel = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>（图像在iOS 设备上是以像素为单位显示的）</p><h5 id="②、kBitsPerComponent：每个组件占多少位（Bit），赋值为8"><a href="#②、kBitsPerComponent：每个组件占多少位（Bit），赋值为8" class="headerlink" title="②、kBitsPerComponent：每个组件占多少位（Bit），赋值为8"></a>②、kBitsPerComponent：每个组件占多少位（Bit），赋值为8</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> size_t kBitsPerComponent = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>kBitsPerComponent：每个组件占多少位（Bit），这个不好理解，举个例子，比如RGBA，其中 R （红色）G（绿色）B（蓝色）A（透明度）总共4个组件，每个像素由这4个组件组成，且该变量被赋值为8，所以一个 RGBA 像素就是8 ＊ 4 ＝ 32 Bits。</p><p>知道了 kBitsPerComponent 和每个像素有多少组件组成就能计算 kBytesPerPixel 了。计算公式是: （bitsPerComponent * number of components + 7）/ 8。</p><h4 id="3-2、其他"><a href="#3-2、其他" class="headerlink" title="3.2、其他"></a>3.2、其他</h4><p><a href="https://www.cnblogs.com/chmhml/p/6817383.html" target="_blank" rel="noopener">SDWebImage源码阅读(四)Decoder</a>，有点抽象</p><h2 id="三、其他参考文章"><a href="#三、其他参考文章" class="headerlink" title="三、其他参考文章"></a>三、其他参考文章</h2><p><a href="https://www.cnblogs.com/chmhml/p/6738180.html" target="_blank" rel="noopener">SDWebImage源码阅读前的准备(三)UIImage.h</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter项目环境切换</title>
      <link href="/Flutter/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Flutter%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/"/>
      <url>/Flutter/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Flutter%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>问：我不要<strong>频繁安装+卸载</strong>来安装我想要的包。<strong>我能不能同时装一个测试环境和正式环境</strong>?</p><p>答：不行。安装两个包，严格上来讲，不用想了，不行。具体原因涉及应用id，及app根据该id配置了各种三方key环境(除非你连三方的也都额外提供一套)，太详细的道理我就不讲了。”不行“就对了。<strong>但是，我能让你安装一个包，却使用不同环境的功能</strong>。</p><p>常见的场景为：</p><p>1、测试时候：换环境不用一直下载；</p><p>2、演示时候：某个环境使用不了，不用重新下载；</p><p>3、抓包时候：想切换代理，不用重新打包安装；</p><p>dio添加代理<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   (dio.httpClientAdapter <span class="keyword">as</span> DefaultHttpClientAdapter).onHttpClientCreate =</span><br><span class="line">        (client) &#123;</span><br><span class="line">      <span class="comment">// config the http client</span></span><br><span class="line">      client.findProxy = (uri) &#123;</span><br><span class="line">        CommonUtils.log(<span class="string">'fcs-myproxy-begin:<span class="subst">$&#123;uri <span class="keyword">is</span> Uri&#125;</span> uri:<span class="subst">$&#123;uri.toString()&#125;</span>'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PROXY 192.168.10.47:8888"</span>;<span class="comment">//如果设置代理（localhost,127.0.0.1这样的是不行的。必须是电脑的ip）</span></span><br><span class="line"><span class="comment">//        return 'DIRECT';// 如果不设置代理</span></span><br><span class="line">      &#125;;</span><br><span class="line">      client.badCertificateCallback =</span><br><span class="line">          (X509Certificate cert, <span class="built_in">String</span> host, <span class="built_in">int</span> port) =&gt; <span class="keyword">true</span>;<span class="comment">//忽略证书</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>如图，长按”Hello”所在的文字区域，进入环境切换界面，进行你想要的环境切换即可。<br><img src="/Flutter/项目实践/Flutter项目环境切换/APP环境切换入口.png" alt="APP环境切换入口" style="zoom:50%;"><img src="/Flutter/项目实践/Flutter项目环境切换/App环境切换界面.png" alt="App环境切换界面" style="zoom:50%;"></p><h2 id="其他附赠的额外功能"><a href="#其他附赠的额外功能" class="headerlink" title="其他附赠的额外功能"></a>其他附赠的额外功能</h2><h3 id="网路代理-抓包专用"><a href="#网路代理-抓包专用" class="headerlink" title="网路代理(抓包专用)"></a>网路代理(抓包专用)</h3><p>当你想抓取当前手机上所进行的网络请求的数据的时候，你可以添加将app的代理添加为你想要的PC的ip地址。</p><p>添加完后，即可在你的抓包工具上，看到这个app的每一步请求了。</p><p>举个例子如下，获取验证码(结果是不要太清楚)：</p><p><img src="/Flutter/项目实践/Flutter项目环境切换/Flutter项目环境切换.png" alt="image-20200824144004437"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android开发环境搭建与运行</title>
      <link href="/Android/1%E5%85%A5%E9%97%A8/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/"/>
      <url>/Android/1%E5%85%A5%E9%97%A8/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="基础认识"><a href="#基础认识" class="headerlink" title="基础认识"></a>基础认识</h2><p>连接设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line">adb kill-server</span><br><span class="line">adb start-server</span><br></pre></td></tr></table></figure><h1 id="minSdkVersion-compileSdkVersion-targetSdkVersion的理解"><a href="#minSdkVersion-compileSdkVersion-targetSdkVersion的理解" class="headerlink" title="minSdkVersion, compileSdkVersion, targetSdkVersion的理解"></a>minSdkVersion, compileSdkVersion, targetSdkVersion的理解</h1><ul><li><a href="https://www.jianshu.com/p/e21a604e546a" target="_blank" rel="noopener">minSdkVersion, compileSdkVersion, targetSdkVersion的理解</a></li></ul><h1 id="Android-12-targetSdkVersion为31应用的安装问题"><a href="#Android-12-targetSdkVersion为31应用的安装问题" class="headerlink" title="Android 12 targetSdkVersion为31应用的安装问题"></a>Android 12 targetSdkVersion为31应用的安装问题</h1><p><a href="https://blog.csdn.net/qq_35559358/article/details/115325911" target="_blank" rel="noopener">Android 12 targetSdkVersion为31应用的安装问题</a></p><blockquote><p>一般为 <a href="https://developer.android.google.cn/guide/topics/manifest/activity-element#exported" target="_blank" rel="noopener">android:exported</a> 为声明</p></blockquote><h2 id="一、Android-SDK的检查"><a href="#一、Android-SDK的检查" class="headerlink" title="一、Android SDK的检查"></a>一、Android SDK的检查</h2><p>下载 31版本的SDK</p><p><img src="/Android/1入门/Android开发环境搭建与运行/android_sdk31_1.png" alt="android_sdk31_1" style="zoom:33%;"></p><p><img src="/Android/1入门/Android开发环境搭建与运行/android_sdk31_2.png" alt="android_sdk31_2" style="zoom:33%;"></p><p><img src="/Android/1入门/Android开发环境搭建与运行/android_sdk31_3.png" alt="android_sdk31_3" style="zoom:33%;"></p><p><img src="/Android/1入门/Android开发环境搭建与运行/android_sdk31_4.png" alt="android_sdk31_4" style="zoom:33%;"></p><p>查看 Android SDK 的路径</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220320233100662.png" alt="image-20220320233100662"></p><h1 id="Mac-配置Android环境变量"><a href="#Mac-配置Android环境变量" class="headerlink" title="Mac 配置Android环境变量"></a>Mac 配置Android环境变量</h1><p>环境变量设置方法：<a href="../../电脑使用/环境变量设置">环境变量设置</a></p><p>修改环境变量：</p><p>非M1类型的Mac：终端输入<code>open -n ~/.bash_profile</code></p><p>是M1类型的Mac：终端输入<code>open -n ~/.zshrc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#android sdk</span></span><br><span class="line"><span class="built_in">export</span> ANDROID_HOME=/Users/qian/Library/Android/sdk</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/tools</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/platform-tools</span><br></pre></td></tr></table></figure><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220321011954689.png" alt="image-20220321011954689" style="zoom:25%;"></p><p>编辑完保存并退出</p><p>非M1类型的Mac：输入 <code>source ~/.bash_profile</code> 使环境变量生效。</p><p>是M1类型的Mac：输入 <code>source ~/.zshrc</code> 使环境变量生效。</p><h3 id="1、mac-gradle存放路径"><a href="#1、mac-gradle存放路径" class="headerlink" title="1、mac gradle存放路径"></a>1、mac gradle存放路径</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.gradle/wrapper/dists</span><br><span class="line">open ./</span><br></pre></td></tr></table></figure><p><img src="/Android/1入门/Android开发环境搭建与运行/android gradle 1.png" alt="android gradle 1"></p><p><img src="/Android/1入门/Android开发环境搭建与运行/android gradle 2.png" alt="image-20200825154514730"></p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220401110513513.png" alt="image-20220401110513513"></p><h3 id="Mac-android-studio-一直卡在Gradle-Build-Running的解决办法"><a href="#Mac-android-studio-一直卡在Gradle-Build-Running的解决办法" class="headerlink" title="Mac android studio 一直卡在Gradle:Build Running的解决办法"></a><a href="https://www.cnblogs.com/zhoumiao/p/9885570.html" target="_blank" rel="noopener">Mac android studio 一直卡在Gradle:Build Running的解决办法</a></h3><p>1.找到路径/Users/michael/.gradle/wrapper/dists/gradle-4.1-all/bzyivzo6n839fup2jbap0tjew，在此文件夹下有一个gradle版本文件夹，打开后是一个名字很长的文件夹，<br>例如我的/Users/michael/.gradle/wrapper/dists/gradle-4.1-all/bzyivzo6n839fup2jbap0tjew，然后下载对应版本的gradle，将下载的压缩包直接放进名字很长的文件夹中即可，不需要解压</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220401111143361.png" alt="image-20220401111143361"></p><p>附：Gradle下载地址：<a href="https://services.gradle.org/distributions/" target="_blank" rel="noopener">https://services.gradle.org/distributions/</a></p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220401111917520.png" alt="image-20220401111917520"></p><p>不要使用Safari下载，因为其会自动解压。所以我们使用Chrome下载。</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220401112139784.png" alt="image-20220401112139784"></p><p>打开cmd，输入gradle -v(mac系统下是<code>./gradle -v</code>)，测试下安装成功了没</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220401112616236.png" alt="image-20220401112616236"></p><p>distributionurl gradle本地配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-6.7-all.zip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改为：</span></span><br><span class="line">distributionUrl=file:/Users/qian/.gradle/wrapper/dists/gradle-6.7-all/cuy9mc7upwgwgeb72wkcrupxe/gradle-6.7-all.zip</span><br></pre></td></tr></table></figure><h3 id="安装Flutter插件"><a href="#安装Flutter插件" class="headerlink" title="安装Flutter插件"></a>安装Flutter插件</h3><p>在android studio中，选择“Plugins”-&gt;”Broswer repositories”-&gt;输入搜索flutter,再点击安装即可</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220317184609635.png" alt="image-20220317184609635"></p><p>先用Android Studio，新建一个全新app，然后执行尝试<code>./gradlew assembleRelease</code>效果。</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220320222222228.png" alt="image-20220320222222228"></p><h2 id="执行-gradlew-assembleRelease过程中的问题"><a href="#执行-gradlew-assembleRelease过程中的问题" class="headerlink" title="执行./gradlew assembleRelease过程中的问题"></a>执行<code>./gradlew assembleRelease</code>过程中的问题</h2><h3 id="1、没有gradlew文件"><a href="#1、没有gradlew文件" class="headerlink" title="1、没有gradlew文件"></a>1、没有<code>gradlew</code>文件</h3><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220317194632116.png" alt="image-20220317194632116"></p><p>解决：拷贝文件</p><p>2、没有配置Java环境</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220317194538523.png" alt="image-20220317194538523"></p><p>解决安装Java环境。</p><h2 id="安装Java环境"><a href="#安装Java环境" class="headerlink" title="安装Java环境"></a>安装Java环境</h2><p><strong>1.</strong>检查Java环境</p><p>在安装JDK之前，先查看下自己电脑是否已经安装了JDK。</p><p>打开终端，输入java -version并回车。</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220317194403944.png" alt="image-20220317194403944"></p><p>从上图中可以看没有安装。。</p><p>2、未安装情况下，进入<a href="https://www.oracle.com/java/technologies/downloads/#jdk17-mac" target="_blank" rel="noopener">oracle 官网</a> 下载Java安装</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220317194000775.png" alt="image-20220317194000775"></p><p><strong>3.</strong> JDK安装。MAC系统JDK安装是很简单的，一路下一步就ok了。</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220317195327540.png" alt="image-20220317195327540"></p><p>安装结束后，再执行<code>java -version</code>会看到如下结果：</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220317195420668.png" alt="image-20220317195420668"></p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220317195534731.png" alt="image-20220317195534731"></p><h2 id="二、Android-的打包运行"><a href="#二、Android-的打包运行" class="headerlink" title="二、Android 的打包运行"></a>二、Android 的打包运行</h2><p>工具打包:</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220321164244146.png" alt="image-20220321164244146"></p><p>通过 assembleRelease 打包</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220321165149026.png" alt="image-20220321165149026"></p><p>打包成功后，</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220321164741999.png" alt="image-20220321164741999"></p><h3 id="1、卡在Running-Gradle-task-‘assembleDebug’…"><a href="#1、卡在Running-Gradle-task-‘assembleDebug’…" class="headerlink" title="1、卡在Running Gradle task ‘assembleDebug’…"></a>1、卡在Running Gradle task ‘assembleDebug’…</h3><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220321013241447.png" alt="image-20220321013241447"></p><p>解决方案参考：<a href="https://www.jianshu.com/p/171a9660e1f9" target="_blank" rel="noopener">Running Gradle task ‘assembleDebug’…</a></p><blockquote><p>(1). 修改项目中<code>android/build.gradle</code>文件</p><p>(2). 修改Flutter的配置文件, 该文件在<code>Flutter安装目录/packages/flutter_tools/gradle/flutter.gradle</code></p><p>注意：要加上</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; maven &#123;</span><br><span class="line">&gt;          url <span class="symbol">'http</span>:<span class="comment">//download.flutter.io'</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220427032205807.png" alt="image-20220427032205807"></p><blockquote><p>Installing build/app/outputs/flutter-apk/app.apk…<br>Error: ADB exited with exit code 1<br>Performing Streamed Install</p><p>adb: failed to install /Users/qian/Project/Bojue/app-paipal/follow_shot/build/app/outputs/flutter-apk/app.apk: Failure [INSTALL_PARSE_FAILED_MANIFEST_MALFORMED: Failed parse during installPackageLI: /data/app/vmdl1858238574.tmp/base.apk (at Binary XML file line #29): com.example.untitled.MainActivity: Targeting S+ (version 31 and above) requires that an explicit value for android:exported be defined when intent filters are present]<br>Error: Failed to install APK again.<br>Error launching application on sdk gphone64 arm64.</p></blockquote><h1 id="Android-Studio-Kotlin版本兼容"><a href="#Android-Studio-Kotlin版本兼容" class="headerlink" title="Android Studio Kotlin版本兼容"></a>Android Studio Kotlin版本兼容</h1><p>1.build.<a href="https://so.csdn.net/so/search?q=gradle&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">gradle</a>中的kotlinVersion</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val kotlinVersion = &quot;1.3.**&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>Android Studio中<a href="https://so.csdn.net/so/search?q=kotlin&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">kotlin</a>插件版本</li></ol><p>在File-Settings中搜索kotlin plugin,查看版本</p><p><img src="/Android/1入门/Android开发环境搭建与运行/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220427031441396.png" alt="image-20220427031441396"></p><ul><li><a href="https://www.jianshu.com/p/a8704f402ad2" target="_blank" rel="noopener">Mac下maven的安装与配置</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>状态管理1Provider</title>
      <link href="/Flutter/8%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%861Provider/"/>
      <url>/Flutter/8%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%861Provider/</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter页面跳转和传值传参，接收页面返回数据、以及解决返回（pop）页面时黑屏的问题"><a href="#Flutter页面跳转和传值传参，接收页面返回数据、以及解决返回（pop）页面时黑屏的问题" class="headerlink" title="Flutter页面跳转和传值传参，接收页面返回数据、以及解决返回（pop）页面时黑屏的问题"></a>Flutter页面跳转和传值传参，接收页面返回数据、以及解决返回（pop）页面时黑屏的问题</h1><p><a href="https://blog.csdn.net/yuzhiqiang_1993/article/details/89090742" target="_blank" rel="noopener">Flutter页面跳转和传值传参，接收页面返回数据、以及解决返回（pop）页面时黑屏的问题</a></p><p>flutter的渲染方式和移动端完全不同，它采用的React的思路。</p><p>移动端的UI控件可以通过修改其属性改变外观，但是flutter和RN，改变样式基本是靠重新渲染，所以想要更新内容，就要改变state，然后再通过setState()更新UI。</p><h2 id="ReactNative的Redux"><a href="#ReactNative的Redux" class="headerlink" title="ReactNative的Redux"></a>ReactNative的Redux</h2><p><a href="/Users/lichaoqian/Project/CQComponent/UIKit-Overlay-ReactNative/TSOverlayDemo/src/Redux">CQComponent/UIKit-Overlay-ReactNative/TSOverlayDemo/src/Redux</a></p><h2 id="一、SetState"><a href="#一、SetState" class="headerlink" title="一、SetState"></a>一、SetState</h2><p>我们都知道，Flutter中Widget的状态控制了UI的更新，比如最常见的StatefulWidget，通过调用<code>setState({})</code>方法来刷新控件。那么其他类型的控件，比如StatelessWidget就不能更新状态来吗？答案当然是肯定可以的。前文已经介绍过几种状态管理</p><h2 id="二、flutter全局状态管理器Provider"><a href="#二、flutter全局状态管理器Provider" class="headerlink" title="二、flutter全局状态管理器Provider"></a>二、flutter全局状态管理器Provider</h2><p><a href="https://pub.dev/packages/provider/install" target="_blank" rel="noopener">https://pub.dev/packages/provider/install</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">provider:</span> <span class="string">^4.3.1</span></span><br></pre></td></tr></table></figure><p>为节省代码，我们以<a href="https://www.jianshu.com/p/47e5d6b6655b" target="_blank" rel="noopener">flutter全局状态管理器Provider</a>中的代码为例，进行说明。</p><p>1、声明ChangeNotifier，类似于iOS中的Manager。</p><blockquote><p>ChangeNotifier == Manager</p><p>ChangeNotifier 的 method == Manager 的 method</p><p>ChangeNotifier 的 notifyListeners == Manager 的 broadcast</p><blockquote><p>ChangeNotifier 的 notifyListeners 的内部：Flutter系统提供的通知中心<br>Manager 的 broadcast 的内部：自己实现的多协议通知中心</p></blockquote></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/cupertino.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumModel</span> <span class="title">with</span> <span class="title">ChangeNotifier</span></span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _theNum;</span><br><span class="line">  NumModel(<span class="keyword">this</span>._theNum);</span><br><span class="line">  <span class="comment">/*_theNum递增*/</span></span><br><span class="line">  <span class="keyword">void</span> add() &#123;</span><br><span class="line">    _theNum++;</span><br><span class="line">    notifyListeners();<span class="comment">//通知所有监听的页面，如果写在runapp中那么通知所有页面重新加载</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*_theNum递减*/</span></span><br><span class="line">  <span class="keyword">void</span> reduction()&#123;</span><br><span class="line">    _theNum--;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*获取_theNum*/</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> theNum =&gt; _theNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、搭建监听系统，即搭建可以接收变化的结构</p><p>如果只监听一个model</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  runApp(ChangeNotifierProvider&lt;NumModel&gt;.value(</span><br><span class="line">    value: NumModel(<span class="number">1</span>), </span><br><span class="line">    child: MyApp(),</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果监听多个model</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">      MultiProvider(providers: [</span><br><span class="line">      ChangeNotifierProvider&lt;NumModel&gt;.value(value: NumModel(<span class="number">1</span>)),</span><br><span class="line">      ChangeNotifierProvider&lt;NameModel&gt;.value(value: NameModel(<span class="string">"json"</span>))</span><br><span class="line">  ],</span><br><span class="line">      child: MyApp()</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的项目中很多情况下监听一个model是不够的，所以我们默认使用MultiProvider</p><blockquote><p>个人理解：它类似将所有的监听放在了AppDelegate上。</p></blockquote><p>3、使用Provider，发送变化</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MaterialButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Provider.of&lt;NumModel&gt;(context).add();</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">"num递增"</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>4、使用Provider，接收变化</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">"name="</span> + Provider.of&lt;NameModel&gt;(context).theName,</span><br><span class="line">  style: TextStyle(fontSize: <span class="number">20</span>, color: Colors.red),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="BloC【Business-Logic-Component】"><a href="#BloC【Business-Logic-Component】" class="headerlink" title="BloC【Business Logic Component】"></a>BloC【Business Logic Component】</h2>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第八章：状态管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实践小结</title>
      <link href="/Flutter/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Flutter%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E5%B0%8F%E7%BB%93/"/>
      <url>/Flutter/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Flutter%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><ul><li><a href="https://www.jianshu.com/p/c221161a9bff" target="_blank" rel="noopener">Flutter中JSON数据到模型 复杂数据模型解析 模型嵌套</a></li></ul><ul><li><a href="https://www.cnblogs.com/lxlx1798/p/11280106.html" target="_blank" rel="noopener">Dart之字符串(String)的相关方法总结</a></li></ul><p><a href="http://www.voidcn.com/article/p-aoiprojh-bwb.html" target="_blank" rel="noopener">为什么某些变量在flutter自定义类中被标记为final？</a></p><h1 id="升级-Flutter"><a href="#升级-Flutter" class="headerlink" title="升级 Flutter"></a>升级 Flutter</h1><p>1、命令方式</p><ul><li><a href="https://flutterchina.club/upgrading/" target="_blank" rel="noopener">升级Flutter</a></li></ul><p>2、自己下载替换方式</p><ul><li>去 <a href="https://flutter.dev/docs/development/tools/sdk/releases?tab=macos" target="_blank" rel="noopener">Flutter SDK 官网</a> 下载对应的SDK</li><li>替换掉你本地的</li><li>关掉所有正在编辑Flutter的项目(如果没有关掉所有的，则会遇到如 @require等找不到的问题)</li><li>重新pub get</li></ul><h1 id="Flutter出现List-is-not-a-subtype-of-type-List解决方法"><a href="#Flutter出现List-is-not-a-subtype-of-type-List解决方法" class="headerlink" title="Flutter出现List is not a subtype of type List解决方法"></a>Flutter出现List is not a subtype of type List解决方法</h1><h2 id="控制台错误如下："><a href="#控制台错误如下：" class="headerlink" title="控制台错误如下："></a>控制台错误如下：</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type <span class="string">'List&lt;dynamic&gt;'</span> <span class="keyword">is</span> not a subtype of type <span class="string">'List&lt;String&gt;'</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="出现这个错误的原因是由于解析json的数据类型不一致导致"><a href="#出现这个错误的原因是由于解析json的数据类型不一致导致" class="headerlink" title="出现这个错误的原因是由于解析json的数据类型不一致导致"></a>出现这个错误的原因是由于解析json的数据类型不一致导致</h2><p><strong>后台返回的一个json字段为：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; imagesString = [<span class="string">'https://1.png'</span>, <span class="string">'https://2.png'</span>];</span><br><span class="line">  <span class="built_in">String</span> imageParam = jsonEncode(imagesString);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'imageParam = <span class="subst">$imageParam<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">//List&lt;String&gt; images = jsonDecode(imageParam);// 错误写法,会造成崩溃</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  List&lt;String&gt; images = jsonDecode(imageParam).cast&lt;String&gt;();// 正确写法</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>转换完成'</span>);</span><br></pre></td></tr></table></figure><p>解析json用到的model实体类，由于labelList是一个字符串集合数组，<br>需要在解析labelList字段时加上<code>cast&lt;String&gt;()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; labelList = json[<span class="string">'labelList'</span>].cast&lt;String&gt;();</span><br></pre></td></tr></table></figure><h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><h4 id="问题1：Flutter-gpu-surface-gl"><a href="#问题1：Flutter-gpu-surface-gl" class="headerlink" title="问题1：Flutter gpu_surface_gl"></a>问题1：Flutter gpu_surface_gl</h4><p>原因为：<strong>机型的gpu不匹配</strong></p><p><img src="/Flutter/项目实践/Flutter工程实践小结/Flutter gpu_surface_gl.png" alt="Flutter gpu_surface_gl"></p><p>如果你使用的是命令来运行flutter的话，那么在flutter run加参数就可以。即<code>flutter run --enable-software-rendering</code>。</p><p>但是这个办法有个坑，就是热加载的时候要手动在命令行输入r（不是说好的自动的么，也许是我打开的方式不对）；</p><p>如果不是用命令来运行的话，那解决步骤如下：</p><p><img src="/Flutter/项目实践/Flutter工程实践小结/Flutter gpu_surface_gl问题2.png" alt="Flutter gpu_surface_gl问题"></p><p><img src="/Flutter/项目实践/Flutter工程实践小结/Flutter gpu_surface_gl问题3.png" alt="Flutter gpu_surface_gl问题3"></p><p>–enable-software-rendering</p><h4 id="问题2：resource-android-attr-fontVariationSettings-not-found"><a href="#问题2：resource-android-attr-fontVariationSettings-not-found" class="headerlink" title="问题2：resource android:attr/fontVariationSettings not found"></a>问题2：resource android:attr/fontVariationSettings not found</h4><p>解决方案：</p><p>try to change the compileSdkVersion to:</p><p>compileSdkVersion 28</p><h4 id="bash-dart-command-not-found"><a href="#bash-dart-command-not-found" class="headerlink" title="-bash: dart: command not found"></a>-bash: dart: command not found</h4><p>原因是下载Fluter SDK时，Dart SDK已经在捆绑Fluter里了，所以需要设置下Dart环境变量的路径：</p><p>①打开配置环境变量的文件: <code>.bash_profile</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open ~<span class="regexp">/.bash_profile</span></span><br></pre></td></tr></table></figure><p>②配置Dart SDK所在路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export DART_BIN=/Applications/flutter/bin/cache/dart-sdk/bin</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;DART_BIN&#125;</span><br></pre></td></tr></table></figure><p>③最后在终端里执行: <code>source ~/.bash_profile</code> 重新加载一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>④此时，就可以用dart命令来执行你想要的操作了。比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dart --version</span><br></pre></td></tr></table></figure><h3 id="Failed-assertion-line-1687-pos-12-‘hasSize’"><a href="#Failed-assertion-line-1687-pos-12-‘hasSize’" class="headerlink" title="Failed assertion: line 1687 pos 12: ‘hasSize’"></a>Failed assertion: line 1687 pos 12: ‘hasSize’</h3><p>原因：<strong>Column的子widget中包含ListView</strong></p><p><a href="https://www.cnblogs.com/madlife/p/12465136.html" target="_blank" rel="noopener">Column的子widget中包含ListView</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实践小结</title>
      <link href="/Flutter/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Flutter%E6%8E%A7%E4%BB%B6%E4%B8%8E%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3/"/>
      <url>/Flutter/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Flutter%E6%8E%A7%E4%BB%B6%E4%B8%8E%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="待做"><a href="#待做" class="headerlink" title="待做"></a>待做</h2><ul><li><a href="https://www.cnblogs.com/joe235/p/11224772.html" target="_blank" rel="noopener">Flutter 实现简单搜索功能</a></li></ul><h2 id="Flutter获取版本号"><a href="#Flutter获取版本号" class="headerlink" title="Flutter获取版本号"></a>Flutter获取版本号</h2><p>我们app版本号写在<code>pubspec.yaml</code>里<code>version</code>字段后面。例如<code>version: 1.0.0+3</code> 其中+前面为版本号，后面为构建号。</p><h2 id="一、基本设置"><a href="#一、基本设置" class="headerlink" title="一、基本设置"></a>一、基本设置</h2><h3 id="1、设置背景颜色-背景图"><a href="#1、设置背景颜色-背景图" class="headerlink" title="1、设置背景颜色/背景图"></a>1、设置背景颜色/背景图</h3><h4 id="1-1、设置普通视图的背景色"><a href="#1-1、设置普通视图的背景色" class="headerlink" title="1.1、设置普通视图的背景色"></a>1.1、设置普通视图的背景色</h4><p>采用包一层<code>Container</code>，进行对应的color设置。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Container(</span><br><span class="line">  color: Colors.red,<span class="comment">// 设置视图颜色</span></span><br><span class="line">child: xxx,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="1-2、设置页面的背景色"><a href="#1-2、设置页面的背景色" class="headerlink" title="1.2、设置页面的背景色"></a>1.2、设置页面的背景色</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">      backgroundColor: Colors.yellow,<span class="comment">// 设置页面背景颜色</span></span><br><span class="line">      appBar: _appBar(),</span><br><span class="line">      body: _pageWidget(),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h3 id="2、设置背景图片"><a href="#2、设置背景图片" class="headerlink" title="2、设置背景图片"></a>2、设置背景图片</h3><h4 id="2-1、设置普通视图的背景图"><a href="#2-1、设置普通视图的背景图" class="headerlink" title="2.1、设置普通视图的背景图"></a>2.1、设置普通视图的背景图</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> EmptyView(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      decoration: BoxDecoration(<span class="comment">// 设置视图的背景图/秀视图</span></span><br><span class="line">        image: <span class="keyword">new</span> DecorationImage(</span><br><span class="line">          fit: BoxFit.cover,<span class="comment">// 充满容器，可能会被截断。</span></span><br><span class="line">          image: <span class="keyword">new</span> NetworkImage(</span><br><span class="line">              <span class="string">'https://randomuser.me/api/portraits/men/43.jpg'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      child: Container(</span><br><span class="line">        color: Colors.red.withOpacity(<span class="number">.5</span>),</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">"我在图片的上面哦~"</span>,</span><br><span class="line">            style: TextStyle(color: Colors.white, fontSize: <span class="number">33</span>),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2、设置页面的背景图"><a href="#2-2、设置页面的背景图" class="headerlink" title="2.2、设置页面的背景图"></a>2.2、设置页面的背景图</h4><p>设背景图为如上EmptyView，则设置代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      backgroundColor: Colors.yellow,</span><br><span class="line">      appBar: _appBar(),</span><br><span class="line">      body: _emptyView(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊场景：如果你的页面上有TextField等会弹出键盘的视图。因为默认情况下键盘出现时是否应调整主体Scaffold的大小。所以，为了图片能正确显示，我们使用resizeToAvoidBottomInset指定在键盘出现时是否应调整主体的大小。</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      backgroundColor: Colors.yellow,</span><br><span class="line">      resizeToAvoidBottomInset: <span class="keyword">false</span>,<span class="comment">// 增加此行，指定在键盘出现时不调整主体的大小</span></span><br><span class="line">      appBar: _appBar(),</span><br><span class="line">      body: _emptyView(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="二、布局"><a href="#二、布局" class="headerlink" title="二、布局"></a>二、布局</h2><h3 id="1、充满"><a href="#1、充满" class="headerlink" title="1、充满"></a>1、充满</h3><p><strong>默认情况下，大多数组件都会使用尽可能小的空间</strong>。所以如果不设置视图的大小的话，其会自动计算大小，只显示对应的大小。所以当你的视图不够大，而你却又想让它充满父视图的话。那应该进行一些对应的设置。</p><h4 id="1-1、设置width、height等于父视图大小方式-不建议"><a href="#1-1、设置width、height等于父视图大小方式-不建议" class="headerlink" title="1.1、设置width、height等于父视图大小方式(不建议)"></a>1.1、设置width、height等于父视图大小方式(不建议)</h4><h5 id="①、如果视图有width和height属性，则直接设置。如Container和Image等。如下："><a href="#①、如果视图有width和height属性，则直接设置。如Container和Image等。如下：" class="headerlink" title="①、如果视图有width和height属性，则直接设置。如Container和Image等。如下："></a>①、如果视图有width和height属性，则直接设置。如<code>Container</code>和<code>Image</code>等。如下：</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Image(</span><br><span class="line">  width: MediaQuery.of(context).size.width,</span><br><span class="line">  height: MediaQuery.of(context).size.height,</span><br><span class="line">  image: AssetImage(</span><br><span class="line">  <span class="string">'lib/commonui/cq-guide-overlay/Resources/bg_背景遮罩.png'</span>),</span><br><span class="line">  fit: BoxFit.fill,</span><br><span class="line">),</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Container(</span><br><span class="line">  width: MediaQuery.of(context).size.width,</span><br><span class="line">  height: MediaQuery.of(context).size.height,</span><br><span class="line">  color: Colors.red,</span><br><span class="line">child: xxx,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>缺点：需要计算大小，不建议使用。</p><h5 id="②、如果该视图没有width和height属性，则我们通过为该视图包一层Container后来设置width、height。"><a href="#②、如果该视图没有width和height属性，则我们通过为该视图包一层Container后来设置width、height。" class="headerlink" title="②、如果该视图没有width和height属性，则我们通过为该视图包一层Container后来设置width、height。"></a>②、如果该视图没有width和height属性，则我们通过为该视图包一层<code>Container</code>后来设置width、height。</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Container(</span><br><span class="line">  width: MediaQuery.of(context).size.width,</span><br><span class="line">  height: MediaQuery.of(context).size.height,</span><br><span class="line">  color: Colors.red,</span><br><span class="line">child: xxx,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="1-2、设置constraints方式"><a href="#1-2、设置constraints方式" class="headerlink" title="1.2、设置constraints方式"></a>1.2、设置constraints方式</h4><p>如果你不想/不能通过设置width、height属性的方式设置，则你可以构建一层<code>Container</code>或者<code>ConstrainedBox</code>，然后设置constraints的属性。建议两者的选择，使用<code>ConstrainedBox</code>会使得语意更明白。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Container(</span><br><span class="line">  constraints: BoxConstraints(</span><br><span class="line">    minWidth: <span class="built_in">double</span>.infinity,</span><br><span class="line">    minHeight: <span class="built_in">double</span>.infinity,</span><br><span class="line">  ),</span><br><span class="line">  color: Colors.red,</span><br><span class="line">child: xxx,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ConstrainedBox(</span><br><span class="line">constraints: <span class="keyword">new</span> BoxConstraints.expand(),</span><br><span class="line">  child: xxx,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>默认情况下，大多数组件都会使用尽可能小的空间：</p><p><code>ConstrainedBox</code> 让部件可以使用期望的剩余空间。</p><p><code>BoxConstraints.expand</code> 将会让组件使用无限制（所有可用）的空间，除非另有指定。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BoxConstraints.tightFor(width: <span class="number">80.0</span>,height: <span class="number">80.0</span>),</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">BoxConstraints(minHeight: <span class="number">80.0</span>,maxHeight: <span class="number">80.0</span>,minWidth: <span class="number">80.0</span>,maxWidth: <span class="number">80.0</span>)</span><br></pre></td></tr></table></figure><p>更多</p><h3 id="2、图片的显示方式"><a href="#2、图片的显示方式" class="headerlink" title="2、图片的显示方式"></a>2、图片的显示方式</h3><ul><li><a href="https://www.jianshu.com/p/8810bacfe5d4" target="_blank" rel="noopener">Flutter 图片如何充满父布局</a></li></ul><p>BoxFit.fill：图显示，显示可能拉伸，充满</p><h3 id="3、绝对布局"><a href="#3、绝对布局" class="headerlink" title="3、绝对布局"></a>3、绝对布局</h3><ul><li><a href="https://www.jianshu.com/p/6108433be896" target="_blank" rel="noopener">Flutter Stack 组件</a></li><li><a href="https://www.jianshu.com/p/97183dd3167e" target="_blank" rel="noopener">flutter 层叠布局Stack、Positioned</a></li></ul><h2 id="三、控件"><a href="#三、控件" class="headerlink" title="三、控件"></a>三、控件</h2><p><a href="https://www.jianshu.com/p/3f15e8d398f9" target="_blank" rel="noopener">Flutter 自定义组件之列表头悬浮</a></p><p><a href="https://www.jianshu.com/p/5de174e82175" target="_blank" rel="noopener">Flutter笔记-深入分析滑动控件</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动效果</span></span><br><span class="line"><span class="comment">  * AlwaysScrollableScrollPhysics() 总是可以滑动，默认值</span></span><br><span class="line"><span class="comment">  * NeverScrollableScrollPhysics禁止滚动</span></span><br><span class="line"><span class="comment">  * BouncingScrollPhysics 内容超过一屏 上拉有回弹效果</span></span><br><span class="line"><span class="comment">  * ClampingScrollPhysics 包裹内容 不会有回弹</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">final</span> ScrollPhysics physics;</span><br></pre></td></tr></table></figure><h2 id="三方控件"><a href="#三方控件" class="headerlink" title="三方控件"></a>三方控件</h2><h3 id="Flutter-中使用-video-player-播放视频"><a href="#Flutter-中使用-video-player-播放视频" class="headerlink" title="Flutter 中使用 video_player 播放视频"></a>Flutter 中使用 video_player 播放视频</h3><p><a href="http://www.ptbird.cn/flutter-video.html" target="_blank" rel="noopener">Flutter 中使用 video_player 播放视频</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实践小结</title>
      <link href="/Flutter/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Flutter%E6%95%B0%E6%8D%AE%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
      <url>/Flutter/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Flutter%E6%95%B0%E6%8D%AE%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="一、对比-MVC、MVP、BloC、Redux-四种架构"><a href="#一、对比-MVC、MVP、BloC、Redux-四种架构" class="headerlink" title="一、对比[MVC、MVP、BloC、Redux]四种架构"></a>一、对比[MVC、MVP、BloC、Redux]四种架构</h2><ul><li><p><a href="https://www.jianshu.com/p/ba3414457419" target="_blank" rel="noopener">MVC、MVP、BloC、Redux四种架构在Flutter上的尝试</a></p><blockquote><h3 id="对比-MVC、MVP、BloC、Redux-四种架构的好坏，"><a href="#对比-MVC、MVP、BloC、Redux-四种架构的好坏，" class="headerlink" title="对比[MVC、MVP、BloC、Redux]四种架构的好坏，"></a>对比[MVC、MVP、BloC、Redux]四种架构的好坏，</h3><p>对比[MVC、MVP、BloC、Redux]四种架构的好坏，最终还是的回归到状态管理上来。<code>MVC</code>、<code>MVP</code>的状态管理都是采用<code>setState</code>方式，而<code>BloC</code>和<code>Redux</code>都有自己的一套状态管理。</p><p>当项目最初不是很复杂的时候，采用<code>setState</code>方式更新数据是可以的。但是随着功能的增加，你的项目将会有几十个甚至上百个状态，<code>setState</code>出现的次数便会显著增加，每次<code>setState</code>都会重新调用build方法，这势必对于性能以及代码的可阅读性带来一定的影响。所以就放弃了<code>MVC</code>、<code>MVP</code>这两种架构。</p><p>最初对<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FYuzopro%2FOpenGit_Flutter" target="_blank" rel="noopener">OpenGit_Flutter</a>进行架构重构的时候，用到的是<code>Redux</code>，到涉及到多个页面复用时，例如项目中的<code>项目页</code>，每涉及到一个复用页面就需要在<code>state</code>内定义一些列的变量，这是个很痛苦的过程，所以后面就放弃了用<code>Redux</code>，但是<code>Redux</code>在保存全局状态有优势，例如主题、语言、用户资料等。后面又尝试了<code>BloC</code>，该架构在多页面复用时，就没存在<code>Redux</code>的问题。</p><p><strong>所以最后我采用的架构是<code>Bloc+Redux</code>，用<code>BloC</code>控制局部状态，用<code>Redux</code>控制全局状态。</strong></p></blockquote></li></ul><ul><li><a href="https://www.cnblogs.com/joe235/p/11970343.html" target="_blank" rel="noopener">Flutter Bloc状态管理 简单上手</a></li><li><p><a href="https://cloud.tencent.com/developer/article/1622727" target="_blank" rel="noopener">[- Flutter-技能篇 -] 使用Provider前你应了解Consumer</a></p></li><li><p><a href="https://www.jianshu.com/p/9cd4b9fb7b44" target="_blank" rel="noopener">Flutter状态管理provider的使用和封装</a></p></li><li><a href="https://juejin.im/post/6844903864852807694#heading-43" target="_blank" rel="noopener">Flutter | 状态管理指南篇——Provider（鉴定为精450赞）</a></li></ul><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>Flutter中，dart的单例模式设计</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个单例的Manager类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 工厂模式</span></span><br><span class="line">  <span class="keyword">factory</span> Manager() =&gt;_getInstance();</span><br><span class="line">  <span class="keyword">static</span> Manager <span class="keyword">get</span> instance =&gt; _getInstance();</span><br><span class="line">  <span class="keyword">static</span> Manager _instance;</span><br><span class="line">  Manager._internal() &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Manager _getInstance() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _instance = <span class="keyword">new</span> Manager._internal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// 无论如何初始化，取到的都是同一个对象</span></span><br><span class="line">Manager manager = <span class="keyword">new</span> Manager();</span><br><span class="line">Manager manager2 = Manager.instance;</span><br></pre></td></tr></table></figure><h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><p><a href="https://dart-pub.mirrors.sjtug.sjtu.edu.cn/packages/shared_preferences/install" target="_blank" rel="noopener">shared_preferences 0.5.8</a></p><p><a href="https://www.jianshu.com/p/33578467b1fa" target="_blank" rel="noopener">Flutter sharedPreferences使用</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:shared_preferences/shared_preferences.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// desc：本地储存</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPreferenceUtil</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> UserTokenKey = <span class="string">"userTokenKey"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 异步保存</span></span><br><span class="line">  Future setUserToken(<span class="built_in">String</span> userToken) <span class="keyword">async</span>&#123;</span><br><span class="line">     SharedPreferences prefs = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line">     prefs.setString(UserTokenKey, userToken);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步删除</span></span><br><span class="line">  Future delUserToken() <span class="keyword">async</span>&#123;</span><br><span class="line">    SharedPreferences prefs = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line">    prefs.remove(UserTokenKey);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步读取</span></span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; getUserToken() <span class="keyword">async</span>&#123;</span><br><span class="line">    SharedPreferences prefs = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line">    <span class="built_in">String</span> userToken =  prefs.getString(UserTokenKey);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'------userToken = <span class="subst">$userToken</span>-----'</span>);</span><br><span class="line">    <span class="keyword">return</span> userToken;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// 保存：</span></span><br><span class="line">SharedPreferenceUtil.setUserToken(<span class="string">"usertoken_zhangsan"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取：</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; userTokenFuture = SharedPreferenceUtil.getUserToken();</span><br><span class="line">userTokenFuture.then((<span class="built_in">String</span> userToken) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'------userToken = <span class="subst">$userToken</span>-----'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实践小结</title>
      <link href="/Flutter/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Flutter%E6%95%B0%E6%8D%AE%E4%BC%A0%E5%80%BC/"/>
      <url>/Flutter/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Flutter%E6%95%B0%E6%8D%AE%E4%BC%A0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据传输一般处理方式：自上而下的一层一层传递数据。</span><br><span class="line"></span><br><span class="line">场景： WidgetB数据改变后，WidgetA也随之作出响应。</span><br><span class="line"></span><br><span class="line">解决方案1： 参考Flutter知识点: InheritedWidget</span><br><span class="line"></span><br><span class="line">解决方案2：Notification，子节点状态变更，发送通知上报。</span><br></pre></td></tr></table></figure><h2 id="一、父传给子"><a href="#一、父传给子" class="headerlink" title="一、父传给子"></a>一、父传给子</h2><h3 id="1、直接传"><a href="#1、直接传" class="headerlink" title="1、直接传"></a>1、直接传</h3><p><a href="https://www.jianshu.com/p/08f448b7a8aa" target="_blank" rel="noopener">Flutter中界面之间参数的传递与接收</a></p><h2 id="二、子传给父"><a href="#二、子传给父" class="headerlink" title="二、子传给父"></a>二、子传给父</h2><h3 id="1、Callback-子传给父"><a href="#1、Callback-子传给父" class="headerlink" title="1、Callback(子传给父)"></a>1、Callback(子传给父)</h3><p>大家都知道回调方法在父子Widget之间传值是非常有用的,特别是用于子Widget向父Widget传值,接。</p><p>定义一个回调函数类型</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> clickCallback = <span class="keyword">void</span> <span class="built_in">Function</span>(<span class="built_in">String</span> value);</span><br></pre></td></tr></table></figure><p>将回调函数透出子Widget</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> clickCallback onClick;</span><br><span class="line"></span><br><span class="line">TestWidget(&#123;</span><br><span class="line">   Key key,</span><br><span class="line">   <span class="keyword">this</span>. onClick,</span><br><span class="line"> &#125;):<span class="keyword">super</span>(key:key);</span><br></pre></td></tr></table></figure><h2 id="三、传给其它-给父或给其它"><a href="#三、传给其它-给父或给其它" class="headerlink" title="三、传给其它(给父或给其它)"></a>三、传给其它(给父或给其它)</h2><h3 id="1、Notification-给其它"><a href="#1、Notification-给其它" class="headerlink" title="1、Notification(给其它)"></a>1、Notification(给其它)</h3><p>1.自定义notification</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> count;</span><br><span class="line">  </span><br><span class="line">  TestNotification(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.count,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.子节点发送通知</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">  textColor: Colors.black,</span><br><span class="line">  child: <span class="keyword">new</span> Center(</span><br><span class="line">    child: <span class="keyword">new</span> Text(<span class="string">'点击传递随机数给上层Widget'</span>),</span><br><span class="line">  ),</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    <span class="keyword">new</span> TestNotification(count: <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>)).dispatch(key.currentContext);</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>3.父节点使用NotificationListener进行监听子节点发出的通知，并作出响应</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> NotificationListener(</span><br><span class="line">  onNotification: (TestNotification n) &#123;</span><br><span class="line">    scaffoldStateKey.currentState.showSnackBar(<span class="keyword">new</span> SnackBar(content: <span class="keyword">new</span> Text(<span class="string">'随机数：<span class="subst">$&#123;n.count&#125;</span>'</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  child: <span class="keyword">new</span> TestAPage(</span><br><span class="line">    key: key,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实践小结</title>
      <link href="/Flutter/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Flutter%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E8%B7%AF%E7%94%B1/"/>
      <url>/Flutter/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Flutter%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h2><ul><li><a href="http://findsrc.com/flutter/detail/8697" target="_blank" rel="noopener">flutter切换到后台、前台等事件的监听</a></li></ul><p>该界面前提：</p><p>①、StatefulWidget</p><p>②、WidgetsBindingObserver</p><p>③、@override didChangeAppLifecycleState</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:background_fetch/background_fetch.dart'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Enable integration testing with the Flutter Driver extension.</span></span><br><span class="line">  <span class="comment">// See https://flutter.io/testing/ for more info.</span></span><br><span class="line">  runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyAppState createState() =&gt; <span class="keyword">new</span> _MyAppState();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyApp</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    WidgetsBinding.instance.addObserver(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeAppLifecycleState(state);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"--"</span> + state.toString());</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">      <span class="keyword">case</span> AppLifecycleState.inactive: <span class="comment">// 处于这种状态的应用程序应该假设它们可能在任何时候暂停。</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AppLifecycleState.resumed: <span class="comment">// 应用程序可见，前台</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AppLifecycleState.paused: <span class="comment">// 应用程序不可见，后台</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AppLifecycleState.detached: <span class="comment">// detached</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    WidgetsBinding.instance.removeObserver(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      home: <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">            title: <span class="keyword">const</span> Text(<span class="string">'前后台测试'</span>)</span><br><span class="line">        ),</span><br><span class="line"> </span><br><span class="line">        body: Container(</span><br><span class="line">          color: Colors.black,</span><br><span class="line">          child: Text(<span class="string">'前后台测试'</span>),</span><br><span class="line">        ),</span><br><span class="line"> </span><br><span class="line">      ),</span><br><span class="line"> </span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、什么时候渲染完成？"><a href="#1、什么时候渲染完成？" class="headerlink" title="1、什么时候渲染完成？"></a>1、什么时候渲染完成？</h3><ul><li><a href="https://www.jianshu.com/p/c634cea0f88a" target="_blank" rel="noopener">flutter获取元素大小、位置</a></li><li><a href="https://blog.csdn.net/senkai123/article/details/102934260" target="_blank" rel="noopener">flutter 如何判断页面渲染完毕</a></li></ul><ul><li><a href="https://blog.csdn.net/baidu_34120295/article/details/86495861" target="_blank" rel="noopener">Flutter 获取某个控件的坐标</a></li></ul><p>使用场景：</p><ul><li><a href="https://www.imooc.com/article/304897?block_id=tuijian_wz" target="_blank" rel="noopener"><strong>Flutter 89: 图解基本 Overlay 悬浮新手引导</strong></a></li></ul><h2 id="二、路由"><a href="#二、路由" class="headerlink" title="二、路由"></a>二、路由</h2><ul><li><p><a href="https://www.cnblogs.com/journeyzc/p/12574750.html" target="_blank" rel="noopener">Flutter进阶—路由和导航</a></p></li><li><p><a href="https://www.jianshu.com/p/1faaeaf4f3f7" target="_blank" rel="noopener">Flutter路由管理三方Fluro使用（一）</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>yapi的项目运行</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="yapi的项目运行"><a href="#yapi的项目运行" class="headerlink" title="yapi的项目运行"></a>yapi的项目运行</h1><p>官网地址：<a href="https://github.com/YMFE/yapi" target="_blank" rel="noopener">https://github.com/YMFE/yapi</a></p><h2 id="一、下载已有的yapi的项目"><a href="#一、下载已有的yapi的项目" class="headerlink" title="一、下载已有的yapi的项目"></a>一、下载已有的yapi的项目</h2><p>下载你之前保存的 <a href="https://gitee.com/dvlpApi/CQApp-api" target="_blank" rel="noopener">yapi项目:CQApp-api</a>和<a href="https://gitee.com/dvlpApi/CQApp-api-mongodb" target="_blank" rel="noopener">yapi项目的数据:CQApp-api-mongodb</a>两个git工程到<code>本地</code>或<code>云服务器ECS</code>上，然后运行。</p><p><img src="/实用工具/yapi/yapi的项目运行/image-20211222150604187.png" alt="image-20211222150604187"></p><h2 id="二、运行效果预览"><a href="#二、运行效果预览" class="headerlink" title="二、运行效果预览"></a>二、运行效果预览</h2><p>运行成功的结果：</p><p>要运行项目，最终是要进入项目，执行node vendors/server/app.js 指令启动服务器，然后在浏览器打开 <a href="http://127.0.0.1:3000" target="_blank" rel="noopener">http://127.0.0.1:3000</a> 访问。</p><p><img src="file:///Users/lichaoqian/Project/CQBook/dvlproadHexo/source/_posts/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C/yapi%20start4.png?lastModify=1640156982" alt="yapi start4"></p><h2 id="三、终端运行yapi项目的步骤"><a href="#三、终端运行yapi项目的步骤" class="headerlink" title="三、终端运行yapi项目的步骤"></a>三、终端运行yapi项目的步骤</h2><h3 id="1、-下载并-进入yapi项目，然后启动"><a href="#1、-下载并-进入yapi项目，然后启动" class="headerlink" title="1、(下载并)进入yapi项目，然后启动"></a>1、(下载并)进入<code>yapi项目</code>，然后启动</h3><h4 id="1-1、下载已存在的yapi项目到Project中"><a href="#1-1、下载已存在的yapi项目到Project中" class="headerlink" title="1.1、下载已存在的yapi项目到Project中"></a>1.1、下载已存在的<code>yapi项目</code>到Project中</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Project/</span><br><span class="line">git clone https://gitee.com/dvlpApi/CQApp-api</span><br></pre></td></tr></table></figure><h4 id="1-2、启动yapi项目"><a href="#1-2、启动yapi项目" class="headerlink" title="1.2、启动yapi项目"></a>1.2、启动<code>yapi项目</code></h4><p>即在终端执行的命令如下：</p><p><img src="/实用工具/yapi/yapi的项目运行/image-20210805012844104.png" alt="image-20210805012844104"></p><p>如图，提示<code>mongodb load success...</code>则yapi启动成功。跳过如下MongoNetworkError错误，查看yapi的访问方法。</p><blockquote><p>如果出现如下的MongoNetworkError问题，则原因是你执行node vendors/server/app.js 前，未先成功启动mongodb。从而导致<strong>MongoNetworkError</strong>错误。解决方式，请查看本文最后的<code>1、MongoNetworkError的解决</code><br><img src="/实用工具/yapi/yapi的项目运行/yapi-MongoNetworkError.png" alt="MongoNetworkError"></p></blockquote><h3 id="2、yapi服务开启后，我们根据提示，再在浏览器访问地址，即可看到我们的效果。"><a href="#2、yapi服务开启后，我们根据提示，再在浏览器访问地址，即可看到我们的效果。" class="headerlink" title="2、yapi服务开启后，我们根据提示，再在浏览器访问地址，即可看到我们的效果。"></a>2、yapi服务开启后，我们根据提示，再在浏览器访问地址，即可看到我们的效果。</h3><p><img src="/实用工具/yapi/yapi的项目运行/yapi start5.png" alt="yapi start5" style="zoom:33%;"></p><h3 id="3、登录yapi"><a href="#3、登录yapi" class="headerlink" title="3、登录yapi"></a>3、登录yapi</h3><p>利用上述部署成功后的账号和密码，登录yapi网页。</p><blockquote><p>账号：<a href="mailto:admin@admin.com" target="_blank" rel="noopener">admin@admin.com</a></p><p>密码：ymfe.org # 已修改为姓名全拼</p></blockquote><p>登录后的界面截图如下：</p><p><img src="/实用工具/yapi/yapi的项目运行/image-20201024153331339.png" alt="image-20201024153331339"></p><h2 id="四、如启动yapi项目过程中遇到错误，各解决方式如下"><a href="#四、如启动yapi项目过程中遇到错误，各解决方式如下" class="headerlink" title="四、如启动yapi项目过程中遇到错误，各解决方式如下"></a>四、如启动yapi项目过程中遇到错误，各解决方式如下</h2><h3 id="1、MongoNetworkError的解决"><a href="#1、MongoNetworkError的解决" class="headerlink" title="1、MongoNetworkError的解决"></a>1、MongoNetworkError的解决</h3><h4 id="1-1、下载已存在的yapi项目的数据mongodb到Project中"><a href="#1-1、下载已存在的yapi项目的数据mongodb到Project中" class="headerlink" title="1.1、下载已存在的yapi项目的数据mongodb到Project中"></a>1.1、下载已存在的<code>yapi项目的数据mongodb</code>到Project中</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Project/</span><br><span class="line">git clone https://gitee.com/dvlpApi/CQApp-api-mongodb</span><br></pre></td></tr></table></figure><p>举例：下载mongodb的问题</p><p><img src="/实用工具/yapi/yapi的项目运行/image-20210805001123542.png" alt="image-20210805001123542"></p><h4 id="1-2、启动yapi项目的数据mongodb"><a href="#1-2、启动yapi项目的数据mongodb" class="headerlink" title="1.2、启动yapi项目的数据mongodb"></a>1.2、启动<code>yapi项目的数据mongodb</code></h4><p><img src="/实用工具/yapi/yapi的项目运行/image-20210805003329469.png" alt="image-20210805003329469"></p><p>这样启动mongodb后，再执行node vendors/server/app.js，就能让yapi正确启动了。</p><p>### </p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yapi的安装及其项目的创建和启动</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="yapi的安装及其项目的创建和启动"><a href="#yapi的安装及其项目的创建和启动" class="headerlink" title="yapi的安装及其项目的创建和启动"></a>yapi的安装及其项目的创建和启动</h1><p>官网地址：<a href="https://github.com/YMFE/yapi" target="_blank" rel="noopener">https://github.com/YMFE/yapi</a></p><h2 id="前言-官网"><a href="#前言-官网" class="headerlink" title="前言/官网"></a>前言/官网</h2><p><a href="https://github.com/ymfe/yapi" target="_blank" rel="noopener">官网 https://github.com/ymfe/yapi</a></p><h2 id="一、安装yapi"><a href="#一、安装yapi" class="headerlink" title="一、安装yapi"></a>一、安装yapi</h2><p> 使用yapi-cli 工具，部署 YApi 平台。</p><p>命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yapi-cli --registry https://registry.npm.taobao.org# 需要 nodejs环境</span><br><span class="line">yapi server# 需要 MongoDB环境</span><br></pre></td></tr></table></figure><p>虽然只有两个命令，但是两个命令的执行分别需要nodejs环境和MongoDB环境。</p><p>所以，使用这两个命令前，我们先按需依次完成以下步骤，搭建yapi所需的nodejs环境和MongoDB环境。</p><h2 id="二、yapi所需环境nodejs的安装"><a href="#二、yapi所需环境nodejs的安装" class="headerlink" title="二、yapi所需环境nodejs的安装"></a>二、yapi所需环境nodejs的安装</h2><h3 id="1、nodejs环境的检测"><a href="#1、nodejs环境的检测" class="headerlink" title="1、nodejs环境的检测"></a>1、nodejs环境的检测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>如果能够执行此命令，则代表你已安装nodejs的环境，请不用再重复安装。如果没有，请看下一步<code>3、nodejs环境的安装</code>。</p><h3 id="2、未安装nodejs环境，导致的yapi安装失败"><a href="#2、未安装nodejs环境，导致的yapi安装失败" class="headerlink" title="2、未安装nodejs环境，导致的yapi安装失败"></a>2、未安装nodejs环境，导致的yapi安装失败</h3><p>因为安装yapi的  <code>npm install -g yapi-cli --registry https://registry.npm.taobao.org</code> 那条命令，需要用到npm环境。如果没安装，则会失败如下：</p><p><img src="/实用工具/yapi/yapi的安装/image-20201117155309965.png" alt="image-20201117155309965"></p><p>所以请先检测您电脑是否已经安装了nodejs（7.6+)了。</p><h3 id="3、nodejs环境的安装"><a href="#3、nodejs环境的安装" class="headerlink" title="3、nodejs环境的安装"></a>3、nodejs环境的安装</h3><p>安装nodejs（7.6+)。另关于node的安装，请查看<a href="../../node/node.md">本网站中的node.md</a></p><h2 id="三、yapi所需环境MongoDB的安装与启动"><a href="#三、yapi所需环境MongoDB的安装与启动" class="headerlink" title="三、yapi所需环境MongoDB的安装与启动"></a>三、yapi所需环境MongoDB的安装与启动</h2><h3 id="1、未配MongoDB环境，导致的yapi安装失败"><a href="#1、未配MongoDB环境，导致的yapi安装失败" class="headerlink" title="1、未配MongoDB环境，导致的yapi安装失败"></a>1、未配MongoDB环境，导致的yapi安装失败</h3><p>执行部署yapi的 <code>yapi server</code> 命令时候，此时看到的执行结果如下：</p><p><img src="/实用工具/yapi/yapi的安装/yapi start1.png" alt="yapi start1" style="zoom: 33%;"></p><p>如果你未提前安装<code>mongodb</code>，则会在部署yapi的时候发生如下错误。</p><p><img src="/实用工具/yapi/yapi的安装/yapi start1error.png" alt="yapi start error" style="zoom:50%;"></p><p>所以要完成yapi的成功部署，其还需要 <strong>mongodb（2.6+）</strong></p><h3 id="2、MongoDB环境的检测"><a href="#2、MongoDB环境的检测" class="headerlink" title="2、MongoDB环境的检测"></a>2、MongoDB环境的检测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo -version</span><br></pre></td></tr></table></figure><p>如果能够执行此命令，则代表你已安装mongodb的环境，请不用再重复安装。如果没有，请看<code>3、yapi所需环境MongoDB的安装</code>。</p><h3 id="3、yapi所需环境MongoDB的安装"><a href="#3、yapi所需环境MongoDB的安装" class="headerlink" title="3、yapi所需环境MongoDB的安装"></a>3、yapi所需环境MongoDB的安装</h3><h4 id="方法一、可视化桌面安装"><a href="#方法一、可视化桌面安装" class="headerlink" title="方法一、可视化桌面安装"></a>方法一、可视化桌面安装</h4><p><strong>如果您是云服务器ECS，请跳过方法一，直接使用方法二终端命令安装MongoDB。</strong></p><p>其他参考见：<a href="https://www.runoob.com/mongodb/mongodb-osx-install.html" target="_blank" rel="noopener">Mac OSX 平台安装 MongoDB</a></p><p><a href="https://zhuanlan.zhihu.com/p/94152357" target="_blank" rel="noopener">在Mac 安装MongoDB</a></p><p>1、点击进入下载地址<a href="https://www.mongodb.com/download-center/enterprise" target="_blank" rel="noopener">https://www.mongodb.com/download-center/enterprise</a></p><p><img src="/实用工具/yapi/yapi的安装/mongodb download1.png" alt="mongodb download"></p><p>将下载下来的tgz解压后，放到<code>/usr/local</code>文件夹中，并改名为<code>mongodb</code>。</p><p><img src="/实用工具/yapi/yapi的安装/mongodb install1.png" alt="mongodb install"></p><p>在改名为<code>mongodb</code>后，通过在终端执行<code>open ~</code>，找到并打开该目录下的<code>.bash_profile</code>中配置如下环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;PATH&#125;:/usr/local/mongodb/bin</span><br></pre></td></tr></table></figure><p>配置完后，关闭文件，终端执行如下命令，使得钢材配置的环境变量能够生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">source ./.bash_profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者直接下面一句</span></span><br><span class="line">source  ~/.bash_profile</span><br></pre></td></tr></table></figure><p>不执行 上述source命令的话， mongo -version 无法生效。</p><p>安装成功后，执行<code>mongo -version</code>，如果不提示 command not found，代表安装成功了。</p><p><img src="/实用工具/yapi/yapi的安装/mongodb install success.png" alt="mongodb install success" style="zoom:50%;"></p><p>至此，mongo安装完成，接下去进行启动mongo。</p><h4 id="方法二、终端命令安装MongoDB-云服务器常用的安装方式"><a href="#方法二、终端命令安装MongoDB-云服务器常用的安装方式" class="headerlink" title="方法二、终端命令安装MongoDB(云服务器常用的安装方式)"></a>方法二、终端命令安装MongoDB(云服务器常用的安装方式)</h4><p><a href="https://www.runoob.com/mongodb/mongodb-linux-install.html" target="_blank" rel="noopener">Linux平台安装MongoDB官网安装文档 https://www.runoob.com/mongodb/mongodb-linux-install.html</a></p><p>进入地址：<a href="https://www.mongodb.com/try/download/community" target="_blank" rel="noopener">https://www.mongodb.com/try/download/community</a></p><p><img src="/实用工具/yapi/yapi的安装/image-20201117221110499.png" alt="image-20201117221110499"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd 到某个目录，执行以下命令,下载文件</span><br><span class="line">yum install libcurl openssl</span><br><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel80-4.4.1.tgz</span><br></pre></td></tr></table></figure><p><img src="/实用工具/yapi/yapi的安装/image-20201117235817379.png" alt="image-20201117235817379"></p><h5 id="1、找到并提前测试所下载的mongodb能否在本操作系统下有效执行。如果无效，会出现以下错误"><a href="#1、找到并提前测试所下载的mongodb能否在本操作系统下有效执行。如果无效，会出现以下错误" class="headerlink" title="1、找到并提前测试所下载的mongodb能否在本操作系统下有效执行。如果无效，会出现以下错误"></a>1、找到并提前测试所下载的mongodb能否在本操作系统下有效执行。如果无效，会出现以下错误</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: ./mongo: cannot execute binary file: Exec format error</span><br></pre></td></tr></table></figure><p>查看系统是几位的终端命令为<code>getconf LONG_BIT</code></p><p>测试方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、使用wget下载</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、使用tar -zxvf解压缩后</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、直接进入解压缩后的mongodb的bin目录下，执行对应的命令</span></span><br></pre></td></tr></table></figure><p><img src="/实用工具/yapi/yapi的安装/image-20210804131852567.png" alt="image-20210804131852567"></p><h5 id="2、有效后，再转移并设置环境变量"><a href="#2、有效后，再转移并设置环境变量" class="headerlink" title="2、有效后，再转移并设置环境变量"></a>2、有效后，再转移并设置环境变量</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf mongodb-linux-x86_64-rhel80-4.4.1.tgz</span><br><span class="line"></span><br><span class="line">mv mongodb-linux-x86_64-rhel80-4.4.1 /usr/local/mongodb</span><br></pre></td></tr></table></figure><p><img src="/实用工具/yapi/yapi的安装/image-20201118004346856.png" alt="image-20201118004346856"></p><p>输入<code>vim /etc/profile</code>编辑环境变量文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> <span class="keyword">for</span> mongo</span></span><br><span class="line">export PATH=/usr/local/mongodb/bin:$PATH</span><br></pre></td></tr></table></figure><p><img src="/实用工具/yapi/yapi的安装/image-20210803224610402.png" alt="image-20210803224610402"></p><p>插入完成后，执行<code>source /etc/profile</code>，使环境变量生效，之后执行以下命令，就可以看到有效了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo -version</span><br></pre></td></tr></table></figure><h3 id="4、yapi所需环境MongoDB的启动"><a href="#4、yapi所需环境MongoDB的启动" class="headerlink" title="4、yapi所需环境MongoDB的启动"></a>4、yapi所需环境MongoDB的启动</h3><p>命令认识：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --dbpath 设置数据存放目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --logpath 设置日志存放目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --fork 在后台运行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mongod --dbpath &lt;path to data directory&gt; <span class="comment"># 基础的运行命令</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mongod --dbpath &lt;path to data directory&gt; --logpath &lt;path to <span class="built_in">log</span> directory&gt; --fork <span class="comment"># 后台的运行命令（如果要--fork，则必须有--logpath参数）</span></span></span><br></pre></td></tr></table></figure><h4 id="方法一：可视化桌面操作-以MacOS为例"><a href="#方法一：可视化桌面操作-以MacOS为例" class="headerlink" title="方法一：可视化桌面操作(以MacOS为例)"></a>方法一：可视化桌面操作(以MacOS为例)</h4><h5 id="1、为MongoDB创建数据-必需-及日志存放的目录-可选"><a href="#1、为MongoDB创建数据-必需-及日志存放的目录-可选" class="headerlink" title="1、为MongoDB创建数据(必需)及日志存放的目录(可选)"></a>1、为MongoDB创建数据(必需)及日志存放的目录(可选)</h5><p>步骤：为MongoDB创建数据及日志存放的目录，这里我们就把它们放在/usr/local/var目录下。</p><p>创建数据目录：            /usr/local/var/mongodb</p><p>创建日志存放的目录：/usr/local/var/log/mongodb</p><p><img src="/实用工具/yapi/yapi的安装/mongodb start1.png" alt="mongodb start1"></p><h5 id="2、执行命令启动-mongodb"><a href="#2、执行命令启动-mongodb" class="headerlink" title="2、执行命令启动 mongodb"></a>2、执行命令启动 mongodb</h5><p>数据(必需)及日志存放的目录创建完成后，输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --dbpath 设置数据存放目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --logpath 设置日志存放目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --fork 在后台运行</span></span><br><span class="line">mongod --dbpath /usr/local/var/mongodb --logpath /usr/local/var/log/mongodb/mongo.log --fork</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">cd /usr/local/var/</span><br><span class="line">mongod --dbpath ./mongodb --logpath ./log/mongodb/mongo.log --fork</span><br></pre></td></tr></table></figure><p><img src="/实用工具/yapi/yapi的安装/mongodb start2.png" alt="mongodb start2"></p><h4 id="方法二：终端命令操作-常用于云服务器"><a href="#方法二：终端命令操作-常用于云服务器" class="headerlink" title="方法二：终端命令操作(常用于云服务器)"></a>方法二：终端命令操作(常用于云服务器)</h4><h5 id="1、为MongoDB创建数据-必需-及日志存放的目录-可选-1"><a href="#1、为MongoDB创建数据-必需-及日志存放的目录-可选-1" class="headerlink" title="1、为MongoDB创建数据(必需)及日志存放的目录(可选)"></a>1、为MongoDB创建数据(必需)及日志存放的目录(可选)</h5><p>步骤：为MongoDB创建数据及日志存放的目录，这里我们新建一个单独的文件夹，如CQApp-api-mongodb来单独存放yapi的数据及日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建存放的目录</span></span><br><span class="line">cd Project</span><br><span class="line">mkdir CQApp-api-mongodb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建数据目录data</span></span><br><span class="line">sudo mkdir -p data</span><br><span class="line">sudo chown -R 777 data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建日志存放的目录<span class="built_in">log</span></span></span><br><span class="line">sudo mkdir -p log</span><br><span class="line">sudo chown -R 777 log</span><br></pre></td></tr></table></figure><p>生成后，文件如下：</p><p><img src="/实用工具/yapi/yapi的安装/image-20210805014810744.png" alt="image-20210805014810744" style="zoom: 33%;"></p><h5 id="2、执行命令启动-mongodb-1"><a href="#2、执行命令启动-mongodb-1" class="headerlink" title="2、执行命令启动 mongodb"></a>2、执行命令启动 mongodb</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Project/CQApp-api-mongodb/</span><br><span class="line">mongod --dbpath ./data --logpath ./log/mongo.log --fork</span><br></pre></td></tr></table></figure><p><img src="/实用工具/yapi/yapi的安装/image-20210805003329469.png" alt="image-20210805003329469"></p><h3 id="5、mongodb启动成功后，即可重新点击之前的开始部署-开始创建yapi项目。"><a href="#5、mongodb启动成功后，即可重新点击之前的开始部署-开始创建yapi项目。" class="headerlink" title="5、mongodb启动成功后，即可重新点击之前的开始部署/开始创建yapi项目。"></a>5、mongodb启动成功后，即可重新点击之前的开始部署/开始创建yapi项目。</h3><h3 id="6、yapi所需环境MongoDB的关闭"><a href="#6、yapi所需环境MongoDB的关闭" class="headerlink" title="6、yapi所需环境MongoDB的关闭"></a>6、yapi所需环境MongoDB的关闭</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对于处理后台启动的mogodb的关闭，使用以下命令来关闭</span></span><br><span class="line">pkill mongod</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其他前台的，直接退出终端或者Ctrl+C结束就行了。</span></span><br></pre></td></tr></table></figure><h2 id="四、创建yapi项目"><a href="#四、创建yapi项目" class="headerlink" title="四、创建yapi项目"></a>四、创建yapi项目</h2><h3 id="1、执行部署yapi的-yapi-server-命令"><a href="#1、执行部署yapi的-yapi-server-命令" class="headerlink" title="1、执行部署yapi的 yapi server 命令"></a>1、执行部署yapi的 <code>yapi server</code> 命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yapi server</span><br></pre></td></tr></table></figure><h3 id="2、访问http-0-0-0-0-9090，"><a href="#2、访问http-0-0-0-0-9090，" class="headerlink" title="2、访问http://0.0.0.0:9090，"></a>2、访问<code>http://0.0.0.0:9090</code>，</h3><p>此时看到的结果如下：</p><p><img src="/实用工具/yapi/yapi的安装/yapi start1.png" alt="yapi start1" style="zoom: 33%;"></p><h3 id="3、点击开始部署，"><a href="#3、点击开始部署，" class="headerlink" title="3、点击开始部署，"></a>3、点击开始部署，</h3><p>执行过程如下：</p><p><img src="/实用工具/yapi/yapi的安装/yapi start2.png" alt="yapi start2"></p><h3 id="4、部署-创建成功"><a href="#4、部署-创建成功" class="headerlink" title="4、部署/创建成功"></a>4、部署/创建成功</h3><p>部署/创建成功，截图如下：</p><p><img src="/实用工具/yapi/yapi的安装/yapi start3 success.png" alt="yapi start success"></p><blockquote><p>账号：<a href="mailto:admin@admin.com" target="_blank" rel="noopener">admin@admin.com</a></p><p>密码：ymfe.org</p></blockquote><p>这个账号密码，待会需要用于登录yapi网页界面使用。</p><p>此时你所填写的部署路径下，就会有所创建生成的yapi工程。</p><p>附：执行后mongodb config1</p><p><img src="/实用工具/yapi/yapi的安装/mongodb config1.jpg" alt="mongodb config1" style="zoom:33%;"></p><h2 id="五、yapi的项目运行"><a href="#五、yapi的项目运行" class="headerlink" title="五、yapi的项目运行"></a>五、yapi的项目运行</h2><p>请查看 <a href="./yapi的项目运行.md">本博客中的yapi的项目运行.md</a></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web扩展1</title>
      <link href="/HTML/2%E6%89%A9%E5%B1%95/web%E6%89%A9%E5%B1%951/"/>
      <url>/HTML/2%E6%89%A9%E5%B1%95/web%E6%89%A9%E5%B1%951/</url>
      
        <content type="html"><![CDATA[<p>[Toc]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="一、单位"><a href="#一、单位" class="headerlink" title="一、单位"></a>一、单位</h3><ul><li><a href="http://caibaojian.com/rem-and-px.html" target="_blank" rel="noopener">rem与px的转换</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>web必备基础3-代码复用</title>
      <link href="/HTML/1%E5%85%A5%E9%97%A8/web%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%803-%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8/"/>
      <url>/HTML/1%E5%85%A5%E9%97%A8/web%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%803-%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[Toc]</p><h2 id="一、css复用"><a href="#一、css复用" class="headerlink" title="一、css复用"></a>一、css复用</h2><ul><li><a href="http://www.divcss5.com/html/h50848.shtml" target="_blank" rel="noopener">用HTML使用CSS的六种方法</a></li></ul><h2 id="二、UI-复用"><a href="#二、UI-复用" class="headerlink" title="二、UI 复用"></a>二、UI 复用</h2><h3 id="1、目前实例-jquery的load方法"><a href="#1、目前实例-jquery的load方法" class="headerlink" title="1、目前实例(jquery的load方法)"></a>1、目前实例(jquery的load方法)</h3><h4 id="将一个页面分成多个html文件（静态html分割页面）"><a href="#将一个页面分成多个html文件（静态html分割页面）" class="headerlink" title="将一个页面分成多个html文件（静态html分割页面）"></a>将一个页面分成多个html文件（静态html分割页面）</h4><p>参考文章：</p><ul><li><p><a href="https://blog.csdn.net/qq_35713752/article/details/99308821" target="_blank" rel="noopener">HTML引用公共组件</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">$(&quot;.footer&quot;).load(&apos;footer.html&apos;);</span><br><span class="line">$.nicenav(300, &apos;216px&apos;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://blog.csdn.net/x_chengqq/article/details/51712391" target="_blank" rel="noopener">将一个页面分成多个html文件（静态html分割页面）</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(function()&#123;</span><br><span class="line">$(&apos;#header&apos;).load(&apos;header.html&apos;);</span><br><span class="line">$(&apos;#content&apos;).load(&apos;content.html&apos;);</span><br><span class="line">$(&apos;#footer&apos;).load(&apos;footer.html&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2、其他方法"><a href="#2、其他方法" class="headerlink" title="2、其他方法"></a>2、其他方法</h2><ul><li><p><a href="https://blog.csdn.net/weixin_41804429/article/details/90488474?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">抽离出html公用部分实现多页面复用</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何抽离出公用的部分呢？(有点类似Vue，React等框架的组件化)我选的是运用jquery的load方法，还有很多其他方法，如iframe ，include等等网上都能搜到。</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.baidu.com/link?url=9aVNoNnWu7fbnm7qF-VTmvcyIROjJWdg49fKD8LWBWF38CFFOdE98f3lsVDS2ltDAUWSTp3_Pug9NEFgAVO39RalPujGt6-v9N4AKwZ_-93&amp;wd=&amp;eqid=cff5540700033911000000055ed22601" target="_blank" rel="noopener"><em>自定义元素</em>:在 HTML 中定义新元素 - HTML5 Rocks</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>web必备基础2-实践基础</title>
      <link href="/HTML/1%E5%85%A5%E9%97%A8/web%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%802-%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80/"/>
      <url>/HTML/1%E5%85%A5%E9%97%A8/web%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%802-%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>[Toc]</p><h2 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h2><ul><li><a href="http://jsbin.com/dawenun/edit?html,css,output" target="_blank" rel="noopener">html demo工具</a>：<a href="https://jsbin.com/?html,css,output" target="_blank" rel="noopener">https://jsbin.com/?html,css,output</a></li></ul><h2 id="二、布局常用基础"><a href="#二、布局常用基础" class="headerlink" title="二、布局常用基础"></a>二、布局常用基础</h2><h2 id="1、布局"><a href="#1、布局" class="headerlink" title="1、布局"></a>1、布局</h2><ul><li><p><a href="http://www.divcss5.com/shili/s547.shtml" target="_blank" rel="noopener">div水平居中</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#divcss5</span>&#123;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span> auto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.w3school.com.cn/css3/css3_background.asp" target="_blank" rel="noopener">css背景/图片填充div</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(../images/home/bg_appstore@3x.jpg);</span><br><span class="line"><span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>web必备基础1-学习路线</title>
      <link href="/HTML/1%E5%85%A5%E9%97%A8/web%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%801-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/HTML/1%E5%85%A5%E9%97%A8/web%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%801-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><ul><li><a href="https://www.jianshu.com/p/86cdd0bd4147" target="_blank" rel="noopener">2017 Web 开发者学习路线图</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>启动优化</title>
      <link href="/iOS/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
      <url>/iOS/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h1><p>[toc]</p><p><a href="https://www.jianshu.com/p/024b3d847fe0" target="_blank" rel="noopener">iOS App启动优化（一）—— 了解App的启动流程</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H5-APP开发小技巧</title>
      <link href="/H5-APP/1%E5%85%A5%E9%97%A8/H5-APP%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/H5-APP/1%E5%85%A5%E9%97%A8/H5-APP%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、div设置多个class"><a href="#一、div设置多个class" class="headerlink" title="一、div设置多个class"></a>一、div设置多个class</h2><p>在 HTML 中，一个 class 值中可能包含一个词列表，各个词之间用空格分隔。例如，如果希望将一个特定的元素同时标记为重要（important）和警告（warning），就可以写作：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p <span class="keyword">class</span>=<span class="string">"important warning"</span>&gt;</span><br><span class="line">This paragraph <span class="keyword">is</span> a very important warning.</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>这两个词的顺序无关紧要，写成 warning important 也可以。<br>我们假设 class 为 important 的所有元素都是粗体，而 class 为 warning 的所有元素为斜体，class 中同时包含 important 和 warning 的所有元素还有一个银色的背景 。就可以写作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.important &#123;font-weight:bold;&#125;</span><br><span class="line">.warning &#123;font-weight:italic;&#125;</span><br><span class="line">.important.warning &#123;background:silver;&#125;  <span class="comment">//相当于两个class有相同的样式。</span></span><br></pre></td></tr></table></figure><p>其实是一个DIV拥有两个Class 空格并不是一个CLASS，用jquery你只需要<img src="https://math.jianshu.com/math?formula=(%22.import%22" alt="(&quot;.import&quot;)或">%E6%88%96)(“.warning”)就可将其选定。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>H5-APP开发环境搭建与运行</title>
      <link href="/H5-APP/1%E5%85%A5%E9%97%A8/H5-APP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/"/>
      <url>/H5-APP/1%E5%85%A5%E9%97%A8/H5-APP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、启动"><a href="#一、启动" class="headerlink" title="一、启动"></a>一、启动</h2><h3 id="1、启动服务"><a href="#1、启动服务" class="headerlink" title="1、启动服务"></a>1、启动服务</h3><p>1、cd 到 <code>package.json</code> 所在层</p><p>2、执行<code>npm install</code>/<code>yarn install</code>，</p><p>​        =&gt; 执行后会生成<code>node_modules</code></p><p>3、通过<code>npm run</code>执行<code>package.json</code>中<code>scripts</code>里提供的命令(里面的命令是自己可以改的)。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev:client</span><br></pre></td></tr></table></figure><p>执行结果在终端成功的话，显示为：Compiled successfully.</p><p>如：</p><p><img src="/H5-APP/1入门/H5-APP开发环境搭建与运行/package_scripts_2npmrun.png" alt="image-20200401004428926"></p><p>分析本步骤的命令执行的内部原理</p><p>观察得执行该命令，其实会去执行当前目录下的bulid中的webpack.dev.js文件</p><p><img src="/H5-APP/1入门/H5-APP开发环境搭建与运行/package_scripts_1.png" alt="image-20200401003619216"></p><p>打开该文件</p><p><img src="/H5-APP/1入门/H5-APP开发环境搭建与运行/package_scripts_3.png" alt="image-20200401004814191" style="zoom:25%;"></p><h3 id="2、URL主路径的获取"><a href="#2、URL主路径的获取" class="headerlink" title="2、URL主路径的获取"></a>2、URL主路径的获取</h3><p><a href="http://localhost:9000/" target="_blank" rel="noopener">http://localhost:9000/</a> 其中9000即是上面的端口号</p><h3 id="3、URL路径的获取"><a href="#3、URL路径的获取" class="headerlink" title="3、URL路径的获取"></a>3、URL路径的获取</h3><p>如何得知你的界面的URL地址</p><p><img src="/H5-APP/1入门/H5-APP开发环境搭建与运行/h5_url_1.png" alt="image-20200401011247816"></p><h3 id="4、浏览器访问"><a href="#4、浏览器访问" class="headerlink" title="4、浏览器访问"></a>4、浏览器访问</h3><p>在浏览器中输入地址</p><p><a href="http://localhost:9000/inspection/HomeEntrance" target="_blank" rel="noopener">http://localhost:9000/inspection/HomeEntrance</a></p><ul><li><a href="https://www.cnblogs.com/lixuemin/p/6350183.html" target="_blank" rel="noopener">H5页面获取屏幕宽高</a></li></ul><p>document.documentElement.clientWidth;<br>document.documentElement.clientHeight;</p><p>用window.screen.height;window.screen.width;并不准确，当部分手机页面本身有超出屏幕宽度的元素时，会将超出部分也计算进内。目前遇到的机型有ZTE。</p><p>进程线程</p><h1 id="react-异常状态记录"><a href="#react-异常状态记录" class="headerlink" title="react-异常状态记录"></a>react-异常状态记录</h1><p>来源：<a href="https://www.jianshu.com/p/2b62e9939c7b" target="_blank" rel="noopener">react-异常状态记录</a></p><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>日志信息：<code>React does not recognize the</code>fieldType<code>prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase</code>fieldtype<code>instead. If you accidentally passed it from a parent component, remove it from the DOM element.</code><br> 问题来源：<code>react</code><br> 原因：DOM节点中被传入了组件属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resPorps=&#123;</span><br><span class="line">  fieldType:<span class="string">'.txt'</span>,</span><br><span class="line">  marginLeft:<span class="number">10</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span>(</span><br><span class="line">  &lt;div &#123;...resProps&#125;&gt;</span><br><span class="line">    test</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>如上，fieldType不属于DOM的默认属性，对于React来说，这是一种冗余的写法。<br> 解决办法：将不属于DOM的属性提取出来</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resPorps=&#123;</span><br><span class="line">  marginLeft:<span class="number">10</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span>(</span><br><span class="line">  &lt;div &#123;...resProps&#125; fieldType=<span class="string">'.txt'</span>&gt;</span><br><span class="line">    test</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js</title>
      <link href="/HTML/common_js/"/>
      <url>/HTML/common_js/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="公共js"><a href="#公共js" class="headerlink" title="公共js"></a>公共js</h1>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>h5_open_app</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5_open_app/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5_open_app/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="测试app外的h5直接打开app"><a href="#测试app外的h5直接打开app" class="headerlink" title="测试app外的h5直接打开app"></a>测试app外的h5直接打开app</h1><h2 id="一、app外h5地址生成及解析器网页"><a href="#一、app外h5地址生成及解析器网页" class="headerlink" title="一、app外h5地址生成及解析器网页"></a>一、app外h5地址生成及解析器网页</h2><p>网页地址及内容：请点击<a href="./dvlp_h5_open_app_url_create_demo.html">dvlp_h5_open_app_url_create_demo.html</a>查看。</p><p>demo使用的json数据<a href="./dvlp_h5_open_app_url_create_demo.json">dvlp_h5_open_app_url_create_demo.json</a></p><h3 id="1、网址组成元素"><a href="#1、网址组成元素" class="headerlink" title="1、网址组成元素"></a>1、网址组成元素</h3><h4 id="1-1、主地址-必传"><a href="#1-1、主地址-必传" class="headerlink" title="1.1、主地址(必传)"></a>1.1、主地址(必传)</h4><h4 id="1-2、app参数信息-非必传"><a href="#1-2、app参数信息-非必传" class="headerlink" title="1.2、app参数信息(非必传)"></a>1.2、app参数信息(非必传)</h4><h4 id="1-3、其他参数信息-非必传"><a href="#1-3、其他参数信息-非必传" class="headerlink" title="1.3、其他参数信息(非必传)"></a>1.3、其他参数信息(非必传)</h4><h3 id="2、网址组成方式"><a href="#2、网址组成方式" class="headerlink" title="2、网址组成方式"></a>2、网址组成方式</h3><h4 id="2-1、直接地址"><a href="#2-1、直接地址" class="headerlink" title="2.1、直接地址"></a>2.1、直接地址</h4><h4 id="2-2、自己构成"><a href="#2-2、自己构成" class="headerlink" title="2.2、自己构成"></a>2.2、自己构成</h4><h3 id="3、网址解析器功能"><a href="#3、网址解析器功能" class="headerlink" title="3、网址解析器功能"></a>3、网址解析器功能</h3><h3 id="4、网址生成器功能"><a href="#4、网址生成器功能" class="headerlink" title="4、网址生成器功能"></a>4、网址生成器功能</h3><h3 id="5、执行按钮"><a href="#5、执行按钮" class="headerlink" title="5、执行按钮"></a>5、执行按钮</h3><h4 id="5-1、如果本地址生成及解析器，是正常在app外的浏览器打开的"><a href="#5-1、如果本地址生成及解析器，是正常在app外的浏览器打开的" class="headerlink" title="5.1、如果本地址生成及解析器，是正常在app外的浏览器打开的"></a>5.1、如果本地址生成及解析器，是正常在app外的浏览器打开的</h4><p>那点击按钮，直接打开到指定页面。</p><h4 id="5-2、如果本地址生成及解析器，是正常在app内的WebView打开的"><a href="#5-2、如果本地址生成及解析器，是正常在app内的WebView打开的" class="headerlink" title="5.2、如果本地址生成及解析器，是正常在app内的WebView打开的"></a>5.2、如果本地址生成及解析器，是正常在app内的WebView打开的</h4><p>那点击按钮，打开外部浏览器，浏览指定页面。</p><p>iOS：无法打开外部浏览器。</p><p>Android：可以直接打开外部浏览器。</p><h2 id="二、测试工具网页"><a href="#二、测试工具网页" class="headerlink" title="二、测试工具网页"></a>二、测试工具网页</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dvlp_h5js_demo</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5js/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/h5js/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="测试app中的h5调用app的网页"><a href="#测试app中的h5调用app的网页" class="headerlink" title="测试app中的h5调用app的网页"></a>测试app中的h5调用app的网页</h1><h2 id="一、测试h5调用app的网页"><a href="#一、测试h5调用app的网页" class="headerlink" title="一、测试h5调用app的网页"></a>一、测试h5调用app的网页</h2><h3 id="1、测试h5调用app的网页1-硬编码，不推荐使用"><a href="#1、测试h5调用app的网页1-硬编码，不推荐使用" class="headerlink" title="1、测试h5调用app的网页1(硬编码，不推荐使用)"></a>1、测试h5调用app的网页1(硬编码，不推荐使用)</h3><p>网页地址及内容：请点击<a href="./test_h5js_demo.html">test_h5js_demo.html</a>查看</p><h4 id="支持的功能："><a href="#支持的功能：" class="headerlink" title="支持的功能："></a>支持的功能：</h4><ul><li style="list-style: none"><input type="checkbox" checked> 点击对应按钮，让h5调用app提供的方法，并传递对应的参数。</li></ul><h3 id="2、测试h5调用app的网页2-自动编码，推荐使用，能够根据json文件自动化布局"><a href="#2、测试h5调用app的网页2-自动编码，推荐使用，能够根据json文件自动化布局" class="headerlink" title="2、测试h5调用app的网页2(自动编码，推荐使用，能够根据json文件自动化布局)"></a>2、测试h5调用app的网页2(自动编码，推荐使用，能够根据json文件自动化布局)</h3><p>网页地址及内容：请点击<a href="./dvlp_h5js_demo.html">dvlp_h5js_demo.html</a>查看。</p><p>demo使用的json数据<a href="./dvlp_h5js_demo.json">dvlp_h5js_demo.json</a></p><h4 id="新增支持内容如下：根据json数据，自动布局html内容"><a href="#新增支持内容如下：根据json数据，自动布局html内容" class="headerlink" title="新增支持内容如下：根据json数据，自动布局html内容"></a>新增支持内容如下：根据json数据，自动布局html内容</h4><ul><li><p>[x] 1、方法名、参数、参数说明，输入框化，以支持任意桥接方法</p><ul><li style="list-style: none"><input type="checkbox" checked> 字符串转方法</li></ul></li><li><p>[x] 2、输入框内容，json化</p><ul><li style="list-style: none"><input type="checkbox" checked> json数据，先内嵌在html中。因为先只支持一个，所以直接更新到文本框中（内容：方法名、参数、参数说明）</li></ul></li><li><p>[x] 3、输入框内容，支持从url中获取单个示例的数据（因为只有一个，所以直接通过dataJson传入输入框中的各个参数）</p><ul><li><p>[x] 网页副标题增加数据来源标识，以区分数据是html本身内嵌的数据，还是从url中获取</p></li><li><p>[x] 因为参数是从url中获取的，所以需要考虑编码问题。(虽然放在系统浏览器中可以通过)</p><ul><li style="list-style: none"><input type="checkbox" checked> 参数值支持非中文的字符串，可以不用编码</li><li style="list-style: none"><input type="checkbox" checked> 参数值支持中文，需编码</li><li style="list-style: none"><input type="checkbox" checked> 参数值支持json对象，需编码</li></ul></li><li style="list-style: none"><input type="checkbox" checked> 直接将从url中获取到的参数值，更新到文本框中，以可直接执行</li><li style="list-style: none"><input type="checkbox" checked> app中将输入框中的各个参数组成json，提供给h5。提供方式为将各参数添加到url中(每个url的参数，都需要先编码，否则当参数中含中文，或者是非字符串对象的时候，解析的时候会有问题，虽然放在系统浏览器中可以通过)</li><li style="list-style: none"><input type="checkbox" checked> app中提供json数据，并列表化。app选中对应项，将所选项对应的json数据传递给url的参数。</li><li style="list-style: none"><input type="checkbox" checked> json数据支持section形式，以区分不同类型的示例。</li></ul></li><li><p>[x] 4、输入框内容，通过之前支持的json，提供各种demo数据功能</p><ul><li style="list-style: none"><input type="checkbox" checked> json数据，先内嵌在html中。根据json数据，展示可选操作。</li><li style="list-style: none"><input type="checkbox" checked> 选中任意可选操作，更新文本框内容：方法名、参数、参数说明</li></ul></li><li><p>[x] 5、输入框内容，支持从url中获取多个示例的数据（因为要支持多个，所以是通过fileUrl传入json文件路径）</p><ul><li><p>[x] 网页副标题增加数据来源标识，以区分数据是html本身内嵌的数据，还是从url中获取。如果是url中获取的，那来源是单个示例使用的dataJson各参数，还是多个示例使用的fileUrl参数。</p></li><li><p>[x] 根据json数据，展示示例列表。（若只有一个数据，不显示列表，直接使用；若有多个，默认将第一个更新到文本框中）</p></li></ul></li><li><p>[x] 6、网页html支持跳转到demo示例</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>h5与native交互</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/h5_native_interacte/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="h5与native交互"><a href="#h5与native交互" class="headerlink" title="h5与native交互"></a>h5与native交互</h1><h2 id="一、app内的h5与app互相调用JS方法及传值"><a href="#一、app内的h5与app互相调用JS方法及传值" class="headerlink" title="一、app内的h5与app互相调用JS方法及传值"></a>一、app内的h5与app互相调用JS方法及传值</h2><h2 id="二、app外的h5直接打开app"><a href="#二、app外的h5直接打开app" class="headerlink" title="二、app外的h5直接打开app"></a>二、app外的h5直接打开app</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4节：详解Exception异常处理</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Exception%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Exception%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="详解Exception异常处理"><a href="#详解Exception异常处理" class="headerlink" title="详解Exception异常处理"></a>详解Exception异常处理</h1><p>好文分享：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/154514485" target="_blank" rel="noopener">Flutter中异常处理</a>：必须一定要看。</li><li></li></ul><h2 id="一、异常的捕获"><a href="#一、异常的捕获" class="headerlink" title="一、异常的捕获"></a>一、异常的捕获</h2><p><strong>同步异常</strong>通过 try-catch 机制捕获</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 try-catch 捕获同步异常</span></span><br><span class="line">xxx() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> StateError(<span class="string">'This is a Dart exception.'</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异步异常</strong>采用 Future 提供的 catchError 语句捕获。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 catchError 捕获异步异常</span></span><br><span class="line">Future&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt;&gt; simulate_get(<span class="built_in">String</span> url) <span class="keyword">async</span> &#123;</span><br><span class="line">   Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>)).then((value) &#123;</span><br><span class="line">     <span class="keyword">throw</span> StateError(<span class="string">'This is a Dart exception in Future.'</span>);</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="string">'statusCode'</span>: <span class="number">200</span>,</span><br><span class="line">       <span class="string">'msg'</span>: <span class="string">'"<span class="subst">$&#123;url&#125;</span>执行成功"'</span>,</span><br><span class="line">     &#125;;</span><br><span class="line">   &#125;).catchError((onError) &#123;</span><br><span class="line">     <span class="built_in">print</span>(onError);</span><br><span class="line">     <span class="comment">//rethrow; // 这里不能rethrow. 因为A rethrow must be inside of a catch clause.</span></span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="二、异常的上抛"><a href="#二、异常的上抛" class="headerlink" title="二、异常的上抛"></a>二、异常的上抛</h2><p><strong>异步异常</strong>的上抛</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 使用上文中自己建的异步方法 await simulate_get(url) 来模拟</span></span><br><span class="line">Future&lt;<span class="keyword">dynamic</span>&gt; requestBaidu1() <span class="keyword">async</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> url = <span class="string">"https://www.baidu.com/"</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">dynamic</span> response = <span class="keyword">await</span> simulate_get(url);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (response[<span class="string">'statusCode'</span>] == <span class="number">200</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> response.data;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> Exception(<span class="string">'后端接口出现异常'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">'网络错误:======&gt;url:<span class="subst">$url</span> \nbody:<span class="subst">$&#123;e.toString()&#125;</span>'</span>);</span><br><span class="line">     <span class="comment">// 这里只有执行了rethrow 或 throw，外层才能继续 .catchError((onError) &#123;&#125;</span></span><br><span class="line">     <span class="keyword">rethrow</span>;</span><br><span class="line">     <span class="comment">// throw Exception('网络错误:======&gt;url:$url \nbody:$&#123;e.toString()&#125;');</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用网络请求库 dio 中的异步方法 await dio.get(url) 来模拟</span></span><br><span class="line"> Future&lt;<span class="keyword">dynamic</span>&gt; requestBaidu2() <span class="keyword">async</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> url = <span class="string">"https://www.baidu.com/"</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     Dio dio = <span class="keyword">new</span> Dio();</span><br><span class="line">     Response response = <span class="keyword">await</span> dio.<span class="keyword">get</span>(url);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> response.data;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> Exception(<span class="string">'后端接口出现异常'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">     <span class="comment">// throw Exception('网络错误:======&gt;url:$url \nbody:$&#123;e.toString()&#125;');</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">'网络错误:======&gt;url:<span class="subst">$url</span> \nbody:<span class="subst">$&#123;e.toString()&#125;</span>'</span>);</span><br><span class="line">     <span class="keyword">rethrow</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>进行如上的上抛操作后，</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xxxPage.dart</span></span><br><span class="line">getData() &#123;</span><br><span class="line">    Api.requestBaidu2().then((<span class="keyword">dynamic</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.isSuccess) &#123;</span><br><span class="line">        Toast.show(<span class="string">"请求成功，有数据 isSuccess = true"</span>, context);</span><br><span class="line">        updateWidgetType(WidgetType.SuccessWithData);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Toast.show(<span class="string">"服务器失败 isSuccess = false"</span>, context);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).catchError((onError) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'网络问题'</span>);</span><br><span class="line">      Toast.show(<span class="string">"catchError网络问题111"</span>, context);</span><br><span class="line">      updateWidgetType(WidgetType.ErrorNetwork);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="判断网络异常"><a href="#判断网络异常" class="headerlink" title="判断网络异常"></a>判断网络异常</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">checkNetwork() <span class="keyword">async</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> result = <span class="keyword">await</span> InternetAddress.lookup(<span class="string">'baidu.com'</span>); <span class="comment">//尝试连接baidu</span></span><br><span class="line">   &#125; on SocketException <span class="keyword">catch</span> (_) &#123;</span><br><span class="line">     Toast.show(<span class="string">"catchError网络问题222333"</span>, context);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第五章：详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git代码同步</title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%E4%BB%A3%E7%A0%81%E5%90%8C%E6%AD%A5/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%E4%BB%A3%E7%A0%81%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Git代码同步"><a href="#Git代码同步" class="headerlink" title="Git代码同步"></a>Git代码同步</h1><h3 id="1、拉取最新代码、提交"><a href="#1、拉取最新代码、提交" class="headerlink" title="1、拉取最新代码、提交"></a>1、拉取最新代码、提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd CQApp-api-mongodb/</span><br><span class="line">git pull origin master</span><br><span class="line">git add .</span><br><span class="line">git commit -m "add api cardlist"</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p><img src="/代码管理/Git代码同步/image-20201121123010573.png" alt="image-20201121123010573"></p><p><img src="/代码管理/Git代码同步/image-20201121123124236.png" alt="image-20201121123124236"></p><p>上传成功，我们通过网站或者sourcetree等查看效果</p><p><img src="/代码管理/Git代码同步/image-20201121124131447.png" alt="image-20201121124131447"></p><h4 id="1、问题1：未配置用户名和邮箱"><a href="#1、问题1：未配置用户名和邮箱" class="headerlink" title="1、问题1：未配置用户名和邮箱"></a>1、问题1：未配置用户名和邮箱</h4><p><img src="/代码管理/Git代码同步/image-20201121123308986.png" alt="image-20201121123308986"></p><p><strong>解决配置用户名和邮箱</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、全局配置：使用 --global 修饰后设置的全局的用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"Your Name"</span>  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"email@example.com"</span>  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、如果只想设置单个项目的用户：可<span class="built_in">cd</span>到项目根目录下,执行如下命令:</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config user.name <span class="string">"Your Name"</span>  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config user.email <span class="string">"email@example.com"</span></span></span><br></pre></td></tr></table></figure><p>使用命令:git config –list 可查看当前用户信息以及其他的一些信息</p><p><img src="/代码管理/Git代码同步/image-20201121123421969.png" alt="image-20201121123421969"></p><h3 id="2、拉取提交省去密码输入的技巧–ssh"><a href="#2、拉取提交省去密码输入的技巧–ssh" class="headerlink" title="2、拉取提交省去密码输入的技巧–ssh"></a>2、拉取提交省去密码输入的技巧–ssh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "ecs_aliyun"</span><br><span class="line"></span><br><span class="line">cd /root/.ssh</span><br><span class="line"></span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="/代码管理/Git代码同步/image-20201121114358468.png" alt="image-20201121114358468"></p><p>到 github/gitee/gitlab 上添加对应的ssh</p><p><img src="/代码管理/Git代码同步/image-20201121114618923.png" alt="image-20201121114618923"></p><h2 id="四、提交云服务器代码"><a href="#四、提交云服务器代码" class="headerlink" title="四、提交云服务器代码"></a>四、提交云服务器代码</h2><ul><li>1、从服务器重新拉代码，将本地代码更新为服务器上的最新代码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p><img src="/代码管理/Git代码同步/yapi_git_1.png" alt="image-20220112144529354"></p><ul><li>2、查看本地代码状态，是否有待提交的代码 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><ul><li>3、将本地代码全部提交</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  add .</span><br></pre></td></tr></table></figure><ul><li>4、commit提交并添加注释 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "我是提交的注释"</span><br></pre></td></tr></table></figure><p>如果提交过程中出现如下问题：</p><p><img src="/代码管理/Git代码同步/yapi_git_3commit1.png" alt="image-20220112145348308"></p><p>请先根据提示，设置全局邮件和用户名，以让其他开发者可以看到是谁提交。配置前和配置后，可使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">git config -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置提交者的邮箱</span></span><br><span class="line">git config --global user.email "dvlproad@163.com"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置提交者的用户名</span></span><br><span class="line">git config --global user.email "dvlproad"</span><br></pre></td></tr></table></figure><p><img src="/代码管理/Git代码同步/yapi_git_3commit2.png" alt="image-20220112145514520"></p><p>设置完后，重新执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "我是提交的注释"</span><br></pre></td></tr></table></figure><p>即可。接下来就只剩最后一步，就可正式提交完成了。</p><ul><li>5、将本地的 master 分支推送到 origin 主机的 master 分支。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure><p>更多 git push用法，查看官网<a href="https://www.runoob.com/git/git-push.html" target="_blank" rel="noopener">https://www.runoob.com/git/git-push.html</a></p><p><img src="/代码管理/Git代码同步/yapi_git_5push.png" alt="image-20220112163849708"></p><p>结果：</p><p><img src="/代码管理/Git代码同步/yapi_git_5push2.png" alt="image-20220112172647153"></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常识类</title>
      <link href="/%E5%B8%B8%E8%AF%86%E7%B1%BB/"/>
      <url>/%E5%B8%B8%E8%AF%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>管理工具类</title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS功能_通用链接</title>
      <link href="/iOS/%E5%8A%9F%E8%83%BD%E6%80%A7%E6%8A%80%E6%9C%AF/iOS%E5%8A%9F%E8%83%BD-Universal%20Link(%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5)/"/>
      <url>/iOS/%E5%8A%9F%E8%83%BD%E6%80%A7%E6%8A%80%E6%9C%AF/iOS%E5%8A%9F%E8%83%BD-Universal%20Link(%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5)/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Universal-Links-通用链接"><a href="#Universal-Links-通用链接" class="headerlink" title="Universal Links(通用链接)"></a>Universal Links(通用链接)</h1><p>相关文档：</p><ul><li><p><a href="https://www.jianshu.com/p/1970fd59de12" target="_blank" rel="noopener">iOS Universal Links(通用链接)的使用</a></p></li><li><p><a href="https://www.jianshu.com/p/9117f925447c" target="_blank" rel="noopener">iOS-Universal Link 接入与微信分享的配置</a></p></li><li><a href="https://blog.csdn.net/wisudom/article/details/106431078" target="_blank" rel="noopener">iOS微信分享、通用链接Universal Link注意事项</a></li></ul><h2 id="一、Universal-Links-amp-scheme"><a href="#一、Universal-Links-amp-scheme" class="headerlink" title="一、Universal Links &amp; scheme"></a>一、Universal Links &amp; scheme</h2><p>Universal Links(通用链接)，是iOS9推出的一项新功能。如果你的应用（app）支持通用链接（Universal Link）之后，iOS用户能够在点击网页的链接的时候无缝的重定向到已经安装的app，不需要额外的任何操作。如果没有安装对应的app，那么点击链接会使用Safari打开网页。</p><p>附：在iOS9以前，对于各种浏览器，Safari中唤醒app的需求，我们通常是<strong>只能</strong>使用scheme的方式。现在iOS9之后，我们多了一种方式。两种方式的区别是scheme能够支持我们跳转app的时候加入参数。</p><h2 id="二、Universal-Links的表现及测试"><a href="#二、Universal-Links的表现及测试" class="headerlink" title="二、Universal Links的表现及测试"></a>二、Universal Links的表现及测试</h2><p>假设对于 com.dvlproad.Beyond 这个app，</p><p>dvlproad.com/app 是通用链接， dvlproad.com/mobile 不是通用链接。</p><h3 id="1、在浏览器Safari地址栏中的表现"><a href="#1、在浏览器Safari地址栏中的表现" class="headerlink" title="1、在浏览器Safari地址栏中的表现"></a>1、在浏览器Safari地址栏中的表现</h3><p>则我们先分别将这些链接粘贴到浏览器Safari的地址栏中，</p><p>1、浏览器地址栏为非通用链接时，没什么特别。<br>2、而浏览器地址栏为通用链接的时候，<br>①如果我们有安装`com.dvlproad.Beyond这个app，则会发现该页面下滑后，在顶部会多了个在应用中打开的操作，形如：</p><p><img src="/iOS/功能性技术/iOS功能-Universal Link(通用链接)/UniversalLinks_show1.png" alt="UniversalLinks_show1" style="zoom:25%;"></p><p>②如果我们没有安装<code>com.dvlproad.Beyond</code>这个app，则没有多这栏打开。即使你的通用链接都配置正确了。</p><h3 id="2、在非浏览器，如备用录app里的表现"><a href="#2、在非浏览器，如备用录app里的表现" class="headerlink" title="2、在非浏览器，如备用录app里的表现"></a>2、在非浏览器，如备用录app里的表现</h3><p><img src="/iOS/功能性技术/iOS功能-Universal Link(通用链接)/UniversalLinks_show2.png" alt="UniversalLinks_show2" style="zoom:25%;"></p><p>我们会发现点击</p><p>1、备忘录中的链接为非通用链接时，点击链接没什么特别。<br>2、而备忘录中的链接为通用链接的时候，点击链接会直接跳转到我们的<code>com.dvlproad.Beyond</code>这个app上。</p><h2 id="三、Universal-Links的实现"><a href="#三、Universal-Links的实现" class="headerlink" title="三、Universal Links的实现"></a>三、Universal Links的实现</h2><p>要让一个链接成为通用链接。需要</p><p>1、开启配置 Associated Domains</p><p>只有以该域名开头的链接，才可能是通用链接。</p><p>2、制作上传 apple-app-site-association</p><h3 id="1、Associated-Domains"><a href="#1、Associated-Domains" class="headerlink" title="1、Associated Domains"></a>1、Associated Domains</h3><p>1、进入苹果Apple Developer -&gt; Member Center -&gt; Certificates, Identifiers &amp; Profiles – &gt;Identifiers - &gt;App IDs–&gt;Edit 然后开启打钩 Associated Domains 后保存。</p><p><img src="https://upload-images.jianshu.io/upload_images/3636987-50a3c3b1594ac805.png?imageMogr2/auto-orient/strip|imageView2/2/w/1099" alt="img"></p><p>如果你使用Xcode的自动管理证书，可直接跳到第二步，即Xcode会在你打开Associated Domains时，自动帮你处理证书配置问题以及appIDs打开Associated Domains。</p><p>2、在项目中添加Associated Domains</p><p><img src="/iOS/功能性技术/iOS功能-Universal Link(通用链接)/iOS功能-Universal Link(通用链接" alt="AssociatedDomains_Set1">/AssociatedDomains_Set1.png)</p><p>点击Associated Domains的+号填入applinks:后面是你的域名。</p><p><img src="/iOS/功能性技术/iOS功能-Universal Link(通用链接)/iOS功能-Universal Link(通用链接" alt="AssociatedDomains_Set2">/AssociatedDomains_Set2.png)</p><p>及添加完后，只有以该域名<code>dvlproad.com</code>开头的链接，才可能是通用链接。</p><h3 id="2、apple-app-site-association"><a href="#2、apple-app-site-association" class="headerlink" title="2、apple-app-site-association"></a>2、apple-app-site-association</h3><p>App在安装的时候，iOS系统会去根据该app配置里填的那些<code>Associated Domains</code>下，去这些域的根目录下，取apple-app-site-association文件。</p><p>我们创建apple-app-site-association文件，并上传也是为了让iOS系统通过<code>Associated Domains</code>和<code>apple-app-site-association</code>这个文件，一起知道你的哪些是链接是Universal Links，哪些不是Universal Links。</p><h4 id="2-1、制作apple-app-site-association-文件"><a href="#2-1、制作apple-app-site-association-文件" class="headerlink" title="2.1、制作apple-app-site-association 文件"></a>2.1、制作apple-app-site-association 文件</h4><p>创建一个命名为apple-app-site-association文件，文件名必须为<strong>apple-app-site-association</strong>!!!（注意这个文件<strong>必须没有后缀名</strong>）</p><p>设<code>apple-app-site-association</code>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;applinks&quot;: &#123;</span><br><span class="line">        &quot;apps&quot;: [],</span><br><span class="line">        &quot;details&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;appID&quot;: &quot;myTeamId.com.dvlproad.Beyond1&quot;,</span><br><span class="line">                &quot;paths&quot;: [ &quot;*&quot; ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;appID&quot;: &quot;myTeamId.com.dvlproad.Beyond2&quot;,</span><br><span class="line">                &quot;paths&quot;: [ &quot;app&quot; ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>appID 是由你的Team ID+BundleID组成，如果你不知道你的Team ID是什么？进入苹果Apple Developer -&gt; Member Center -&gt;Membership-&gt;Team ID</p><p>paths 是一个字符串的数组,这里是你的应用支持的通用链接与不支持的链接，例如你使用的是/*,代表着只要是Associated Domains域名下的所有的链接都支持。如果你不支持某一个链接，在这个链接前面加NOT空格，举个例子</p><p>“paths”:[ “NOT /home/<em>“, “/</em>“ ]</p><p>如果这样写就是除了不支持/home下所有的链接，其他链接都支持。</p><h4 id="2-2、上传apple-app-site-association-文件"><a href="#2-2、上传apple-app-site-association-文件" class="headerlink" title="2.2、上传apple-app-site-association 文件"></a>2.2、上传apple-app-site-association 文件</h4><p>把你刚才制作好的apple-app-site-association文件，放到<strong>1中Associated Domains所填写的域名<code>dvlproad.com</code></strong>的根目录下或者<code>.well-known</code>下（要怕除问题，两个地方都放也行。）。</p><h4 id="2-3、检测上传的apple-app-site-association-文件是否成功"><a href="#2-3、检测上传的apple-app-site-association-文件是否成功" class="headerlink" title="2.3、检测上传的apple-app-site-association 文件是否成功"></a>2.3、检测上传的apple-app-site-association 文件是否成功</h4><p>①、通过浏览器访问<code>https://xxx.com/apple-app-site-association</code>地址，看文件是否上传成功。</p><p>②、苹果有一个检测的接口<a href="https://link.jianshu.com/?t=https://search.developer.apple.com/appsearch-validation-tool/" target="_blank" rel="noopener"> 苹果测试入口</a> ，将你的域名放入测试口，点击TestURL即可。</p><h4 id="2-4、上传apple-app-site-association-文件到dvlproad-github-io的例子"><a href="#2-4、上传apple-app-site-association-文件到dvlproad-github-io的例子" class="headerlink" title="2.4、上传apple-app-site-association 文件到dvlproad.github.io的例子"></a>2.4、上传apple-app-site-association 文件到<code>dvlproad.github.io</code>的例子</h4><p>为方便测试，我们域名使用<code>dvlproad.github.io</code>这个。</p><p>1、<code>apple-app-site-association</code>必须放置在域名的根目录或者 .well-known 目录下，</p><p>2、在本地测试跟路径是否有效。</p><p>方法：将<code>apple-app-site-association</code>放置好后，我们执行<code>hexo s</code>，则我们就能成功访问<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>，进而<a href="http://localhost:4000/apple-app-site-association" target="_blank" rel="noopener">http://localhost:4000/apple-app-site-association</a>。</p><p><img src="/iOS/功能性技术/iOS功能-Universal Link(通用链接)/iOS功能-Universal Link(通用链接" alt="UniversalLinks_test1">/UniversalLinks_test1.png)</p><p>3、本地可以后，就部署到服务器</p><p>测试部署成功与否，通过浏览器访问<a href="https://dvlproad.github.io/apple-app-site-association">https://dvlproad.github.io/apple-app-site-association</a></p><p>1、优先本地部署测试，即 hexo s 后，通过浏览器访问：<br><a href="http://localhost:4000/apple-app-site-association" target="_blank" rel="noopener">http://localhost:4000/apple-app-site-association</a> 如果可以下载则文件位置放置在根目录正确。<br>2、本地测试通过后，进行远程部署 hexo g 和 hexo d 测试，及通过浏览器访问：<br><a href="https://dvlproad.github.io/apple-app-site-association">https://dvlproad.github.io/apple-app-site-association</a><br>如果可以下载代表在1的基础上，远程部署也成功了。<br>如果无法访问/下载，而又确认部署完成了，那一般是部署了但还没同步到域名地址上的问题。建议等等或者再部署一下看看。</p><h3 id="3、写一个通用链接并测试"><a href="#3、写一个通用链接并测试" class="headerlink" title="3、写一个通用链接并测试"></a>3、写一个通用链接并测试</h3><p>为进一步了解知道哪些链接是通用链接，哪些不是。我们以上述例子进行说明。</p><p>则对于<code>com.dvlproad.Beyond1</code>这个app，由于paths是<code>[ &quot;*&quot; ]</code>，</p><p>即只要是<code>dvlproad.com</code>开头的链接都是通用链接。</p><p>而对于<code>com.dvlproad.Beyond2</code>这个app，由于paths是<code>[ &quot;app&quot; ]</code>，</p><p>所以，只有以<code>dvlproad.com/app</code>开头的链接才是通用链接。即形如 dvlproad.com/app/111、dvlproad.com/app/abc 等都是通用链接。</p><p>通用链接的测试方法，请按上面已经写玩的<em>Universal Links的表现及测试</em>进行测试，不再累述。</p><h2 id="四、Universal-Links的使用"><a href="#四、Universal-Links的使用" class="headerlink" title="四、Universal Links的使用"></a>四、Universal Links的使用</h2><p>在AppDelegate添加下面的方法处理Universal Links</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//TODO:后台进入前台/通用链接</span><br><span class="line">#pragma mark - Universal Link</span><br><span class="line">- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void(^)(NSArray&lt;id&lt;UIUserActivityRestoring&gt;&gt; * __nullable restorableObjects))restorationHandler &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;userActivity : %@&quot;,userActivity.webpageURL.description);</span><br><span class="line">    if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb]) &#123;</span><br><span class="line">        NSURL *webUrl = userActivity.webpageURL;</span><br><span class="line">        NSArray *universalLinks = LUCKIN_UNIVERSALLINKS;</span><br><span class="line">        BOOL isUniversalLinks = NO;</span><br><span class="line">        for (NSString *universalLink in universalLinks) &#123;</span><br><span class="line">            isUniversalLinks = [webUrl.host isEqualToString:universalLink];</span><br><span class="line">            if (isUniversalLinks) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isUniversalLinks) &#123;</span><br><span class="line">            //TODO:判断域名是自己的网站，进行我们需要的处理</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [[UIApplication sharedApplication] openURL:webUrl];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用Universal Links启动APP时就会调用上面的方法。</p><p>把我们设置好通用链接的URL放到备忘录中，长按URL会多出一条在“××××”中打开，当你点击时就会打开你的APP，并且在上面的方法中将URL传给你处理。</p><h2 id="五、微信配Universal-Links"><a href="#五、微信配Universal-Links" class="headerlink" title="五、微信配Universal Links"></a>五、微信配Universal Links</h2><p>微信SDK的最新版本openSDK1.8.6 开始，需要进行Universal Links配置。</p><h3 id="1、分析微信配Universal-Links的原因"><a href="#1、分析微信配Universal-Links的原因" class="headerlink" title="1、分析微信配Universal Links的原因"></a>1、分析微信配Universal Links的原因</h3><p>回顾iOS9之前，假设一个页面在微信app内部打开，其要跳转到app，一般需要先跳转到浏览器，如Safari中，然后才能再进行scheme跳转到我们的应用。</p><p><img src="/iOS/功能性技术/iOS功能-Universal Link(通用链接)/UniversalLinks_wechat1.png" alt="UniversalLinks_wechat1" style="zoom:25%;"></p><p>而有了Universal Links后，现在你用微信打开的页面，跳转的时候，即可直接跳转到app中，不用再经过浏览器。</p><h3 id="2、微信配Universal-Links的操作"><a href="#2、微信配Universal-Links的操作" class="headerlink" title="2、微信配Universal Links的操作"></a>2、微信配Universal Links的操作</h3><h4 id="2-1、基本分享操作的支持"><a href="#2-1、基本分享操作的支持" class="headerlink" title="2.1、基本分享操作的支持"></a>2.1、基本分享操作的支持</h4><p>微信分享配置Universal Links的有两个地方。</p><p>1、微信开放平台 <a href="https://open.weixin.qq.com" target="_blank" rel="noopener">https://open.weixin.qq.com</a> 上对应app的Universal Links配置</p><p><img src="/iOS/功能性技术/iOS功能-Universal Link(通用链接)/iOS功能-Universal Link(通用链接" alt="UniversalLinks_wechat_Set1">/UniversalLinks_wechat_Set1.png)</p><p>2、微信SDK使用时候的Universal Links配置。</p><p>如果上述两个值设置不一样，会导致在app中点击分享的时候，没法正常调起分享操作。错误信息如下：</p><p><img src="/iOS/功能性技术/iOS功能-Universal Link(通用链接)/UniversalLinks_wechat_error1.png" alt="UniversalLinks_wechat_error1" style="zoom: 33%;"></p><p>我们知道Universal Links是用来做通用链接的。但要完成这一步的操作不需要我们去开<code>Associated Domains</code>和上传<code>apple-app-site-association</code>才能完成基本的分享操作了。</p><h4 id="2-2、分享完微信能够正常返回"><a href="#2-2、分享完微信能够正常返回" class="headerlink" title="2.2、分享完微信能够正常返回"></a>2.2、分享完微信能够正常返回</h4><p>iOS 9系统策略更新，限制了http协议的访问，需要在“Info.plist”中将要使用的URL Schemes列为白名单，才可正常检查其他应用是否安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">    &lt;string&gt;weixin&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;weixinULAPI&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;</span><br><span class="line">    &lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure><h4 id="2-3、可以在微信内部直接跳转到app"><a href="#2-3、可以在微信内部直接跳转到app" class="headerlink" title="2.3、可以在微信内部直接跳转到app"></a>2.3、可以在微信内部直接跳转到app</h4><p>实现Universal Links的实现。即</p><p>1、开启配置 Associated Domains</p><p>2、制作上传 apple-app-site-association</p><p>上面已说明，请查看上面内容。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT常识</title>
      <link href="/%E5%B8%B8%E8%AF%86%E7%B1%BB/Office%E5%B8%B8%E8%AF%86/PPT%E5%B8%B8%E8%AF%86/"/>
      <url>/%E5%B8%B8%E8%AF%86%E7%B1%BB/Office%E5%B8%B8%E8%AF%86/PPT%E5%B8%B8%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="PPT母版"><a href="#PPT母版" class="headerlink" title="PPT母版"></a>PPT母版</h2><ul><li><a href="https://baijiahao.baidu.com/s?id=1636110219743238793&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">PPT母版真的好用的不要不要的！谁用谁知道！</a></li></ul><h3 id="PPT占位图"><a href="#PPT占位图" class="headerlink" title="PPT占位图"></a>PPT占位图</h3><ul><li><p><a href="https://www.zhihu.com/question/278013482" target="_blank" rel="noopener">WPS office2016怎么插入占位符？</a></p><p>占位符需要在母版中插入，通过［视图→幻灯片母版］，可进入「幻灯片母版」视图。</p><p>进入之后，会发现，<strong>WPS演示中并不能直接插入新的占位符，不过，默认的母版及其下各版式中，已经有各种类型的占位符（标题占位符、文本占位符、竖排文字占位符、内容占位符、图片占位符）了。</strong></p><p>所以可以通过【复制】原有版式，或者仅复制版式中特定的占位符，来实现新的占位符的添加。</p></li></ul><p>附：</p><ul><li><a href="http://blog.sina.com.cn/s/blog_62f256ba0102v7ar.html" target="_blank" rel="noopener">自定义母版图片占位符的形状</a></li></ul><h2 id="Office-Word-PPT-高亮"><a href="#Office-Word-PPT-高亮" class="headerlink" title="Office Word/PPT 高亮"></a>Office Word/PPT 高亮</h2><p>需求，将以下代码在word、ppt中进行高亮显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;LKImagesUploadList</span><br><span class="line">    imageModels=&#123;this.state.imageModels&#125;</span><br><span class="line">    isEditing=&#123;this.state.isEditing&#125;</span><br><span class="line">    supportBrowseImage=&#123;true&#125;</span><br><span class="line">    imageModelsChangeBlock=&#123;(imageModels)=&gt;&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            imageModels: imageModels</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://blog.csdn.net/qq_33575901/article/details/95198303?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-16.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-16.nonecase" target="_blank" rel="noopener">在word中插入带语法高亮功能的代码</a> (不推荐，虽然可以，但是不好看)</p><p>借助一个网站的功能即可搞定，网址：<a href="http://www.planetb.ca/syntax-highlight-word" target="_blank" rel="noopener">http://www.planetb.ca/syntax-highlight-word</a></p><p>只需复制点击Show Highlighted后生成的那个新页面中的代码内容，将其粘贴到word中即可看到我们想要的带语法高亮功能的代码了。</p></li><li><p><a href="https://www.cnblogs.com/tsingke/p/9573975.html" target="_blank" rel="noopener">如何在ppt或word中添加高亮代码的几种方法</a></p><p>特别说明：<strong>使得代码在PPT可以高亮的方法是从word中复制带格式(Commond+Alt+V)的代码到PPT来</strong>。</p><p>所以，首先看使得代码在word文件中高亮的方法步骤如下：</p><p><strong>高亮方法一：比SciTE更加强大的软件，HightLight，官网是：<a href="http://www.andre-simon.de/" target="_blank" rel="noopener">http://www.andre-simon.de/</a> </strong> 往下看还有个更好用的<a href="https://romannurik.github.io/SlidesCodeHighlighter/" target="_blank" rel="noopener">在线代码高亮网站</a></p><p>操作方法：</p><p>①、在自己的文件中复制要修改的代码</p><p>②、进入highlight工具中的<code>Clipboard标签页</code>，<strong>Paste from clipboard</strong></p><p>③、选择输入的<code>Select syntax</code>为对应的语言</p><p>④、选择输出为<strong>RTF</strong>，然后执行<code>Copy preview to clipboard</code></p><p>⑤、打开word文件，粘贴(Command+V)</p><p>至此，已完成代码在word文件中的高亮。接下来才能执行代码在ppt中的高亮。</p><p>⑥、将高亮的代码，拷贝粘贴到word。</p><p>⑦、再从word中复制粘贴到ppt中即可完成。</p><p>附1：<strong>目前HighLight使用的主题风格</strong>有 </p><p>①light+Acid、同时在word中对该区域的填充颜色为</p><p>②dark+dark blue、同时在word中对该区域的填充颜色为黑蓝色</p><p>附2：对HightLight软件其他功能的使用说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插件python_ref_python_org.lua（视情况添加）即可在后续生成的代码中加入函数引用出处</span><br></pre></td></tr></table></figure><p><strong>高亮方法二：<a href="https://romannurik.github.io/SlidesCodeHighlighter/" target="_blank" rel="noopener">在线代码高亮网站</a>  强烈推荐</strong></p><p>操作方法：也是高亮后，拷贝粘贴到word，再从word中复制粘贴到ppt中。</p><p>参考文章：<a href="https://www.aspirantzhang.com/network/ppt-syntax-hightlight.html" target="_blank" rel="noopener">在PowerPoint中插入高亮代码的方法一则</a></p></li></ul><h1 id="团队介绍的ppt"><a href="#团队介绍的ppt" class="headerlink" title="团队介绍的ppt"></a>团队介绍的ppt</h1><ul><li><a href="https://www.zhihu.com/question/68041152" target="_blank" rel="noopener">如何做团队介绍的ppt？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术常识</title>
      <link href="/%E5%B8%B8%E8%AF%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3%E5%B8%B8%E8%AF%86/"/>
      <url>/%E5%B8%B8%E8%AF%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3%E5%B8%B8%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、判断图片是png还是jpg或者jpeg"><a href="#一、判断图片是png还是jpg或者jpeg" class="headerlink" title="一、判断图片是png还是jpg或者jpeg"></a>一、判断图片是png还是jpg或者jpeg</h2><h3 id="1、快速数据判断方法："><a href="#1、快速数据判断方法：" class="headerlink" title="1、快速数据判断方法："></a>1、快速数据判断方法：</h3><p>PNG格式的图片去除后缀后用记事本/Sublime打开的显示结果如下：</p><p><img src="/常识类/技术常识/图片相关常识/图片格式判断1.png" alt="PNG格式的图片去除后缀后用记事本/Sublime打开的显示结果"></p><p>JPEG格式的图片去除后缀后用记事本/Sublime打开的显示结果如下：</p><p><img src="/常识类/技术常识/图片相关常识/图片格式判断2.png" alt="JPEG格式的图片去除后缀后用记事本/Sublime打开的显示结果"></p><h3 id="2、代码判断方法："><a href="#2、代码判断方法：" class="headerlink" title="2、代码判断方法："></a>2、代码判断方法：</h3><p>参考文档：<a href="https://blog.csdn.net/lsy2013/article/details/42965805" target="_blank" rel="noopener">iOS判断图片是png还是jpg或者jpeg</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的网站</title>
      <link href="/%E5%B8%B8%E8%AF%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/"/>
      <url>/%E5%B8%B8%E8%AF%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>好用的网站</p><p><a href="https://www.macbl.com" target="_blank" rel="noopener">https://www.macbl.com</a></p><p><a href="https://xclient.info" target="_blank" rel="noopener">https://xclient.info</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学上学常识</title>
      <link href="/%E5%B8%B8%E8%AF%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/%E7%A7%91%E5%AD%A6%E4%B8%8A%E5%AD%A6%E5%B8%B8%E8%AF%86/"/>
      <url>/%E5%B8%B8%E8%AF%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/%E7%A7%91%E5%AD%A6%E4%B8%8A%E5%AD%A6%E5%B8%B8%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-为什么访问不了github-io类的网站："><a href="#1-为什么访问不了github-io类的网站：" class="headerlink" title="1.为什么访问不了github.io类的网站："></a>1.为什么访问不了github.io类的网站：</h3><p>上网查找后看到有两种说法：</p><ol><li>DNS的问题：DNS污染（域名指向不正确的IP地址）</li><li>github.io禁止中国的ip</li></ol><h3 id="2-如何访问"><a href="#2-如何访问" class="headerlink" title="2.如何访问"></a>2.如何访问</h3><p>（参考：<a href="https://tieba.baidu.com/p/6865126778）" target="_blank" rel="noopener">https://tieba.baidu.com/p/6865126778）</a></p><p>通过 <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a> 链接查找到github.io的IP地址，一般是四个地址任选一个；</p><p><img src="/常识类/技术常识/科学上学常识/image-20201116231422201.png" alt="image-20201116231422201" style="zoom: 33%;"></p><p>找到/etc/hosts文件，Windows一般在/Windows/System32/drivers/etc目录下，MAC在/private/etc目录下，添加一行。</p><p><img src="/常识类/技术常识/科学上学常识/image-20201116231638326.png" alt="image-20201116231638326" style="zoom:50%;"></p><p>例如：要访问：<a href="https://dvlproad.github.io/">https://dvlproad.github.io/</a></p><p>则在hosts添加：</p><p>185.199.108.153 dvlproad.github.io</p>]]></content>
      
      
      <categories>
          
          <category> 技术常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>developer</title>
      <link href="/developer/Apple/"/>
      <url>/developer/Apple/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS描述文件位置：</p><p><code>~/Library/MobileDevice/Provisioning Profiles</code></p><h2 id="一、申请证书"><a href="#一、申请证书" class="headerlink" title="一、申请证书"></a>一、申请证书</h2><h3 id="1、CSR"><a href="#1、CSR" class="headerlink" title="1、CSR"></a>1、CSR</h3><p><img src="/developer/Apple/Apple1CSR.png" alt="CSR"></p><p>选择类型</p><p><img src="/developer/Apple/Apple2.png" alt="image-20190610152950274"></p><p>上传添加CSR</p><p><img src="/developer/Apple/Apple3UploadCSR.png" alt="image-20190610153103669"></p><p>选择后，</p><p><img src="/developer/Apple/Apple4.png" alt="image-20190610153244042"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>developer</title>
      <link href="/developer/developer/"/>
      <url>/developer/developer/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>npmjs的发布</title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/npmjs/npmjs%E7%9A%84%E5%8F%91%E5%B8%83/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/npmjs/npmjs%E7%9A%84%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本的操作"><a href="#一、基本的操作" class="headerlink" title="一、基本的操作"></a>一、基本的操作</h2><p><strong>npmjs的官网地址：<a href="https://www.npmjs.com" target="_blank" rel="noopener">https://www.npmjs.com</a></strong></p><p>以上传本地的 <a href="/Users/lichaoqian/Project/TestNPM">~/Project/TestNPM</a> 为例。</p><h3 id="1、镜像的处理"><a href="#1、镜像的处理" class="headerlink" title="1、镜像的处理"></a>1、镜像的处理</h3><h4 id="1-1、查看npm当前登录源-使用的镜像"><a href="#1-1、查看npm当前登录源-使用的镜像" class="headerlink" title="1.1、查看npm当前登录源/使用的镜像"></a>1.1、查看npm当前登录源/使用的镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><h4 id="1-2、设置镜像"><a href="#1-2、设置镜像" class="headerlink" title="1.2、设置镜像"></a>1.2、设置镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmjs.org/# 上传包必须使用原本的登录源</span><br><span class="line">npm config set registry https://registry.npm.taobao.org/# 原来错误的登录源</span><br></pre></td></tr></table></figure><p>附：为了上传npm包能够成功，所以，如果你之前使用的是淘宝镜像，那么你就得执行此命令替换回原来的镜像。</p><h3 id="2、npm的登录-连接"><a href="#2、npm的登录-连接" class="headerlink" title="2、npm的登录/连接"></a>2、npm的登录/连接</h3><p>npm login的命令及执行结果如下：</p><p><img src="/代码管理/库管理/npmjs/npmjs的发布/npm login error.png" alt="错误的npm login"></p><p>可以看到这边登录到了淘宝了，是错误的。</p><p><img src="/代码管理/库管理/npmjs/npmjs的发布/npm login correct.png" alt="正确的npm login"></p><p>## </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line"></span><br><span class="line">npm login</span><br><span class="line"></span><br><span class="line">npm publish --access=public</span><br></pre></td></tr></table></figure><p>附：如果你执意使用错误的登录源后，那么再去publish会出现如下错误。</p><p>错误1：<code>npm ERR! 403 Forbidden - PUT https://registry.npm.taobao.org/testnpm - [no_perms] Private mode enable, only admin can publish this module</code></p><p><img src="/代码管理/库管理/npmjs/npmjs的发布/npm publish error403_1.png" alt="错误的登录源，导致的publish错误"></p><p>错误2：<code>npm ERR! 403 Forbidden - PUT https://registry.npmjs.org/testnpm - You do not have permission to publish &quot;testnpm&quot;. Are you logged in as the correct user?</code></p><p>原因：组件版本已存在，更新版本号/版本名(如果该版本的名字已被占用)，然后重新npm publish。</p><p>比如这里我们使用了已经被占用的<a href="https://www.npmjs.com/package/testnpm" target="_blank" rel="noopener">testnpm</a></p><p><img src="/代码管理/库管理/npmjs/npmjs的发布/npm publish error403_2.png" alt="image-20190610112228108"></p><p>修改成未被占用的名字lcqtestnpm，再npm publish后，</p><p><img src="/代码管理/库管理/npmjs/npmjs的发布/npm publish error403_3.png" alt="npm publish连接超时"></p><p>网络翻墙后，再执行npm publish后，结果如下：</p><p><img src="/代码管理/库管理/npmjs/npmjs的发布/npm publish correct.png" alt="正确执行的结果如下"></p><p>附：提交后的包地址为<a href="https://www.npmjs.com/package/lcqtestnpm" target="_blank" rel="noopener">https://www.npmjs.com/package/lcqtestnpm</a></p>]]></content>
      
      
      <categories>
          
          <category> npmjs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npmjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npmjs的调试</title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/npmjs/npmjs%E7%9A%84%E8%B0%83%E8%AF%95/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/npmjs/npmjs%E7%9A%84%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>[Toc]</p><p>参考文章：<a href="https://my.oschina.net/jamesview/blog/1858828?from=groupmessage" target="_blank" rel="noopener">npm link,你不知道的npm模块调试技巧</a></p><h2 id="一、基本的操作"><a href="#一、基本的操作" class="headerlink" title="一、基本的操作"></a>一、基本的操作</h2><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>node 应用开发中，我们不可避免的需要使用或拆分为 npm 模块，经常遇到的一个问题是：</p><blockquote><p>新开发或修改的 npm 模块，如何在项目中试验？</p></blockquote><p>新同学一般会有以下几种方式：</p><p>为了方便示范，我们假设项目是 <code>my-project</code>, 需要用到一个独立的 <code>my-utils</code> 模块</p><h3 id="1-1-发布一个-beta-版本"><a href="#1-1-发布一个-beta-版本" class="headerlink" title="1.1 发布一个 beta 版本"></a>1.1 发布一个 beta 版本</h3><ul><li>优点：你高兴就好。</li><li><strong>缺点：</strong> 无趣+无趣+无趣，麻烦+麻烦+麻烦。</li></ul><h3 id="1-2-直接用相对路径安装"><a href="#1-2-直接用相对路径安装" class="headerlink" title="1.2 直接用相对路径安装"></a>1.2 直接用相对路径安装</h3><h4 id="方式1：终端npm-install-路径"><a href="#方式1：终端npm-install-路径" class="headerlink" title="方式1：终端npm install 路径"></a>方式1：终端npm install 路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd path/to/my-project</span><br><span class="line">$ npm install path/to/my-utils</span><br></pre></td></tr></table></figure><ul><li>优点：简单明了</li><li><strong>缺点：</strong> 调试过程中往往需要微调，此时需要切换到 my-utils 目录修改，然后反复重新 install，很麻烦。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd xxx/demo</span><br><span class="line">npm install ../react-native-theme-overlay</span><br><span class="line">附：../react-native-theme-overlay 这个路径是react-native-theme-overlay这个库其自身的pageage.json文件所在的路径</span><br><span class="line"></span><br><span class="line">则package.json中</span><br><span class="line">原来：</span><br><span class="line">    &quot;react-native-theme-overlay&quot;: &quot;^0.8.3&quot;,</span><br><span class="line">现在：</span><br><span class="line">    &quot;react-native-theme-overlay&quot;: &quot;file:../react-native-theme-overlay&quot;,</span><br></pre></td></tr></table></figure><h4 id="方式2：直接在demo的package-json中处理。"><a href="#方式2：直接在demo的package-json中处理。" class="headerlink" title="方式2：直接在demo的package.json中处理。"></a>方式2：直接在demo的package.json中处理。</h4><p>做法，如上例子，直接写”file:../react-native-theme-overlay”</p><h4 id="问题：如果调试的b库，依赖调试的a库，这个时候想a、b两个调试库都OK，应该怎么处理？"><a href="#问题：如果调试的b库，依赖调试的a库，这个时候想a、b两个调试库都OK，应该怎么处理？" class="headerlink" title="问题：如果调试的b库，依赖调试的a库，这个时候想a、b两个调试库都OK，应该怎么处理？"></a>问题：如果调试的b库，依赖调试的a库，这个时候想a、b两个调试库都OK，应该怎么处理？</h4><p>答：</p><h3 id="1-3-使用软链"><a href="#1-3-使用软链" class="headerlink" title="1.3 使用软链"></a>1.3 使用软链</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd path/to/my-project/node_modules</span><br><span class="line">$ ln -s path/to/my-utils my-utils</span><br></pre></td></tr></table></figure><ul><li>优点：软链后，两边修改直接同步</li><li><strong>缺点：</strong> 指令操作麻烦，不同操作系统语法不一样</li></ul><h2 id="2-正解-npm-link"><a href="#2-正解-npm-link" class="headerlink" title="2. 正解 - npm link"></a>2. 正解 - npm link</h2><p>但其实 npm 本身已经对此类情况提供了专门的 <code>npm link</code> 指令。</p><p>相关文档： <a href="https://docs.npmjs.com/cli/link" target="_blank" rel="noopener">https://docs.npmjs.com/cli/link</a></p><p>下面我们简单介绍下用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd path/to/my-project</span><br><span class="line">$ npm link path/to/my-utils</span><br></pre></td></tr></table></figure><p>简单的替换一个单词，就搞定了，cool~</p><p>如果这两种的目录不在一起，那还有一种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ # 先去到模块目录，把它 link 到全局</span><br><span class="line">$ cd path/to/my-utils</span><br><span class="line">$ npm link</span><br><span class="line">$</span><br><span class="line">$ # 再去项目目录通过包名来 link</span><br><span class="line">$ cd path/to/my-project</span><br><span class="line">$ npm link my-utils</span><br></pre></td></tr></table></figure><p>该指令还可以用来调试 node cli 模块，譬如需要本地调试我们的 <a href="https://github.com/eggjs/egg-init" target="_blank" rel="noopener">egg-init</a>，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd path/to/egg-init</span><br><span class="line">$ npm link</span><br><span class="line">$ # 此时全局的 egg-init 指令就已经指向你的本地开发目录了</span><br><span class="line">$ egg-init # 即可</span><br></pre></td></tr></table></figure><p>想去掉 link 也很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm unlink my-utils </span><br><span class="line">或者 直接$ npm unlink 这样所有的link都会去除</span><br></pre></td></tr></table></figure><h2 id="3-写在最后"><a href="#3-写在最后" class="headerlink" title="3. 写在最后"></a>3. 写在最后</h2><ul><li>该方法只是为了最后一步调试，模块本身的正确性，应该更多的通过单元测试来保证。</li><li>单元测试相关内容，可以参见：<a href="https://eggjs.org/zh-cn/core/unittest.html" target="_blank" rel="noopener">单元测试</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> npmjs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npmjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4节：ReactNative必备的语言基础知识</title>
      <link href="/ReactNative/1%E5%85%A5%E9%97%A8/ReactNative%E5%BF%85%E5%A4%87%E7%9A%84%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/ReactNative/1%E5%85%A5%E9%97%A8/ReactNative%E5%BF%85%E5%A4%87%E7%9A%84%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative必备的语言基础知识"><a href="#ReactNative必备的语言基础知识" class="headerlink" title="ReactNative必备的语言基础知识"></a>ReactNative必备的语言基础知识</h1><p>参考文章：</p><ul><li><a href="http://wiki.jikexueyuan.com/project/es6/intro.html" target="_blank" rel="noopener">极客学院 ECMAScript 6 系列教程</a></li></ul><p>ReactNative的语法基础要求JS,JSX,ES6.其中ES6是这三种语法的核心。系统学习ES6的语法是ReactNative编程的基本要求。</p><p>下面记录ES6的典型语法的示例,以方便编程中的随时查用。</p><h2 id="一、关键字"><a href="#一、关键字" class="headerlink" title="一、关键字"></a>一、关键字</h2><p>参考文章：<a href="http://wiki.jikexueyuan.com/project/es6/let.html" target="_blank" rel="noopener">极客学院 ECMAScript 6 let 和 const 命令</a></p><table><thead><tr><th>关键字</th><th>用途</th><th>作用域</th><th></th></tr></thead><tbody><tr><td>const</td><td>声明常量，不可修改</td><td></td><td></td></tr><tr><td>var</td><td>声明变量</td><td></td><td></td></tr><tr><td>let</td><td>声明变量</td><td>let 声明的变量只在它所在的代码块有效</td><td>for 循环的计数器，就很合适使用 let 命令。</td></tr></tbody></table><h2 id="二、变量的解构赋值"><a href="#二、变量的解构赋值" class="headerlink" title="二、变量的解构赋值"></a>二、变量的解构赋值</h2><p>参考文章：</p><ul><li><p><a href="http://wiki.jikexueyuan.com/project/es6/destructuring.html" target="_blank" rel="noopener">极客学院 ECMAScript 6 变量的解构赋值</a></p></li><li><p><a href="https://www.cnblogs.com/xiaohuochai/p/7243166.html" target="_blank" rel="noopener">ES6解构赋值</a></p></li></ul><p>对变量复制时,当等号左边定义的变量和等号右边的赋值形式一致时,能够对变量自动赋值;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let &#123;a, b&#125; = &#123;a:&quot;x&quot;, b:&quot;y&quot;&#125;;</span><br><span class="line">//a = x, b = y;</span><br><span class="line"></span><br><span class="line">let [a, b] = [0, 1, 2, 3];</span><br><span class="line">//a=0, b = 1;</span><br><span class="line"></span><br><span class="line">let [a, ...b] = [0, 1, 2, 3];</span><br><span class="line">//a=0, b = [1,2,3];</span><br></pre></td></tr></table></figure><p>常见于：</p><ul><li>style的解构赋值</li></ul><h2 id="三、Generator函数"><a href="#三、Generator函数" class="headerlink" title="三、Generator函数"></a>三、Generator函数</h2><p>参考文章：<a href="http://wiki.jikexueyuan.com/project/es6/generator.html" target="_blank" rel="noopener">极客学院 ECMAScript 6 Generator 函数</a></p><p>通过在函数名前添加 <strong>*</strong> 和在方法中添加 <strong>yield</strong> 关键字来定义,控制函数的顺序执行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 设有如下函数</span><br><span class="line">function *genFun() &#123;</span><br><span class="line">      yield &apos;Lily&apos;;</span><br><span class="line">      yield &apos;Json&apos;;</span><br><span class="line">      return &apos;Niu&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 则以下第一种调用的写法及结果如下：</span><br><span class="line">    let gen = genFun();</span><br><span class="line">    genFun().next();//&#123;value: &apos;Lily&apos;, done: false&#125;</span><br><span class="line">    genFun().next();//&#123;value: &apos;Json&apos;, done: false&#125;</span><br><span class="line">    genFun().next();//&#123;value: &apos;Niu&apos;, done: true&#125;</span><br><span class="line"></span><br><span class="line">// 则以下第二种调用的写法及结果如下：</span><br><span class="line">for (i of gen) &#123;//使用for of 语句来遍历</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">//return后的元素,不会被遍历到</span><br><span class="line">Lily</span><br><span class="line">Json</span><br></pre></td></tr></table></figure><h2 id="四、Promise对象"><a href="#四、Promise对象" class="headerlink" title="四、Promise对象"></a>四、Promise对象</h2><p>参考文章：<a href="http://wiki.jikexueyuan.com/project/es6/promise.html" target="_blank" rel="noopener">极客学院 ECMAScript 6 Promise 对象</a></p><p>通过定义Promise和关键字then的结合，可以方便实现函数的成功回调和失败回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1)定义</span><br><span class="line">    var prom = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;download success&apos;)</span><br><span class="line">        resolve(&apos;success&apos;);</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    prom.then((flag) =&gt; &#123;</span><br><span class="line">      console.log(&apos;success block:&apos; + flag);</span><br><span class="line">    &#125;, (error) =&gt; &#123;</span><br><span class="line">      console.log(&apos;failure block:&apos; + error);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">(2)async关键字和Promise实例相结合,实现多个异步线程的顺序执行;</span><br><span class="line">    async function foo() &#123;</span><br><span class="line">      await new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;, 5000);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      console.log(&apos;await function completed&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    foo();</span><br><span class="line">//打印消息会在5s后resolve回调执行后,才执行;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第一章：ReactNative入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：ReactNative的Hello World</title>
      <link href="/ReactNative/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84Hello%20World/"/>
      <url>/ReactNative/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84Hello%20World/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第一章：ReactNative入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：ReactNative的Hello World</title>
      <link href="/React/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84Hello%20World/"/>
      <url>/React/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84Hello%20World/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第一章：ReactNative入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4节：React必备的语言基础知识</title>
      <link href="/React/1%E5%85%A5%E9%97%A8/React%E5%BF%85%E5%A4%87%E7%9A%84%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/React/1%E5%85%A5%E9%97%A8/React%E5%BF%85%E5%A4%87%E7%9A%84%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="React必备的语言基础知识"><a href="#React必备的语言基础知识" class="headerlink" title="React必备的语言基础知识"></a>React必备的语言基础知识</h1><p>参考文章：</p><ul><li><p><a href="https://www.cnblogs.com/52fhy/p/5425801.html" target="_blank" rel="noopener">Less:优雅的写CSS代码</a></p></li><li><p>其他查看：<a href="../../ReactNative/1入门/ReactNative必备的语言基础知识">第4节：ReactNative必备的语言基础知识</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
          <category> 第一章：React入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebStorm</title>
      <link href="/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/VSCode/"/>
      <url>/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/VSCode/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、注册码-破解"><a href="#一、注册码-破解" class="headerlink" title="一、注册码/破解"></a>一、注册码/破解</h2><h2 id="二、代码格式化"><a href="#二、代码格式化" class="headerlink" title="二、代码格式化"></a>二、代码格式化</h2><ul><li>参考文档：<a href="https://flutter.cn/docs/development/tools/formatting" target="_blank" rel="noopener">Flutter开发者中文网-开发工具-代码格式化</a></li></ul><p><img src="/编程工具/VSCode/image-20220318221847396.png" alt="image-20220318221847396"></p><p><img src="/编程工具/VSCode/image-20220317154211932.png" alt="image-20220317154211932"></p><h2 id="三、VSCode好用的工具"><a href="#三、VSCode好用的工具" class="headerlink" title="三、VSCode好用的工具"></a>三、VSCode好用的工具</h2><h3 id="1、koroFileHeader-vscode文件头部注释插件"><a href="#1、koroFileHeader-vscode文件头部注释插件" class="headerlink" title="1、koroFileHeader(vscode文件头部注释插件)"></a>1、koroFileHeader(vscode文件头部注释插件)</h3><p>1、安装</p><p><img src="/编程工具/VSCode/image-20220413163004512.png" alt="image-20220413163004512"></p><p>2、配置</p><p><img src="/编程工具/VSCode/image-20220413160825547.png" alt="image-20220413160825547"></p><p>初始值为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"diffEditor.ignoreTrimWhitespace"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"[dart]"</span>: &#123;</span><br><span class="line">        <span class="attr">"editor.formatOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"editor.formatOnType"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"editor.rulers"</span>: [</span><br><span class="line">            <span class="number">80</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"editor.selectionHighlight"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"editor.suggest.snippetsPreventQuickSuggestions"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"editor.suggestSelection"</span>: <span class="string">"first"</span>,</span><br><span class="line">        <span class="attr">"editor.tabCompletion"</span>: <span class="string">"onlySnippets"</span>,</span><br><span class="line">        <span class="attr">"editor.wordBasedSuggestions"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"workbench.colorTheme"</span>: <span class="string">"Visual Studio Dark"</span>,</span><br><span class="line">    <span class="attr">"eslint.alwaysShowStatus"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"dart.debugExternalLibraries"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"dart.debugSdkLibraries"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"dart.debugExternalPackageLibraries"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"dart.flutterSdkPath"</span>: <span class="string">"/Applications/flutter"</span>,</span><br><span class="line">    <span class="attr">"editor.formatOnSave"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在json后面加上以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// &quot;editor.fontSize&quot;: 20,</span><br><span class="line">// &quot;files.autoSave&quot;: &quot;onFocusChange&quot;,</span><br><span class="line">// &quot;editor.formatOnPaste&quot;: true,</span><br><span class="line">// &quot;workbench.colorTheme&quot;: &quot;Solarized Light&quot;,</span><br><span class="line">// &quot;[vue]&quot;: &#123;</span><br><span class="line">//     &quot;editor.defaultFormatter&quot;: &quot;octref.vetur&quot;</span><br><span class="line">// &#125;,</span><br><span class="line">// &quot;[javascript]&quot;: &#123;</span><br><span class="line">//     &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;</span><br><span class="line">// &#125;,</span><br><span class="line">&quot;fileheader.customMade&quot;: &#123;</span><br><span class="line">    &quot;Author&quot;: &quot;dvlproad&quot;,</span><br><span class="line">    &quot;Date&quot;: &quot;Do not edit&quot;,</span><br><span class="line">    &quot;LastEditors&quot;: &quot;填入自己的名字&quot;,</span><br><span class="line">    &quot;LastEditTime&quot;: &quot;Do not edit&quot;,</span><br><span class="line">    &quot;Description&quot;: &quot;&quot;,</span><br><span class="line">    &quot;FilePath&quot;: &quot;Do not edit&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&quot;fileheader.cursorMode&quot;: &#123;</span><br><span class="line">    &quot;description&quot;: &quot;&quot;,</span><br><span class="line">    &quot;event&quot;: &quot;&quot;,</span><br><span class="line">    &quot;param&quot;: &quot;&quot;,</span><br><span class="line">    &quot;return&quot;: &quot;&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;fileheader.configObj&quot;: &#123;</span><br><span class="line">    &quot;prohibitAutoAdd&quot;: [</span><br><span class="line">        &quot;json&quot;,</span><br><span class="line">        &quot;md&quot;,</span><br><span class="line">    ], // 禁止.json .md文件，自动添加头部注释</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>3、如何使用</p><p>文件头部添加注释:</p><p>快捷键：ctrl+alt+i<br>功能：保存文件的时候，自动更新最后的编辑时间和编辑人<br>在光标处添加函数注释:</p><p>快捷键：ctrl+alt+t<br>功能在光标处自动生成一个注释模板<br>效果</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: dvlproad</span></span><br><span class="line"><span class="comment"> * @Date: 2022-04-13 10:17:11</span></span><br><span class="line"><span class="comment"> * @LastEditors: 填入自己的名字</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2022-04-13 16:26:54</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> * @FilePath: /wish/Users/qian/Project/flutter_effect_kit/lib/src/hud/loading_util.dart</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="2、GitLens-VsCode中好用的git源代码管理插件：每一行代码旁边都有日志"><a href="#2、GitLens-VsCode中好用的git源代码管理插件：每一行代码旁边都有日志" class="headerlink" title="2、GitLens(VsCode中好用的git源代码管理插件：每一行代码旁边都有日志)"></a>2、GitLens(VsCode中好用的git源代码管理插件：每一行代码旁边都有日志)</h3><h2 id="四、VSCode快捷键"><a href="#四、VSCode快捷键" class="headerlink" title="四、VSCode快捷键"></a>四、VSCode快捷键</h2><p>VSCode快捷键1_前进后退</p><p><img src="/编程工具/VSCode/VSCode快捷键1_前进后退.png" alt="VSCode快捷键1_前进后退"></p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebStorm</title>
      <link href="/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/WebStorm/"/>
      <url>/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/WebStorm/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、注册码-破解"><a href="#一、注册码-破解" class="headerlink" title="一、注册码/破解"></a>一、注册码/破解</h2><p>注册码获取：</p><p>进入<a href="http://idea.lanyus.com" target="_blank" rel="noopener">http://idea.lanyus.com</a>进行获取。</p><h2 id="二、WebStorm好用的工具"><a href="#二、WebStorm好用的工具" class="headerlink" title="二、WebStorm好用的工具"></a>二、WebStorm好用的工具</h2><ul><li>IconViewer：<a href="https://blog.csdn.net/weixin_33779515/article/details/87149865" target="_blank" rel="noopener">WebStorm安装IconViewer插件</a></li><li><a href="https://blog.csdn.net/xs20691718/article/details/52269027" target="_blank" rel="noopener">webstorm 常用插件集合</a></li></ul><p>VSCode快捷键1_前进后退</p><p><img src="/编程工具/WebStorm/VSCode/VSCode快捷键1_前进后退.png" alt="VSCode快捷键1_前进后退"></p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebStorm</title>
      <link href="/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/WebStorm/WebStorm%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/WebStorm/WebStorm%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、WebStorm文档注释技巧"><a href="#一、WebStorm文档注释技巧" class="headerlink" title="一、WebStorm文档注释技巧"></a>一、WebStorm文档注释技巧</h2><ul><li>1、Webstorm设置 -&gt; <code>Live Template</code> -&gt; <code>JavaScript</code> -&gt; 右上角“<code>+</code>”</li></ul><p><img src="/编程工具/WebStorm/WebStorm的使用技巧/文档注释技巧.png" alt="文档注释技巧"></p><ul><li>2、文档注释技巧2_模板的编辑</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * $FileName$</span><br><span class="line"> *</span><br><span class="line"> * @Description: $FileDesc$</span><br><span class="line"> *</span><br><span class="line"> * @author      ciyouzen</span><br><span class="line"> * @email       dvlproad@163.com</span><br><span class="line"> * @date        $date$ $time$</span><br><span class="line"> *</span><br><span class="line"> * Copyright (c) dvlproad. All rights reserved.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><img src="/编程工具/WebStorm/WebStorm的使用技巧/文档注释技巧2_模板的编辑.png" alt="文档注释技巧2_模板的编辑"></p><p>①、设置模板内容中的变量定义</p><p><img src="/编程工具/WebStorm/WebStorm的使用技巧/文档注释技巧2_模板的编辑2_Edit Variables.png" alt="文档注释技巧2_模板的编辑2_Edit Variables"></p><p>②、勾选你选将该模板应用到的编程语言/地方</p><p><img src="/编程工具/WebStorm/WebStorm的使用技巧/文档注释技巧2_模板的编辑3_Define.png" alt="勾选你选将该模板应用到的编程语言/地方"></p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：ReactNative的调试</title>
      <link href="/ReactNative/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84%E8%B0%83%E8%AF%95/"/>
      <url>/ReactNative/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative"><a href="#ReactNative" class="headerlink" title="ReactNative"></a>ReactNative</h1><ul><li><p><a href="https://juejin.im/post/5be68e3b51882516c94e6b9c" target="_blank" rel="noopener">一篇写得不错的RN入门教程</a></p></li><li><p><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">RN中文网搭建开发环境</a></p></li></ul><h2 id="一、检测您是否具备了ReactNative的开发环境"><a href="#一、检测您是否具备了ReactNative的开发环境" class="headerlink" title="一、检测您是否具备了ReactNative的开发环境"></a>一、检测您是否具备了ReactNative的开发环境</h2><h3 id="1、环境已完善时"><a href="#1、环境已完善时" class="headerlink" title="1、环境已完善时"></a>1、环境已完善时</h3><p>无</p><h3 id="2、环境未完善时"><a href="#2、环境未完善时" class="headerlink" title="2、环境未完善时"></a>2、环境未完善时</h3><h4 id="2-1、React-Native-环境搭建"><a href="#2-1、React-Native-环境搭建" class="headerlink" title="2.1、React Native 环境搭建"></a>2.1、React Native 环境搭建</h4><ul><li>1、按照<a href="https://www.jianshu.com/p/a85cba2efb7a" target="_blank" rel="noopener">React Native 环境搭建和创建项目(Mac)</a>进行环境搭建。</li></ul><h2 id="二、react-native-cli"><a href="#二、react-native-cli" class="headerlink" title="二、react-native-cli"></a>二、react-native-cli</h2><h3 id="1、react-native-cli的安装"><a href="#1、react-native-cli的安装" class="headerlink" title="1、react-native-cli的安装"></a>1、react-native-cli的安装</h3><p><img src="/ReactNative/1入门/ReactNative的调试/react-native-cli的安装1.png" alt="react-native-cli的安装1"></p><h3 id="2、react-native-cli的使用"><a href="#2、react-native-cli的使用" class="headerlink" title="2、react-native-cli的使用"></a>2、react-native-cli的使用</h3><p><img src="/ReactNative/1入门/ReactNative的调试/react-native-cli的使用1.png" alt="react-native-cli的使用"></p>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第一章：ReactNative入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：ReactNative的调试</title>
      <link href="/React/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84%E8%B0%83%E8%AF%95/"/>
      <url>/React/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative"><a href="#ReactNative" class="headerlink" title="ReactNative"></a>ReactNative</h1><ul><li><p><a href="https://juejin.im/post/5be68e3b51882516c94e6b9c" target="_blank" rel="noopener">一篇写得不错的RN入门教程</a></p></li><li><p><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">RN中文网搭建开发环境</a></p></li></ul><h2 id="一、检测您是否具备了ReactNative的开发环境"><a href="#一、检测您是否具备了ReactNative的开发环境" class="headerlink" title="一、检测您是否具备了ReactNative的开发环境"></a>一、检测您是否具备了ReactNative的开发环境</h2><h3 id="1、环境已完善时"><a href="#1、环境已完善时" class="headerlink" title="1、环境已完善时"></a>1、环境已完善时</h3><p>无</p><h3 id="2、环境未完善时"><a href="#2、环境未完善时" class="headerlink" title="2、环境未完善时"></a>2、环境未完善时</h3><h4 id="2-1、React-Native-环境搭建"><a href="#2-1、React-Native-环境搭建" class="headerlink" title="2.1、React Native 环境搭建"></a>2.1、React Native 环境搭建</h4><ul><li>1、按照<a href="https://www.jianshu.com/p/a85cba2efb7a" target="_blank" rel="noopener">React Native 环境搭建和创建项目(Mac)</a>进行环境搭建。</li></ul><h2 id="二、react-native-cli"><a href="#二、react-native-cli" class="headerlink" title="二、react-native-cli"></a>二、react-native-cli</h2><h3 id="1、react-native-cli的安装"><a href="#1、react-native-cli的安装" class="headerlink" title="1、react-native-cli的安装"></a>1、react-native-cli的安装</h3><p><img src="/React/1入门/ReactNative的调试/react-native-cli的安装1.png" alt="react-native-cli的安装1"></p><h3 id="2、react-native-cli的使用"><a href="#2、react-native-cli的使用" class="headerlink" title="2、react-native-cli的使用"></a>2、react-native-cli的使用</h3><p><img src="/React/1入门/ReactNative的调试/Users/lichaoqian/Project/Github/dvlproadHexo/source/_posts/ReactNative/1入门/ReactNative的调试/react-native-cli的使用1.png" alt="react-native-cli的使用"></p>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第一章：ReactNative入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>protobuf的安装</title>
      <link href="/protobuf/protobuf%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/protobuf/protobuf%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="protobuf-iOS简单总结-编译、环境搭建"><a href="#protobuf-iOS简单总结-编译、环境搭建" class="headerlink" title="protobuf-iOS简单总结(编译、环境搭建)"></a>protobuf-iOS简单总结(编译、环境搭建)</h1><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>检查是否安装成功，执行 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --version</span><br></pre></td></tr></table></figure><p>一、安装流程</p><p><a href="https://blog.csdn.net/dalehui/article/details/17593383?utm_medium=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control" target="_blank" rel="noopener">https://blog.csdn.net/dalehui/article/details/17593383?utm_medium=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）进入终端 跳转至protobuf文件夹. cd xxxxxxxxxxxxxx(路径)</span><br><span class="line">（2）切换用户身份. sudo su </span><br><span class="line">（3）执行 ./configure</span><br><span class="line">（4）执行 make</span><br><span class="line">（5）执行 make check(可能message.cc会报错，解决办法请看下面)</span><br><span class="line">（6）执行 make install</span><br><span class="line">（7）检查是否安装成功，执行 protoc --version</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=./ --objc_out=./ XXX.proto</span><br></pre></td></tr></table></figure><p><img src="/protobuf/protobuf的安装/image-20201202200227595.png" alt="image-20201202200227595"></p><h1 id="如何编译protobuf-for-IOS"><a href="#如何编译protobuf-for-IOS" class="headerlink" title="如何编译protobuf for IOS"></a>如何编译protobuf for IOS</h1><p><a href="https://blog.csdn.net/u013654125/article/details/76992261?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control" target="_blank" rel="noopener">https://blog.csdn.net/u013654125/article/details/76992261?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>node</title>
      <link href="/node/node/"/>
      <url>/node/node/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="前言、查看之前是否安装过node"><a href="#前言、查看之前是否安装过node" class="headerlink" title="前言、查看之前是否安装过node"></a>前言、查看之前是否安装过node</h2><p>查看之前是否安装过node</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>常识：</p><p>终端执行<code>node -v</code>查看是否安装并配置了其环境变量。如果执行无果，也有可能是安装了，但未配置环境变量。又因为node的安装目录一般是放在 usr/src下。所以，查看命令为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd usr/src</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>如果看到本地有node文件即代表有安装了，只是不一定有配置环境变量</p><p><img src="/node/node/node_install_check1.png" alt="node_install_check"></p><p>如果没有安装， 则按以下步骤进行安装。</p><h2 id="一、node的安装"><a href="#一、node的安装" class="headerlink" title="一、node的安装"></a>一、node的安装</h2><h3 id="1、可视化安装node的方法"><a href="#1、可视化安装node的方法" class="headerlink" title="1、可视化安装node的方法"></a>1、可视化安装node的方法</h3><p>访问<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node官网</a>，下载稳定版</p><p><img src="/node/node/node download1.png" alt="image-20201022150722483"></p><p>安装即可。</p><h3 id="2、终端命令安装node的方法-云服务器安装常用的方式"><a href="#2、终端命令安装node的方法-云服务器安装常用的方式" class="headerlink" title="2、终端命令安装node的方法(云服务器安装常用的方式)"></a>2、终端命令安装node的方法(云服务器安装常用的方式)</h3><p>下面我们以在 <a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">CentOS 下源码安装 Node.js</a> 为例</p><h4 id="2-1、进入-https-nodejs-org-en-download-获取最新的Nodejs版本的下载地址-不建议使用最新的node版本，建议使用V12的"><a href="#2-1、进入-https-nodejs-org-en-download-获取最新的Nodejs版本的下载地址-不建议使用最新的node版本，建议使用V12的" class="headerlink" title="2.1、进入 https://nodejs.org/en/download/ 获取最新的Nodejs版本的下载地址(不建议使用最新的node版本，建议使用V12的)"></a>2.1、进入 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> 获取最新的Nodejs版本的下载地址(不建议使用最新的node版本，建议使用V12的)</h4><p><img src="/node/node/node_comman_install_1.png" alt="node_comman_install_1"></p><h5 id="Nodejs版本的下载注意：不建议使用最新的node版本，建议使用V12的"><a href="#Nodejs版本的下载注意：不建议使用最新的node版本，建议使用V12的" class="headerlink" title="Nodejs版本的下载注意：不建议使用最新的node版本，建议使用V12的"></a>Nodejs版本的下载注意：不建议使用最新的node版本，建议使用V12的</h5><p>否则如你使用V14的时候，执行yapi server会出现如下警告提示</p><p><img src="/node/node/image-20210804152703816.png" alt="image-20210804152703816"></p><p>出现这样的问题是node版本过高的原因，将版本14降到12便可以解决。首先将原node卸载，然后去官网下载12的版本</p><p>拷贝链接，得到  <a href="https://nodejs.org/dist/v14.15.1/node-v14.15.1.tar.gz" target="_blank" rel="noopener">https://nodejs.org/dist/v14.15.1/node-v14.15.1.tar.gz</a></p><p>在终端下载该版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/</span><br><span class="line">wget https://nodejs.org/dist/v14.15.1/node-v14.15.1.tar.gz</span><br></pre></td></tr></table></figure><p><img src="/node/node/node_comman_install_2.png" alt="node_comman_install_2"></p><h4 id="2-2、解压源码"><a href="#2-2、解压源码" class="headerlink" title="2.2、解压源码"></a>2.2、解压源码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls # 查看该目录下的文件</span><br><span class="line"></span><br><span class="line">tar zxvf node-v14.15.1.tar.gz # 解压制定的压缩包</span><br></pre></td></tr></table></figure><h4 id="2-3、编译安装"><a href="#2-3、编译安装" class="headerlink" title="2.3、编译安装"></a>2.3、编译安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd node-v14.15.1</span><br><span class="line">./configure --prefix=/usr/local/node/14.15.1</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="/node/node/node_comman_install_3.png" alt="node_comman_install3"></p><p>虽然看似成功了，但其实有警告。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: failed to autodetect C++ compiler version (CXX=g++)</span><br><span class="line">WARNING: warnings were emitted in the configure phase</span><br></pre></td></tr></table></figure><p>需要解决该警告，如果不解决就继续执行make命令，则会发生失败，失败截图如下：</p><p><img src="/node/node/node_comman_install_3_2.png" alt="node_comman_install_3_2"></p><p>所以，我们先需要安装gcc，安装gcc成功后，重新执行<code>./configure --prefix=/usr/local/node/14.15.1</code>确保命令成功，且无警告。才能保证后续的make等命令才能跟着成功。</p><p>安装gcc的命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ kernel-devel //安装gcc、c++编译器以及内核文件</span><br></pre></td></tr></table></figure><p><img src="/node/node/node_comman_install_3_gcc.png" alt="node_comman_install_3_gcc"></p><p>重新执行<code>./configure --prefix=/usr/local/node/14.15.1</code>命令，警告解除了</p><p><img src="/node/node/node_comman_install_3_success.png" alt="node_comman_install_3_success"></p><p>然后，我们继续剩余的还没执行的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>执行<code>make</code>成功的截图如下：（我表示在阿里云CentOS系统上，从早上10点多，执行到下午三点多才执行结束。好坑啊。。。。）</p><p><img src="/node/node/node_comman_install_4.png" alt="node_comman_install_4"></p><p><code>make install</code>的执行就很快了，几秒钟中结束。OK！</p><h4 id="2-4、-配置NODE-HOME，进入profile编辑环境变量"><a href="#2-4、-配置NODE-HOME，进入profile编辑环境变量" class="headerlink" title="2.4、 配置NODE_HOME，进入profile编辑环境变量"></a>2.4、 配置NODE_HOME，进入profile编辑环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>该文件内容初始如下截图：</p><p><img src="/node/node/node_comman_install_6.png" alt="node_comman_install_6"></p><p>输入字母i，进行插入模式，来设置 nodejs 环境变量，即在 <strong><em>export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL</em></strong> 一行的上面添加如下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#set for nodejs</span><br><span class="line">export NODE_HOME=/usr/local/node/14.15.1</span><br><span class="line">export PATH=$NODE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p><img src="/node/node/node_comman_install_6_2.png" alt="node_comman_install_6_2"></p><p>插入完成后，按ESC，然后输入:wq进行保存并退出。然后执行以下命令来编译/etc/profile 从而使刚才的环境变量配置生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p><img src="/node/node/node_comman_install_7.png" alt="node_comman_install_7"></p><p>验证是否安装配置成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>输出 v14.15.1 表示配置成功</p><p>npm模块安装路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/node/14.15.1/lib/node_modules/</span><br></pre></td></tr></table></figure><p>至此，命令安装nodejs结束。</p><p><strong>注：</strong>Nodejs 官网提供了编译好的 Linux 二进制包，你也可以下载下来直接应用。</p><h2 id="二、node指定版本的安装、切换、删除"><a href="#二、node指定版本的安装、切换、删除" class="headerlink" title="二、node指定版本的安装、切换、删除"></a>二、node指定版本的安装、切换、删除</h2><p>有时候你之前安装的node版本可能太高，导致在执行某些命令的时候识别不到，那时候，你可能需要切换下node版本。切换node版本的方法如下：</p><p>1、先利用工具n安装指定的node版本，再进行切换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前使用的node的版本</span></span><br><span class="line">node -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看npm的版本</span></span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装指定的node版本</span></span><br><span class="line">npm install -g n # 利用npm安装工具n，之后再用n来安装指定的node版本</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装指定版本（最好用），版本v自定义</span></span><br><span class="line">sudo n v12.19.0# 利用工具n来安装node指定的12.19.0的版本</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已经安装的版本</span></span><br><span class="line">sudo n rm 14.19.0</span><br></pre></td></tr></table></figure><p><img src="/node/node/image-20201118141002543.png" alt="image-20201118141002543"></p><p>2、进行node的版本的切换（不一定能够立即生效）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输入命令n进入node的版本切换界面</span></span><br><span class="line">n</span><br></pre></td></tr></table></figure><p><img src="/node/node/image-20201118141135112.png" alt="image-20201118141135112"></p><p>通过上下选择，选定指定的node版本，或者按q退出。</p><p>我们选定12.19.0的版本回车后，退出执行node -v查看当前的node版本，<strong>发现还是之前的版本</strong>。所以我们应该还要再执行一步生效操作。</p><p><img src="/node/node/image-20201118141320375.png" alt="image-20201118141320375"></p><p>3、添加环境变量，使得上述进行的node版本切换能够生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export NODE_HOME=/usr/local</span><br><span class="line">export PATH=$NODE_HOME/bin:$PATH</span><br><span class="line">export NODE_PATH=$NODE_HOME/lib/node_modules:$PATH</span><br><span class="line"></span><br><span class="line">source ~/.bash_profile# MacOS的环境变量文件</span><br><span class="line">source /etc/profile# 云服务器的环境变量文件</span><br><span class="line"></span><br><span class="line">node -v</span><br></pre></td></tr></table></figure><p><img src="/node/node/image-20201118141513712.png" alt="image-20201118141513712"></p><p>为避免每次都得终端执行export命令，建议 vim ~/.bash_profile</p><h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h2><p><code>sudo cnpm install -g n</code></p><p><img src="/node/node/node_n1.png" alt="image-20190517182929169"></p><p><code>sudo n stable</code></p><p><img src="/node/node/node_n2.png" alt="image-20190517183108288"></p><h2 id="二、npm执行警告⚠️处理"><a href="#二、npm执行警告⚠️处理" class="headerlink" title="二、npm执行警告⚠️处理"></a>二、npm执行警告⚠️处理</h2><h3 id="1、npm-解决缺失-core-js-的问题"><a href="#1、npm-解决缺失-core-js-的问题" class="headerlink" title="1、npm 解决缺失 core-js 的问题"></a>1、npm 解决缺失 core-js 的问题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core-js@1.2.7: core-js@&lt;2.6.5 is no longer maintained. Please, upgrade to core-js@3 or at least to actual version of core-js@2.</span><br></pre></td></tr></table></figure><p><img src="/node/node/node install warning1.png" alt="image-20190520002140149"></p><p>解决办法：使用 npm 或者 cnpm 执行以下命令<br>npm install core-js@3</p><h3 id="2、npm-解决缺失-react-dom-的问题"><a href="#2、npm-解决缺失-react-dom-的问题" class="headerlink" title="2、npm 解决缺失 react-dom 的问题"></a>2、npm 解决缺失 react-dom 的问题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antd@3.18.1 requires a peer of react-dom@&gt;=16.0.0 but none is installed. You must install peer dependencies yourself.</span><br></pre></td></tr></table></figure><p><img src="/node/node/node install warning2.png" alt="image-20190520003332237"></p><h3 id="3、npm-解决缺失-react-的问题"><a href="#3、npm-解决缺失-react-的问题" class="headerlink" title="3、npm 解决缺失 react 的问题"></a>3、npm 解决缺失 react 的问题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm WARN react-native@0.59.8 requires a peer of react@16.8.3 but none is installed. You must install peer dependencies yourself.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数学</title>
      <link href="/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"/>
      <url>/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>sin, cos都是三角函数，分别叫做“正弦”、“余弦”、“正切”。</p><p>在初中阶段，这三个三角函数是这样解释的：</p><p>在一个直角三角形中，设∠C=90°，∠A, B, C 所对的边分别记作 a,b,c，那么对于锐角∠A，它的对边 a 和斜边 c 的比值 a/c 叫做∠A的正弦，记作 sinA；它的邻直角边 b 和斜边 c 的比值 b/c 叫做∠A的余弦，记作 cosA；它的对边 a 和邻直角边 b 的比值 a/b 叫做∠A的正切，记作 tanA。</p><p>在高中阶段，这三个三角函数是这样解释的：</p><p>在一个平面直角坐标系中，以原点为圆心，1 为半径画一个圆，这个圆交 x 轴于 A 点。以 O 为旋转中心，将 A 点逆时针旋转一定的角度α至 B 点，设此时 B 点的坐标是(x,y)，那么此时 y 的值就叫做α的正弦，记作 sinα；此时 x 的值就叫做α的余弦，记作 cosα；y 与 x 的比值 y/x 就叫做α的正切，记作 tanα。</p><p><a href="https://iknow-pic.cdn.bcebos.com/9345d688d43f879407765cd3de1b0ef41ad53a45" target="_blank" rel="noopener"><img src="https://iknow-pic.cdn.bcebos.com/9345d688d43f879407765cd3de1b0ef41ad53a45?x-bce-process%3Dimage%2Fresize%2Cm_lfit%2Cw_600%2Ch_800%2Climit_1%2Fquality%2Cq_85%2Fformat%2Cf_jpg" alt="img"></a></p><p>asin,acos,atan应该是Matlab里的函数（程序），数学中分别被记为（也是规范的记法） arcsin, arccos,arctan, 分别是sin,cos,tan 的限制在 [-pi/2,pi/2], [0, pi], (-pi/2, pi/2) 的反函数（函数的逆）。（三角函数本身是没有反函数的）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数学</title>
      <link href="/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6-%E4%B8%89%E7%BB%B4/"/>
      <url>/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6-%E4%B8%89%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="三维空间中向量的旋转"><a href="#三维空间中向量的旋转" class="headerlink" title="三维空间中向量的旋转"></a>三维空间中向量的旋转</h1><ul><li><a href="https://blog.csdn.net/weixin_42694889/article/details/117063484?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-117063484.pc_agg_new_rank&amp;utm_term=三维空间向量旋转角度&amp;spm=1000.2123.3001.4430" target="_blank" rel="noopener">三维空间中向量的旋转</a></li></ul><p>问题</p><p>在三维空间中，计算一个向量 v v v（或点 v v v）绕另一个向量 u u u旋转 θ \theta θ角后的坐标。</p><p>方法</p><p>罗德里格旋转公式(Rodrigues’ Rotation Formula)：<br>v ′ = v c o s θ + u × v s i n θ + ( u ⋅ v ) u ( 1 − c o s θ ) v’ = v cos \theta + u \times v sin \theta + (u \cdot v) u ( 1 - cos \theta)<br>v<br>′<br> =vcosθ+u×vsinθ+(u⋅v)u(1−cosθ)</p><p>公式推导可见 <a href="https://zhuanlan.zhihu.com/p/85862903" target="_blank" rel="noopener">旋转之二 - 三维空间中的旋转:罗德里格旋转公式</a></p><ul><li><a href="https://blog.csdn.net/bobo553443/article/details/79481881" target="_blank" rel="noopener">Unity3D_向量（Vector3）数学基础</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS随笔</title>
      <link href="/%E9%9A%8F%E7%AC%94/iOS%E9%9A%8F%E7%AC%94/"/>
      <url>/%E9%9A%8F%E7%AC%94/iOS%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS-14-0-UIDatePicker坑"><a href="#iOS-14-0-UIDatePicker坑" class="headerlink" title="iOS 14.0 UIDatePicker坑"></a>iOS 14.0 UIDatePicker坑</h1><p><a href="https://www.jianshu.com/p/dc6434d19701" target="_blank" rel="noopener">https://www.jianshu.com/p/dc6434d19701</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.selectedBackgroundView = (&#123;</span><br><span class="line">        UIView *view = [UIView new];</span><br><span class="line">        view.backgroundColor = [UIColor colorWithRed:244/255.0 green:244/255.0 blue:244/255.0 alpha:1.0]; //#f4f4f4</span><br><span class="line">        view;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># [给 Pod 添加资源文件](http://blog.xianqu.org/2015/08/pod-resources/)</span><br><span class="line">  # 利用 resources 属性，这些资源文件在 build 时会被直接拷贝到 client target 的 mainBundle 里。这样就实现了把图片、音频、NIB等资源打包进最终应用程序的目的。</span><br><span class="line">  s.resources = [&apos;CQImagePickerSampleView/Modules/HealthCer/NDM/SimulateApiJSON/*&apos;]</span><br><span class="line">  # 利用 resource_bundles 属性，这些资源文件在 build 时会被拷贝到 指定的 customBundle 里。这样就实现了把图片、音频、NIB等资源打包进最终应用程序的目的。</span><br><span class="line">  s.resource_bundles = &#123;</span><br><span class="line">    &apos;CQImagePickerSampleView&apos; =&gt; [&apos;CQImagePickerSampleView/**/*.&#123;png,jpg&#125;&apos;] # CQImagePickerSampleView 为生成boudle的名称，可以随便起，但要记住，库里要用</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ReactNative</title>
      <link href="/ReactNative/ReactNative%20README/"/>
      <url>/ReactNative/ReactNative%20README/</url>
      
        <content type="html"><![CDATA[<h1 id="ReactNative"><a href="#ReactNative" class="headerlink" title="ReactNative"></a>ReactNative</h1><p>重要参考：</p><ul><li><a href="https://www.jianshu.com/p/5b185df2d11a" target="_blank" rel="noopener">1) React Native 简介与入门</a></li><li><a href="https://www.jianshu.com/p/a85cba2efb7a" target="_blank" rel="noopener">2)React Native 环境搭建和创建项目(Mac)</a></li><li><a href="https://www.jianshu.com/p/dfec60a479ec" target="_blank" rel="noopener">3) React Native 开发之IDE</a></li><li><a href="https://www.jianshu.com/p/35c3e08bfddd" target="_blank" rel="noopener">4) React Native 入门项目与解析</a></li><li><a href="https://www.jianshu.com/p/61a5fdbc9b35" target="_blank" rel="noopener">5) React Native 相关JS和React基础</a></li><li><a href="https://www.jianshu.com/p/72f8c1da0b65" target="_blank" rel="noopener">6) React Native 组件生命周期(ES6)</a></li><li><a href="https://www.jianshu.com/p/3dc9d70a790f" target="_blank" rel="noopener">7) React Native 集成到原生项目(iOS)</a></li><li><a href="https://www.jianshu.com/p/9d7dbf17daa5" target="_blank" rel="noopener">8) React Native 与原生之间的通信(iOS)</a></li><li><a href="https://www.jianshu.com/p/e16c91acce03" target="_blank" rel="noopener">9) React Native 封装原生ＵI组件(iOS)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactNative</title>
      <link href="/React/React%20README/"/>
      <url>/React/React%20README/</url>
      
        <content type="html"><![CDATA[<h1 id="ReactNative"><a href="#ReactNative" class="headerlink" title="ReactNative"></a>ReactNative</h1><p>重要参考：</p><ul><li><a href="https://www.jianshu.com/p/5b185df2d11a" target="_blank" rel="noopener">1) React Native 简介与入门</a></li><li><a href="https://www.jianshu.com/p/a85cba2efb7a" target="_blank" rel="noopener">2)React Native 环境搭建和创建项目(Mac)</a></li><li><a href="https://www.jianshu.com/p/dfec60a479ec" target="_blank" rel="noopener">3) React Native 开发之IDE</a></li><li><a href="https://www.jianshu.com/p/35c3e08bfddd" target="_blank" rel="noopener">4) React Native 入门项目与解析</a></li><li><a href="https://www.jianshu.com/p/61a5fdbc9b35" target="_blank" rel="noopener">5) React Native 相关JS和React基础</a></li><li><a href="https://www.jianshu.com/p/72f8c1da0b65" target="_blank" rel="noopener">6) React Native 组件生命周期(ES6)</a></li><li><a href="https://www.jianshu.com/p/3dc9d70a790f" target="_blank" rel="noopener">7) React Native 集成到原生项目(iOS)</a></li><li><a href="https://www.jianshu.com/p/9d7dbf17daa5" target="_blank" rel="noopener">8) React Native 与原生之间的通信(iOS)</a></li><li><a href="https://www.jianshu.com/p/e16c91acce03" target="_blank" rel="noopener">9) React Native 封装原生ＵI组件(iOS)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：ReactNative开发环境搭建与运行</title>
      <link href="/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Android_devices/"/>
      <url>/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Android_devices/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Android-devices"><a href="#Android-devices" class="headerlink" title="Android_devices"></a>Android_devices</h1><h2 id="一、Android中找不到devices的问题处理"><a href="#一、Android中找不到devices的问题处理" class="headerlink" title="一、Android中找不到devices的问题处理"></a>一、Android中找不到devices的问题处理</h2><p>查询设备，请使用<code>adb devices</code></p><p>错误提示：<code>error No Android devices connected.</code></p><p><img src="/编程工具/Android_devices/no_Android_device.png" alt="no_Android_device"></p><p>此时需要：</p><p>①、<code>adb kill-server</code></p><p>②、<code>adb start-server</code></p><p><code>adb devices</code></p><p>原因：模拟器在运行一段时间后，adb服务有可能会出现异常。这时需要重新对adb服务关闭和重启。</p><p>附：reload 命令<code>adb shell input keyevent 82</code></p><p>   安卓设备值来源：</p><p>  <img src="/编程工具/Android_devices/设备_adb devices.png" alt="设备_adb devices"></p>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第一章：ReactNative入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：ReactNative开发环境搭建与运行</title>
      <link href="/ReactNative/1%E5%85%A5%E9%97%A8/ReactNative%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/"/>
      <url>/ReactNative/1%E5%85%A5%E9%97%A8/ReactNative%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative"><a href="#ReactNative" class="headerlink" title="ReactNative"></a>ReactNative</h1><ul><li><p><a href="https://juejin.im/post/5be68e3b51882516c94e6b9c" target="_blank" rel="noopener">一篇写得不错的RN入门教程</a></p></li><li><p><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">RN中文网搭建开发环境</a></p></li></ul><h2 id="一、检测您是否具备了ReactNative的开发环境"><a href="#一、检测您是否具备了ReactNative的开发环境" class="headerlink" title="一、检测您是否具备了ReactNative的开发环境"></a>一、检测您是否具备了ReactNative的开发环境</h2><h3 id="1、环境已完善时"><a href="#1、环境已完善时" class="headerlink" title="1、环境已完善时"></a>1、环境已完善时</h3><p>无</p><h3 id="2、环境未完善时"><a href="#2、环境未完善时" class="headerlink" title="2、环境未完善时"></a>2、环境未完善时</h3><h4 id="2-1、React-Native-环境搭建"><a href="#2-1、React-Native-环境搭建" class="headerlink" title="2.1、React Native 环境搭建"></a>2.1、React Native 环境搭建</h4><ul><li>1、按照<a href="https://www.jianshu.com/p/a85cba2efb7a" target="_blank" rel="noopener">React Native 环境搭建和创建项目(Mac)</a>进行环境搭建。</li></ul><h2 id="二、创建第一个ReactNative项目"><a href="#二、创建第一个ReactNative项目" class="headerlink" title="二、创建第一个ReactNative项目"></a>二、创建第一个ReactNative项目</h2><h3 id="1、创建项目"><a href="#1、创建项目" class="headerlink" title="1、创建项目"></a>1、创建项目</h3><p>方法一：执行<code>react-native init cj_rn_logindemo</code></p><blockquote><p>此步骤会生成<strong>React Native依赖包<code>node_modules</code></strong>文件夹。每个项目中都要有这部分内容。且该部分的内容可以直接被复制使用。所以，创建项目还有另一个方法。</p></blockquote><p>生成的<code>cj_rn_logindemo</code>工程详见<a href="https://github.com/dvlproad/DvlproadPlatformLoginCollect/RN/cj_rn_logindemo" target="_blank" rel="noopener">cj_rn_logindemo</a></p><p>方法二：原有iOS项目集成RN</p><blockquote><p>参考来源：<a href="https://www.jianshu.com/p/3dc9d70a790f" target="_blank" rel="noopener">React Native 集成到原生项目(iOS)</a></p></blockquote><p>react-native 指定版本创建项目</p><p>因为<code>react-native</code>更新太快，每次<code>react-native init</code>初始化项目的时候，都会安装最新的rn版本，导致之前的一些api不兼容等问题。<br>所以我们需要安装指定版本的rn来初始化项目：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">react-native</span> <span class="selector-tag">init</span> <span class="selector-tag">demo</span> <span class="selector-tag">--version</span> 0<span class="selector-class">.59</span><span class="selector-class">.8</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">react-native 安装指定的版本</span><br><span class="line"></span><br><span class="line">react-native init name --version 0.xx.xx</span><br><span class="line"></span><br><span class="line">react-native 降低版本</span><br><span class="line"></span><br><span class="line">react-native --save [react-native@0.xx.xx](mailto:react-native@0.xx.xx)</span><br></pre></td></tr></table></figure><h2 id="三、运行ReactNative项目"><a href="#三、运行ReactNative项目" class="headerlink" title="三、运行ReactNative项目"></a>三、运行ReactNative项目</h2><h3 id="1、运行方法"><a href="#1、运行方法" class="headerlink" title="1、运行方法"></a>1、运行方法</h3><h4 id="1-1、常见运行方法"><a href="#1-1、常见运行方法" class="headerlink" title="1.1、常见运行方法"></a>1.1、常见运行方法</h4><p>命令行运行项目</p><blockquote><p>进入项目根目录<code>cd TestRNProject</code></p><p>运行iOS项目<code>react-native run-ios</code></p></blockquote><h4 id="1-2、像iOS原生那样在Xcode中运行"><a href="#1-2、像iOS原生那样在Xcode中运行" class="headerlink" title="1.2、像iOS原生那样在Xcode中运行"></a>1.2、像iOS原生那样在Xcode中运行</h4><blockquote><p>双击ios/TestRNProject.xcodeproj文件然后在Xcode中点击Run按钮。（最常用，对iOS开发者）</p></blockquote><h4 id="1-3、在WebStorm中直接运行"><a href="#1-3、在WebStorm中直接运行" class="headerlink" title="1.3、在WebStorm中直接运行"></a>1.3、在WebStorm中直接运行</h4><p>详见本文中的<code>附一、进阶：为WebStorm搭建React Native开发环境</code></p><h4 id="1-4、Android中找不到devices的问题处理"><a href="#1-4、Android中找不到devices的问题处理" class="headerlink" title="1.4、Android中找不到devices的问题处理"></a>1.4、Android中找不到devices的问题处理</h4><p>错误提示：<code>error No Android devices connected.</code></p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/rn_Android_device.png" alt="rn_Android_device"></p><p>此时需要：</p><p>①、<code>adb kill-server</code></p><p>②、<code>adb start-server</code></p><p>原因：模拟器在运行一段时间后，adb服务有可能会出现异常。这时需要重新对adb服务关闭和重启。</p><p>附：reload 命令<code>adb shell input keyevent 82</code></p><h3 id="2、运行项目的常见问题"><a href="#2、运行项目的常见问题" class="headerlink" title="2、运行项目的常见问题"></a>2、运行项目的常见问题</h3><h4 id="2-1、RN项目报错“RCTBundleURLProvider-h”-file-not-found"><a href="#2-1、RN项目报错“RCTBundleURLProvider-h”-file-not-found" class="headerlink" title="2.1、RN项目报错“RCTBundleURLProvider.h” file not found"></a>2.1、RN项目报错“RCTBundleURLProvider.h” file not found</h4><p>从网上下载别人的ReactNative项目，打开iOS项目的时候，xcode会报错，提示：“RCTBundleURLProvider.h” file not found</p><p>原因：node_modules文件夹不存在 或者 node_modules文件夹下的包和当前版本不匹配</p><p>解决方法：<br>1、打开Mac里面的终端，进入项目所在的文件夹目录；<br>2、把项目里面的 node_modules 文件夹删除掉，然后执行 npm install 命令<br>3、npm install安装完成后， 执行react-native upgrade命令<br>4、最后重新打开Xcode,clean一下，应该就没有问题了。</p><h2 id="附一、进阶：为WebStorm搭建React-Native开发环境"><a href="#附一、进阶：为WebStorm搭建React-Native开发环境" class="headerlink" title="附一、进阶：为WebStorm搭建React Native开发环境"></a>附一、进阶：为WebStorm搭建React Native开发环境</h2><p>PS：最近又回来搞RN了，以下虽然都是一些老知识了，但你也许有用</p><p><strong>问题背景：我不想在WebStorm/VSCode、终端、XCode中来回切换。我想在WebStorm直接运行ReactNative项目</strong><br><strong>问题背景：我不想在WebStorm/VSCode、终端、XCode中来回切换。我想在WebStorm直接运行ReactNative项目</strong><br><strong>问题背景：我不想在WebStorm/VSCode、终端、XCode中来回切换。我想在WebStorm直接运行ReactNative项目</strong></p><h3 id="1、为Run添加Add-New-Configuration"><a href="#1、为Run添加Add-New-Configuration" class="headerlink" title="1、为Run添加Add New Configuration"></a>1、为<strong>Run</strong>添加<code>Add New Configuration</code></h3><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/rn_WebStorm_setting1.png" alt="image-20190519205612140" style="zoom:50%;"></p><p>点击，<strong>Edit configurations…</strong>会进入如下界面</p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/rn_WebStorm_setting2.png" alt="image-20190519221955691"></p><p>点击 <strong>+</strong> ，选择<strong>npm</strong></p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/rn_WebStorm_setting3.png" alt="image-20190519222125672"></p><h3 id="2、完善所添加的Configuration内容"><a href="#2、完善所添加的Configuration内容" class="headerlink" title="2、完善所添加的Configuration内容"></a>2、完善所添加的Configuration内容</h3><p>外层内容填写如下：</p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/rn_WebStorm_setting4.png" alt="image-20190519222852727"></p><p>External tool内容如下：</p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/rn_WebStorm_setting5.png" alt="image-20190519223454054"></p><p>上述步骤2中的各值分别为：</p><ul><li><p>①<strong>Program：</strong></p><p>从<code>which react-native</code>中获得的 <strong><code>/usr/local/bin/react-native</code></strong></p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/rn_WebStorm_setting5_1.png" alt="image-20190519223703388"></p></li><li><p>②<strong>Arguments：</strong></p><p><strong><code>run-ios --simulator=&quot;iPhone Xʀ&quot;</code></strong></p><p><strong><code>run-ios --device=&quot;iPhone7_Qian&quot;</code></strong></p><p><strong><code>run-android --deviceId=&quot;emulator-5554&quot;</code></strong></p></li></ul><p>附：启动和关闭ADB服务（<code>adb start-server</code>和<code>adb kill-server</code>）</p><p>  iOS设备值来源：</p><p>  <img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/设备_iOS.png" alt="设备_iOS"></p><p>  安卓设备值来源：</p><p>  <img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/设备_adb devices.png" alt="设备_adb devices"></p><p>执行的命令有：</p><p>注：前提要cd到工程中后，执行<code>react-native run-android  --help</code>才有效。</p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/设备_react-native run-android  --help.png" alt="设备_react-native run-android  --help"></p><ul><li><p>③<strong>Working directory：</strong></p><p>建议通过如下图添加宏的方式添加Working directory值。</p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/rn_WebStorm_setting5_2.png" alt="image-20190519224816841"></p></li></ul><p>添加完成后的图为：</p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/rn_WebStorm_setting6.png" alt="image-20190519225336448"></p><p>至此，配置结束。接下来我们试下效果。</p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/分割图1.jpg" alt="恭喜，配置结束，休息一下吧"></p><h3 id="3、试下配置效果是否有效"><a href="#3、试下配置效果是否有效" class="headerlink" title="3、试下配置效果是否有效"></a>3、试下配置效果是否有效</h3><p>从<strong>Run</strong>菜单中选择刚才添加的执行项，其就会在执行我们所设置的选项，即执行<code>/usr/local/bin/react-native run-ios &quot;--simulator=iPhone Xʀ&quot;</code>。</p><p>执行结果如下：</p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/rn_WebStorm_setting7.png" alt="image-20190519225942964"></p><p>同样的其也会在终端中有如下显示：</p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/rn_WebStorm_setting8.png" alt="image-20190519231236234"></p><p>当然，如果你使用快捷键”Cmd+R”也能达到这个效果。</p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/rn_WebStorm_setting9.png" alt="image-20190519231502977"></p><p>经验证，配置无误，使用有效。</p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/分割图1.jpg" alt="经验证，配置无误，使用有效，打工告成"></p><h2 id="四、Xcode11问题"><a href="#四、Xcode11问题" class="headerlink" title="四、Xcode11问题"></a>四、Xcode11问题</h2><p><strong>2019.10.27: Could not find iPhone 11 simulator. Run CLI with –verbose flag for more details.</strong></p><p>1、初步分析：</p><p>Xcode 11无法在模拟器上运行React-Native应用程序。看结论为没有你想运行的那个模拟器iPhone X。<br>2、判断分析正确否：</p><p>单独运行模拟器，在顶部菜单中，在“硬件，设备，iOS 13.0”下查看。</p><p><img src="/ReactNative/1入门/ReactNative开发环境搭建与运行/rn_Could not find simulator.png" alt="rn_Could not find simulator" style="zoom:50%;"></p><p>①当您执行run-ios时，react-native旨在匹配请求的设备。内部硬编码默认值为iPhoneX。</p><p>②尝试匹配请求的设备的函数在：</p><p>/node_modules/@react-native-community/cli-platform-ios/build/commands/runIOS/findMatchingSimulator.js</p><p>设计此功能是为了使您可以为其提供设备和可选的版本号。</p><p>③如果找不到给定的设备和版本，则默认情况下它将使用列表中的第一个设备返回匹配项。</p><p>3、解决：</p><p>如上所述，首先自己运行模拟器，并记下所需的iPhone或iPad。</p><p>然后将此名称作为可选参数传递给run-ios命令行命令，如下所示：</p>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第一章：ReactNative入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：React开发环境搭建与运行</title>
      <link href="/React/1%E5%85%A5%E9%97%A8/React%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/"/>
      <url>/React/1%E5%85%A5%E9%97%A8/React%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><ul><li><p><a href="https://juejin.im/post/5be68e3b51882516c94e6b9c" target="_blank" rel="noopener">一篇写得不错的RN入门教程</a></p></li><li><p><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">RN中文网搭建开发环境</a></p></li></ul><h2 id="一、检测您是否具备了ReactNative的开发环境"><a href="#一、检测您是否具备了ReactNative的开发环境" class="headerlink" title="一、检测您是否具备了ReactNative的开发环境"></a>一、检测您是否具备了ReactNative的开发环境</h2><h3 id="1、环境已完善时"><a href="#1、环境已完善时" class="headerlink" title="1、环境已完善时"></a>1、环境已完善时</h3><p>无</p><h3 id="2、环境未完善时"><a href="#2、环境未完善时" class="headerlink" title="2、环境未完善时"></a>2、环境未完善时</h3><h4 id="2-1、React-Native-环境搭建"><a href="#2-1、React-Native-环境搭建" class="headerlink" title="2.1、React Native 环境搭建"></a>2.1、React Native 环境搭建</h4><ul><li><p>1、按照<a href="https://zh-hans.reactjs.org/docs/create-a-new-react-app.html" target="_blank" rel="noopener">创建新的 React 应用</a>进行环境搭建。</p></li><li><p>安装方法：<code>npm install create-react-app -g</code></p></li><li>创建一个应用：<code>create-react-app my-app</code></li></ul><h2 id="二、创建第一个ReactNative项目"><a href="#二、创建第一个ReactNative项目" class="headerlink" title="二、创建第一个ReactNative项目"></a>二、创建第一个ReactNative项目</h2><h3 id="1、创建项目"><a href="#1、创建项目" class="headerlink" title="1、创建项目"></a>1、创建项目</h3><p>方法一：执行<code>react-native init cj_rn_logindemo</code></p><blockquote><p>此步骤会生成<strong>React Native依赖包<code>node_modules</code></strong>文件夹。每个项目中都要有这部分内容。且该部分的内容可以直接被复制使用。所以，创建项目还有另一个方法。</p></blockquote><p>生成的<code>cj_rn_logindemo</code>工程详见<a href="https://github.com/dvlproad/DvlproadPlatformLoginCollect/RN/cj_rn_logindemo" target="_blank" rel="noopener">cj_rn_logindemo</a></p><p>方法二：原有iOS项目集成RN</p><blockquote><p>参考来源：<a href="https://www.jianshu.com/p/3dc9d70a790f" target="_blank" rel="noopener">React Native 集成到原生项目(iOS)</a></p></blockquote><p>react-native 指定版本创建项目</p><p>因为<code>react-native</code>更新太快，每次<code>react-native init</code>初始化项目的时候，都会安装最新的rn版本，导致之前的一些api不兼容等问题。<br>所以我们需要安装指定版本的rn来初始化项目：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">react-native</span> <span class="selector-tag">init</span> <span class="selector-tag">demo</span> <span class="selector-tag">--version</span> 0<span class="selector-class">.59</span><span class="selector-class">.8</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">react-native 安装指定的版本</span><br><span class="line"></span><br><span class="line">react-native init name --version 0.xx.xx</span><br><span class="line"></span><br><span class="line">react-native 降低版本</span><br><span class="line"></span><br><span class="line">react-native --save [react-native@0.xx.xx](mailto:react-native@0.xx.xx)</span><br></pre></td></tr></table></figure><h2 id="三、运行ReactNative项目"><a href="#三、运行ReactNative项目" class="headerlink" title="三、运行ReactNative项目"></a>三、运行ReactNative项目</h2><h3 id="1、运行方法"><a href="#1、运行方法" class="headerlink" title="1、运行方法"></a>1、运行方法</h3><h4 id="1-1、常见运行方法"><a href="#1-1、常见运行方法" class="headerlink" title="1.1、常见运行方法"></a>1.1、常见运行方法</h4><p>命令行运行项目</p><blockquote><p>进入项目根目录<code>cd TestRNProject</code></p><p>运行iOS项目<code>react-native run-ios</code></p></blockquote><h4 id="1-2、像iOS原生那样在Xcode中运行"><a href="#1-2、像iOS原生那样在Xcode中运行" class="headerlink" title="1.2、像iOS原生那样在Xcode中运行"></a>1.2、像iOS原生那样在Xcode中运行</h4><blockquote><p>双击ios/TestRNProject.xcodeproj文件然后在Xcode中点击Run按钮。（最常用，对iOS开发者）</p></blockquote><h4 id="1-3、在WebStorm中直接运行"><a href="#1-3、在WebStorm中直接运行" class="headerlink" title="1.3、在WebStorm中直接运行"></a>1.3、在WebStorm中直接运行</h4><p>详见本文中的<code>附一、进阶：为WebStorm搭建React Native开发环境</code></p><h4 id="1-4、Android中找不到devices的问题处理"><a href="#1-4、Android中找不到devices的问题处理" class="headerlink" title="1.4、Android中找不到devices的问题处理"></a>1.4、Android中找不到devices的问题处理</h4><p>错误提示：<code>error No Android devices connected.</code></p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/rn_Android_device.png" alt="rn_Android_device"></p><p>此时需要：</p><p>①、<code>adb kill-server</code></p><p>②、<code>adb start-server</code></p><p>原因：模拟器在运行一段时间后，adb服务有可能会出现异常。这时需要重新对adb服务关闭和重启。</p><p>附：reload 命令<code>adb shell input keyevent 82</code></p><h3 id="2、运行项目的常见问题"><a href="#2、运行项目的常见问题" class="headerlink" title="2、运行项目的常见问题"></a>2、运行项目的常见问题</h3><h4 id="2-1、RN项目报错“RCTBundleURLProvider-h”-file-not-found"><a href="#2-1、RN项目报错“RCTBundleURLProvider-h”-file-not-found" class="headerlink" title="2.1、RN项目报错“RCTBundleURLProvider.h” file not found"></a>2.1、RN项目报错“RCTBundleURLProvider.h” file not found</h4><p>从网上下载别人的ReactNative项目，打开iOS项目的时候，xcode会报错，提示：“RCTBundleURLProvider.h” file not found</p><p>原因：node_modules文件夹不存在 或者 node_modules文件夹下的包和当前版本不匹配</p><p>解决方法：<br>1、打开Mac里面的终端，进入项目所在的文件夹目录；<br>2、把项目里面的 node_modules 文件夹删除掉，然后执行 npm install 命令<br>3、npm install安装完成后， 执行react-native upgrade命令<br>4、最后重新打开Xcode,clean一下，应该就没有问题了。</p><h2 id="附一、进阶：为WebStorm搭建React-Native开发环境"><a href="#附一、进阶：为WebStorm搭建React-Native开发环境" class="headerlink" title="附一、进阶：为WebStorm搭建React Native开发环境"></a>附一、进阶：为WebStorm搭建React Native开发环境</h2><p>PS：最近又回来搞RN了，以下虽然都是一些老知识了，但你也许有用</p><p><strong>问题背景：我不想在WebStorm/VSCode、终端、XCode中来回切换。我想在WebStorm直接运行ReactNative项目</strong><br><strong>问题背景：我不想在WebStorm/VSCode、终端、XCode中来回切换。我想在WebStorm直接运行ReactNative项目</strong><br><strong>问题背景：我不想在WebStorm/VSCode、终端、XCode中来回切换。我想在WebStorm直接运行ReactNative项目</strong></p><h3 id="1、为Run添加Add-New-Configuration"><a href="#1、为Run添加Add-New-Configuration" class="headerlink" title="1、为Run添加Add New Configuration"></a>1、为<strong>Run</strong>添加<code>Add New Configuration</code></h3><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/rn_WebStorm_setting1.png" alt="image-20190519205612140" style="zoom:50%;"></p><p>点击，<strong>Edit configurations…</strong>会进入如下界面</p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/rn_WebStorm_setting2.png" alt="image-20190519221955691"></p><p>点击 <strong>+</strong> ，选择<strong>npm</strong></p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/rn_WebStorm_setting3.png" alt="image-20190519222125672"></p><h3 id="2、完善所添加的Configuration内容"><a href="#2、完善所添加的Configuration内容" class="headerlink" title="2、完善所添加的Configuration内容"></a>2、完善所添加的Configuration内容</h3><p>外层内容填写如下：</p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/rn_WebStorm_setting4.png" alt="image-20190519222852727"></p><p>External tool内容如下：</p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/rn_WebStorm_setting5.png" alt="image-20190519223454054"></p><p>上述步骤2中的各值分别为：</p><ul><li><p>①<strong>Program：</strong></p><p>从<code>which react-native</code>中获得的 <strong><code>/usr/local/bin/react-native</code></strong></p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/rn_WebStorm_setting5_1.png" alt="image-20190519223703388"></p></li><li><p>②<strong>Arguments：</strong></p><p><strong><code>run-ios --simulator=&quot;iPhone Xʀ&quot;</code></strong></p><p><strong><code>run-ios --device=&quot;iPhone7_Qian&quot;</code></strong></p><p><strong><code>run-android --deviceId=&quot;emulator-5554&quot;</code></strong></p></li></ul><p>附：启动和关闭ADB服务（<code>adb start-server</code>和<code>adb kill-server</code>）</p><p>  iOS设备值来源：</p><p>  <img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/设备_iOS.png" alt="设备_iOS"></p><p>  安卓设备值来源：</p><p>  <img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/设备_adb devices.png" alt="设备_adb devices"></p><p>执行的命令有：</p><p>注：前提要cd到工程中后，执行<code>react-native run-android  --help</code>才有效。</p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/设备_react-native run-android  --help.png" alt="设备_react-native run-android  --help"></p><ul><li><p>③<strong>Working directory：</strong></p><p>建议通过如下图添加宏的方式添加Working directory值。</p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/rn_WebStorm_setting5_2.png" alt="image-20190519224816841"></p></li></ul><p>添加完成后的图为：</p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/rn_WebStorm_setting6.png" alt="image-20190519225336448"></p><p>至此，配置结束。接下来我们试下效果。</p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/分割图1.jpg" alt="恭喜，配置结束，休息一下吧"></p><h3 id="3、试下配置效果是否有效"><a href="#3、试下配置效果是否有效" class="headerlink" title="3、试下配置效果是否有效"></a>3、试下配置效果是否有效</h3><p>从<strong>Run</strong>菜单中选择刚才添加的执行项，其就会在执行我们所设置的选项，即执行<code>/usr/local/bin/react-native run-ios &quot;--simulator=iPhone Xʀ&quot;</code>。</p><p>执行结果如下：</p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/rn_WebStorm_setting7.png" alt="image-20190519225942964"></p><p>同样的其也会在终端中有如下显示：</p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/rn_WebStorm_setting8.png" alt="image-20190519231236234"></p><p>当然，如果你使用快捷键”Cmd+R”也能达到这个效果。</p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/rn_WebStorm_setting9.png" alt="image-20190519231502977"></p><p>经验证，配置无误，使用有效。</p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/分割图1.jpg" alt="经验证，配置无误，使用有效，打工告成"></p><h2 id="四、Xcode11问题"><a href="#四、Xcode11问题" class="headerlink" title="四、Xcode11问题"></a>四、Xcode11问题</h2><p><strong>2019.10.27: Could not find iPhone 11 simulator. Run CLI with –verbose flag for more details.</strong></p><p>1、初步分析：</p><p>Xcode 11无法在模拟器上运行React-Native应用程序。看结论为没有你想运行的那个模拟器iPhone X。<br>2、判断分析正确否：</p><p>单独运行模拟器，在顶部菜单中，在“硬件，设备，iOS 13.0”下查看。</p><p><img src="/React/1入门/React开发环境搭建与运行/ReactNative开发环境搭建与运行/rn_Could not find simulator.png" alt="rn_Could not find simulator" style="zoom:50%;"></p><p>①当您执行run-ios时，react-native旨在匹配请求的设备。内部硬编码默认值为iPhoneX。</p><p>②尝试匹配请求的设备的函数在：</p><p>/node_modules/@react-native-community/cli-platform-ios/build/commands/runIOS/findMatchingSimulator.js</p><p>设计此功能是为了使您可以为其提供设备和可选的版本号。</p><p>③如果找不到给定的设备和版本，则默认情况下它将使用列表中的第一个设备返回匹配项。</p><p>3、解决：</p><p>如上所述，首先自己运行模拟器，并记下所需的iPhone或iPad。</p><p>然后将此名称作为可选参数传递给run-ios命令行命令，如下所示：</p>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第一章：React入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weex</title>
      <link href="/Weex/1%E5%85%A5%E9%97%A8/Weex%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/"/>
      <url>/Weex/1%E5%85%A5%E9%97%A8/Weex%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h1><h2 id="一、集成-Weex-到已有应用"><a href="#一、集成-Weex-到已有应用" class="headerlink" title="一、集成 Weex 到已有应用"></a>一、集成 Weex 到已有应用</h2><p><a href="http://weex-project.io/cn/guide/integrate-to-your-app.html" target="_blank" rel="noopener">集成 Weex 到已有应用(官网)</a></p><h2 id="二、创建Weex项目"><a href="#二、创建Weex项目" class="headerlink" title="二、创建Weex项目"></a>二、创建Weex项目</h2><p>创建Weex项目方法：</p><ul><li><p>①、在终端执行<code>weex create 目录</code>即可。</p><p>②、cd 到<code>项目/platforms/platforms.json</code>所在的<code>platforms</code>目录下执行<code>sudo npm run pack:ios</code>(如果不是在该目录会提示您platforms.json的错误)</p></li><li><p>在使用前，请使用<code>weex -v</code>进行weex环境检测。详见<code>【附1】Weex开发环境检测</code></p></li></ul><h2 id="三、Weex编码"><a href="#三、Weex编码" class="headerlink" title="三、Weex编码"></a>三、Weex编码</h2><ul><li><p>编写.we/vue代码</p></li><li><p>将.we/vue代码文件转为js文件放入项目中</p></li></ul><h4 id="1、将-we-vue文件转换成-js文件的终端命令"><a href="#1、将-we-vue文件转换成-js文件的终端命令" class="headerlink" title="1、将.we/vue文件转换成 js文件的终端命令"></a>1、将<code>.we/vue</code>文件转换成 js文件的终端命令</h4><table><thead><tr><th>.we/vue 转换成 js文件的终端命令</th><th>作用</th><th></th></tr></thead><tbody><tr><td>weex compile dir js</td><td>会将dir文件夹下的所有we文件转换到js文件夹下</td><td></td></tr><tr><td>weex compile dir/xxx.we  js</td><td>会将dir文件夹下的xxx.we文件转换为js文件存到js文件夹下</td><td></td></tr><tr><td>weex compile dir/xxx.vue  js</td><td>会将dir文件夹下的xxx.vue文件转换为js文件存到js文件夹下</td></tr></tbody></table><h4 id="2、vue文件编写"><a href="#2、vue文件编写" class="headerlink" title="2、vue文件编写"></a>2、vue文件编写</h4><ul><li><p>可在<a href="http://dotwe.org/vue" target="_blank" rel="noopener">http://dotwe.org/vue</a>上编写</p></li><li><p>可再vue项目中编写</p></li></ul><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><blockquote><p>【附1】Weex开发环境检测</p><p>【附2】Weex工具WebStorm的安装</p></blockquote><h4 id="【附1】Weex开发环境检测"><a href="#【附1】Weex开发环境检测" class="headerlink" title="【附1】Weex开发环境检测"></a>【附1】Weex开发环境检测</h4><p>通过执行显示当前weex版本的<code>weex -v</code>命令，验证Weex开发环境是否都具备了，如果都成功的时候，其会如下图所示：</p><blockquote><p><img src="/Weex/1入门/Weex开发环境搭建与运行/weex%20-v%202.png" alt="image-20181217175137799"></p></blockquote><p>安装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 国外可使用方法：</span><br><span class="line">npm install -g weex-toolkit</span><br><span class="line"></span><br><span class="line">// 国内请使用方法，否则weekpack安装不上，导致weex create命令执行出错：</span><br><span class="line">sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm install -g weex-toolkit</span><br></pre></td></tr></table></figure><p>weex开发环境安装的命令对比</p><table><thead><tr><th style="text-align:left"></th><th>使用npm</th><th>使用cnpm</th></tr></thead><tbody><tr><td style="text-align:left">weex-bulider</td><td>安装成功</td><td>安装成功</td></tr><tr><td style="text-align:left">weex-previewer</td><td>安装成功</td><td>安装成功</td></tr><tr><td style="text-align:left">weexpack<br>(若无会导致执行weex create失败)</td><td>安装失败</td><td>安装成功</td></tr></tbody></table><p>更详细的weex安装请查看</p><ul><li><p><a href="http://weex.apache.org/cn/guide/set-up-env.html" target="_blank" rel="noopener">官网weex搭建开发环境</a></p></li><li><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node和npm的官网最新版本地址</a></p></li></ul><p>通常，安装了 Node.js 环境，npm 包管理工具也随之安装了。npm 是一个 JavaScript 包管理工具，它可以让开发者轻松共享和重用代码。</p><h6 id="遇到的问题1、weex-v命令-显示当前weex版本-一直报错"><a href="#遇到的问题1、weex-v命令-显示当前weex版本-一直报错" class="headerlink" title="遇到的问题1、weex -v命令(显示当前weex版本)一直报错"></a>遇到的问题1、<code>weex -v</code>命令(显示当前weex版本)一直报错</h6><p>解决办法：通过终端重新执行<code>npm install -g weex-toolkit</code>命令来<strong>重新安装weex</strong>。</p><h6 id="遇到的问题2、weex-create-项目名命令-创建weex项目-出错"><a href="#遇到的问题2、weex-create-项目名命令-创建weex项目-出错" class="headerlink" title="遇到的问题2、weex create 项目名命令(创建weex项目)出错"></a>遇到的问题2、<code>weex create 项目名</code>命令(创建weex项目)出错</h6><p>此问题，是你没正确安装weex-toolkit导致，详细看下个问题<code>npm install -g weex-toolkit</code>命令安装过程有错</p><h6 id="遇到的问题3、npm-install-g-weex-toolkit命令安装过程有错"><a href="#遇到的问题3、npm-install-g-weex-toolkit命令安装过程有错" class="headerlink" title="遇到的问题3、npm install -g weex-toolkit命令安装过程有错"></a>遇到的问题3、<code>npm install -g weex-toolkit</code>命令安装过程有错</h6><p>错误如下：</p><p><img src="/Weex/1入门/Weex开发环境搭建与运行/image-20181217173509332.png" alt="image-20181217173509332"></p><p>分析可得错误原因是：npm的安装权限不足。</p><p>加上<code>sudo</code>后，执行<code>sudo npm install -g weex-toolkit</code>依旧如此。</p><p>最终通过进入<code>/usr/local/lib/node_modules</code>删除之前已经安装的<code>weex-toolkit</code>后，然后执行<code>sudo npm install -g weex-toolkit</code>安装通过。此时你会发现安装过程还有一些错误提示</p><blockquote><p><img src="/Weex/1入门/Weex开发环境搭建与运行/安装weex-toolkit.png" alt="image-20181217175640331"></p></blockquote><p>此问题引起的连锁反应是①终端执行<code>weex -v</code>的结果只有weex-bulider和weex-previewer，没有weexpack，从而导致②终端执行<code>weex create 项目名</code>失败</p><blockquote><p><img src="/Weex/1入门/Weex开发环境搭建与运行/weex%20-v.png" alt="image-20181217174116400"></p></blockquote><h4 id="【附2】Weex工具WebStorm的安装"><a href="#【附2】Weex工具WebStorm的安装" class="headerlink" title="【附2】Weex工具WebStorm的安装"></a>【附2】Weex工具WebStorm的安装</h4><p>1、WebStorm软件安装&amp;破解</p><ul><li><a href="https://blog.csdn.net/voke_/article/details/76418116" target="_blank" rel="noopener">webstorm 2018 激活破解方法大全</a></li></ul><p>2、WebStorm配置vue环境</p><ul><li><a href="https://www.cnblogs.com/karthuslorin/p/8301282.html" target="_blank" rel="noopener">WebStorm配置Vue开发环境</a></li></ul><p>3、WebStorm其他配置</p><ul><li><a href="https://www.jianshu.com/p/4ce97b360c13" target="_blank" rel="noopener">WebStorm其他配置</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Weex </category>
          
          <category> 第一章：Weex入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> Weex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业版灰度流程</title>
      <link href="/iOS/%E8%BF%9B%E9%98%B6/%E4%BC%81%E4%B8%9A%E7%89%88%E7%81%B0%E5%BA%A6%E6%B5%81%E7%A8%8B/"/>
      <url>/iOS/%E8%BF%9B%E9%98%B6/%E4%BC%81%E4%B8%9A%E7%89%88%E7%81%B0%E5%BA%A6%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>企业版灰度流程</p><p><img src="/iOS/进阶/企业版灰度流程/企业版灰度流程.png" alt="企业版灰度流程" style="zoom: 50%;"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swifttify for Xcode</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Xcode%20Extensions/Swifttify%20for%20Xcode/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Xcode%20Extensions/Swifttify%20for%20Xcode/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Swifttify-for-Xcode"><a href="#一、Swifttify-for-Xcode" class="headerlink" title="一、Swifttify for Xcode"></a>一、Swifttify for Xcode</h2><p>使用的详细方法：</p><p><a href="https://objectivec2swift.com/#/xcode-extension/" target="_blank" rel="noopener">https://objectivec2swift.com/#/xcode-extension/</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能监控-①卡顿监控</title>
      <link href="/iOS/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7-%E2%91%A0%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7/"/>
      <url>/iOS/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7-%E2%91%A0%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="卡顿监控"><a href="#卡顿监控" class="headerlink" title="卡顿监控"></a>卡顿监控</h1><p>寻找卡顿的切入点</p><p>监控卡顿,最直接就是找到主线程都在干些啥玩意儿。</p><p>我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动，所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/5a136fbc60a4" target="_blank" rel="noopener">iOS 性能监控（一）—— CPU功耗监控</a><br><a href="https://www.jianshu.com/p/632d7a1526e9" target="_blank" rel="noopener">iOS 性能监控（二）—— 主线程卡顿监控</a><br><a href="https://www.jianshu.com/p/bc1c000afdba" target="_blank" rel="noopener">iOS 性能监控（三）—— 方法耗时监控</a></p><p><a href="https://www.jianshu.com/p/140de3e73ad8" target="_blank" rel="noopener">iOS-卡顿监测-FPS监测</a></p><p><a href="https://www.jianshu.com/p/d0aab0eb8ce4" target="_blank" rel="noopener">iOS实时卡顿检测-RunLoop(附实例)</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能监控-②其他</title>
      <link href="/iOS/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E2%91%A1%E5%85%B6%E4%BB%96/"/>
      <url>/iOS/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E2%91%A1%E5%85%B6%E4%BB%96/</url>
      
        <content type="html"><![CDATA[<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>[toc]</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p><a href="#耗电量、耗流量优化">一、耗电量、耗流量优化</a></p></li><li><p><a href="#内存优化、内存泄露处理">二、内存优化、内存泄露处理</a></p></li><li><p><a href="#UITableView的性能优化">三、UITableView的性能优化</a></p></li><li><p><a href="#其他优化">四、其他优化</a></p></li></ul><p></p><p id="耗电量、耗流量优化"></p><p></p><h2 id="一、耗电量、耗流量优化"><a href="#一、耗电量、耗流量优化" class="headerlink" title="一、耗电量、耗流量优化"></a>一、耗电量、耗流量优化</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>通过</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">①优化位置服务(尽量降低定位精度)、</span><br><span class="line">②网络操作(减少传输、压缩数据、缓存数据)、</span><br><span class="line">③任务处理(减少任务处理量、按需处理，常见于一些后台任务的处理，比如不需要计算里程时候，鹰眼服务可以先关闭)、</span><br><span class="line">④内容更新(减少app使用的视图数量、去除不必要的内容更新)、</span><br><span class="line">⑤定时器(降低触发频率、及时关闭不再需要的重复性定时器)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>优化参考文章：<a href="http://www.cocoachina.com/ios/20171204/21413.html" target="_blank" rel="noopener">iOS进阶–App功耗优化看这篇就够了</a></p><h6 id="定位服务：按需取用，定位频率该降低降低，该关闭关闭"><a href="#定位服务：按需取用，定位频率该降低降低，该关闭关闭" class="headerlink" title="定位服务：按需取用，定位频率该降低降低，该关闭关闭"></a>定位服务：按需取用，定位频率该降低降低，该关闭关闭</h6><blockquote><p>根据位置特性对静止不动的点、位置变化小的点、位置变化大的点，结合不同业务决定位置上报情况，减少不必要的上报，降低耗电量与节省流量。</p><p>相似问题参考：<a href="https://www.cnblogs.com/quxiangfu/p/6622551.html" target="_blank" rel="noopener">解决iOS地图持续定位耗电问题</a></p></blockquote><h6 id="网络请求优化的"><a href="#网络请求优化的" class="headerlink" title="网络请求优化的"></a>网络请求优化的</h6><blockquote><p>这个需要和后台API一起优化，尽量减少不必要的请求，比如一次API请求尽量把客户端要用到的数据都返回过来，而不是要通过多个请求去返回，同时最好注意数据分页，不要几万条数据都扔给客户端了。</p></blockquote><h6 id="CPU"><a href="#CPU" class="headerlink" title="CPU:"></a>CPU:</h6><blockquote><p>使用 Instruments 中的 Time Profile 时间分析工具用来检测应用CPU的使用情况。 定位 app 使用过程中占用高CPU、耗时长的地方。</p><p>使用方法参考：<a href="https://www.jianshu.com/p/21d29be26479" target="_blank" rel="noopener">Instrument 的 Time Profiler总结</a></p></blockquote><h6 id="Timer：合理使用Timer数和Timer时间间隔，不宜太短，满足需求即可"><a href="#Timer：合理使用Timer数和Timer时间间隔，不宜太短，满足需求即可" class="headerlink" title="Timer：合理使用Timer数和Timer时间间隔，不宜太短，满足需求即可"></a>Timer：合理使用Timer数和Timer时间间隔，不宜太短，满足需求即可</h6><blockquote><p>设置上报检测计时器(一般设为1秒，但合理的是取不同业务上报频率的最大公约数，比如报班状态下需要5秒上传一次位置，未报班状态只需要20上传一次位置，则取5秒)</p></blockquote><h6 id="合理使用线程，线程适量，不宜过多，不要阻塞主线程"><a href="#合理使用线程，线程适量，不宜过多，不要阻塞主线程" class="headerlink" title="合理使用线程，线程适量，不宜过多，不要阻塞主线程"></a>合理使用线程，线程适量，不宜过多，不要阻塞主线程</h6><blockquote><p>太多线程会导致消耗大量内存（在iOS中，如果把需要消耗大量时间的操作放在主线程上面，会妨碍主线程中被称为RunLoop的主循环的执行，从而导致不能更新用户界面、应用程序的画面长时间停滞等问题。）。</p></blockquote><h6 id="优化算法，减少循环次数"><a href="#优化算法，减少循环次数" class="headerlink" title="优化算法，减少循环次数"></a>优化算法，减少循环次数</h6><p>​    </p><p>还有关键的就是图片尺寸了，最好客户端需要啥尺寸，服务端就直接给啥尺寸，而不是到客户端上再缩放。</p><p></p><p id="内存优化、内存泄露处理"></p><p></p><h2 id="二、内存优化、内存泄露处理"><a href="#二、内存优化、内存泄露处理" class="headerlink" title="二、内存优化、内存泄露处理"></a>二、内存优化、内存泄露处理</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><h4 id="1、正确的地方使用-reuseIdentifier"><a href="#1、正确的地方使用-reuseIdentifier" class="headerlink" title="1、正确的地方使用 reuseIdentifier"></a>1、正确的地方使用 reuseIdentifier</h4><h4 id="2、内存泄漏"><a href="#2、内存泄漏" class="headerlink" title="2、内存泄漏"></a>2、内存泄漏</h4><p>1、使用Product-Analyze分析内存泄<br>利用Product-Analyze分析内存泄露，并不能把所有的内存泄露查出来，因为有的内存泄露是在运行时，用户操作时才产生的。那就需要用到Instruments了。</p><p>2、<a href="https://blog.csdn.net/mr_zhangrmwork/article/details/76210448" target="_blank" rel="noopener">使用Instruments检测定位并解决iOS内存泄露</a></p><p></p><p id="其他优化"></p><p></p><h2 id="三、其他优化"><a href="#三、其他优化" class="headerlink" title="三、其他优化"></a>三、其他优化</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><h5 id="问题：优化多线程处理，改善多线程嵌套严重，请求耗时的问题"><a href="#问题：优化多线程处理，改善多线程嵌套严重，请求耗时的问题" class="headerlink" title="问题：优化多线程处理，改善多线程嵌套严重，请求耗时的问题"></a>问题：优化多线程处理，改善多线程嵌套严重，请求耗时的问题</h5><p>解决：优化多线程处理，改善多线程嵌套严重，请求耗时的问题。</p><p>详细：原本项目，采用多线程嵌套的同步方式处理多个线程请求到数据后，再执行最后操作。经优化多线程处理为异步执行时，改善了多线程嵌套严重，请求耗时的问题。</p><h4 id="定时器使用的优化"><a href="#定时器使用的优化" class="headerlink" title="定时器使用的优化"></a>定时器使用的优化</h4><p>问题：定时器多，其在主线程</p><p>为什么要在非主线程创建NSTimer</p><p>将 timer 添加到主线程的Runloop里面本身会增加线程负荷<br>如果主线程因为某些原因阻塞卡顿了，timer 定时任务触发的时间精度肯定也会受到影响<br>有些定时任务不是UI相关的，本来就没必要在主线程执行，给主线程增加不必要的负担。当然也可以在定时任务执行时，手动将任务指派到非主线程上，但这也是有额外开销的。</p><h6 id="iOS-应用性能调优其他参考："><a href="#iOS-应用性能调优其他参考：" class="headerlink" title="iOS 应用性能调优其他参考："></a>iOS 应用性能调优其他参考：</h6><p>耗时(instruments的Time Profiler)、卡顿(主线程)</p><p><a href="http://www.jianshu.com/p/5cf9ac335aec" target="_blank" rel="noopener">iOS app性能优化的那些事</a> </p><p><a href="http://www.cocoachina.com/ios/20150408/11501.html" target="_blank" rel="noopener">iOS应用性能调优的25个建议和技巧</a></p><h2 id="四、渲染"><a href="#四、渲染" class="headerlink" title="四、渲染"></a>四、渲染</h2><p>参考文章：<a href="https://mp.weixin.qq.com/s/CfPw-UR4Jseix62bl3JlqQ" target="_blank" rel="noopener">iOS 渲染原理解析</a></p><h3 id="1、渲染原理CPU-与-GPU"><a href="#1、渲染原理CPU-与-GPU" class="headerlink" title="1、渲染原理CPU 与 GPU"></a>1、渲染原理CPU 与 GPU</h3><ul><li><strong>CPU（Central Processing Unit）</strong>：现代计算机整个系统的运算核心、控制核心。</li><li><strong>GPU（Graphics Processing Unit）</strong>：可进行绘图运算工作的专用微处理器，是连接计算机和显示终端的纽带。</li></ul><p>GPU 的渲染流程图</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zOnpE47IbCXG1mn3cZ1bv9KCvBA9qaWiancVQbr9rtnYjNFlyfIvPic8qzReTnwe2feBAEjaKhbVoRtkPlYmEr0g/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="GPU 的渲染流程图"></p><p><strong>1、Application 应用处理阶段：得到图元</strong></p><p>这个阶段具体指的就是<strong>图像在应用中被处理的阶段</strong>，此时还处于 CPU 负责的时期。在这个阶段应用可能会对图像进行一系列的操作或者改变，最终将新的图像信息传给下一阶段。这部分信息被叫做<strong>图元（primitives）</strong>，通常是三角形、线段、顶点等。</p><p><strong>2、Geometry 几何处理阶段：处理图元</strong></p><p><strong>3、Rasterization 光栅化阶段：图元转换为像素</strong></p><p><strong>光栅化的主要目的是将几何渲染之后的图元信息，转换为一系列的像素，以便后续显示在屏幕上。</strong>这个阶段中会根据图元信息，计算出每个图元所覆盖的像素信息等，从而将像素划分成不同的部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zOnpE47IbCXG1mn3cZ1bv9KCvBA9qaWiap8ic9w90fcbJzp9tX0LKbUKzUp8YdQYUO9xAkARaxRE5PjUva3Ha48g/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><strong>一种简单的划分就是根据中心点</strong>，如果像素的中心点在图元内部，那么这个像素就属于这个图元。如上图所示，深蓝色的线就是图元信息所构建出的三角形；而通过是否覆盖中心点，可以遍历出所有属于该图元的所有像素，即浅蓝色部分。</p><p><strong>4、Pixel 像素处理阶段：处理像素，得到位图</strong></p><p>经过上述光栅化阶段，我们得到了图元所对应的像素，此时，我们需要给这些像素填充颜色和效果。所以最后这个阶段就是给像素填充正确的内容，最终显示在屏幕上。这些经过处理、蕴含大量信息的像素点集合，被称作位图（bitmap）。</p><h2 id="2-屏幕成像与卡顿"><a href="#2-屏幕成像与卡顿" class="headerlink" title="2. 屏幕成像与卡顿"></a>2. 屏幕成像与卡顿</h2><h4 id="屏幕撕裂-Screen-Tearing"><a href="#屏幕撕裂-Screen-Tearing" class="headerlink" title="屏幕撕裂 Screen Tearing"></a>屏幕撕裂 Screen Tearing</h4><p>CPU+GPU 的渲染流程是一个非常耗时的过程。如果在电子束开始扫描新的一帧时，位图还没有渲染好，而是在扫描到屏幕中间时才渲染完成，那么已扫描的部分和未扫描的部分就不是同一帧图像，这就造成屏幕撕裂。</p><p>解决屏幕撕裂、提高显示效率的一个策略就是使用垂直同步信号 Vsync 与双缓冲机制 Double Buffering。</p><h4 id="屏幕卡顿的本质"><a href="#屏幕卡顿的本质" class="headerlink" title="屏幕卡顿的本质"></a>屏幕卡顿的本质</h4><p>手机使用卡顿的直接原因，就是掉帧。前文也说过，屏幕刷新频率必须要足够高才能流畅。对于 iPhone 手机来说，屏幕最大的刷新频率是 60 FPS，一般只要保证 50 FPS 就已经是较好的体验了。但是如果掉帧过多，导致刷新频率过低，就会造成不流畅的使用体验。</p><h4 id="CALayer-与-UIView-的关系"><a href="#CALayer-与-UIView-的关系" class="headerlink" title="CALayer 与 UIView 的关系"></a>CALayer 与 UIView 的关系</h4><p>当我们创建一个 UIView 的时候，UIView 会自动创建一个 CALayer，为自身提供存储 bitmap 的地方（也就是前文说的 <strong>backing store</strong>），并将自身固定设置为 CALayer 的代理。</p><p><strong>核心关系</strong>：</p><ol><li>CALayer 是 UIView 的属性之一，负责渲染和动画，提供可视内容的呈现。</li><li>UIView 提供了对 CALayer 部分功能的封装，同时也另外负责了交互事件的处理。</li></ol><p>有了这两个最关键的根本关系，那么下面这些经常出现在面试答案里的显性的异同就很好解释了。举几个例子：</p><ul><li><strong>相同的层级结构</strong>：我们对 UIView 的层级结构非常熟悉，由于每个 UIView 都对应 CALayer 负责页面的绘制，所以 CALayer 也具有相应的层级结构。</li><li><strong>部分效果的设置</strong>：因为 UIView 只对 CALayer 的部分功能进行了封装，而另一部分如圆角、阴影、边框等特效都需要通过调用 layer 属性来设置。</li><li><strong>是否响应点击事件</strong>：CALayer 不负责点击事件，所以不响应点击事件，而 UIView 会响应。</li><li><strong>不同继承关系</strong>：CALayer 继承自 NSObject，UIView 由于要负责交互事件，所以继承自 UIResponder。</li></ul><p>当然还剩最后一个问题，为什么要将 CALayer 独立出来，直接使用 UIView 统一管理不行吗？为什么不用一个统一的对象来处理所有事情呢？</p><p>这样设计的主要原因就是为了职责分离，拆分功能，方便代码的复用。通过 Core Animation 框架来负责可视内容的呈现，这样在 iOS 和 OS X 上都可以使用 Core Animation 进行渲染。与此同时，两个系统还可以根据交互规则的不同来进一步封装统一的控件，比如 iOS 有 UIKit 和 UIView，OS X 则是AppKit 和 NSView。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能监控-①TableView优化</title>
      <link href="/iOS/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E2%91%A0TableView%E4%BC%98%E5%8C%96/"/>
      <url>/iOS/%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E2%91%A0TableView%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="TableView优化"><a href="#TableView优化" class="headerlink" title="TableView优化"></a>TableView优化</h1><p>[toc]</p><h2 id="三、UITableView的性能优化"><a href="#三、UITableView的性能优化" class="headerlink" title="三、UITableView的性能优化"></a>三、UITableView的性能优化</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>参考资料：<a href="http://blog.csdn.net/u011452278/article/details/60961350" target="_blank" rel="noopener">UITableView性能优化，超实用</a></p><blockquote><p>①Cell重用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; // 返回Cell的代理方法会调用很多次，为防止重复创建，我们使用static 保证只创建一次reuseID，提高性能</span><br><span class="line">&gt; static NSString *reuseID = “reuseCellID”;</span><br><span class="line">&gt; </span><br><span class="line">&gt; // 从缓存池中取相应identifier的Cell并更新数据。</span><br><span class="line">&gt; // 如果没有，才开始alloc新的Cell，并用identifier标识Cell。每个Cell都会注册一个identifier（重用标识符）放入缓存池，当需要调用的时候就直接从缓存池里找对应的id，当不需要时就放入缓存池等待调用。（移出屏幕的Cell才会放入缓存池中，并不会被release）</span><br><span class="line">&gt; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:reuseID];</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>附：比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; 缓存池获取可重用Cell两个方法的区别</span><br><span class="line">&gt; </span><br><span class="line">&gt; -(nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier; </span><br><span class="line">&gt; // 方法1：这个方法会查询可重用Cell，如果注册了原型Cell，能够查询到，否则，返回nil；而且需要判断if（cell == nil），才会创建Cell，不推荐</span><br><span class="line">&gt; </span><br><span class="line">&gt; -(__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);</span><br><span class="line">&gt; // 方法2：使用这个方法之前，必须通过xib（storyboard）或是Class（纯代码）注册可重用Cell，而且这个方法一定会返回一个Cell</span><br><span class="line">&gt; </span><br><span class="line">&gt; // 附：方法2需要的注册Cell的方法</span><br><span class="line">&gt; - (void)registerNib:(nullable UINib *)nib forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(5_0);</span><br><span class="line">&gt; - (void)registerClass:(nullable Class)cellClass forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);</span><br><span class="line">&gt; </span><br><span class="line">&gt; // 好处：如果缓冲区 Cell 不存在，会使用原型 Cell 实例化一个新的 Cell，不需要再判断，同时代码结构更清晰。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>②定义一种(尽量少)类型的Cell及善用hidden隐藏(显示)subviews。即可以初始化时就添加，然后通过hide来控制是否显示。（比如朋友圈），而不要用addView给Cell动态添加View，</p><p>③提前计算并缓存Cell的高度；(Model去缓存，或者使用SDAutoLayout工具)<br>④网络数据的异步加载(如cell中的图片加载)，不要阻塞主线程；<br>⑤滑动时，按需加载，常见于大量图片时候。即当UITableView静止或者减速滑动结束之后才去进行异步加载图片。<br>⑥渲染优化：减少subviews的个数和层级；对于不透明的View，设置opaque为YES；阴影绘制及性能优化。</p><p>更新时候：使用局部更新，如果只是更新某组的话，使用reloadSection进行局部更新</p><ul><li><a href="https://www.cnblogs.com/fishbay/p/7217471.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">阴影绘制及性能优化</a></li></ul></blockquote><h3 id="1、Cell的重用"><a href="#1、Cell的重用" class="headerlink" title="1、Cell的重用"></a>1、Cell的重用</h3><blockquote><p>基于Cell的重用，真正运行时铺满屏幕所需的Cell数量大致是固定的，设为N个。所以<br>①如果如果只有一种Cell，那就是只有N个Cell的实例；<br>②但是如果有M种Cell，那么运行时最多可能会是“M x N = MN”个Cell的实例；<br>虽然可能并不会占用太多内存，但是能少点不是更好吗。</p></blockquote><h2 id="四、列表加载图片的优化"><a href="#四、列表加载图片的优化" class="headerlink" title="四、列表加载图片的优化"></a>四、列表加载图片的优化</h2><h3 id="1、缩略图的使用"><a href="#1、缩略图的使用" class="headerlink" title="1、缩略图的使用"></a>1、缩略图的使用</h3><p>图片划分两个地址.一个地址获取缩略图,一个地址获取原图&gt;&gt; 这样你就可以在TableViewCell使用缩略图(展示用),点击图片查看(使用原图). 这样就大大减少了内存的使用.</p><h3 id="2、UITableView优化"><a href="#2、UITableView优化" class="headerlink" title="2、UITableView优化"></a>2、UITableView优化</h3>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APNS+TCP推送流程</title>
      <link href="/iOS/%E8%BF%9B%E9%98%B6/APNS+TCP%E6%8E%A8%E9%80%81%E6%B5%81%E7%A8%8B/"/>
      <url>/iOS/%E8%BF%9B%E9%98%B6/APNS+TCP%E6%8E%A8%E9%80%81%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>APNS+TCP推送流程</p><p><img src="/iOS/进阶/APNS+TCP推送流程/APNS+TCP推送流程.png" alt="APNS+TCP推送流程"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>必备知识架构-线程与网络-③网络</title>
      <link href="/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A1%E7%BD%91%E7%BB%9C/4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C-%E2%91%A2%E7%BD%91%E7%BB%9C/"/>
      <url>/iOS/3%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/4%E2%91%A1%E7%BD%91%E7%BB%9C/4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C-%E2%91%A2%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-线程与网络-③网络"><a href="#必备知识架构-线程与网络-③网络" class="headerlink" title="必备知识架构-线程与网络-③网络"></a>必备知识架构-线程与网络-③网络</h1><p>[toc]</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><p><a href="#HTTP请求">九、在一个https连接的网站里，输入账号密码点击登录后，到服务器返回这个请求前，中间经历了什么</a></p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、一次完整的HTTP请求过程</span><br><span class="line">2、TCP三次握手</span><br><span class="line">3、TCP四次挥手</span><br></pre></td></tr></table></figure></li><li><p><a href="#TCP与UDP">十、TCP与UDP</a></p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、TCP与UDP的区别</span><br><span class="line">2、为什么说UDP是不可靠的？</span><br></pre></td></tr></table></figure></li><li><p><a href="#网络数据缓存">十一、网络数据缓存</a></p></li><li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、简要说下Http通信协议的原理，与Socket协议的区别有哪些？</span><br><span class="line">2、cookie 和session 的区别</span><br></pre></td></tr></table></figure></li><li><p><a href="#网络数据缓存">网络数据缓存</a></p></li><li><p><a href="#END">END</a></p></li></ul><p></p><p id="HTTP请求"></p><p></p><h2 id="九、在一个https连接的网站里，输入账号密码点击登录后，到服务器返回这个请求前，中间经历了什么"><a href="#九、在一个https连接的网站里，输入账号密码点击登录后，到服务器返回这个请求前，中间经历了什么" class="headerlink" title="九、在一个https连接的网站里，输入账号密码点击登录后，到服务器返回这个请求前，中间经历了什么"></a>九、在一个https连接的网站里，输入账号密码点击登录后，到服务器返回这个请求前，中间经历了什么</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p>回答这个问题，我们必须要先了解，一次完整的HTTP请求过程，大概是什么样的。</p><p>点击登录和服务器返回这个请求前，中间发生的起始就是一个域名解析和一次完整的http请求过程。</p><p>域名解析：即请求DNS服务器，进行域名解析。DNS服务器负责将你的网络地址解析成IP地址，这个IP地址对应网上一台机器；</p><p>而一次完整的HTTP请求过程，下面介绍之。</p><h3 id="1、一次完整的HTTP请求过程"><a href="#1、一次完整的HTTP请求过程" class="headerlink" title="1、一次完整的HTTP请求过程"></a>1、一次完整的HTTP请求过程</h3><p>一次完整的HTTP请求过程如下图所示：</p><blockquote><p><img src="/iOS/3必备知识架构/4②网络/4线程与网络-③网络/一次完整的HTTP请求过程.png" alt="一次完整的HTTP请求过程"><br>详情可参考：<a href="http://android.jobbole.com/85218/" target="_blank" rel="noopener">一次完整的HTTP请求过程</a></p></blockquote><h4 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h4><p> http和https使用的是完全不同的连接方式。</p><p> 区别统计：</p><p>①HTTP是不安全的(它的信息使用明文传输)，而HTTPS是安全的(会进行加密)；</p><p>②使用的端口也不同，http使用的是80端口，https使用的是443端口。</p><p>③HTTP无需证书，而HTTPS需要认证证书。</p><p>在网络模型中，HTTP工作于应用层，而HTTPS工作在传输层；</p><h3 id="2、TCP三次握手"><a href="#2、TCP三次握手" class="headerlink" title="2、TCP三次握手"></a>2、TCP三次握手</h3><p>一个故事让大家明白为什么会有tcp三次握手</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 敌人封锁江面, 我方间谍和联络员只能通过电报机隔着江面交流. 但是那时的电报机质量不稳定, 有可能会出现失灵的情况. 所以就出现了如下对话:</span><br><span class="line">间谍: 联络员, 你能收到我发的话么? 你要是能收到, 就说明我这个电报机可以发电报.</span><br><span class="line">联络员: 间谍, 我收到你发的话了, 这说明我的电报机可以收. 但是我不确定我的电报机能不能发, 你能收到我发的这句话么? 你要是能收到, 就说明我的电报机是可以发电报的. </span><br><span class="line">间谍: 联络员, 我收到你的话了. 我的电报机也是能发能收, 我们可以正式交流情报了.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>TCP三次握手过程</p><blockquote><p>第一次握手： 客户端给服务器发送一个含有<code>同步序列号SYN</code> 报文。</p><blockquote><p><em>主机A通过向主机B 发送一个含有同步序列号SYN的标志位的数据段给主机B ,向主机B <code>请求建立连接</code>,通过这个数据段,主机A告诉主机B 两件事:<code>我想要和你通信</code>;你可以用哪个序列号作为起始数据段来回应我.</em></p></blockquote><p>第二次握手： 服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。</p><blockquote><p><em>主机B 收到主机A的请求后,用一个带有<code>确认应答(ACK)</code>和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:<code>我已经收到你的请求了,你可以传输数据了</code>;你要用哪佧序列号作为起始数据段来回应我</em></p></blockquote><p>第三次握手： 客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。</p><blockquote><p><em>主机A收到这个数据段后,再发送一个<code>确认应答</code>,确认已收到主机B 的数据段:”<code>我已收到回复,我现在要开始传输实际数据了</code>,这样三次握手就完成了,主机A和主机B 就可以传输数据了.</em></p></blockquote><p>服务器收到 ACK 报文之后，三次握手建立完成。</p></blockquote><p>附：</p><p>TCP三次握手的作用是为了确认双方的接收与发送能力是否正常。</p><p>握手过程中传送的包里正常不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据</p><p>但其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p><h3 id="3、TCP四次挥手"><a href="#3、TCP四次挥手" class="headerlink" title="3、TCP四次挥手"></a>3、TCP四次挥手</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 举个栗子：把客户端比作男孩，服务器比作女孩。通过他们的分手来说明“四次挥手”过程。</span><br><span class="line">&gt; &quot;第一次挥手&quot;：日久见人心，男孩发现女孩变成了自己讨厌的样子，忍无可忍，于是决定分手，随即写了一封信告诉女孩。</span><br><span class="line">&gt; “第二次挥手”：女孩收到信之后，知道了男孩要和自己分手，立马给男孩写了一封回信：分手就分手，给我点时间，我要把你的东西整理好，全部还给你！男孩收到女孩的第一封信之后，明白了女孩知道自己要和她分手。随后等待女孩把自己的东西收拾好。</span><br><span class="line">&gt; “第三次挥手”：过了几天，女孩把男孩送的东西都整理好了，于是再次写信给男孩：你的东西我整理好了，快把它们拿走，从此你我恩断义绝！</span><br><span class="line">&gt; “第四次挥手”：男孩收到女孩第二封信之后，知道了女孩收拾好东西了，可以正式分手了，于是再次写信告诉女孩：我知道了，这就去拿回来！</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="4、为什么TCP建立连接要进行3次握手-而断开连接要进行4次？"><a href="#4、为什么TCP建立连接要进行3次握手-而断开连接要进行4次？" class="headerlink" title="4、为什么TCP建立连接要进行3次握手,而断开连接要进行4次？"></a>4、为什么TCP建立连接要进行3次握手,而断开连接要进行4次？</h3><p><a href="https://baijiahao.baidu.com/s?id=1654225744653405133&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">详解 TCP 连接的“ 三次握手 ”与“ 四次挥手 ”/为什么“握手”是三次，“挥手”却要四次？</a></p><blockquote><p>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。</p><p>释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。</p><p>所以是“三次握手”，“四次挥手”。</p></blockquote><h3 id="5、TCP两次握手会出现什么问题"><a href="#5、TCP两次握手会出现什么问题" class="headerlink" title="5、TCP两次握手会出现什么问题"></a>5、TCP两次握手会出现什么问题</h3><blockquote><p>《计算机网络》（谢希仁 译）中讲了原因：<br>1.采用两次握手，那么<strong>若Client向Server发起的包A1如果在传输链路上遇到的故障，导致传输到Server的时间相当滞后，在这个时间段由于Client没有收到Server的对于包A1的确认(如果有确认，即Server有收到的话，会发送回一个B1包)，那么就会重传一个包A2(应该是等超时了)</strong>，假设服务器正常收到了A2的包，然后返回确认B2包。由于没有第三次握手，这个时候Client和Server就被认为是已经建立连接，可以传输数据了。</p><p><strong>接着假设Client发送的第一个A1包随后在链路中传到了Server，对于Server来说这是一个新连接请求，然后Server又为这个连接申请资源，返回B1包</strong>，但是由于Client现在用的是A2包，A1包是无效的，Client对于返回的B1包也不会去理会，即后面建立的这个连接其实是没用的(相当于“僵尸”的连接)，Server一直为这个连接维持着资源，造成资源的浪费。</p><p>所以采用两次握手，有可能会浪费Server的网络资源。</p><p>TCP的三次握手最主要是防止已过期/失效的连接再次传到被连接的主机。</p></blockquote><p><strong>为什么要进行第三次握手？</strong></p><p>为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p></p><p id="TCP与UDP"></p><p></p><h2 id="十、TCP与UDP"><a href="#十、TCP与UDP" class="headerlink" title="十、TCP与UDP"></a>十、TCP与UDP</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><h3 id="1、TCP与UDP的区别"><a href="#1、TCP与UDP的区别" class="headerlink" title="1、TCP与UDP的区别"></a>1、TCP与UDP的区别</h3><p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。<br>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！<br>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p><p>TCP与UDP的区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 基于连接与无连接；</span><br><span class="line">2. 对系统资源的要求（TCP较多，UDP少）；</span><br><span class="line">3. UDP程序结构较简单；</span><br><span class="line">4. 流模式与数据报模式 ；</span><br><span class="line">5. TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。</span><br></pre></td></tr></table></figure><h3 id="2、为什么说UDP是不可靠的？"><a href="#2、为什么说UDP是不可靠的？" class="headerlink" title="2、为什么说UDP是不可靠的？"></a>2、为什么说UDP是不可靠的？</h3><blockquote><p>答：UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议<br>也正由于上面的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。</p></blockquote><blockquote><p>也正由于上面的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。</p></blockquote><blockquote><p>所以采用TCP传输协议的MSN比采用UDP的QQ传输文件慢，<br>但并不能说QQ的通信是不安全的，因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，即使是这样，UDP因为在底层协议的封装上没有采用类似 TCP的“三次握手”而实现了TCP所无法达到的传输效率。 </p></blockquote><h3 id="3、移动端IM系统的协议选型：UDP还是TCP？"><a href="#3、移动端IM系统的协议选型：UDP还是TCP？" class="headerlink" title="3、移动端IM系统的协议选型：UDP还是TCP？"></a>3、移动端IM系统的协议选型：UDP还是TCP？</h3><p><a href="https://www.jianshu.com/p/e58064496e40" target="_blank" rel="noopener">移动端IM系统的协议选型：UDP还是TCP？</a></p><ul><li>《<a href="https://link.jianshu.com/?t=http://www.52im.net/thread-279-1-1.html" target="_blank" rel="noopener">为什么QQ用的是UDP协议而不是TCP协议？</a>》</li></ul><blockquote><p>TCP还是UDP？长连接如何实现？如何实现心跳机制？心跳的间隔如何确定？这些问题都是讨论<strong>移动端IM</strong>、<strong>消息推送</strong>等类似话题时，几乎一定被问到的问题。</p></blockquote><blockquote><p>个人认为，更恰当的方式应该是：两种通信协议同时使用，各有侧重。UDP用于保持大量终端的在线与控制，应用与业务则通过TCP去实现。这个和FTP服务控制与数据分离，采取不同的连接，有异曲同工之处。<br>事实上，这个也是即时通讯巨头QQ所采用的方式。早期的时候，QQ还是主要使用TCP协议，而后来就转向了采用UDP的方式来保持在线，TCP的方式来上传和下载数据。现在，UDP是QQ的默认工作方式，表现良好。相信这个也被沿用到了微信上。<br>简单的考证：登录PC版QQ，关闭多余的QQ窗口只留下主窗口，并将其最小化。几分钟过后，查看系统网络连接，会发现QQ进程已不保有任何TCP连接，但有UDP网络活动。这时在发送聊天信息，或者打开其他窗口和功能，将发现QQ进程会启用TCP连接。</p></blockquote><p></p><p id="网络数据缓存"></p><p></p><h2 id="十一、网络数据缓存"><a href="#十一、网络数据缓存" class="headerlink" title="十一、网络数据缓存"></a>十一、网络数据缓存</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><p><a href="http://www.cnblogs.com/wendingding/p/3950198.html" target="_blank" rel="noopener">iOS开发网络篇—数据缓存</a></p><h1 id="网络-http常见错误码"><a href="#网络-http常见错误码" class="headerlink" title="网络 | http常见错误码"></a>网络 | http常见错误码</h1><ul><li><p><a href="https://baijiahao.baidu.com/s?id=1609940322276045505&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">HTTP状态码介绍，以及HTTP错误代码的故障修复？</a></p><blockquote><p>HTTP 状态码是一个客户发出请求时候，WEB服务器返回给客户的一个状态回应，常见HTTP状态有以下五类：</p><p>1.信息代码：1xx，</p><p>2.成功代码：2xx，</p><p>3.重定向：3xx，</p><p>4.客户端错误：4xx，</p><p>5.服务器错误：5xx</p><p>其中，我们需要关注的是客户端和服务器端错误代码，即4xx和5xx代码以及这些代码的常见解决方案。</p><p>客户端错误，从400到499编码的客户端错误是由客户端引起的某些错误导致的，该客户端是Web浏览器、curl命令或postman等其他服务器测试软件发出的请求等。</p><p>服务器错误，当服务器发生错误或服务器识别出无法处理请求时，将发送代码为500到599的服务器错误。</p></blockquote></li></ul><h2 id="常见状态码："><a href="#常见状态码：" class="headerlink" title="常见状态码："></a>常见状态码：</h2><p>一些常见的状态码为：</p><ul><li><p>200 – 服务器成功返回网页</p></li><li><p>302</p></li><li><p>304（未修改）</p></li><li><p>404 – 请求的网页不存在</p></li><li><p>503 – 服务器超时</p></li></ul><p>1xx（临时响应）</p><p>表示临时响应并需要请求者继续执行操作的状态代码。</p><p>2xx （成功）</p><p>表示成功处理了请求的状态代码。</p><p>3xx （重定向）</p><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p><p>4xx（请求错误）</p><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p><p>5xx（服务器错误）</p><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p><h1 id="AFNetworking-302-重定向"><a href="#AFNetworking-302-重定向" class="headerlink" title="AFNetworking 302 重定向"></a>AFNetworking 302 重定向</h1><ul><li><a href="https://www.jianshu.com/p/4fcba7db11c2" target="_blank" rel="noopener">AFNetworking 302 重定向</a></li></ul><p>所有的AF请求都会在post get等请求前执行下面这个方法，所以只需重写这个方法就能拦截请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface AFURLSessionManager ()</span><br><span class="line">// 省略一堆代码</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line">// 省略一堆代码</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>使用举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">manager = [AFHTTPSessionManager manager];</span><br><span class="line">[manager setTaskWillPerformHTTPRedirectionBlock:^NSURLRequest * _Nonnull(NSURLSession * _Nonnull session, NSURLSessionTask * _Nonnull task, NSURLResponse * _Nonnull response, NSURLRequest * _Nonnull request) &#123;</span><br><span class="line">            NSHTTPURLResponse *resPonse = (NSHTTPURLResponse *)response;</span><br><span class="line">           //1、如果要忽略重定向</span><br><span class="line">          /*</span><br><span class="line">            if (resPonse.statusCode == 302)&#123;</span><br><span class="line">                return nil;</span><br><span class="line">            &#125;else &#123;//正常请求</span><br><span class="line">                return request;</span><br><span class="line">            &#125;</span><br><span class="line">             */</span><br><span class="line">         // 2、通过重定向url去获取数据</span><br><span class="line">            if (resPonse.statusCode == 302)&#123;//如果响应code==302 就是重定向</span><br><span class="line">                NSMutableURLRequest *res = [NSMutableURLRequest requestWithURL:request.URL];</span><br><span class="line">              //通过抓包发现请求头不见了 所以在这里添加请求头，如果没有这个需求的可以忽略</span><br><span class="line">                NSMutableDictionary *headers = [NSMutableDictionary dictionaryWithDictionary:request.allHTTPHeaderFields];</span><br><span class="line">                NSString *valueStr = [NSString stringWithFormat:@&quot; %@&quot;,localToken];</span><br><span class="line">                [headers setObject:valueStr forKey:@&quot;Authorization&quot;];</span><br><span class="line">                res.allHTTPHeaderFields = headers;</span><br><span class="line"></span><br><span class="line">                return res;</span><br><span class="line">            &#125;else &#123;//正常请求</span><br><span class="line">                return request;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p></p><p id="常见笔试/面试题"></p><p></p><h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p><h6 id="1、简要说下Http通信协议的原理，与Socket协议的区别有哪些？"><a href="#1、简要说下Http通信协议的原理，与Socket协议的区别有哪些？" class="headerlink" title="1、简要说下Http通信协议的原理，与Socket协议的区别有哪些？"></a>1、简要说下Http通信协议的原理，与Socket协议的区别有哪些？</h6><blockquote><p>答：HTTP协议：简单对象访问协议，对应于应用层，HTTP协议是基于TCP连接的</p></blockquote><p>tcp协议：对应于传输层</p><blockquote></blockquote><p>ip协议：对应于网络层</p><blockquote></blockquote><p>TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。</p><blockquote></blockquote><p>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，才能使用TCP/IP协议。</p><blockquote></blockquote><p>http连接：http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断掉；</p><blockquote></blockquote><p>socket连接：socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；但是由于各种环境因素可能会是连接断开，比如说：服务器端或客户端主机down了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以释放网络资源。</p><h6 id="2、cookie-和session-的区别："><a href="#2、cookie-和session-的区别：" class="headerlink" title="2、cookie 和session 的区别："></a>2、cookie 和session 的区别：</h6><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、安全性：<br>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。<br>考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>   考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、所以个人建议：<br>   将登陆信息等重要信息存放为SESSION<br>   其他信息如果需要保留，可以放在COOKIE中</p><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三方库SDWebImage①缓存-①缓存不更新问题</title>
      <link href="/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A0%E7%BC%93%E5%AD%98-%E2%91%A2%E7%BC%93%E5%AD%98%E4%B8%8D%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
      <url>/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A0%E7%BC%93%E5%AD%98-%E2%91%A2%E7%BC%93%E5%AD%98%E4%B8%8D%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-第三方库SDWebImage①缓存-①缓存不更新问题"><a href="#必备知识架构-第三方库SDWebImage①缓存-①缓存不更新问题" class="headerlink" title="必备知识架构-第三方库SDWebImage①缓存-①缓存不更新问题"></a>必备知识架构-第三方库SDWebImage①缓存-①缓存不更新问题</h1><p>[Toc]</p><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>后台图片内容换了，但是<code>url</code>还是老的，手机就用了缓存，没有从后台更新图片。</p><p>主要问题表现在哪里呢？<br>很多app都有用户的概念，用户一般都会有头像，基本上都上传到服务器上，而服务器往往也支持在pc端更新头像（比如微博、QQ等）。<br>如果你的头像使用SDWebImage设置的，那么你会发现，pc端更新头像后，客户端可能（往往）不会自动更新！！！</p><h2 id="二、解决"><a href="#二、解决" class="headerlink" title="二、解决"></a>二、解决</h2><p>问：使用<code>SDWebImage</code>如何加载url不变，但图片已经变化的图片。</p><p>答：解决方法可以有如下几种：</p><ol><li><p>让服务器更新url，也就是说服务器端如果更新了头像，那么就生成新的url(推荐)</p><blockquote><p>后台给的<code>url</code>中增加字段，表示图片是否更新，比如增加一个<code>timestamp</code>字段.图片更新了，就更新下这个字段；<br>对客户端来说，只要这个<code>timestamp</code>字段变了，整个<code>url</code>就不一样了，就会从网络取图片。比如<code>http://xxx/xx? timestamp=xxx</code><br>也可以添加图片文件的<code>md5</code>来表示文件是否更新，比如<code>http://xxx/xx? md5=xxx</code>。并且<code>md5</code>比时间戳要好，这是强校验。时间戳在服务器回滚或者服务器重启的时候会有特殊的逻辑。不过大多数时候时间戳也够用了。<br>====这个方案客户端不用改，后台改动也不会太大。====强烈推荐</p></blockquote></li><li><p>客户端只使用内存缓存，不使用磁盘缓存，那么下次启动时候就会重新下载，从而得到最新的了。(缺点：本次使用过程中没能看到最新图片。且即使之后下载到最新图片了，由于只使用内存缓存，不使用磁盘缓存。导致程序关闭又打开之后，缓存就没了，需要访问网络，重新加载图片)</p><blockquote><p><code>SDWebImageCacheMemoryOnly</code>这个参数对解决这个问题有帮助，只用内存缓存，不用磁盘缓存，<code>App</code>关了再开，肯定会重新下载，不会出现服务器和手机缓存图片不一致的情况。</p></blockquote></li><li><p>客户端使用SDWebImageRefreshCached，同时让服务器端支持cache-control。</p><blockquote><p><code>SDWebImageRefreshCached</code>，这个参数就是为了解决url没变但是服务器图片改变的问题，很适合当前的场景。方案就是磁盘缓存不自己实现了，直接使用<code>NSURLCache</code>。记得<code>AFNetworking</code>的大神<code>Matt</code>就曾经嘲笑过<code>SDWebImage</code>的缓存是多此一举，还不如系统的<code>NSURLCache</code>好用。</p><h4 id="SDWebImageRefreshCached参数设置之后，会怎么样？"><a href="#SDWebImageRefreshCached参数设置之后，会怎么样？" class="headerlink" title="SDWebImageRefreshCached参数设置之后，会怎么样？"></a><code>SDWebImageRefreshCached</code>参数设置之后，会怎么样？</h4><ul><li><p>不使用<code>SDWebImage</code>提供的内存缓存和硬盘缓存</p></li><li><p>采用<code>NSURLCache</code>提供的缓存，默认情况下有效时间只有5秒</p></li><li><p>图片不一致的问题是解决了，不过效果跟不使用缓存差别不大。个人建议这个参数还是不要用为好，为了一个小特性，丢掉了<code>SDWebImage</code>最核心的特色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   [imageview sd_setImageWithURL:[NSURL URLWithString:url]</span><br><span class="line">&gt;     placeholderImage:nil</span><br><span class="line">&gt;    options:SDWebImageRefreshCached];</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>不使用SDWebImage，自己控制缓存，用系统API实现（NSURLCache）实现。（缺点还是和3一样，得服务端配合更改。）</p><blockquote><p>主要也是和使用<code>SDWebImageRefreshCached</code>时候一样，会涉及到<code>Cache-Control(设定缓存有效时间，默认是5s)</code>、<code>Last-Modified/If-Modified-Since(时间戳)</code>、<code>Etag/If-None-Match(标签，一般用MD5值)</code>。</p></blockquote></li></ol><p>附：其他options</p><p><code>SDWebImageRetryFailed</code>表示就算下载失败也会再次尝试（不把下载失败的的<code>url</code>加入黑名单）</p><p>参考文章：</p><ul><li><a href="https://www.jianshu.com/p/8cc494e77507" target="_blank" rel="noopener">SDWebImage如何加载url不变，但图片已经变化的图片</a></li><li><a href="https://www.jianshu.com/p/145ffa299eff" target="_blank" rel="noopener">SDWebImage：缓存不更新问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三方库SDWebImage①缓存-①NSCache</title>
      <link href="/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A0%E7%BC%93%E5%AD%98-%E2%91%A0NSCache/"/>
      <url>/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A0%E7%BC%93%E5%AD%98-%E2%91%A0NSCache/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-第三方库SDWebImage①缓存-①NSCache"><a href="#必备知识架构-第三方库SDWebImage①缓存-①NSCache" class="headerlink" title="必备知识架构-第三方库SDWebImage①缓存-①NSCache"></a>必备知识架构-第三方库SDWebImage①缓存-①NSCache</h1><p>[toc]</p><h2 id="一、NSCache的认识"><a href="#一、NSCache的认识" class="headerlink" title="一、NSCache的认识"></a>一、NSCache的认识</h2><h3 id="1、为什么内存缓存要基于-NSCache？"><a href="#1、为什么内存缓存要基于-NSCache？" class="headerlink" title="1、为什么内存缓存要基于 NSCache？"></a>1、为什么内存缓存要基于 NSCache？</h3><p>NSCache和NSMutableDictionary，它们是iOS中常用的两个缓存类，基本上相同，都是<strong>健-值形式的内存缓存方式</strong>。</p><p>1、<code>NSCache</code>的使用很方便，提供了类似可变字典的使用方式，但它比可变字典更适用于实现缓存，最重要的原因为<strong><code>NSCache</code>是线程安全的，使用<code>NSMutableDictionary</code>自定义实现缓存时需要考虑加锁和释放锁</strong>，<code>NSCache</code>已经帮我们做好了这一步，即在开发者自己不编写加锁代码的前提下，多个线程便可以同时访问NSCache。</p><p>2、其次，在内存不足时<code>NSCache</code>会自动释放存储的对象，不需要手动干预，如果是自定义实现需要监听内存状态然后做进一步的删除对象的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface NSCache &lt;KeyType, ObjectType&gt; : NSObject &#123;</span><br><span class="line">@private</span><br><span class="line">    id _delegate;</span><br><span class="line">    void *_private[5];</span><br><span class="line">    void *_reserved;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@property (nullable, assign) id&lt;NSCacheDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">- (nullable ObjectType)objectForKey:(KeyType)key;</span><br><span class="line">- (void)setObject:(ObjectType)obj forKey:(KeyType)key; // 0 cost</span><br><span class="line">- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;</span><br><span class="line">- (void)removeObjectForKey:(KeyType)key;</span><br><span class="line"></span><br><span class="line">- (void)removeAllObjects;</span><br><span class="line"></span><br><span class="line">// NSCache可以指定缓存的限额，当缓存超出限额自动释放内存</span><br><span class="line">// ①对象缓存可持有最大的数量 ，默认是0 没有限制），一旦超出限额，会自动删除之前添加的缓存数据</span><br><span class="line">@property NSUInteger countLimit;// limits are imprecise/not strict</span><br><span class="line">// ②缓存中可持有的最大空间 默认是0（没有限制）</span><br><span class="line">@property NSUInteger totalCostLimit;// limits are imprecise/not strict</span><br><span class="line"></span><br><span class="line">// 管理丢弃内容</span><br><span class="line">// 是否可以自动缓存清除可丢弃的内容，默认是YES</span><br><span class="line">@property BOOL evictsObjectsWithDiscardedContent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>3、还有一点就是<strong><code>NSCache</code>的<code>key</code>不需要实现<code>NSCopying</code>协议</strong>，因为<code>NSCache</code>的键<code>key</code>不会被复制/拷贝。在键key不支持拷贝操作的情况下，该类用起来比字典更方便。</p><h3 id="2、NSCache什么时候会删除缓存中的对象"><a href="#2、NSCache什么时候会删除缓存中的对象" class="headerlink" title="2、NSCache什么时候会删除缓存中的对象"></a>2、NSCache什么时候会删除缓存中的对象</h3><p><code>NSCache</code>删除缓存中的对象会在以下情形中发生:</p><ul><li>NSCache缓存对象自身被释放</li><li>手动调用<code>removeObjectForKey:</code>或<code>removeAllObjects</code>方法</li><li>缓存中对象的个数大于countLimit，或缓存中对象的总cost值大于totalCostLimit</li><li>程序进入后台后</li><li>收到系统的内存警告</li></ul><h2 id="二、SDMemoryCache的认识"><a href="#二、SDMemoryCache的认识" class="headerlink" title="二、SDMemoryCache的认识"></a>二、SDMemoryCache的认识</h2><p>以上已说明内存缓存要基于 NSCache，所以SDMemoryCache要继承于NSCache，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SDMemoryCache.h</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> A memory cache which auto purge the cache on memory warning and support weak cache.</span><br><span class="line"> */</span><br><span class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; : NSCache &lt;KeyType, ObjectType&gt; &lt;SDMemoryCache&gt; // 请注意这里除继承 NSCache &lt;KeyType, ObjectType&gt; 外，还有一个 与 SDMemoryCache 类名同名的 &lt;SDMemoryCache&gt; 协议</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, nonnull, readonly) SDImageCacheConfig *config;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>可以看出类<code>@interface SDMemoryCache</code>还要遵守<code>&lt;SDMemoryCache&gt;</code>协议。虽然类<code>@interface SDMemoryCache</code>没提供什么方法，但与 SDMemoryCache 类名同名的<code>&lt;SDMemoryCache&gt;</code>协议提供了。</p><p><code>&lt;SDMemoryCache&gt;</code>协议源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> A protocol to allow custom memory cache used in SDImageCache.</span><br><span class="line"> */</span><br><span class="line">@protocol SDMemoryCache &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@required</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithConfig:(nonnull SDImageCacheConfig *)config;</span><br><span class="line"></span><br><span class="line">- (nullable id)objectForKey:(nonnull id)key;</span><br><span class="line"></span><br><span class="line">- (void)setObject:(nullable id)object forKey:(nonnull id)key;</span><br><span class="line"></span><br><span class="line">- (void)setObject:(nullable id)object forKey:(nonnull id)key cost:(NSUInteger)cost;</span><br><span class="line"></span><br><span class="line">- (void)removeObjectForKey:(nonnull id)key;</span><br><span class="line">- (void)removeAllObjects;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="1、为什么另外建了个与类名SDMemoryCache同名的-lt-SDMemoryCache-gt-协议，并把方法提到了-lt-SDMemoryCache-gt-协议中？"><a href="#1、为什么另外建了个与类名SDMemoryCache同名的-lt-SDMemoryCache-gt-协议，并把方法提到了-lt-SDMemoryCache-gt-协议中？" class="headerlink" title="1、为什么另外建了个与类名SDMemoryCache同名的&lt;SDMemoryCache&gt;协议，并把方法提到了&lt;SDMemoryCache&gt;协议中？"></a>1、为什么另外建了个与类名SDMemoryCache同名的<code>&lt;SDMemoryCache&gt;</code>协议，并把方法提到了<code>&lt;SDMemoryCache&gt;</code>协议中？</h3><p>答：为了当你想要要使用自定义的缓存类的时候，可以不用继承<code>@interface SDMemoryCache</code>，而只需遵循<code>&lt;SDMemoryCache&gt;</code>协议的方便。</p><h3 id="2、内存缓存SDMemoryCache、磁盘缓存SDDiskCache的基类各是什么？"><a href="#2、内存缓存SDMemoryCache、磁盘缓存SDDiskCache的基类各是什么？" class="headerlink" title="2、内存缓存SDMemoryCache、磁盘缓存SDDiskCache的基类各是什么？"></a>2、内存缓存SDMemoryCache、磁盘缓存SDDiskCache的基类各是什么？</h3><p>答：</p><blockquote><p>内存：@interface SDMemoryCache &lt;KeyType, ObjectType&gt; : NSCache &lt;KeyType, ObjectType&gt; <sdmemorycache></sdmemorycache></p><p>磁盘：@interface SDDiskCache : NSObject <sddiskcache></sddiskcache></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> The built-in disk cache.</span><br><span class="line"> */</span><br><span class="line">@interface SDDiskCache : NSObject &lt;SDDiskCache&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readonly, nonnull) SDImageCacheConfig *config;</span><br><span class="line"></span><br><span class="line">- (void)moveCacheDirectoryFromPath:(nonnull NSString *)srcPath toPath:(nonnull NSString *)dstPath;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="三、内存缓存的设计"><a href="#三、内存缓存的设计" class="headerlink" title="三、内存缓存的设计"></a>三、内存缓存的设计</h2><h3 id="1、SDImageCache"><a href="#1、SDImageCache" class="headerlink" title="1、SDImageCache"></a>1、SDImageCache</h3><p>含<code>id&lt;SDMemoryCache&gt; memoryCache;</code>和<code>id&lt;SDDiskCache&gt; diskCache;</code></p><p>一个SDImageCache对象，由内存和磁盘共同控制缓存。控制的策略由<code>SDImageCacheConfig</code>类来定制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@interface SDImageCache : NSObject</span><br><span class="line"></span><br><span class="line">#pragma mark - Properties</span><br><span class="line">@property (nonatomic, copy, nonnull, readonly) SDImageCacheConfig *config;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readonly, nonnull) id&lt;SDMemoryCache&gt; memoryCache;</span><br><span class="line">@property (nonatomic, strong, readonly, nonnull) id&lt;SDDiskCache&gt; diskCache;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, nonnull, readonly) NSString *diskCachePath;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, nullable) SDImageCacheAdditionalCachePathBlock additionalCachePathBlock;</span><br><span class="line"></span><br><span class="line">#pragma mark - Singleton and initialization</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns global shared cache instance</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, class, readonly, nonnull) SDImageCache *sharedImageCache;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Init a new cache store with a specific namespace</span><br><span class="line"> *</span><br><span class="line"> * @param ns The namespace to use for this cache store</span><br><span class="line"> */</span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns;</span><br></pre></td></tr></table></figure><p>同时SDImageCache还有个类目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SDImageCache.h</span><br><span class="line">@interface SDImageCache (SDImageCache) &lt;SDImageCache&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">// SDImageCacheDefine.h</span><br><span class="line">@protocol SDImageCache &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>内存和磁盘共同控制缓存策略定制类SDImageCacheConfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// SDImageCacheConfig.h</span><br><span class="line">@interface SDImageCacheConfig : NSObject &lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">// 是否使用内存做缓存，默认为YES</span><br><span class="line">@property (assign, nonatomic) BOOL shouldCacheImagesInMemory;</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic) BOOL shouldRemoveExpiredDataWhenEnterBackground;</span><br><span class="line"></span><br><span class="line">// 缓存图片的最长时间，单位是秒，默认是缓存一周</span><br><span class="line">@property (assign, nonatomic) NSTimeInterval maxDiskAge;</span><br><span class="line">// 缓存占用最大的空间，单位是字节</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxDiskSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCost;</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCount;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The attribute which the clear cache will be checked against when clearing the disk cache</span><br><span class="line"> * Default is Modified Date</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) SDImageCacheConfigExpireType diskCacheExpireType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="2、SDImageCachesManager"><a href="#2、SDImageCachesManager" class="headerlink" title="2、SDImageCachesManager"></a>2、SDImageCachesManager</h3><p>管理NSArray&lt;id<sdimagecache>&gt; *caches;</sdimagecache></p><p>一张图片就是一份SDImageCache元素对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> A caches manager to manage multiple caches.</span><br><span class="line"> */</span><br><span class="line">@interface SDImageCachesManager : NSObject &lt;SDImageCache&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, class, readonly, nonnull) SDImageCachesManager *sharedManager;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) SDImageCachesManagerOperationPolicy queryOperationPolicy;</span><br><span class="line">@property (nonatomic, assign) SDImageCachesManagerOperationPolicy storeOperationPolicy;</span><br><span class="line">@property (nonatomic, assign) SDImageCachesManagerOperationPolicy removeOperationPolicy;</span><br><span class="line">@property (nonatomic, assign) SDImageCachesManagerOperationPolicy containsOperationPolicy;</span><br><span class="line">@property (nonatomic, assign) SDImageCachesManagerOperationPolicy clearOperationPolicy;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, nullable) NSArray&lt;id&lt;SDImageCache&gt;&gt; *caches; // 一张图片就是一份SDImageCache元素对象。</span><br><span class="line"></span><br><span class="line">- (void)addCache:(nonnull id&lt;SDImageCache&gt;)cache;</span><br><span class="line">- (void)removeCache:(nonnull id&lt;SDImageCache&gt;)cache;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>### </p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDWebImage①缓存-②缓存原理</title>
      <link href="/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A0%E7%BC%93%E5%AD%98-%E2%91%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/"/>
      <url>/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A0%E7%BC%93%E5%AD%98-%E2%91%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-SDWebImage①缓存-②缓存原理"><a href="#必备知识架构-SDWebImage①缓存-②缓存原理" class="headerlink" title="必备知识架构-SDWebImage①缓存-②缓存原理"></a>必备知识架构-SDWebImage①缓存-②缓存原理</h1><p>[toc]</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><p></p><p id="SDWebImage"></p><p></p><h2 id="七、多线程–第三方库SDWebImage"><a href="#七、多线程–第三方库SDWebImage" class="headerlink" title="七、多线程–第三方库SDWebImage"></a>七、多线程–第三方库SDWebImage</h2><p>参考资料：</p><ul><li><a href="http://blog.csdn.net/l_511/article/details/48242793" target="_blank" rel="noopener">ioS开发之多线程– 第三方库SDWebImage</a></li><li><a href="http://blog.csdn.net/kuangdacaikuang/article/details/53332771" target="_blank" rel="noopener">旧版本SDWebImage图解</a></li></ul><p>这个类库提供一个UIImageView类别以支持加载来自网络的远程图片。具有缓存管理、异步下载、同一个URL下载次数控制和优化等特征。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>SDWebImage 基本思路如下：</p><p><a href="https://blog.csdn.net/zhang7761/article/details/45224917" target="_blank" rel="noopener">SDWebImage基本思路</a></p><p>1 扩展(category) UIImageView，这样写出的代码更整洁</p><p>2 GCD 异步下载 </p><p>3 重用 UITableViewCell 加异步下载会出现图片错位，所以每次 cell 渲染时都要预设一个图片 (placeholder)，</p><p>以覆盖先前由于 cell 重用可能存在的图片, 同时要给 UIImageView 设置 tag 以防止错位。</p><p>4 内存 + 文件 二级缓存， 内存缓存基于 NSCache</p><p>暂时没有考虑 cell 划出屏幕的情况，一是没看明白 SDWebImage 是怎么判断滑出屏幕并 cancel 掉队列中对应的请求的</p><p>二是我觉得用户很多情况下滑下去一般还会滑回来，预加载一下也挺好。坏处是对当前页图片加载性能上有点小影响。</p><h3 id="1、SDWebImage在图片下载及缓存的处理方法"><a href="#1、SDWebImage在图片下载及缓存的处理方法" class="headerlink" title="1、SDWebImage在图片下载及缓存的处理方法"></a>1、SDWebImage在图片下载及缓存的处理方法</h3><p>SDWebImage加载网络图片的原理图分析如下：<br><img src="/iOS/第三方库/图片库SDWebImage/SDWebImage①缓存-②缓存原理/SDWebImage加载网络图片的原理图分析.jpg" alt="SDWebImage加载网络图片的原理图分析"></p><p>其中图片的获取与存储过程大概如下：<br><img src="/iOS/第三方库/图片库SDWebImage/SDWebImage①缓存-②缓存原理/SDWebImage theory.png" alt="SDWebImage theory"></p><p>大概描述为：<br>注：SDWebImage中的<code>SDWebImageDownloader</code>有使用到GCD相关<code>dispatch_barrier_sync</code><br>1）当我门需要获取网络图片的时候，我们首先需要的便是URl没有URl什么都没有，获得URL后我们SDWebImage实现的并不是直接去请求网路，而是检查图片缓存中有没有和URl相关的图片，如果有则直接返回image，如果没有则进行下一步。</p><p>2）当图片缓存中没有图片时，SDWebImage依旧不会直从网络上获取，而是检查沙盒中是否存在图片，如果存在，则把沙盒中对应的图片存进image缓存中，然后按着第一步的判断进行。</p><p>3）如果沙盒中也不存在，则显示占位图，然后根据图片的下载队列缓存判断是否正在下载，如果下载则等待，避免二次下载。如果不存则创建下载队列，下载完毕后将下载操作从队列中清除，并且将image存入图片缓存中。</p><p>4）刷新UI（当然根据实际情况操作）将image存入沙盒缓存。</p><h4 id="缓存策略的源码解析：SDWebImage-源码解析—缓存策略"><a href="#缓存策略的源码解析：SDWebImage-源码解析—缓存策略" class="headerlink" title="缓存策略的源码解析：SDWebImage 源码解析—缓存策略"></a>缓存策略的源码解析：<a href="https://zhang759740844.github.io/2018/03/03/SDWebImage2/" target="_blank" rel="noopener">SDWebImage 源码解析—缓存策略</a></h4><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三方库SDWebImage②请求-①简介</title>
      <link href="/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A1%E8%AF%B7%E6%B1%82-%E2%91%A0%E7%AE%80%E4%BB%8B/"/>
      <url>/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A1%E8%AF%B7%E6%B1%82-%E2%91%A0%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-第三方库SDWebImage②请求-①简介"><a href="#必备知识架构-第三方库SDWebImage②请求-①简介" class="headerlink" title="必备知识架构-第三方库SDWebImage②请求-①简介"></a>必备知识架构-第三方库SDWebImage②请求-①简介</h1><p>[toc]</p><h3 id="2、SDWebImageDownloader-异步的图片下载器"><a href="#2、SDWebImageDownloader-异步的图片下载器" class="headerlink" title="2、SDWebImageDownloader 异步的图片下载器"></a>2、SDWebImageDownloader 异步的图片下载器</h3><p>SDWebImageDownloader是一个异步的图片下载器，它是一个单例类，主要负责图片的下载操作的管理。图片的下载是放在一个NSOperationQueue操作队列中来完成的，默认情况下，队列最大并发数是6。如果需要的话，我们可以通过SDWebImageDownloader类的maxConcurrentDownloads属性来修改。其声明如下：</p><h3 id="3、SDWebImageDownloaderOperation-下载操作"><a href="#3、SDWebImageDownloaderOperation-下载操作" class="headerlink" title="3、SDWebImageDownloaderOperation 下载操作"></a>3、SDWebImageDownloaderOperation 下载操作</h3><p>下面我们来说一说SDWebImage的下载操作SDWebImageDownloaderOperation。该类继承自NSOperation，并且采用了 <code>SDWebImageDownloaderOperationInterface</code>, <code>SDWebImageOperation</code>, <code>NSURLSessionTaskDelegate</code>, <code>NSURLSessionDataDelegate</code> 四个协议方法。</p><p>①、SDWebImageDownloaderOperation的下载请求</p><p>先通过URL等生成NSURLRequest，并设置给operation属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">声明：</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) NSURLRequest *request;</span><br><span class="line"></span><br><span class="line">定义：</span><br><span class="line">NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url</span><br><span class="line">                                               cachePolicy:cachePolicy</span><br><span class="line">                                timeoutInterval:timeoutInterval];</span><br></pre></td></tr></table></figure><p>有时候下我们希望它支持后台下载。所以在operation的start方法中，如果支持后台<code>shouldContinueWhenAppEntersBackground</code>，则将当前请求添加到后台任务中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">    __weak __typeof__ (self) wself = self;</span><br><span class="line">    UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">    self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        __strong __typeof (wself) sself = wself;</span><br><span class="line"></span><br><span class="line">        if (sself) &#123;</span><br><span class="line">            [sself cancel];</span><br><span class="line"></span><br><span class="line">            [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">            sself.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于图片的下载，SDWebImageDownloaderOperation的下载使用<code>NSURLSession</code>类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.dataTask = [session dataTaskWithRequest:self.request];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (self.dataTask) &#123;</span><br><span class="line">    [self.dataTask resume];</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">// 任务开始后，会在主线程抛出下载开始通知</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:weakSelf];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三方库SDWebImag②请求-①避免重复请求问题</title>
      <link href="/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A1%E8%AF%B7%E6%B1%82-%E2%91%A1%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/"/>
      <url>/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A1%E8%AF%B7%E6%B1%82-%E2%91%A1%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-第三方库SDWebImag②请求-①避免重复请求问题"><a href="#必备知识架构-第三方库SDWebImag②请求-①避免重复请求问题" class="headerlink" title="必备知识架构-第三方库SDWebImag②请求-①避免重复请求问题"></a>必备知识架构-第三方库SDWebImag②请求-①避免重复请求问题</h1><p>[toc]</p><h2 id="iOS-如何避免在短时间内频繁发出相同的网络请求？"><a href="#iOS-如何避免在短时间内频繁发出相同的网络请求？" class="headerlink" title="iOS 如何避免在短时间内频繁发出相同的网络请求？"></a>iOS 如何避免在短时间内频繁发出相同的网络请求？</h2><ul><li><p><a href="https://www.jianshu.com/p/85cfc47276d5" target="_blank" rel="noopener">iOS 如何避免在短时间内频繁发出相同的网络请求？</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1492729" target="_blank" rel="noopener">iOS多个线程发起相同请求，避免重复</a></p></li><li><p><a href="https://blog.csdn.net/lipengfei_1993/article/details/84872511" target="_blank" rel="noopener">iOS客户端防止发送重复点击发请求</a></p><blockquote><p>1、利用遮罩等控件阻止一个请求后，下一个重复请求的发出。<br>众所周知MBProgressHud或者SVProgresHud经常被利用在项目中，主要是在网络请求发起到网络相应收到的这段时间在客户端形成一个遮罩，可以用来阻止用户点击UI进行操作，防止某些意外的请求产生。</p><p>2、利用运行时设置相应按钮点击间隔<br>①对UIControl进行扩展<br>②对UIButton进行扩展</p><p>3、客户端网络请求方法中过滤</p><p>4、交给服务器解决</p></blockquote></li><li><p><a href="https://www.jianshu.com/p/149a871fd7f1" target="_blank" rel="noopener">SDWebImage 同一时间请求相同URL时，只进行一次网络请求</a></p></li></ul><h2 id="SDWebImage框架特征"><a href="#SDWebImage框架特征" class="headerlink" title="SDWebImage框架特征"></a>SDWebImage框架特征</h2><ul><li>类别UIImageView，UIButton，MKAnnotationView- - 添加Web图像和高速缓存管理</li><li>异步图像下载器</li><li>具有自动缓存到期处理的异步内存+磁盘映像缓存</li><li>背景图像解压缩</li><li>保证相同的URL不会被下载多次</li><li>保证虚假网址不会重复重试</li><li>保证主线程永远不会被阻止</li><li>使用GCD和ARC</li></ul><h2 id="一、SDWebImage是如何避免在短时间内频繁发出相同的网络请求？"><a href="#一、SDWebImage是如何避免在短时间内频繁发出相同的网络请求？" class="headerlink" title="一、SDWebImage是如何避免在短时间内频繁发出相同的网络请求？"></a>一、SDWebImage是如何避免在短时间内频繁发出相同的网络请求？</h2><p>SDWebImage是如何避免在短时间内频繁发出相同的网络请求？</p><p>设想：一个列表所有的图片请求都是同一个url。</p><p>答：</p><h3 id="1、如何确保不生成重复的网络请求"><a href="#1、如何确保不生成重复的网络请求" class="headerlink" title="1、如何确保不生成重复的网络请求"></a>1、如何确保不生成重复的网络请求</h3><p>图片下载的回调信息存储在SDWebImageDownloader类的URLOperations属性中，该属性是一个字典，key是图片的URL地址，value则是一个SDWebImageDownloaderOperation对象，包含每个图片的多组回调信息。由于我们允许多个图片同时下载，因此可能会有多个线程同时操作URLOperations属性。需要保证URLOperations操作（添加、删除）的线程安全性。</p><p><strong>为了避免同一个URL在被多次任务请求的时候，进行多次的重复网络下载。</strong></p><p><strong>1、将下载地址URL与其对应的网络下载请求，通过下载管理器SDWebImageDownloader的URLOperations属性管理起来。（该属性是一个字典，key是图片的URL地址，value是operation）</strong></p><p><strong>2、我们并不会对每次操作一进来就进行创建请求任务，而是先通过之前缓存的下载任务URLOperations，通过URL寻找是否有该操作了，①如果有则不创建，而是直接取出来使用；②如果没有才创建operation来使用，并添加到URLOperations中。以备后续有同样URL请求的时候，能会从URLOperations中得到operation，就不会导致重复创建和添加到队列中了。（通过URLOperations，我们以此保证一个URL同时在被请求多次的情况下，生成/取到的是同一个，也只有一个SDWebImageDownloaderOperation，从而也就只会被下载一次。）。</strong></p><p>在SDWebImage版本5.8.1中的相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SD_LOCK(self.operationsLock);// 6、加锁，防止添加过程中，又有数据需要添加，保证线程安全</span><br><span class="line">id downloadOperationCancelToken;</span><br><span class="line">  NSOperation&lt;SDWebImageDownloaderOperation&gt; *operation = [self.URLOperations objectForKey:url]; // 1、从进行中的 URLOperations 获取</span><br><span class="line">  if (!operation || operation.isFinished || operation.isCancelled) &#123;</span><br><span class="line">      operation = [self createDownloaderOperationWithUrl:url options:options context:context]; // 2、如果之前没有下载操作，则创建，并加入到 URLOperations 中</span><br><span class="line">      // ....省略一堆代码</span><br><span class="line">      @weakify(self);</span><br><span class="line">      operation.completionBlock = ^&#123;</span><br><span class="line">          @strongify(self);</span><br><span class="line">          if (!self) &#123;</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line">          SD_LOCK(self.operationsLock);</span><br><span class="line">          [self.URLOperations removeObjectForKey:url];// 3、下载完成后，记得删除操作</span><br><span class="line">          SD_UNLOCK(self.operationsLock);</span><br><span class="line">      &#125;;</span><br><span class="line">      self.URLOperations[url] = operation;// 4、保存到 URLOperations 中，用于判断</span><br><span class="line">    downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">      [self.downloadQueue addOperation:operation];// 4、添加操作</span><br><span class="line">    </span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      // ....省略一堆代码</span><br><span class="line">    @synchronized (operation) &#123;</span><br><span class="line">        // 5、如果之前有下载操作，则不用创建操作，但是仍然需要保存回调，不然其他位置的图片的请求就丢失了(虽然说它们是同一张图片)</span><br><span class="line">          downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  SD_UNLOCK(self.operationsLock);// 6、解锁</span><br></pre></td></tr></table></figure><p>3、问：重复的url请求，没有创建operation了，那operation的回调怎么办？</p><p>答：虽然重复的URL只有一个SDWebImageDownloaderOperation。但是这个opeartion的<code>callbackBlocks</code>是个数组，所有的回调都用这个数组保存起来的，所以不会丢失的（这里<code>callbackBlocks</code>数组里存放字典，对应进行时候的ProgressCallback回调和结束时候的CompletedCallback回调）。</p><p>4、问：对同一个operation的<code>callbackBlocks</code>数组操作，有什么要注意的？</p><p>答：因为不管同个url不管有没有新的operation生成，我们都会有一个当前任务对应<code>downloadOperationCancelToken</code>生成，来给这个operation添加回调。即同一个url所对应opeartion里的callbackBlocks数组，在有多次图片任务时候，就会有多次操作callbackBlocks的情况。所以对callbackBlocks的操作，也要保证线程安全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageDownloader.m</span><br><span class="line"></span><br><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                   context:(nullable SDWebImageContext *)context</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    // ....省略一堆代码</span><br><span class="line">                                                   </span><br><span class="line">    SD_LOCK(self.operationsLock);</span><br><span class="line">    id downloadOperationCancelToken;</span><br><span class="line">    NSOperation&lt;SDWebImageDownloaderOperation&gt; *operation = [self.URLOperations objectForKey:url];</span><br><span class="line">    if (!operation || operation.isFinished || operation.isCancelled) &#123;</span><br><span class="line">       // ....省略一堆代码</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // When we reuse the download operation to attach more callbacks, there may be thread safe issue because the getter of callbacks may in another queue (decoding queue or delegate queue)</span><br><span class="line">        // So we lock the operation here, and in `SDWebImageDownloaderOperation`, we use `@synchonzied (self)`, to ensure the thread safe between these two classes.</span><br><span class="line">        @synchronized (operation) &#123;</span><br><span class="line">            downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">        &#125;</span><br><span class="line">        // ....省略一堆代码</span><br><span class="line">    &#125;</span><br><span class="line">    SD_UNLOCK(self.operationsLock);</span><br><span class="line">    </span><br><span class="line">    // 虽然重复的URL只有一个SDWebImageDownloaderOperation。但是SDWebImageDownloadToken是每个URL都会有一个的，只是他们的SDWebImageDownloaderOperation是同一个。</span><br><span class="line">    SDWebImageDownloadToken *token = [[SDWebImageDownloadToken alloc] initWithDownloadOperation:operation];</span><br><span class="line">    token.url = url;</span><br><span class="line">    token.request = operation.request;</span><br><span class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line">    </span><br><span class="line">    return token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对callbackBlocks的操作，也要保证线程安全，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageDownloaderOperation.m</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableArray&lt;SDCallbacksDictionary *&gt; *callbackBlocks;</span><br><span class="line"></span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    SDCallbacksDictionary *callbacks = [NSMutableDictionary new];</span><br><span class="line">    if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</span><br><span class="line">    if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        [self.callbackBlocks addObject:callbacks];</span><br><span class="line">    &#125;</span><br><span class="line">    return callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、它是如何保证请求管理的线程安全"><a href="#2、它是如何保证请求管理的线程安全" class="headerlink" title="2、它是如何保证请求管理的线程安全"></a>2、它是如何保证请求管理的线程安全</h3><p>说明：由于我们允许多个任务同时进行，也就造成了会有多个线程同时操作<code>URLOperations</code>属性。为了保证URLOperations操作(添加、删除)的线程安全性，我们添加了一个锁，且考虑到各种具备锁功能的性能问题，这里我们使用信号量semaphore。所以，<strong>我们控制线程安全的锁是使用信号量实现的<code>operationsLock</code>，且其初始值为1，用它来确保同一时间只有一个线程操作URLOperations属性</strong>。</p><p>在SDWebImage版本5.8.1中的相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageDownloader.m</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    return [self initWithConfig:SDWebImageDownloaderConfig.defaultDownloaderConfig];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithConfig:(SDWebImageDownloaderConfig *)config &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // ....省略一堆代码</span><br><span class="line">        _downloadQueue = [NSOperationQueue new];</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = _config.maxConcurrentDownloads;</span><br><span class="line">        _downloadQueue.name = @&quot;com.hackemist.SDWebImageDownloader&quot;;</span><br><span class="line">        _URLOperations = [NSMutableDictionary new];</span><br><span class="line">        // ....省略一堆代码</span><br><span class="line">        _operationsLock = dispatch_semaphore_create(1);</span><br><span class="line">        // ....省略一堆代码</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、其它知识说明"><a href="#3、其它知识说明" class="headerlink" title="3、其它知识说明"></a>3、其它知识说明</h3><h4 id="3-1、SDWebImageDownloader-是什么？-异步的图片下载器"><a href="#3-1、SDWebImageDownloader-是什么？-异步的图片下载器" class="headerlink" title="3.1、SDWebImageDownloader 是什么？(异步的图片下载器)"></a>3.1、SDWebImageDownloader 是什么？(异步的图片下载器)</h4><p>SDWebImageDownloader是一个异步的图片下载器，它是一个单例类，主要负责图片的下载操作的管理。</p><p>图片的下载是放在一个NSOperationQueue操作队列中来完成的，默认情况下，队列最大并发数是6。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageDownloader.m</span><br><span class="line">@property (strong, nonatomic, nonnull) NSOperationQueue *downloadQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_downloadQueue = [NSOperationQueue new];</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = _config.maxConcurrentDownloads;</span><br><span class="line"></span><br><span class="line">// SDWebImageDownloaderConfig.h</span><br><span class="line">/**</span><br><span class="line"> * The maximum number of concurrent downloads.</span><br><span class="line"> * Defaults to 6.</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) NSInteger maxConcurrentDownloads;</span><br></pre></td></tr></table></figure><p>如果需要的话，我们可以通过修改maxConcurrentDownloads属性来修改并发下载数。</p><h2 id="二、其他版本的SDWebImage的代码解析"><a href="#二、其他版本的SDWebImage的代码解析" class="headerlink" title="二、其他版本的SDWebImage的代码解析"></a>二、其他版本的SDWebImage的代码解析</h2><h3 id="1、SDWebImageDownloader-是什么？-异步的图片下载器"><a href="#1、SDWebImageDownloader-是什么？-异步的图片下载器" class="headerlink" title="1、SDWebImageDownloader 是什么？(异步的图片下载器)"></a>1、SDWebImageDownloader 是什么？(异步的图片下载器)</h3><p>其声明及定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//SDWebImageDownloader.m</span><br><span class="line"></span><br><span class="line">@property (SDDispatchQueueSetterSementics, nonatomic) dispatch_queue_t barrierQueue;</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        ...</span><br><span class="line">        _barrierQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageDownloaderBarrierQueue&quot;, DISPATCH_QUEUE_CONCURRENT);// 并发队列</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每有一个图片下载请求，SDWebImageDownloader图片下载管理器就会生成一个继承自NSOperation的下载操作SDWebImageDownloaderOperation，并添加到下载队列downloadQueue中。</p><p><code>[sself.downloadQueue addOperation:operation];</code></p><p>该队列允许修改最大并发数。</p><p>1、由于我们允许多个任务同时进行，也就造成了会有多个线程同时操作<code>URLOperations</code>属性。为了保证URLOperations操作(添加、删除)的线程安全性，我们添加了线程操作的<strong>信号量<code>operationsLock</code>，其初始值为1，来确保同一时间只有一个线程操作URLOperations属性</strong>，我们以添加操作为例，如下代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LOCK(self.operationsLock);</span><br><span class="line">SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</span><br><span class="line">if (!operation) &#123;</span><br><span class="line">    operation = createCallback();</span><br><span class="line">    __weak typeof(self) wself = self;</span><br><span class="line">    operation.completionBlock = ^&#123;</span><br><span class="line">        __strong typeof(wself) sself = wself;</span><br><span class="line">        if (!sself) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        LOCK(sself.operationsLock);</span><br><span class="line">        [sself.URLOperations removeObjectForKey:url];</span><br><span class="line">        UNLOCK(sself.operationsLock);</span><br><span class="line">    &#125;;</span><br><span class="line">    [self.URLOperations setObject:operation forKey:url];</span><br><span class="line">&#125;</span><br><span class="line">UNLOCK(self.operationsLock);</span><br></pre></td></tr></table></figure><p>2、同样由于为了避免同一个URL的图片被下载多次，所以我们并不会对每次操作一进来就进行创建请求任务，而是先通过之前缓存的下载任务URLOperations中通过URL寻找是否有该操作了，如果有则不创建，如果没有才创建。因此，这里就会有一个URL同时在被请求多次的情况下，生成/取到的是同一个SDWebImageDownloaderOperation。</p><h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h2><p>对于下载任务的执行，SDWebImage还允许我们设置是默认的先进先出还是后进先出。该功能的实现，其自然是通过队列操作的依赖来完成的(其中lastAddedOperation指的是上一次的操作)。源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[sself.downloadQueue addOperation:operation];</span><br><span class="line">if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">    // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</span><br><span class="line">    [sself.lastAddedOperation addDependency:operation];</span><br><span class="line">    sself.lastAddedOperation = operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他参考文章"><a href="#其他参考文章" class="headerlink" title="其他参考文章"></a>其他参考文章</h2><ul><li><a href="https://www.jianshu.com/p/e00854ab5567" target="_blank" rel="noopener">有关请求相同地址图片的下载问题(SDWebIMage底层原理的实现)</a></li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三方网络库AFNetworking</title>
      <link href="/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E7%BD%91%E7%BB%9C%E5%BA%93AFNetworking/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%BB%9C%E5%BA%93AFNetworking/"/>
      <url>/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E7%BD%91%E7%BB%9C%E5%BA%93AFNetworking/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%BB%9C%E5%BA%93AFNetworking/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-第三方网络库AFNetworking"><a href="#必备知识架构-第三方网络库AFNetworking" class="headerlink" title="必备知识架构-第三方网络库AFNetworking"></a>必备知识架构-第三方网络库AFNetworking</h1><p>[toc]</p><h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p><p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p><h1 id="AFNetworking源码解析与面试考点思考"><a href="#AFNetworking源码解析与面试考点思考" class="headerlink" title="AFNetworking源码解析与面试考点思考"></a>AFNetworking源码解析与面试考点思考</h1><p><a href="https://www.jianshu.com/p/4c169c127c70" target="_blank" rel="noopener">AFNetworking源码解析与面试考点思考</a></p><h2 id="八、多线程–第三方库AFNetworking"><a href="#八、多线程–第三方库AFNetworking" class="headerlink" title="八、多线程–第三方库AFNetworking"></a>八、多线程–第三方库AFNetworking</h2><blockquote><p><a href="#目录">&lt; 返回目录</a></p></blockquote><h4 id="1、AFNetworking源码解析"><a href="#1、AFNetworking源码解析" class="headerlink" title="1、AFNetworking源码解析"></a>1、AFNetworking源码解析</h4><ul><li><a href="https://www.cnblogs.com/Jordandan/p/6223089.html" target="_blank" rel="noopener">AFNetworking 3.0 使用详解 和 源码解析实现原理</a></li></ul><h4 id="2、AFNetworking的线程和信号量问题"><a href="#2、AFNetworking的线程和信号量问题" class="headerlink" title="2、AFNetworking的线程和信号量问题"></a>2、AFNetworking的线程和信号量问题</h4><ul><li><a href="http://www.cocoachina.com/bbs/read.php?tid=1695717" target="_blank" rel="noopener">AFNetworking的线程和信号量问题</a></li></ul><h3 id="AFNetworking3-0后为什么不再需要常驻线程？"><a href="#AFNetworking3-0后为什么不再需要常驻线程？" class="headerlink" title="AFNetworking3.0后为什么不再需要常驻线程？"></a>AFNetworking3.0后为什么不再需要常驻线程？</h3><p><a href="http://www.cocoachina.com/articles/25225" target="_blank" rel="noopener">AFNetworking3.0后为什么不再需要常驻线程？</a></p><p><strong>B.一个请求一条线程</strong></p><p>如果来一个请求开辟一条线程，设置runloop保活线程，等待结果回调。这种方式理论上是可行的，但是你也看到了，线程开销太大了。（PASS）</p><p><strong>C.一条常驻线程</strong></p><p>只开辟一条子线程，设置runloop使线程常驻。所有的请求在这个线程上发起、同时也<strong>在这个线程上处理回调</strong>。</p><p>线程保活的代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)aliveThread &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道主线程一直是保活的；而新建的子线程默认是没有添加Runloop的，因此给这个线程添加了一个runloop，并且加了一个NSMachPort，来防止这个新建的线程由于没有活动直接退出。</p><h4 id="AFNetworking一些API介绍"><a href="#AFNetworking一些API介绍" class="headerlink" title="AFNetworking一些API介绍"></a>AFNetworking一些API介绍</h4><p>必知点：AFNetworking框架默认请求类型<code>requestSerializer</code>和响应类型<code>responseSerializer</code>都是JSON格式的，即默认请求类型为<code>AFJSONRequestSerializer</code>，默认相应类型为<code>AFJSONResponseSerializer</code>。</p><h6 id="1、关于请求类型及请求参数的书写"><a href="#1、关于请求类型及请求参数的书写" class="headerlink" title="1、关于请求类型及请求参数的书写"></a>1、关于请求类型及请求参数的书写</h6><p>所以在进行请求时候，我们必须根据自己请求的参数类型parameters，对AFNetworking的请求类型进行设置。主要设置为：</p><ol><li>如果请求参数是字典类型<code>NSDictionary</code>，则请求类型应设置<code>AFHTTPRequestSerializer</code>。</li><li>如果请求参数是JSON类型，则请求类型应设置<code>AFJSONRequestSerializer</code>。</li></ol><p>因为设置的类型不同，AFNetworking会根据设置的类型执行该类型下面对应的<code>- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error</code>方法。</p><p>其中</p><p>AFHTTPRequestSerializer对参数会有如下第496行的处理<code>query = AFQueryStringFromParameters(parameters);</code>该处理为将字典类型转为一串请求的字符串格式。</p><p>AFJSONRequestSerializer对参数的处理主要为第1260行的<br><code>[mutableRequest setHTTPBody:[NSJSONSerialization dataWithJSONObject:parameters options:self.writingOptions error:error]];</code></p><h6 id="2、关于响应类型及响应response"><a href="#2、关于响应类型及响应response" class="headerlink" title="2、关于响应类型及响应response"></a>2、关于响应类型及响应response</h6><p>响应的时候，<code>AFURLSessionManager</code>其会调用<code>AFURLSessionManagerTaskDelegate</code>协议，执行该协议里第292的<code>responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</code>可以看出这里会根据我们设置的不同响应类型，调用该响应类型下的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br></pre></td></tr></table></figure><p>所以，这里我们衍生出一个继承自AFJSONResponseSerializer的<strong>CJJSONResponseSerializer</strong>的新响应类型，重写该方法，用来处理服务端返回的JSON不是标准的json格式的问题，即主要处理AFNetworking 3840的错误。</p><p></p><p id="END"></p><p></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote><p>&lt; <a href="#目录">返回目录</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三方库SDWebImage①缓存-①缓存不更新问题</title>
      <link href="/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A3%E5%85%B6%E4%BB%96/"/>
      <url>/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E5%9B%BE%E7%89%87%E5%BA%93SDWebImage/SDWebImage%E2%91%A3%E5%85%B6%E4%BB%96/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-第三方库SDWebImage③其他"><a href="#必备知识架构-第三方库SDWebImage③其他" class="headerlink" title="必备知识架构-第三方库SDWebImage③其他"></a>必备知识架构-第三方库SDWebImage③其他</h1><p>[toc]</p><p><a href="https://blog.csdn.net/applelg/article/details/81293013" target="_blank" rel="noopener">iOS - 主线程调度在应用中的小技巧</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 宏定义</span><br><span class="line">#ifndef dispatch_queue_async_safe</span><br><span class="line">#define dispatch_queue_async_safe(queue, block)\</span><br><span class="line">if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(queue)) &#123;\</span><br><span class="line">block();\</span><br><span class="line">&#125; else &#123;\</span><br><span class="line">dispatch_async(queue, block);\</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef dispatch_main_async_safe</span><br><span class="line">#define dispatch_main_async_safe(block) dispatch_queue_async_safe(dispatch_get_main_queue(), block)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><code>dispatch_queue_get_label</code>：返回创建队列时为队列指定的标签。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库-①FMDB</title>
      <link href="/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93FMDB/%E6%95%B0%E6%8D%AE%E5%BA%93-%E2%91%A0FMDB/"/>
      <url>/iOS/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93FMDB/%E6%95%B0%E6%8D%AE%E5%BA%93-%E2%91%A0FMDB/</url>
      
        <content type="html"><![CDATA[<h1 id="必备知识架构-数据库-①FMDB"><a href="#必备知识架构-数据库-①FMDB" class="headerlink" title="必备知识架构-数据库-①FMDB"></a>必备知识架构-数据库-①FMDB</h1><p>[toc]</p><h2 id="一、FMDB的多线程问题"><a href="#一、FMDB的多线程问题" class="headerlink" title="一、FMDB的多线程问题"></a>一、FMDB的多线程问题</h2><p>你项目用FMDB吗？你写的数据库类是线程安全的吗？如果不是，希望这篇小文章会对你有点帮助</p><h3 id="1、FMDB如何保证多线程处理的数据安全"><a href="#1、FMDB如何保证多线程处理的数据安全" class="headerlink" title="1、FMDB如何保证多线程处理的数据安全"></a>1、FMDB如何保证多线程处理的数据安全</h3><p>对于数据操作，最重要的一点就是数据安全的问题，在多线程中，线程安全是数据安全的首要前提，下面谈谈FMDB 是如何对多线程进行处理的。</p><p>详情参考：<a href="https://www.jianshu.com/p/cb60951cdc31" target="_blank" rel="noopener">FMDB 中的多线程处理</a></p><p><a href="https://blog.csdn.net/gdutxzy/article/details/43307643" target="_blank" rel="noopener">FMDatabaseQueue为何会线程安全的一点心得</a></p><h3 id="2、FMDatabaseQueue为何能保证线程安全"><a href="#2、FMDatabaseQueue为何能保证线程安全" class="headerlink" title="2、FMDatabaseQueue为何能保证线程安全"></a>2、FMDatabaseQueue为何能保证线程安全</h3><p>在做iOS项目的时候，会用到许多第三方的框架，比如用FMDB来处理数据库的东西。但是FMDatabase并不是线程安全的，当你在不同的线程里同时操作一个Database的时候，就容易产生崩溃。但是好在FMDB提供了一个解决的方法，就是FMDatabaseQueue。通过它来操作数据库就是线程安全的了。<br>即：FMDB是使用databaseQueue实现数据库操作线程安全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:_dbPath];</span><br><span class="line">[queue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">[db executeUpdateWithFormat:@&quot;INSERT INTO TABLENAME(id, name) VALUES (%zd, %@);&quot;, @1, @&quot;idage&quot;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>queue inDatabase:的本质如下：</p><p><img src="/iOS/第三方库/数据库FMDB/数据库-①FMDB/FMDB数据安全1.jpg" alt="FMDB数据安全1"></p><p>_queue的初始化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_queue = dispatch_queue_create([[NSString stringWithFormat:@&quot;fmdb.%@&quot;, self] UTF8String], NULL);</span><br></pre></td></tr></table></figure><p>FMDB是怎么处理线程安全的？</p><p><strong>综上所述：FMDB的线程处理就是强行就所有的多线程逻辑在一个串行队列中同步处理。</strong></p><h2 id="二、FMDB的数据库事务-Database-Transaction"><a href="#二、FMDB的数据库事务-Database-Transaction" class="headerlink" title="二、FMDB的数据库事务(Database Transaction)"></a>二、FMDB的数据库事务(Database Transaction)</h2><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。简单的来说就是可以同时处理多个数据库操作，并且速度很快。</p><p>FMDB是支持数据库事务的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[queue inTransaction:^(FMDatabase *db, BOOL *rollback) &#123;</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @1];</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @2];</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @3];</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @4];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="三、为什么要从FMDB迁移到WCDB？"><a href="#三、为什么要从FMDB迁移到WCDB？" class="headerlink" title="三、为什么要从FMDB迁移到WCDB？"></a>三、为什么要从FMDB迁移到WCDB？</h2><p><a href="https://www.juhe.cn/news/index/id/1998" target="_blank" rel="noopener">为什么要从FMDB迁移到WCDB？</a></p><p>表结构</p><p>WCDB 提供了 ORM 的功能，将类的属性绑定到数据库表的字段。在日常实践中，类的属性名和表的字段名通常不一致。因此，WCDB 提供了 WCDB_SYNTHESIZE_COLUMN(className, propertyName, columnName) 宏，用于映射属性名。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4节、Jenkins使用问题常见</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E4%B8%8A%E6%98%BE%E7%A4%BA%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%9B%BE%E7%89%87/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E4%B8%8A%E6%98%BE%E7%A4%BA%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Jenkins上显示二维码图片"><a href="#Jenkins上显示二维码图片" class="headerlink" title="Jenkins上显示二维码图片"></a>Jenkins上显示二维码图片</h1><h2 id="一、在Jenkins上显示二维码图片"><a href="#一、在Jenkins上显示二维码图片" class="headerlink" title="一、在Jenkins上显示二维码图片"></a>一、在Jenkins上显示二维码图片</h2><p><a href="https://testerhome.com/topics/19161#" target="_blank" rel="noopener">持续集成 从零开始在 Jenkins 上显示打包二维码</a></p><h3 id="1-安装Jenkins插件"><a href="#1-安装Jenkins插件" class="headerlink" title="1. 安装Jenkins插件"></a>1. 安装Jenkins插件</h3><ul><li><p>进入Jenkins工作台<code>系统管理</code>&gt;<code>插件管理</code>&gt;<code>可选插件</code>&gt;<code>过滤</code>&gt;<code>build-name-setter</code>，勾选对应插件<code>直接安装</code></p><p><img src="/实用工具/Jenkins/Jenkins上显示二维码图片/showQR1.png" alt="showQR1"></p></li><li><p>返回<code>工作台首页</code>，选择一个<code>Build工程</code>&gt;<code>配置</code></p></li><li><p>可以看到<code>构建环境</code>处多了一个<code>Set Build Name</code>的选项，即插件安装成功</p><p><img src="/实用工具/Jenkins/Jenkins上显示二维码图片/showQR2.png" alt="showQR2"></p></li></ul><h3 id="2-配置Set-Build-Name插件"><a href="#2-配置Set-Build-Name插件" class="headerlink" title="2. 配置Set Build Name插件"></a>2. 配置<code>Set Build Name</code>插件</h3><p>查看Jekins的环境变量参数，我们可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BUILD_NUMBER</span><br><span class="line">The current build number, such as &quot;153&quot;</span><br><span class="line">BUILD_DISPLAY_NAME</span><br><span class="line">The display name of the current build, which is something like &quot;#153&quot; by default.</span><br></pre></td></tr></table></figure><ul><li><p><code>Set Build Name</code>就是修改这个<code>BUILD_DISPLAY_NAME</code>，默认为<code>#${BUILD_NUMBER}</code></p></li><li><p>Jenkins的默认安全设置，会把所有的输入都当成纯文本，为了使图片链接生效，需要更改一下<code>系统管理</code>&gt;<code>全局安全配置</code>&gt;<code>标记格式器</code>，将<code>纯文本</code>选项改为<code>Safe HTML</code>,保存设置</p><p><img src="/实用工具/Jenkins/Jenkins上显示二维码图片/showQR3.png" alt="showQR3"></p></li><li><p>点击<code>Set Build Name</code>的高级，会出现<code>Build Description</code>的设置，可以在这里写入一个图片的链接 <code>&lt;img src=&quot;http://ww1.sinaimg.cn/large/007x9vWyly1g2zgykchtmj30a7064dk4.jpg&quot; height=&quot;200&quot; width=&quot;200/&gt;</code></p></li><li><p>Build完成之后即可在Build历史中看到对应的图片链接</p><p><img src="http://ww1.sinaimg.cn/large/007x9vWyly1g2zhbf2iizj30a206kwho.jpg" alt="img"></p></li></ul><p><img src="/实用工具/Jenkins/Jenkins上显示二维码图片/showQR4_update1.png" alt="showQR4_update1"></p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4节、Jenkins使用问题常见</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Jenkins自定义构建参数使用"><a href="#Jenkins自定义构建参数使用" class="headerlink" title="Jenkins自定义构建参数使用"></a>Jenkins自定义构建参数使用</h1><p><a href="https://blog.csdn.net/qq_21047625/article/details/99643894?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf" target="_blank" rel="noopener">Jenkins自定义构建参数使用</a></p><p><img src="/实用工具/Jenkins/Jenkins参数化构建/parameterized1.png" alt="parameterized1"></p><p><img src="/实用工具/Jenkins/Jenkins参数化构建/parameterized2.png" alt="parameterized2"></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4节、Jenkins使用问题常见</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E5%B8%B8%E8%A7%81/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E5%B8%B8%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/实用工具/Jenkins/Jenkins使用问题常见/Jenkins icon.png" alt="Jenkins"></p><p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>天啊，没遇到问题之前，你永远不知道我下面要讲的这些点是多么多么的重要。你只要稍微不注意，就会导致你所有的正确操作都变成错误。</p><h2 id="Jenkins管理员密码忘记的解决办法"><a href="#Jenkins管理员密码忘记的解决办法" class="headerlink" title="Jenkins管理员密码忘记的解决办法"></a>Jenkins管理员密码忘记的解决办法</h2><p>首先明确，不管是初始密码，还是找回管理员密码都是从<code>共享--Jenkins--Home</code>中处理，目录结果如下：<br><img src="/实用工具/Jenkins/Jenkins使用问题常见/jenkins_Home.png" alt="jenkins_Home"></p><blockquote><p>admin密码更改忘记情况</p><p>1.删除Jenkins目录下config.xml文件中下面代码，并保存文件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;useSecurity&gt;true&lt;/useSecurity&gt;</span><br><span class="line">&lt;authorizationStrategy class=&quot;hudson.security.FullControlOnceLoggedInAuthorizationStrategy&quot;&gt;</span><br><span class="line">  &lt;denyAnonymousReadAccess&gt;true&lt;/denyAnonymousReadAccess&gt;</span><br><span class="line">&lt;/authorizationStrategy&gt;</span><br><span class="line">&lt;securityRealm class=&quot;hudson.security.HudsonPrivateSecurityRealm&quot;&gt;</span><br><span class="line">  &lt;disableSignup&gt;true&lt;/disableSignup&gt;</span><br><span class="line">  &lt;enableCaptcha&gt;false&lt;/enableCaptcha&gt;</span><br><span class="line">&lt;/securityRealm&gt;</span><br></pre></td></tr></table></figure><blockquote><p>2.重启Jenkins服务 <a href="http://localhost:8080/restart" target="_blank" rel="noopener">http://localhost:8080/restart</a></p></blockquote><p> 附：重新加载配置信息 <a href="http://localhost:8080/reload" target="_blank" rel="noopener">http://localhost:8080/reload</a></p><blockquote><p>3.进入首页&gt;“系统管理”&gt;“Configure Global Security”；</p><p>4.勾选“启用安全”；</p><p>5.点选“Jenkins专有用户数据库”，并点击“保存”；</p><p>6.重新点击首页&gt;“系统管理”,发现此时出现“管理用户”；</p><p>7.点击进入展示“用户列表”；</p><p>8.点击右侧进入修改密码页面，修改后即可重新登录。</p></blockquote><p>参考：<a href="http://blog.csdn.net/jlminghui/article/details/54952148" target="_blank" rel="noopener">忘记Jenkins管理员密码的解决办法</a></p><h2 id="一、文件路径问题"><a href="#一、文件路径问题" class="headerlink" title="一、文件路径问题"></a>一、文件路径问题</h2><p>Jenkins脚本中，不能使用桌面路径：</p><p>本地cd目录注意：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 错误<span class="built_in">cd</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /Users/lichaoqian/Desktop/TestScript<span class="comment"># 不能使用桌面路径，执行构建时候Jenkins会提示  `cd: /Users/lichaoqian/Desktop/TestScript: Not a directory`</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 正确<span class="built_in">cd</span></span></span><br><span class="line">cd /Users/lichaoqian/Project/Test/TestScript</span><br></pre></td></tr></table></figure><h2 id="二、权限问题"><a href="#二、权限问题" class="headerlink" title="二、权限问题"></a>二、权限问题</h2><h3 id="1、问题例子"><a href="#1、问题例子" class="headerlink" title="1、问题例子"></a>1、问题例子</h3><p>将在终端中已验证通过的如下脚本，放到Jenkins上执行。</p><h5 id="问题例子1：文件修改"><a href="#问题例子1：文件修改" class="headerlink" title="问题例子1：文件修改"></a>问题例子1：文件修改</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/lichaoqian/Project/Test/TestScript</span><br><span class="line">chmod -R 777 ./0000.txt</span><br></pre></td></tr></table></figure><p>执行后，Jenkins的log如下：</p><p><img src="/实用工具/Jenkins/Jenkins使用问题常见/JenkinsPermission_1.png" alt="Jenkins权限问题log"></p><p>很显然这是个权限问题。</p><h5 id="问题例子2：钥匙串Keychain解锁"><a href="#问题例子2：钥匙串Keychain解锁" class="headerlink" title="问题例子2：钥匙串Keychain解锁"></a>问题例子2：钥匙串Keychain解锁</h5><p>同理的当你执行钥匙串Keychain的时候也会有权限问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">security unlock-keychain -p "lichaoqian" "/Users/lichaoqian/Library/Keychains/login.keychain"</span><br></pre></td></tr></table></figure><p><img src="/实用工具/Jenkins/Jenkins使用问题常见/unlock-keychain_1_JenkinsScript.png" alt="unlock-keychain_1_JenkinsScript"></p><p>执行后，Jenkins的log如下：</p><p><img src="/实用工具/Jenkins/Jenkins使用问题常见/unlock-keychain_1_JenkinsErrorLog.png" alt="unlock-keychain_1_JenkinsErrorLog.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[TestScript] $ /bin/sh -xe /Users/Shared/Jenkins/tmp/jenkins2455609193418764900.sh</span><br><span class="line">+ security unlock-keychain -p lichaoqian /Users/lichaoqian/Library/Keychains/login.keychain</span><br><span class="line">security: SecKeychainUnlock /Users/lichaoqian/Library/Keychains/login.keychain: Write permissions error.</span><br><span class="line">Build step '执行 shell' marked build as failure</span><br><span class="line">Finished: FAILURE</span><br></pre></td></tr></table></figure><p>很显然这也是个权限问题。</p><h3 id="2、权限问题分析"><a href="#2、权限问题分析" class="headerlink" title="2、权限问题分析"></a>2、权限问题分析</h3><p>参考文章：<a href="https://www.jianshu.com/p/69b544d2a9d1" target="_blank" rel="noopener">iOS开发-自动化打包Jenkins集成</a>的文章开头就有讲到。</p><p>原因：<strong>Jenkins打开姿势不对！</strong></p><p>如果你构建的工程，是在<strong>/Users/Shared/Jenkins</strong>工作目录下，那么就会有权限问题。</p><p>如果你构建的工程，是在<strong>/Users/[user name]/.jenkins</strong>工作目录下，才不会有权限问题。</p><ul><li>错误的：有权限问题的Jenkins workspace目录</li></ul><p><img src="/实用工具/Jenkins/Jenkins使用问题常见/JenkinsPermission_2.png" alt="有权限问题的Jenkins workspace目录"></p><ul><li>正确的：无权限问题的Jenkins workspace目录</li></ul><p><img src="/实用工具/Jenkins/Jenkins使用问题常见/JenkinsPermission_3.png" alt="无权限问题的Jenkins workspace目录"></p><ul><li><p>如何验证你当前项目点击构建后的工作目录是哪里呢？</p><p>答：直接构建，然后去查看你的项目显示在哪里啊。</p></li></ul><h3 id="3、权限问题解决-正确的启动Jenkins姿势"><a href="#3、权限问题解决-正确的启动Jenkins姿势" class="headerlink" title="3、权限问题解决(正确的启动Jenkins姿势)"></a>3、权限问题解决(正确的启动Jenkins姿势)</h3><p>在使用正确的启动Jenkins之前，我们先来认识下下面的这个<code>org.jenkins-ci.plist</code>文件。它的位置 <em><code>/Library/LaunchDaemons/org.jenkins-ci.plist</code></em> 如下：</p><p><img src="/实用工具/Jenkins/Jenkins使用问题常见/JenkinsPermission_4.png" alt="正确的启动Jenkins姿势"></p><p>没有权限问题的Jenkins正确的启动方式如下(按下面方式打开，才不会出现权限问题)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -jar /Applications/Jenkins/jenkins.war --httpPort=8080</span></span><br></pre></td></tr></table></figure><p>当你执行完这两行命令的时候，你可以在浏览器上输入<code>http://localhost:8080</code>来访问Jenkins了。(如果你只执行了第一行，没执行第二行，会出现无法访问)</p><h3 id="4、解决后的结果显示"><a href="#4、解决后的结果显示" class="headerlink" title="4、解决后的结果显示"></a>4、解决后的结果显示</h3><ul><li>4.1、脚本内容</li></ul><p><img src="/实用工具/Jenkins/Jenkins使用问题常见/JenkinsPermission_5.png" alt="脚本内容"></p><ul><li>4.2、脚本执行结果</li></ul><p><img src="/实用工具/Jenkins/Jenkins使用问题常见/JenkinsPermission_6.png" alt="脚本执行结果"></p><p>至此，你的权限问题已完美解决。</p><p><img src="/实用工具/Jenkins/Jenkins使用问题常见/分割图1.jpg" alt="休息一下"></p><h2 id="三、其他权限问题"><a href="#三、其他权限问题" class="headerlink" title="三、其他权限问题"></a>三、其他权限问题</h2><ul><li>Jenkins问题解决方案：</li></ul><p>解决：进入mac 系统偏好设置 — 用户与群组 — 其他用户 — jenkins ，勾选允许用户管理这台电脑</p><p><img src="/实用工具/Jenkins/Jenkins使用问题常见/unlock-keychain_Write%20permissions%20error.png" alt="unlock-keychain_Write permissions error"></p><p>勾选选项。</p><p><img src="/实用工具/Jenkins/Jenkins使用问题常见/unlock-keychain_3_JenkinsSolve.png" alt="unlock-keychain_3_JenkinsSolve"></p><h2 id="四、Jenkins权限问题其他解决方法-未实践"><a href="#四、Jenkins权限问题其他解决方法-未实践" class="headerlink" title="四、Jenkins权限问题其他解决方法(未实践)"></a>四、Jenkins权限问题其他解决方法(未实践)</h2><ul><li>未实践方式1(都未实践)：</li></ul><p><a href="https://www.jianshu.com/p/fa546f723724" target="_blank" rel="noopener">Jenkins执行脚本提示没有权限的解决办法</a> 未实践，因为已经通过上述正确的启动Jenkins来解决了。所以这里没去实践。不过看内容应该是可行的。后续有时间再补充。</p><ul><li>未实践方式2(看了应该无效)：</li></ul><p>提高Jenkins用户权限，详见《Terminal -&gt; 终端命令使用.md》中的用户相关操作。应该无效</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS进阶_推送模拟</title>
      <link href="/iOS/%E8%BF%9B%E9%98%B6/iOS%E8%BF%9B%E9%98%B6_%E6%8E%A8%E9%80%81%E6%A8%A1%E6%8B%9F/"/>
      <url>/iOS/%E8%BF%9B%E9%98%B6/iOS%E8%BF%9B%E9%98%B6_%E6%8E%A8%E9%80%81%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="APNS模拟"><a href="#APNS模拟" class="headerlink" title="APNS模拟"></a>APNS模拟</h1><h2 id="一、使用SmartPush调试"><a href="#一、使用SmartPush调试" class="headerlink" title="一、使用SmartPush调试"></a>一、使用SmartPush调试</h2><ul><li>几个工具</li></ul><table><thead><tr><th>工具</th><th>Star</th><th>有效性</th></tr></thead><tbody><tr><td><a href="https://github.com/shaojiankui/SmartPush" target="_blank" rel="noopener">SmartPush</a></td><td>1144</td><td>测了有问题</td></tr><tr><td><a href="https://github.com/KnuffApp/Knuff" target="_blank" rel="noopener">Knuff</a></td><td>4432</td><td>亲测有效</td></tr><tr><td><a href="https://github.com/immobiliare/ApnsPHP" target="_blank" rel="noopener">ApnsPHP</a></td><td>1361</td><td>未测</td></tr><tr><td><a href="https://github.com/manifestinteractive/easyapns" target="_blank" rel="noopener">easyapns</a></td><td>706</td><td>未测</td></tr></tbody></table><h2 id="二、自己搭建"><a href="#二、自己搭建" class="headerlink" title="二、自己搭建"></a>二、自己搭建</h2><p>脚本实现参考文章：</p><ul><li><p><a href="https://blog.csdn.net/TuGeLe/article/details/79699926" target="_blank" rel="noopener">iOS客户端如何测试推送</a></p></li><li><p><a href="https://www.cnblogs.com/ablettchen/p/4162350.html" target="_blank" rel="noopener">iOS 远程推送的实现</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS进阶_打包脚本</title>
      <link href="/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/iOS%E8%BF%9B%E9%98%B6_%E6%89%93%E5%8C%85/"/>
      <url>/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/iOS%E8%BF%9B%E9%98%B6_%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、认识Mac的keychain机制"><a href="#一、认识Mac的keychain机制" class="headerlink" title="一、认识Mac的keychain机制"></a>一、认识Mac的keychain机制</h2><p>要使用Keychain中的证书，请先<code>unlock-keychain</code>。</p><p>完整的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">security unlock-keychain -p "lichaoqian" "/Users/lichaoqian/Library/Keychains/login.keychain"</span><br></pre></td></tr></table></figure><p><strong>如果你是在Jenkins中执行的，请确保你的权限问题。具体的解决可进入《使用工具-&gt;Jenkins-&gt;Jenkins使用问题常见》中的”二、权限问题”</strong>中查看解决。</p><p>其他参考文章：</p><ul><li><a href="https://www.coder4.com/archives/5131" target="_blank" rel="noopener">Jenkins上后台持续集成时如何绕过Mac的keychain机制</a></li><li><a href="https://blog.csdn.net/jintemp/article/details/79894263" target="_blank" rel="noopener">远程连接 Mac 设置使用密钥 security -v unlock-keychain</a></li><li><a href="https://blog.csdn.net/zhaodanfeng1025/article/details/41486993" target="_blank" rel="noopener">security用法</a></li><li><a href="https://stackoverflow.com/questions/35517496/unable-to-unlock-the-keychain" target="_blank" rel="noopener">Unable to unlock the keychain</a></li></ul><h2 id="二、认识几个命令"><a href="#二、认识几个命令" class="headerlink" title="二、认识几个命令"></a>二、认识几个命令</h2><ul><li>查看SDK版本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -showsdks</span><br></pre></td></tr></table></figure><p>查询结果如下：</p><p><img src="/iOS/自动化/iOS进阶_打包/iOS打包_showsdks.png" alt="xcodebuild -showsdks的执行结果"></p><h2 id="三、认识执行命令"><a href="#三、认识执行命令" class="headerlink" title="三、认识执行命令"></a>三、认识执行命令</h2><p>在终端执行<code>xcodebuild --help</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">Beyond-MacBook-Pro:~ lichaoqian$ xcodebuild --help</span><br><span class="line">Usage: xcodebuild [-project &lt;projectname&gt;] [[-target &lt;targetname&gt;]...|-alltargets] [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [-showBuildSettings [-json]] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]...</span><br><span class="line">       xcodebuild [-project &lt;projectname&gt;] -scheme &lt;schemeName&gt; [-destination &lt;destinationspecifier&gt;]... [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [-showBuildSettings [-json]] [-showdestinations] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]...</span><br><span class="line">       xcodebuild -workspace &lt;workspacename&gt; -scheme &lt;schemeName&gt; [-destination &lt;destinationspecifier&gt;]... [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [-showBuildSettings] [-showdestinations] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]...</span><br><span class="line">       xcodebuild -version [-sdk [&lt;sdkfullpath&gt;|&lt;sdkname&gt;] [-json] [&lt;infoitem&gt;] ]</span><br><span class="line">       xcodebuild -list [[-project &lt;projectname&gt;]|[-workspace &lt;workspacename&gt;]] [-json]</span><br><span class="line">       xcodebuild -showsdks [-json]</span><br><span class="line">       xcodebuild -exportArchive -archivePath &lt;xcarchivepath&gt; [-exportPath &lt;destinationpath&gt;] -exportOptionsPlist &lt;plistpath&gt;</span><br><span class="line">       xcodebuild -exportNotarizedApp -archivePath &lt;xcarchivepath&gt; -exportPath &lt;destinationpath&gt;</span><br><span class="line">       xcodebuild -exportLocalizations -localizationPath &lt;path&gt; -project &lt;projectname&gt; [-exportLanguage &lt;targetlanguage&gt;...[-includeScreenshots]]</span><br><span class="line">       xcodebuild -importLocalizations -localizationPath &lt;path&gt; -project &lt;projectname&gt;</span><br><span class="line">       xcodebuild -resolvePackageDependencies [-project &lt;projectname&gt;|-workspace &lt;workspacename&gt;] -clonedSourcePackagesDirPath &lt;path&gt;</span><br><span class="line">       xcodebuild -create-xcframework [-help] [-framework &lt;path&gt;] [-library &lt;path&gt; [-headers &lt;path&gt;]] -output &lt;path&gt;</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -usage                                                   print brief usage</span><br><span class="line">    -help                                                    print complete usage</span><br><span class="line">    -verbose                                                 provide additional status output</span><br><span class="line">    -license                                                 show the Xcode and SDK license agreements</span><br><span class="line">    -checkFirstLaunchStatus                                  Check if any First Launch tasks need to be performed</span><br><span class="line">    -runFirstLaunch                                          install packages and agree to the license</span><br><span class="line">    -project NAME                                            build the project NAME</span><br><span class="line">    -target NAME                                             build the target NAME</span><br><span class="line">    -alltargets                                              build all targets</span><br><span class="line">    -workspace NAME                                          build the workspace NAME</span><br><span class="line">    -scheme NAME                                             build the scheme NAME</span><br><span class="line">    -configuration NAME                                      use the build configuration NAME for building each target</span><br><span class="line">    -xcconfig PATH                                           apply the build settings defined in the file at PATH as overrides</span><br><span class="line">    -arch ARCH                                               build each target for the architecture ARCH; this will override architectures defined in the project</span><br><span class="line">    -sdk SDK                                                 use SDK as the name or path of the base SDK when building the project</span><br><span class="line">    -toolchain NAME                                          use the toolchain with identifier or name NAME</span><br><span class="line">    -destination DESTINATIONSPECIFIER                        use the destination described by DESTINATIONSPECIFIER (a comma-separated set of key=value pairs describing the destination to use)</span><br><span class="line">    -destination-timeout TIMEOUT                             wait for TIMEOUT seconds while searching for the destination device</span><br><span class="line">    -parallelizeTargets                                      build independent targets in parallel</span><br><span class="line">    -jobs NUMBER                                             specify the maximum number of concurrent build operations</span><br><span class="line">    -maximum-concurrent-test-device-destinations NUMBER      the maximum number of device destinations to test on concurrently</span><br><span class="line">    -maximum-concurrent-test-simulator-destinations NUMBER   the maximum number of simulator destinations to test on concurrently</span><br><span class="line">    -parallel-testing-enabled YES|NO                         overrides the per-target setting in the scheme</span><br><span class="line">    -parallel-testing-worker-count NUMBER                    the exact number of test runners that will be spawned during parallel testing</span><br><span class="line">    -maximum-parallel-testing-workers NUMBER                 the maximum number of test runners that will be spawned during parallel testing</span><br><span class="line">    -dry-run                                                 do everything except actually running the commands</span><br><span class="line">    -quiet                                                   do not print any output except for warnings and errors</span><br><span class="line">    -hideShellScriptEnvironment                              don't show shell script environment variables in build log</span><br><span class="line">    -showsdks                                                display a compact list of the installed SDKs</span><br><span class="line">    -showdestinations                                        display a list of destinations</span><br><span class="line">    -showTestPlans                                           display a list of test plans</span><br><span class="line">    -showBuildSettings                                       display a list of build settings and values</span><br><span class="line">    -list                                                    lists the targets and configurations in a project, or the schemes in a workspace</span><br><span class="line">    -find-executable NAME                                    display the full path to executable NAME in the provided SDK and toolchain</span><br><span class="line">    -find-library NAME                                       display the full path to library NAME in the provided SDK and toolchain</span><br><span class="line">    -version                                                 display the version of Xcode; with -sdk will display info about one or all installed SDKs</span><br><span class="line">    -enableAddressSanitizer YES|NO                           turn the address sanitizer on or off</span><br><span class="line">    -enableThreadSanitizer YES|NO                            turn the thread sanitizer on or off</span><br><span class="line">    -enableUndefinedBehaviorSanitizer YES|NO                 turn the undefined behavior sanitizer on or off</span><br><span class="line">    -resultBundlePath PATH                                   specifies the directory where a result bundle describing what occurred will be placed</span><br><span class="line">    -resultStreamPath PATH                                   specifies the file where a result stream will be written to (the file must already exist)</span><br><span class="line">    -resultBundleVersion 3 [default]                         specifies which result bundle version should be used</span><br><span class="line">    -clonedSourcePackagesDirPath PATH                        specifies the directory to which remote source packages are fetch or expected to be found</span><br><span class="line">    -derivedDataPath PATH                                    specifies the directory where build products and other derived data will go</span><br><span class="line">    -archivePath PATH                                        specifies the directory where any created archives will be placed, or the archive that should be exported</span><br><span class="line">    -exportArchive                                           specifies that an archive should be exported</span><br><span class="line">    -exportNotarizedApp                                      export an archive that has been notarized by Apple</span><br><span class="line">    -exportOptionsPlist PATH                                 specifies a path to a plist file that configures archive exporting</span><br><span class="line">    -enableCodeCoverage YES|NO                               turn code coverage on or off when testing</span><br><span class="line">    -exportPath PATH                                         specifies the destination for the product exported from an archive</span><br><span class="line">    -skipUnavailableActions                                  specifies that scheme actions that cannot be performed should be skipped instead of causing a failure</span><br><span class="line">    -exportLocalizations                                     exports completed and outstanding project localizations</span><br><span class="line">    -importLocalizations                                     imports localizations for a project, assuming any necessary localized resources have been created in Xcode</span><br><span class="line">    -localizationPath                                        specifies a path to XLIFF localization files</span><br><span class="line">    -exportLanguage                                          specifies multiple optional ISO 639-1 languages included in a localization export</span><br><span class="line">    -xctestrun                                               specifies a path to a test run specification</span><br><span class="line">    -testPlan                                                specifies the name of the test plan associated with the scheme to use for testing</span><br><span class="line">    -only-testing                                            constrains testing by specifying tests to include, and excluding other tests</span><br><span class="line">    -only-testing:TEST-IDENTIFIER                            constrains testing by specifying tests to include, and excluding other tests</span><br><span class="line">    -skip-testing                                            constrains testing by specifying tests to exclude, but including other tests</span><br><span class="line">    -skip-testing:TEST-IDENTIFIER                            constrains testing by specifying tests to exclude, but including other tests</span><br><span class="line">    -only-test-configuration                                 constrains testing by specifying test configurations to include, and excluding other test configurations</span><br><span class="line">    -skip-test-configuration                                 constrains testing by specifying test configurations to exclude, but including other test configurations</span><br><span class="line">    -testLanguage                                            constrains testing by specifying ISO 639-1 language in which to run the tests</span><br><span class="line">    -testRegion                                              constrains testing by specifying ISO 3166-1 region in which to run the tests</span><br><span class="line">    -resolvePackageDependencies                              resolves any Swift package dependencies referenced by the project or workspace</span><br><span class="line">    -disableAutomaticPackageResolution                       prevents packages from automatically being resolved to versions other than those recorded in the `Package.resolved` file</span><br><span class="line">    -json                                                    output as JSON (note: -json implies -quiet)</span><br><span class="line">    -allowProvisioningUpdates                                Allow xcodebuild to communicate with the Apple Developer website. For automatically signed targets, xcodebuild will create and update profiles, app IDs, and certificates. For manually signed targets, xcodebuild will download missing or updated provisioning profiles. Requires a developer account to have been added in Xcode's Accounts preference pane.</span><br><span class="line">    -allowProvisioningDeviceRegistration                     Allow xcodebuild to register your destination device on the developer portal if necessary. This flag only takes effect if -allowProvisioningUpdates is also passed.</span><br><span class="line">    -showBuildTimingSummary                                  display a report of the timings of all the commands invoked during the build</span><br><span class="line">    -create-xcframework                                      create an xcframework from prebuilt libraries; -help for more information.</span><br><span class="line"></span><br><span class="line">Available keys for -exportOptionsPlist:</span><br><span class="line"></span><br><span class="line">compileBitcode : Bool</span><br><span class="line"></span><br><span class="line">For non-App Store exports, should Xcode re-compile the app from bitcode? Defaults to YES.</span><br><span class="line"></span><br><span class="line">destination : String</span><br><span class="line"></span><br><span class="line">Determines whether the app is exported locally or uploaded to Apple. Options are export or upload. The available options vary based on the selected distribution method. Defaults to export.</span><br><span class="line"></span><br><span class="line">embedOnDemandResourcesAssetPacksInBundle : Bool</span><br><span class="line"></span><br><span class="line">For non-App Store exports, if the app uses On Demand Resources and this is YES, asset packs are embedded in the app bundle so that the app can be tested without a server to host asset packs. Defaults to YES unless onDemandResourcesAssetPacksBaseURL is specified.</span><br><span class="line"></span><br><span class="line">generateAppStoreInformation : Bool</span><br><span class="line"></span><br><span class="line">For App Store exports, should Xcode generate App Store Information for uploading with iTMSTransporter? Defaults to NO.</span><br><span class="line"></span><br><span class="line">iCloudContainerEnvironment : String</span><br><span class="line"></span><br><span class="line">If the app is using CloudKit, this configures the "com.apple.developer.icloud-container-environment" entitlement. Available options vary depending on the type of provisioning profile used, but may include: Development and Production.</span><br><span class="line"></span><br><span class="line">installerSigningCertificate : String</span><br><span class="line"></span><br><span class="line">For manual signing only. Provide a certificate name, SHA-1 hash, or automatic selector to use for signing. Automatic selectors allow Xcode to pick the newest installed certificate of a particular type. The available automatic selectors are "Mac Installer Distribution" and "Developer ID Installer". Defaults to an automatic certificate selector matching the current distribution method.</span><br><span class="line"></span><br><span class="line">manifest : Dictionary</span><br><span class="line"></span><br><span class="line">For non-App Store exports, users can download your app over the web by opening your distribution manifest file in a web browser. To generate a distribution manifest, the value of this key should be a dictionary with three sub-keys: appURL, displayImageURL, fullSizeImageURL. The additional sub-key assetPackManifestURL is required when using on-demand resources.</span><br><span class="line"></span><br><span class="line">method : String</span><br><span class="line"></span><br><span class="line">Describes how Xcode should export the archive. Available options: app-store, validation, ad-hoc, package, enterprise, development, developer-id, and mac-application. The list of options varies based on the type of archive. Defaults to development.</span><br><span class="line"></span><br><span class="line">onDemandResourcesAssetPacksBaseURL : String</span><br><span class="line"></span><br><span class="line">For non-App Store exports, if the app uses On Demand Resources and embedOnDemandResourcesAssetPacksInBundle isn't YES, this should be a base URL specifying where asset packs are going to be hosted. This configures the app to download asset packs from the specified URL.</span><br><span class="line"></span><br><span class="line">provisioningProfiles : Dictionary</span><br><span class="line"></span><br><span class="line">For manual signing only. Specify the provisioning profile to use for each executable in your app. Keys in this dictionary are the bundle identifiers of executables; values are the provisioning profile name or UUID to use.</span><br><span class="line"></span><br><span class="line">signingCertificate : String</span><br><span class="line"></span><br><span class="line">For manual signing only. Provide a certificate name, SHA-1 hash, or automatic selector to use for signing. Automatic selectors allow Xcode to pick the newest installed certificate of a particular type. The available automatic selectors are "Mac App Distribution", "iOS Distribution", "iOS Developer", "Developer ID Application", "Apple Distribution", "Mac Developer", and "Apple Development". Defaults to an automatic certificate selector matching the current distribution method.</span><br><span class="line"></span><br><span class="line">signingStyle : String</span><br><span class="line"></span><br><span class="line">The signing style to use when re-signing the app for distribution. Options are manual or automatic. Apps that were automatically signed when archived can be signed manually or automatically during distribution, and default to automatic. Apps that were manually signed when archived must be manually signed during distribtion, so the value of signingStyle is ignored.</span><br><span class="line"></span><br><span class="line">stripSwiftSymbols : Bool</span><br><span class="line"></span><br><span class="line">Should symbols be stripped from Swift libraries in your IPA? Defaults to YES.</span><br><span class="line"></span><br><span class="line">teamID : String</span><br><span class="line"></span><br><span class="line">The Developer Portal team to use for this export. Defaults to the team used to build the archive.</span><br><span class="line"></span><br><span class="line">thinning : String</span><br><span class="line"></span><br><span class="line">For non-App Store exports, should Xcode thin the package for one or more device variants? Available options: &lt;none&gt; (Xcode produces a non-thinned universal app), &lt;thin-for-all-variants&gt; (Xcode produces a universal app and all available thinned variants), or a model identifier for a specific device (e.g. "iPhone7,1"). Defaults to &lt;none&gt;.</span><br><span class="line"></span><br><span class="line">uploadBitcode : Bool</span><br><span class="line"></span><br><span class="line">For App Store exports, should the package include bitcode? Defaults to YES.</span><br><span class="line"></span><br><span class="line">uploadSymbols : Bool</span><br><span class="line"></span><br><span class="line">For App Store exports, should the package include symbols? Defaults to YES.</span><br></pre></td></tr></table></figure><h3 id="1、cd到代码目录"><a href="#1、cd到代码目录" class="headerlink" title="1、cd到代码目录"></a>1、cd到代码目录</h3><p>略</p><h3 id="2、开始打包"><a href="#2、开始打包" class="headerlink" title="2、开始打包"></a>2、开始打包</h3><ul><li>执行命令</li></ul><p>写在终端进行测试的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -workspace CJAutoPackageDemo.xcworkspace -scheme App1Enterprise -configuration Debug -sdk iphoneos12.2 ARCHS='arm64 armv7' IOS_DEVELOPMENT_TARGET=8.0 -derivedDataPath ../output/build/Debug-iphoneos archive -archivePath ../output/Debug-iphoneos/App1Enterprise.xcarchive</span><br></pre></td></tr></table></figure><p>写在脚本中的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo ""</span><br><span class="line">echo ""</span><br><span class="line">echo "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; step5：begin compile project &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span><br><span class="line">xcodebuild -workspace $&#123;PROJECT_DIR&#125;/$&#123;APPPROJECT_NAME&#125;.xcworkspace -scheme $&#123;APPTARGET_NAME&#125; -configuration $&#123;BUILD_CONFIGURATION_NAME&#125; -sdk $&#123;SIMULATOR_OR_IOS_SDK&#125;$&#123;SDK_VERSION&#125; ARCHS='arm64 armv7' IOS_DEVELOPMENT_TARGET=$&#123;DEVELOPMENT_TARGET&#125; -derivedDataPath $&#123;BUILD_OUTPUT_PATH&#125; archive -archivePath "$&#123;ARCHIVE_OUTPUT_PATH&#125;/$&#123;APPTARGET_NAME&#125;.xcarchive"</span><br><span class="line">echo "&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; step5：end compile project &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span><br></pre></td></tr></table></figure><p>参数介绍：</p><table><thead><tr><th>参数</th><th>含义</th><th></th></tr></thead><tbody><tr><td>-workspace</td><td>工程文件名（用cocopods集成的项目，没有的话 整个改为-xcodeproj xxx.xcodeproj）</td><td></td></tr><tr><td>-scheme</td><td>通过scheme指定不同的target</td><td></td></tr><tr><td>-configuration</td><td>对应的环境配置，就是编译的时候执行的模式<br>(测试Debug、预生产PreRelease、生产Release)</td><td></td></tr><tr><td>-archivePath</td><td>导出的.xcarchive的路径</td><td></td></tr><tr><td>-sdk</td><td></td><td></td></tr><tr><td>-derivedDataPath</td><td></td><td></td></tr><tr><td>-archivePath</td><td>导出的.xcarchive的路径</td></tr></tbody></table><h3 id="3、导出ipa"><a href="#3、导出ipa" class="headerlink" title="3、导出ipa"></a>3、导出ipa</h3><ul><li>执行命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echo ""</span><br><span class="line">echo ""</span><br><span class="line">echo "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; step6：begin archiving app to ipa &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span><br><span class="line">echo "PWD=$PWD"</span><br><span class="line">cd $&#123;ROOT_DIR&#125;</span><br><span class="line">echo "PWD=$PWD"</span><br><span class="line">echo "archivePath ==&gt;&gt;&gt; $&#123;ARCHIVE_OUTPUT_PATH&#125;/$&#123;APPTARGET_NAME&#125;.xcarchive"</span><br><span class="line">echo "exportPath ==&gt;&gt;&gt; $&#123;ARCHIVE_OUTPUT_PATH&#125;/$&#123;APPTARGET_NAME&#125;"</span><br><span class="line">echo "exportOptionsPlist ==&gt;&gt;&gt; $&#123;ExportOptionsPlist_PATH&#125;"</span><br><span class="line">xcodebuild -exportArchive -archivePath "$&#123;ARCHIVE_OUTPUT_PATH&#125;/$&#123;APPTARGET_NAME&#125;.xcarchive" -exportPath "$&#123;ARCHIVE_OUTPUT_PATH&#125;/$&#123;APPTARGET_NAME&#125;" -exportOptionsPlist "$&#123;ExportOptionsPlist_PATH&#125;" -allowProvisioningUpdates</span><br><span class="line">echo "&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; step6：end archiving app to ipa &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span><br></pre></td></tr></table></figure><ul><li>参数解读：</li></ul><table><thead><tr><th>参数</th><th>含义</th><th></th></tr></thead><tbody><tr><td>-archivePath</td><td>.xcarchive文件的路径</td><td></td></tr><tr><td>-exportPath</td><td>导出的ipa的路径</td><td></td></tr><tr><td>-exportOptionsPlist</td><td></td></tr></tbody></table><h2 id="三、完整脚本内容-含使用Jenkins打包"><a href="#三、完整脚本内容-含使用Jenkins打包" class="headerlink" title="三、完整脚本内容(含使用Jenkins打包)"></a>三、完整脚本内容(含使用Jenkins打包)</h2><ul><li><p>测试项目工程详见：gitee中的<a href="https://gitee.com/dvlpCI/AutoPackage-iOS" target="_blank" rel="noopener">AutoPackage-iOS</a>工程</p></li><li><p>测试Jenkins工程详见：本地Jenkins中的<a href="http://localhost:8080/job/CJAutoPackage/" target="_blank" rel="noopener">CJAutoPackage</a>工程</p></li><li><p>最终Jenkins脚本如下图：</p><p><img src="/iOS/自动化/iOS进阶_打包/iOS打包_Jenkins脚本.png" alt="iOS打包_Jenkins脚本"></p></li></ul><p>附：没有权限问题的Jenkins正确的启动方式如下(按下面方式打开，才不会出现权限问题)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -jar /Applications/Jenkins/jenkins.war --httpPort=8080</span></span><br></pre></td></tr></table></figure><p>当你执行完这两行命令的时候，你可以在浏览器上输入<code>http://localhost:8080</code>来访问Jenkins了。(如果你只执行了第一行，没执行第二行，会出现无法访问)</p><p>更多Jenkins知识请查看：<a href="../../实用工具/Jenkins">实用工具-&gt;Jenkins-&gt;Jenkins的安装与启动</a></p><h2 id="四、注意点"><a href="#四、注意点" class="headerlink" title="四、注意点"></a>四、注意点</h2><h3 id="1、多环境的打包"><a href="#1、多环境的打包" class="headerlink" title="1、多环境的打包"></a>1、多环境的打包</h3><p>主要注意为<code>xcodebuild -workspace</code>中的<code>-configuration</code>参数即可。</p><h3 id="2、多Target的打包注意"><a href="#2、多Target的打包注意" class="headerlink" title="2、多Target的打包注意"></a>2、多Target的打包注意</h3><p>多Target的Podfile文件ruby脚本内容，大概如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">'https://github.com/CocoaPods/Specs.git'</span></span><br><span class="line">source <span class="string">'https://gitee.com/dvlproad/dvlproadSpecs'</span></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'8.0'</span></span><br><span class="line"><span class="comment">#use_frameworks!</span></span><br><span class="line">inhibit_all_warnings!</span><br><span class="line"></span><br><span class="line">post_install <span class="keyword">do</span> <span class="params">|installer|</span></span><br><span class="line">    </span><br><span class="line">    puts <span class="string">'Determining pod project minimal deployment target'</span></span><br><span class="line">    </span><br><span class="line">    pods_project = installer.pods_project</span><br><span class="line">    deployment_target_key = <span class="string">'IPHONEOS_DEPLOYMENT_TARGET'</span></span><br><span class="line">    deployment_targets = pods_project.build_configurations.map&#123; <span class="params">|config|</span> config.build_settings[deployment_target_key] &#125;</span><br><span class="line">    minimal_deployment_target = deployment_targets.min_by&#123; <span class="params">|version|</span> Gem::Version.new(version) &#125;</span><br><span class="line">    </span><br><span class="line">    puts <span class="string">'Minimal deployment target is '</span> + minimal_deployment_target</span><br><span class="line">    puts <span class="string">'Setting each pod deployment target to '</span> + minimal_deployment_target</span><br><span class="line">    </span><br><span class="line">    installer.pods_project.targets.each <span class="keyword">do</span> <span class="params">|target|</span></span><br><span class="line">        target.build_configurations.each <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">            config.build_settings[deployment_target_key] = minimal_deployment_target</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># There are no targets called "App1Common" in any Xcode projects</span></span><br><span class="line">abstract_target <span class="string">'App1Common'</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># Has its own copy of App1Common + App1Enterprise</span></span><br><span class="line">    target <span class="string">'App1Enterprise'</span> <span class="keyword">do</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Has its own copy of App1Common + App1AppStore</span></span><br><span class="line">    target <span class="string">'App1AppStore'</span> <span class="keyword">do</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target <span class="string">'CJAutoPackageDemoTests'</span> <span class="keyword">do</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>通过脚本自动化打包的时候的注意点如下：</p><ol><li><p>主要注意为<code>xcodebuild -workspace</code>中的<code>-scheme</code>参数即可。</p></li><li><p>多Target后，记得在<strong>Linked Frameworks and Libraries</strong>中删除已经不存在的原本旧的<code>libPods-xxx.a</code>文件。否则，Jenkins脚本打包Build的时候会报错。</p><ul><li>Jenkins脚本打包Build的时候报错的信息如下：</li></ul><p><img src="/iOS/自动化/iOS进阶_打包/iOS打包_多Target打包1.png" alt="Jenkins脚本打包Build的时候报错的信息"></p><ul><li><p>多Target工程打包时候要删除的旧引用文件如下：</p><p><img src="/iOS/自动化/iOS进阶_打包/iOS打包_多Target打包2.png" alt="多Target工程打包时候要删除的旧引用文件"></p></li></ul></li></ol><ul><li><p>其他参考</p><p><a href="https://www.jianshu.com/p/8767f986fb30?from=jiantop.com" target="_blank" rel="noopener">iOS命令行自动化集成打包全记录（多个target，多种环境）</a>不过觉得没必要看，因为没本文精简</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS进阶_多Configuration</title>
      <link href="/iOS/%E8%BF%9B%E9%98%B6/iOS%E8%BF%9B%E9%98%B6_%E5%A4%9AConfiguration/"/>
      <url>/iOS/%E8%BF%9B%E9%98%B6/iOS%E8%BF%9B%E9%98%B6_%E5%A4%9AConfiguration/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="利用多Configuration打包不同环境"><a href="#利用多Configuration打包不同环境" class="headerlink" title="利用多Configuration打包不同环境"></a>利用多Configuration打包不同环境</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>序言：</p><p>现象：Xcode默认只有DEBUG和RELEASE两种模式。</p><p>问题：如果我们在项目中想增加预发布环境或者再增加其他多个环境呢？</p><p>错误(不当)做法：如果在项目中用if else 弄个全局变量来控制，每次打包之前去手动修改，这样不仅繁琐，而且还会出错。</p><p>正确(推荐)做法：下面来一下在Xcode中添加多个环境变量的方法.</p><p>详细做法参考：<a href="https://blog.csdn.net/FreshManCode/article/details/80354936" target="_blank" rel="noopener">使用Xcode增加环境变量(多种环境区分)</a>，不再累诉。</p></blockquote><h2 id="一、认识"><a href="#一、认识" class="headerlink" title="一、认识"></a>一、认识</h2><h3 id="1、几个描述文件的认识与区别"><a href="#1、几个描述文件的认识与区别" class="headerlink" title="1、几个描述文件的认识与区别"></a>1、几个描述文件的认识与区别</h3><p>通过以下表格，你将认识到为什么你这个环境需要使用这个描述文件打包，用其他描述文件会有什么问题。</p><table><thead><tr><th>描述文件类型</th><th style="text-align:center">可安装的设备</th><th style="text-align:center">证书环境(开发/生产)</th><th style="text-align:center">使用的推送</th><th style="text-align:center">描述文件使用的环境(测试/预生产/生产)</th></tr></thead><tbody><tr><td>development</td><td style="text-align:center">已注册的设备</td><td style="text-align:center">开发环境的证书</td><td style="text-align:center">测试环境的推送</td><td style="text-align:center">测试环境</td></tr><tr><td>adhoc</td><td style="text-align:center">已注册的设备<br>(查看描述文件即可知道它没法做到在所有设备上都能安装的)</td><td style="text-align:center">生产环境的证书</td><td style="text-align:center">生产环境的推送<br>(这个创建描述文件的时候你就该知道的)</td><td style="text-align:center">预生产环境</td></tr><tr><td>appstore/<br>inhouse</td><td style="text-align:center">所有的设备</td><td style="text-align:center">生产环境的证书</td><td style="text-align:center">生产环境的推送</td><td style="text-align:center">生产环境</td></tr></tbody></table><h3 id="2、几种环境的认识"><a href="#2、几种环境的认识" class="headerlink" title="2、几种环境的认识"></a>2、几种环境的认识</h3><table><thead><tr><th>环境</th><th>需要可以安装的设备</th><th>需要测试的推送</th></tr></thead><tbody><tr><td>测试环境</td><td>在《已注册的设备》上可安装即可</td><td>测试环境的推送</td></tr><tr><td>预生产环境</td><td>至少《已注册的设备》上都能够安装吧</td><td>生产环境的推送</td></tr><tr><td>生产环境</td><td>要《所有的设备》上都能安装才行</td><td>生产环境的推送</td></tr></tbody></table><h3 id="3、环境与描述文件的总结"><a href="#3、环境与描述文件的总结" class="headerlink" title="3、环境与描述文件的总结"></a>3、环境与描述文件的总结</h3><table><thead><tr><th>环境</th><th>应该使用的描述文件</th><th>备注</th></tr></thead><tbody><tr><td>测试环境</td><td>development</td><td>不需要上线</td></tr><tr><td>预生产环境</td><td>adhoc</td><td>不需要上线</td></tr><tr><td>生产环境</td><td>appstore / inhouse</td><td>需要上线</td></tr></tbody></table><h3 id="4、Configuration的认识"><a href="#4、Configuration的认识" class="headerlink" title="4、Configuration的认识"></a>4、Configuration的认识</h3><h4 id="4-1、错误认识"><a href="#4-1、错误认识" class="headerlink" title="4.1、错误认识"></a>4.1、错误认识</h4><p>  只知道Archive打包的时候使用的是Release模式，殊不知任何操作Archive打包的时候使用的模式都是可以通过<code>Edit Scheme</code>来更改的。</p><p><img src="/iOS/进阶/iOS进阶_多Configuration/iOS进阶_多Configuration_2.png" alt="image-20190427145459385"></p><h4 id="4-2、正确认识："><a href="#4-2、正确认识：" class="headerlink" title="4.2、正确认识："></a>4.2、正确认识：</h4><p>他代表着各种配置。</p><h2 id="二、问题背景"><a href="#二、问题背景" class="headerlink" title="二、问题背景"></a>二、问题背景</h2><h3 id="1、需要多Configuration的问题背景"><a href="#1、需要多Configuration的问题背景" class="headerlink" title="1、需要多Configuration的问题背景"></a>1、需要多Configuration的问题背景</h3><p>对话：帮我打个测试包</p><p>对话：帮我打个预生产的包吧</p><p>对话：预生产测好了，帮我最后打个生产环境的包，我再测下，没问题就可以上线了。</p><p>那么，你就可能出现，每次打包的时候，去配置里面修改证书(dev、adhoc、appstore/inhouse)。</p><p>为了每次还得去切换证书，你何不多建个Configuration呢？(Xcode默认的已经有且只有DEBUG和RELEASE两种模式)</p><h3 id="2、多Configuration使用的问题背景"><a href="#2、多Configuration使用的问题背景" class="headerlink" title="2、多Configuration使用的问题背景"></a>2、多Configuration使用的问题背景</h3><h4 id="2-1、默认情况下的Configuration常见使用"><a href="#2-1、默认情况下的Configuration常见使用" class="headerlink" title="2.1、默认情况下的Configuration常见使用"></a>2.1、默认情况下的Configuration常见使用</h4><p>Xcode默认只有DEBUG和RELEASE两种模式，如下图：</p><p><img src="/iOS/进阶/iOS进阶_多Configuration/iOS进阶_多Configuration_1.png" alt="Xcode默认只有DEBUG和RELEASE两种模式"></p><p>通常我们的做法：</p><table><thead><tr><th>Configuration</th><th>通过作为什么环境使用</th></tr></thead><tbody><tr><td>DEBUG</td><td>开发环境</td></tr><tr><td>RELEASE</td><td>生产环境</td></tr></tbody></table><h4 id="2-2、默认情况下的Configuration使用的问题"><a href="#2-2、默认情况下的Configuration使用的问题" class="headerlink" title="2.2、默认情况下的Configuration使用的问题"></a>2.2、默认情况下的Configuration使用的问题</h4><p>问题：如果我们在项目中想增加预发布环境或者再增加其他多个环境呢?</p><table><thead><tr><th></th><th>错误(不当)做法</th><th>正确(推荐)做法</th></tr></thead><tbody><tr><td>项目</td><td>从一开始就没考虑到Configuration的使用，在项目中用if else 弄个全局变量来控制,每次打包之前去手动修改</td><td>根据需要新增的环境个数，增加对应的Configuration个数。</td></tr><tr><td>原因</td><td>这样不仅繁琐,而且还会出错</td><td>确保不用修改代码，只需要在<code>Edit Scheme</code>中修改想要使用的Configuration即可。</td></tr></tbody></table><h2 id="三、操作步骤"><a href="#三、操作步骤" class="headerlink" title="三、操作步骤"></a>三、操作步骤</h2><h4 id="1、生成新的Configuration（只能使用Duplicate方式）"><a href="#1、生成新的Configuration（只能使用Duplicate方式）" class="headerlink" title="1、生成新的Configuration（只能使用Duplicate方式）"></a>1、生成新的Configuration（只能使用Duplicate方式）</h4><h5 id="1-1、Duplicate方法略。"><a href="#1-1、Duplicate方法略。" class="headerlink" title="1.1、Duplicate方法略。"></a>1.1、Duplicate方法略。</h5><h5 id="1-2、Duplicate后，必须需要修改的东西"><a href="#1-2、Duplicate后，必须需要修改的东西" class="headerlink" title="1.2、Duplicate后，必须需要修改的东西"></a>1.2、Duplicate后，必须需要修改的东西</h5><table><thead><tr><th>必选需修改项</th><th>操作方法</th><th>得到</th></tr></thead><tbody><tr><td>更新新增Configuration使用的Pod</td><td>重新执行pod install</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="2、Configuration区分"><a href="#2、Configuration区分" class="headerlink" title="2、Configuration区分"></a>2、Configuration区分</h4><p>需求背景：区分配置</p><p>解决办法：为Target的Prerelease Configuration在<code>PreprocessorMacros</code>中添加宏，如添加<code>PRERELEASE=1</code>。</p><ul><li>在PreprocessorMacros中的Prerelease中添加<code>PRERELEASE=1</code>后</li></ul><p><img src="/iOS/进阶/iOS进阶_多Configuration/iOS进阶_多Configuration_PreprocessorMacros添加后.png" alt="多Configuration_PreprocessorMacros添加后"></p><p>Configuration代码区分需用到的知识：</p><table><thead><tr><th></th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>#if</code></td><td>既关心宏是否定义，又关心宏的逻辑的真假</td><td></td></tr><tr><td><code>#ifdef</code><br><code>#ifndef</code></td><td>仅仅关心宏是否被定义，不关心宏的逻辑真假</td></tr></tbody></table><p>代码区分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if DEBUG</span><br><span class="line">    </span><br><span class="line">#elif PRERELEASE</span><br><span class="line">    </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>至此，Configuration添加完成 。</p><p><img src="/iOS/进阶/iOS进阶_多Configuration/iOS进阶_多Target/分割图1.jpg" alt="分割图1"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS进阶_多Target</title>
      <link href="/iOS/%E8%BF%9B%E9%98%B6/iOS%E8%BF%9B%E9%98%B6_%E5%A4%9ATarget/"/>
      <url>/iOS/%E8%BF%9B%E9%98%B6/iOS%E8%BF%9B%E9%98%B6_%E5%A4%9ATarget/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="利用多Target开发相似app"><a href="#利用多Target开发相似app" class="headerlink" title="利用多Target开发相似app"></a>利用多Target开发相似app</h1><h2 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h2><p>开发一个与之前几乎一样的app。只是app名字等基本信息变更。</p><table><thead><tr><th></th><th>错误做法</th><th>正确做法</th><th></th></tr></thead><tbody><tr><td>项目</td><td>再创建了新的项目</td><td>使用同一项目</td><td></td></tr><tr><td>原因</td><td>极容易出现后来新开发的功能两个app都要支持</td><td>保证可共用到以后新开发的功能</td></tr></tbody></table><p>下面我们开始介绍如何利用多Target开发相似app。</p><h2 id="二、操作步骤"><a href="#二、操作步骤" class="headerlink" title="二、操作步骤"></a>二、操作步骤</h2><h4 id="1、生成新的Target（这里推荐采用Duplicate方式，而不是File-gt-New-gt-Target）"><a href="#1、生成新的Target（这里推荐采用Duplicate方式，而不是File-gt-New-gt-Target）" class="headerlink" title="1、生成新的Target（这里推荐采用Duplicate方式，而不是File-&gt;New-&gt;Target）"></a>1、生成新的Target（这里推荐采用Duplicate方式，而不是File-&gt;New-&gt;Target）</h4><h5 id="1-1、Duplicate方法略。"><a href="#1-1、Duplicate方法略。" class="headerlink" title="1.1、Duplicate方法略。"></a>1.1、Duplicate方法略。</h5><h5 id="1-2、Duplicate后，需要修改的东西"><a href="#1-2、Duplicate后，需要修改的东西" class="headerlink" title="1.2、Duplicate后，需要修改的东西"></a>1.2、Duplicate后，需要修改的东西</h5><table><thead><tr><th>必选需修改项</th><th>操作方法</th><th>得到</th></tr></thead><tbody><tr><td>Info.plist</td><td>①复制一份。<br>②并重新为Target选择Info.plist<br>③跟新Info.plist中的名字、签名等</td><td>App1Info.plist、App2Info.plist</td></tr><tr><td>Scheme</td><td>Manager Scheme -&gt; 双击重命名</td><td>新的App2Scheme</td></tr><tr><td>证书&amp;描述文件</td><td>更具新的BundleId，添加证书&amp;描述文件</td><td>真机编译通过</td></tr></tbody></table><p><strong>特别注意</strong>：add Info.plist等文件的时候，一定要注意选择对应的Target。不多多勾选☑️，也不要少勾选。</p><h5 id="1-3、其他APP定制项更改"><a href="#1-3、其他APP定制项更改" class="headerlink" title="1.3、其他APP定制项更改"></a>1.3、其他APP定制项更改</h5><table><thead><tr><th>可选修改项</th><th>操作方法</th><th>得到</th></tr></thead><tbody><tr><td>icon</td><td>修改InfoPlist</td><td>新APP的Icon</td></tr><tr><td>名字</td><td>修改InfoPlist</td><td>新APP的名字</td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="2、Target区分"><a href="#2、Target区分" class="headerlink" title="2、Target区分"></a>2、Target区分</h4><p>需求背景：有些共用的文件在不同的Target下是有细微不同的，那么我们在具体实现的时候就需要作出区分。</p><h5 id="2-1、Objective-C、C、C-的LLVM预处理宏的添加"><a href="#2-1、Objective-C、C、C-的LLVM预处理宏的添加" class="headerlink" title="2.1、Objective-C、C、C++的LLVM预处理宏的添加"></a>2.1、Objective-C、C、C++的LLVM预处理宏的添加</h5><p>Objective-C、C、C++的LLVM预处理宏在Preprocessor Macros处定义。如图创建工程时已经默认创建好了在Debug时定义DEBUG=1 宏标记。</p><h5 id="2-2、Swift"><a href="#2-2、Swift" class="headerlink" title="2.2、Swift"></a>2.2、Swift</h5><p>因为Swift 中没有宏定义的概念，因此我们不能使用 <code>#ifdef</code> 的方法来检查某个符号是否经过宏定义。</p><p>在项目的 Build Settings 中，找到 Swift Compiler - Custom Flags，并在其中的 Other Swift Flags </p><p>为APP1加上 <code>-D APPTARGET1</code> 就可以了；为APP2加上 <code>-D APPTARGET2</code> 就可以了；</p><p>其他参考文章：<a href="https://blog.csdn.net/kaiyuanheshang/article/details/78862382" target="_blank" rel="noopener">https://blog.csdn.net/kaiyuanheshang/article/details/78862382</a></p><p>解决办法：这里解决的方法是针对不同的Target在<code>Preprocessor Macros</code>中定义宏，如添加<code>TargetTYPE</code>。</p><ul><li>在Preprocessor Macros中添加<code>TARGETTYPE</code>后</li></ul><p><img src="/iOS/进阶/iOS进阶_多Target/PreprocessorMacros添加后.png" alt="PreprocessorMacros添加后"></p><p>Target代码区分需用到的知识：</p><table><thead><tr><th></th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>#if</code></td><td>既关心宏是否定义，又关心宏的逻辑的真假</td><td></td></tr><tr><td><code>#ifdef</code><br><code>#ifndef</code></td><td>仅仅关心宏是否被定义，不关心宏的逻辑真假</td></tr></tbody></table><p>代码区分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if TARGETTYPE == 0</span><br><span class="line">    [AMapServices sharedServices].apiKey = @&quot;6d79992bc988b60f68e059edeef82538&quot;;</span><br><span class="line">#elif TARGETTYPE == 1</span><br><span class="line">    [AMapServices sharedServices].apiKey = @&quot;aef6d9dabe4cdd1da9e923e52b5d40ca&quot;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>至此，你直接编译，发现”好像”完成了。实际上如果你的项目没有使用POD的，确实是到此就完成了 。</p><p><img src="/iOS/进阶/iOS进阶_多Target/分割图1.jpg" alt="分割图1"></p><p>下面我们额外补充，当你的项目有使用POD的时候，你还需要处理的东西。</p><h4 id="3、Pod修改"><a href="#3、Pod修改" class="headerlink" title="3、Pod修改"></a>3、Pod修改</h4><p>在上述中，你可能发现好像我使用了POD的但是依然正确编译通过啊。</p><p>是的，是通过了，但是这是假象。或者准确的说，当你下次使用POD相关命令，如<code>pod install</code>的时候，你会发现之前的项目编译不通过了。</p><p>所以，你需要修改PodFile，并重新pod install。PodFile的修改方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target 'APP1' do</span><br><span class="line">pod 'AFNetworking'</span><br><span class="line"> pod 'APP1SDK'</span><br><span class="line">end</span><br><span class="line">  </span><br><span class="line">target 'APP2' do</span><br><span class="line">  pod 'AFNetworking'</span><br><span class="line">  pod 'APP2SDK'</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>修改方式1：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> There are no targets called <span class="string">"APPCommon"</span> <span class="keyword">in</span> any Xcode projects</span></span><br><span class="line">abstract_target 'APPCommon' do</span><br><span class="line">  pod 'AFNetworking'</span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> Has its own copy of APPCommon + APP2SDK</span></span><br><span class="line">  target 'APP1' do</span><br><span class="line">    pod 'APP1SDK'</span><br><span class="line">  end</span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> Has its own copy of APPCommon + APP2SDK</span></span><br><span class="line">  target 'APP2' do</span><br><span class="line">    pod 'APP2SDK'</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>修改方式2：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 共用的第三方库</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AppCommon_Pods</span></span></span><br><span class="line">  pod <span class="string">'AFNetworking'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># APP1所需的第三方库</span></span><br><span class="line">target <span class="string">'APP1'</span> <span class="keyword">do</span></span><br><span class="line">AppCommon_Pods</span><br><span class="line"> pod <span class="string">'APP1SDK'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># APP2所需的第三方库</span></span><br><span class="line">target <span class="string">'APP2'</span> <span class="keyword">do</span></span><br><span class="line">  AppCommon_Pods</span><br><span class="line">  pod <span class="string">'APP2SDK'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>最后修改完后，重新pod install后即可。</p><p><img src="/iOS/进阶/iOS进阶_多Target/分割图1.jpg" alt="分割图1"></p><h4 id="4、脚本打包时候，因为多Target后旧的libPods-xxx-Framework）忘删除引起的问题"><a href="#4、脚本打包时候，因为多Target后旧的libPods-xxx-Framework）忘删除引起的问题" class="headerlink" title="4、脚本打包时候，因为多Target后旧的libPods-xxx(Framework）忘删除引起的问题"></a>4、脚本打包时候，因为多Target后旧的libPods-xxx(Framework）忘删除引起的问题</h4><p>多Target后旧的libPods-xxx引起的问题</p><p><img src="/iOS/进阶/iOS进阶_多Target/多Target后旧的libPods-xxx引起的问题.png" alt="多Target后旧的libPods-xxx引起的问题"></p><p>多Target后旧的libPods-xxx的问题解决否的判断</p><p><img src="/iOS/进阶/iOS进阶_多Target/多Target后旧的libPods-xxx的问题解决否的判断.png" alt="多Target后旧的libPods-xxx的问题解决否的判断"></p><h2 id="三、Swift中的条件编译"><a href="#三、Swift中的条件编译" class="headerlink" title="三、Swift中的条件编译"></a>三、Swift中的条件编译</h2><p>在C 系语言中，我们可以通过预处理宏定义一些参数，使用#if或者#ifdef编译条件分支来控制哪些代码需要编译，而哪些代码不需要。但是在swift中没有宏定义的概念，虽然不能使用 #ifdef 的方法来检查某个符号是否经过宏定义，但是可以支持“#if/#else/#endif”语句。</p><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><p><a href="#https://www.jianshu.com/p/cce38ab8bf91">只用一个target，配合一个脚本，可以进行茫茫多target的管理了</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3节、Jenkins使用技巧常用</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%B8%B8%E7%94%A8/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%B8%B8%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、正确实现并测试一个Jenkins脚本的步骤"><a href="#一、正确实现并测试一个Jenkins脚本的步骤" class="headerlink" title="一、正确实现并测试一个Jenkins脚本的步骤"></a>一、正确实现并测试一个Jenkins脚本的步骤</h2><p><strong>原则</strong>：将脚本中的命令分布测试通过后再一起合成。</p><h3 id="1、将一行行命令单独在终端中操作，验证是否通过；"><a href="#1、将一行行命令单独在终端中操作，验证是否通过；" class="headerlink" title="1、将一行行命令单独在终端中操作，验证是否通过；"></a>1、将一行行命令单独在终端中操作，验证是否通过；</h3><h3 id="2、整理到-sh-py中，通过终端验证；"><a href="#2、整理到-sh-py中，通过终端验证；" class="headerlink" title="2、整理到.sh/.py中，通过终端验证；"></a>2、整理到<em><code>.sh</code></em>/<em><code>.py</code></em>中，通过终端验证；</h3><h3 id="3、放到-Jenkins-的shell脚本中，构建验证；"><a href="#3、放到-Jenkins-的shell脚本中，构建验证；" class="headerlink" title="3、放到 Jenkins 的shell脚本中，构建验证；"></a>3、放到 <em>Jenkins</em> 的shell脚本中，构建验证；</h3><h4 id="3-1、现在本地验证后，再托管到服务器上；"><a href="#3-1、现在本地验证后，再托管到服务器上；" class="headerlink" title="3.1、现在本地验证后，再托管到服务器上；"></a>3.1、现在本地验证后，再托管到服务器上；</h4><p>在本地通过<em><code>cd 脚本绝对路径</code></em>，<em><code>sh 脚本.sh</code></em>，构建验证；</p><h4 id="3-2、本地验证后，使用-git-SVN-管理源码"><a href="#3-2、本地验证后，使用-git-SVN-管理源码" class="headerlink" title="3.2、本地验证后，使用 git/SVN 管理源码"></a>3.2、本地验证后，使用 <em><code>git</code></em>/<em><code>SVN</code></em> 管理源码</h4><h2 id="二、源码托管"><a href="#二、源码托管" class="headerlink" title="二、源码托管"></a>二、源码托管</h2><p>问：Jenkins中的项目一般都是托管在 <em><code>Git</code></em>/<em><code>SVN</code></em> 上，如果你想要在本地尝试呢？如何操作？</p><p>答：源码管理选择None。然后直接在Jenkins中的脚本里cd到执行路径，再操作即可。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：Jenkins基本操作</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><img src="/实用工具/Jenkins/Jenkins基本操作/Jenkins_Shell1_Add.png" alt="Jenkins_Shell1_Add"></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4节：Jenkins常用插件介绍</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>Jenkins_Maven1_install</p><p><img src="/实用工具/Jenkins/Jenkins常用插件介绍/Jenkins_Maven1_install.png" alt="Jenkins_Maven1_install"></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑使用过程中的问题</title>
      <link href="/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="「xxx-app已损坏，打不开。你应该将它移到废纸篓」"><a href="#「xxx-app已损坏，打不开。你应该将它移到废纸篓」" class="headerlink" title="「xxx.app已损坏，打不开。你应该将它移到废纸篓」"></a>「xxx.app已损坏，打不开。你应该将它移到废纸篓」</h2><p>MAC应用无法打开或文件损坏的处理方法：<a href="https://xclient.info/a/74559ea2-7870-b992-ed53-52a9d988e382.html" target="_blank" rel="noopener">https://xclient.info/a/74559ea2-7870-b992-ed53-52a9d988e382.html</a></p><h2 id="技巧一：mac去除dmg密码操作到编程-含批量去除"><a href="#技巧一：mac去除dmg密码操作到编程-含批量去除" class="headerlink" title="技巧一：mac去除dmg密码操作到编程(含批量去除)"></a>技巧一：mac去除dmg密码操作到编程(含批量去除)</h2><p><a href="http://www.pianshen.com/article/9178224481/" target="_blank" rel="noopener">http://www.pianshen.com/article/9178224481/</a></p><p><img src="/电脑使用/电脑使用过程中的问题/dmg_去除dmg密码.png" alt="dmg_去除dmg密码"></p><h1 id="如何在mac-上面改airdrop名字"><a href="#如何在mac-上面改airdrop名字" class="headerlink" title="如何在mac 上面改airdrop名字"></a>如何在mac 上面改airdrop名字</h1><p><img src="/电脑使用/电脑使用过程中的问题/image-20210203170305601.png" alt="image-20210203170305601"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DBSQL</title>
      <link href="/DBSQL/"/>
      <url>/DBSQL/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/yajunLi/p/7204905.html" target="_blank" rel="noopener">Mac终端查看sqlite3数据库、表数据等（含sqlite可视化工具下载）</a></p><h2 id="Navicat-Premium-12-1-19-强大的数据库管理工具"><a href="#Navicat-Premium-12-1-19-强大的数据库管理工具" class="headerlink" title="Navicat Premium 12.1.19 强大的数据库管理工具"></a>Navicat Premium 12.1.19 强大的数据库管理工具</h2><p>地址：<a href="https://xclient.info/s/navicat-premium.html#versions" target="_blank" rel="noopener">https://xclient.info/s/navicat-premium.html#versions</a></p><h2 id="navicat-for-mysql-和-navicat-Premium有什么区别"><a href="#navicat-for-mysql-和-navicat-Premium有什么区别" class="headerlink" title="navicat for mysql 和 navicat Premium有什么区别"></a>navicat for mysql 和 navicat Premium有什么区别</h2><p>navicat for mysql 只适用于 mysql ，navicat Premium 是全系列的。</p><blockquote><p>Navicat Premium是一套数据库管理工具，结合了其它Navicat成员的功能，支持单一程序同时连接到MySQL、MariaDB、SQL Server、SQLite、Oracle和PostgreSQL数据库。Navicat Premium可满足现今<a href="https://www.baidu.com/s?wd=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">数据库管理系统</a>的使用功能，包括<a href="https://www.baidu.com/s?wd=%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">存储过程</a>、事件、触发器、函数、视图等。<br>Navicat for MySQL是一套管理和开发MySQL或MariaDB的理想解决方案，支持单一程序，可同时连接到MySQL和MariaDB。这个功能齐备的前端软件为数据库管理、开发和维护提供了直观而强大的<a href="https://www.baidu.com/s?wd=%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">图形界面</a>，给MySQL或MariaDB新手以及专业人士提供了一组全面的工具。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>切为H5的标准</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/Flutter%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/Flutter%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Flutter代码开发规范"><a href="#Flutter代码开发规范" class="headerlink" title="Flutter代码开发规范"></a>Flutter代码开发规范</h1><p>使用小写加下划线来命名库和源文件</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good </span></span><br><span class="line">  <span class="keyword">library</span> peg_parser.source_scanner;</span><br><span class="line">  <span class="keyword">import</span> <span class="string">'slider_menu.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">library</span> pegparser.SourceScanner;</span><br><span class="line">  <span class="keyword">import</span> <span class="string">'file-system.dart'</span>;</span><br></pre></td></tr></table></figure><p>使用小写加下划线来命名导入前缀</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line">  <span class="keyword">import</span> <span class="string">'dart:math'</span> <span class="keyword">as</span> math; </span><br><span class="line">  <span class="keyword">import</span> <span class="string">'package:angular_components/angular_components'</span></span><br><span class="line">      <span class="keyword">as</span> angular_components;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">   <span class="keyword">import</span> <span class="string">'dart:math'</span> <span class="keyword">as</span> Math;</span><br><span class="line">  <span class="keyword">import</span> <span class="string">'package:angular_components/angular_components'</span></span><br><span class="line">      <span class="keyword">as</span> angularComponents;</span><br></pre></td></tr></table></figure><p>使用小驼峰法命名其他标识符</p><p>import 顺序</p><p>为了使你的文件前言保持整洁，我们有规定的命令，指示应该出现在其中。每个“部分”应该用空行分隔。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ①dart库</span></span><br><span class="line">  <span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line">  <span class="keyword">import</span> <span class="string">'dart:html'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ②三方库</span></span><br><span class="line">  <span class="keyword">import</span> <span class="string">'package:bar/bar.dart'</span>;</span><br><span class="line">  <span class="keyword">import</span> <span class="string">'package:foo/foo.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ③项目文件</span></span><br><span class="line">  <span class="keyword">import</span> <span class="string">'package:my_package/util.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ④相对文件</span></span><br><span class="line">  <span class="keyword">export</span> <span class="string">'src/error.dart'</span>;</span><br></pre></td></tr></table></figure><p>字符串的使用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先使用模板字符串</span></span><br><span class="line"><span class="string">'Hello, <span class="subst">$name</span>! You are <span class="subst">$&#123;year - birth&#125;</span> years old.'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在不需要的时候，避免使用花括号</span></span><br><span class="line">  <span class="string">'Hi, <span class="subst">$name</span>!'</span></span><br><span class="line">  <span class="string">"Wear your wildest <span class="subst">$decade<span class="string">'s outfit."</span></span></span></span><br></pre></td></tr></table></figure><p>判空</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good: isEmpty/isNotEmpty</span></span><br><span class="line"><span class="keyword">if</span> (lunchBox.isEmpty) <span class="keyword">return</span> <span class="string">'so hungry...'</span>;</span><br><span class="line"><span class="keyword">if</span> (words.isNotEmpty) <span class="keyword">return</span> words.join(<span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad:length</span></span><br><span class="line">  <span class="keyword">if</span> (lunchBox.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">'so hungry...'</span>;</span><br><span class="line">  <span class="keyword">if</span> (!words.isEmpty) <span class="keyword">return</span> words.join(<span class="string">' '</span>);</span><br></pre></td></tr></table></figure><p>构造函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// good</span></span><br><span class="line">  Point2(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  Point2(<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">      <span class="keyword">this</span>.x = x;</span><br><span class="line">      <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当异步没有任何用处时，不要使用它</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line">Future afterTwoThings(Future first, Future second) &#123;</span><br><span class="line">    <span class="keyword">return</span> Future.wait([first, second]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">  Future afterTwoThings(Future first, Future second) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Future.wait([first, second]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI组件选择历程</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/FlutterGetX%E6%A1%86%E6%9E%B6%E9%80%89%E6%8B%A9%E5%8E%86%E7%A8%8B/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/FlutterGetX%E6%A1%86%E6%9E%B6%E9%80%89%E6%8B%A9%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="FlutterGetX框架选择历程"><a href="#FlutterGetX框架选择历程" class="headerlink" title="FlutterGetX框架选择历程"></a>FlutterGetX框架选择历程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1.getX的功能不只是只有状态管理功能。<br>2.只是为了状态管理的话，项目中新功能可使用。使用不影响其他人。且目前项目中的依赖已包含getX。<br>3.如果是旧功能，在赶项目的阶段如果没法把握能保量保质的完成开发，不建议使用。当然还是希望大家使用，但任务的完成质量是第一位，如果只是为了使用而影响了项目进度，我认为不是特别可取，除非涉及严重问题不得不。所以没有规定不能使用，但结果是要完成好开发，而不是简单的“好了”，然后存在有很多细节没完善的地方。</p><blockquote><p>对于一个功能，我认为所谓的好了，起码是<br>①主流程没问题，<br>②特殊流程已处理，<br>③异常已容错，<br>④界面效果与ui完全一致，不差任何一两个像素及颜色偏差，<br>⑤使用上至少不存在用户感知到的卡顿，<br>⑥自己发现的问题已跟进处理，而不是挂着等测试或产品提，<br>⑦别人发现的也一样处理，而不是不重要，<br>⑧甚至不应该出现用户感知是可点击的，结果点了了没任何效果的问题，哪个加个toast也比没有强<br>⑨流程上的有些偏可以下沉到底层的，如按钮的重复点击问题处理，图片的加载缓存404等处理，是否在自己的模块上处理完成，或者说告知之前这块没处理过，后面安排处理，<br>⑩debug模式是否正常，而不是像项目一开始时候的debug都基本无法debug，都在跑release。<br>等等…</p><p>对内的代码结构是否合理，</p></blockquote><p>所以在能保证质量完成开发或者除了不影响使用的解决不了的情况下很希望大家也多看看多学学多了解和使用一些优秀的框架。但框架是为开发服务的，不能说想使用了什么框架结果完成不了，或做得有点大概。<br>4.另外对于getX的状态管理使用，也不是一使用了就得全部替换，甚至说新功能就一定得按getX来实现。拿个关于页面，一个简单页面用getX与现有的，反而使用getX可认为是完全没必要，因为页面可认为是不需要“可变”状态，只是需要很独立的数据显示而已。类似于做原生，也有很多优秀的框架甚至架构，但mvc的模式肯定在你的项目里有存在，而且在那种场景下，它的优点反而更明显。可以理解为越简单的东西越没有必要使用非常强大的框架，没必要用大炮打小鸟。</p><p>优秀新框架的初使用，我认为在前期是允许使用，而不是规定都得使用。好比有人很熟悉，但其他人不熟悉可能做起来，他就没法完成他原本安排的任务，形象而夸大的说，可以想象成让你换个语言开发，排期不变，保证开发完成和质量，而且还不是说他那块的就一定得使用新框架才能。</p><p>所以鼓励使用优秀的技术，但别忘了保证完成自己的开发。当然使用新技术时候，如果时间差不多，也可同产品商量适当一两天，在其接受延期的情况下才能延期，不然要使用的话，哪怕加再多班也得完成。而对于一些类似完全重构的任务，自然会同产品协商专门安排一期处理。不管是原生开发还是跨平台，我觉得这些理念和思维应该都差不多。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI组件选择历程</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/UI%E7%BB%84%E4%BB%B6%E9%80%89%E6%8B%A9%E5%8E%86%E7%A8%8B/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/UI%E7%BB%84%E4%BB%B6%E9%80%89%E6%8B%A9%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="UI组件选择历程"><a href="#UI组件选择历程" class="headerlink" title="UI组件选择历程"></a>UI组件选择历程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于组件定制(非从0开发)，现有业内有Bruno和Templates等成套组件库，其中多为个人或团队开发，少为公司或企业开源；</p><p>组件的实现，有使用多个业内公认性强的独立组件和使用成套组件开发两种方式。</p><h2 id="一、现有UI规范与三方UI组件库比较"><a href="#一、现有UI规范与三方UI组件库比较" class="headerlink" title="一、现有UI规范与三方UI组件库比较"></a>一、现有UI规范与三方UI组件库比较</h2><p>与三方的比较相似度：</p><p>1：不一致，可定制成UI样式，无影响</p><p>2：不一致，不可定制成UI样式，</p><table><thead><tr><th>编号</th><th>类型</th><th>现有UI规范图</th><th>三方UI组件图</th><th>相似度</th><th>是否已实现</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>Loading</td><td><img src="/Architecture架构/UI组件选择历程/uikit_loading_01.png" alt="image-20220112191111893" style="zoom:33%;"></td><td><img src="/Architecture架构/UI组件选择历程/uikit_loading_11.png" alt="image-20220112193119354"></td><td>0%</td><td>已实现</td><td></td></tr><tr><td>2</td><td>Toast</td><td><img src="/Architecture架构/UI组件选择历程/uikit_toast_01.png" alt="image-20220112193921648" style="zoom:33%;"></td><td><img src="/Architecture架构/UI组件选择历程/uikit_toast_11.png" alt="image-20220112193810225" style="zoom:50%;"></td><td>100%</td><td>已实现</td><td></td></tr><tr><td>3</td><td>Alert/Dialog</td><td><img src="/Architecture架构/UI组件选择历程/uikit_alert_01.png" alt="image-20220112190638017" style="zoom:50%;"><br><img src="/Architecture架构/UI组件选择历程/uikit_alert_02.png" alt="image-20220112191225610" style="zoom:33%;"><br><img src="/Architecture架构/UI组件选择历程/uikit_alert_03.png" alt="image-20220112192144651" style="zoom:33%;"></td><td><img src="/Architecture架构/UI组件选择历程/uikit_alert_11.png" alt="image-20220112193013294" style="zoom:33%;"><br></td><td>10%</td><td>已实现</td><td></td></tr><tr><td>4</td><td>ActionSheet</td><td><img src="/Architecture架构/UI组件选择历程/uikit_actionsheet_01.png" alt="image-20220112191823819" style="zoom:33%;"></td><td><img src="/Architecture架构/UI组件选择历程/uikit_actionsheet_11.png" alt="image-20220112193433345" style="zoom:33%;"></td><td>40%</td><td>已实现</td><td></td></tr><tr><td>5</td><td>ItemPicker</td><td><img src="/Architecture架构/UI组件选择历程/uikit_itempicker_01.png" alt="image-20220112191918224" style="zoom:33%;"><br><img src="/Architecture架构/UI组件选择历程/uikit_itempicker_02.png" alt="image-20220112192433517" style="zoom: 33%;"></td><td><img src="/Architecture架构/UI组件选择历程/uikit_itempicker_11.png" alt="image-20220112192909758" style="zoom:25%;"></td><td>60%</td><td>已实现</td><td></td></tr><tr><td>6</td><td>DatePicker</td><td><img src="/Architecture架构/UI组件选择历程/uikit_datepicker_01.png" alt="image-20220112191956752" style="zoom: 33%;"></td><td><img src="/Architecture架构/UI组件选择历程/uikit_datepicker_11.png" alt="image-20220112192754849" style="zoom: 25%;"></td><td>60%</td><td>已实现</td><td></td></tr><tr><td>7</td><td>AreaPicker</td><td><img src="/Architecture架构/UI组件选择历程/uikit_areapicker_01.png" alt="image-20220112192520814" style="zoom:33%;"></td><td><img src="/Architecture架构/UI组件选择历程/uikit_areapicker_11.png" alt="image-20220112193655738" style="zoom:33%;"></td><td>0%</td><td>已实现</td><td></td></tr><tr><td>8</td><td>Button</td><td><img src="/Architecture架构/UI组件选择历程/uikit_bgbutton_01.png" alt="image-20220112195209438"><br><img src="/Architecture架构/UI组件选择历程/uikit_borderbutton_01.png" alt="image-20220112195319946" style="zoom:33%;"></td><td><img src="/Architecture架构/UI组件选择历程/uikit_bgbutton_11.png" alt="image-20220112194425751" style="zoom:33%;"><br><img src="/Architecture架构/UI组件选择历程/uikit_borderbutton_11.png" alt="image-20220112194521899" style="zoom:33%;"></td><td>95%</td><td>已实现</td></tr></tbody></table><p>基于，目前app中对应的UI组件，基本已实现过，只是缺少统一，导致有复制代码，局部定制的不当操作；</p><p>又由于避免重复开发，统一组件，是必须处理的事项。所以，当前的处理方案为抽离并保持已实现的UI，新开发部分采用从组件中调用。此工作与后续其他部分不重合。</p><p>而后续如有其他需要定制成组件的部分，对UI实现的图，继续优先与第三方组件库从匹配度、扩展性、维护性等角度考虑。</p><p>如果从数据上比价，得知该三方UI组件库与现有UI匹配度较低(匹配度=符合规范的组件个数/总的组件个数)。</p><p>基于匹配度较低的情况，处理方案有如下两种。</p><p>方案一：UI规范向三方组件靠齐，即后续UI设计使用三方组件样式；</p><p>方案二：放弃三方组件库，分别使用独立三方组件，定制成现有UI想要的特有样式；</p><h2 id="二、UI规范选择方案比较"><a href="#二、UI规范选择方案比较" class="headerlink" title="二、UI规范选择方案比较"></a>二、UI规范选择方案比较</h2><table><thead><tr><th></th><th>方案一：<br>使用三方规范<br>(由组件库集体定制)</th><th>方案二：<br>使用自己规范<br>(由独立组件分别定制)</th></tr></thead><tbody><tr><td>前期开发效率</td><td>高</td><td></td></tr><tr><td>美观性</td><td></td><td>高</td></tr><tr><td>前提</td><td>舍弃部分美观性，需领导批准，同步UI团队</td><td>正常开发</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="1、开发优先，放弃特有风格"><a href="#1、开发优先，放弃特有风格" class="headerlink" title="1、开发优先，放弃特有风格"></a>1、开发优先，放弃特有风格</h3><p>如果从未开发，则基于前期开发效率考虑，使用方案一成套组件库进行开发（需领导批准，同步UI团队改变设计规范）。</p><h3 id="2、风格保持，实现次之"><a href="#2、风格保持，实现次之" class="headerlink" title="2、风格保持，实现次之"></a>2、风格保持，实现次之</h3><p>如果为了保证维持app特有的风格，组件实现则必须与UI设计保持一致，则</p><p>1、三方成套组件库与UI匹配度高：</p><p>直接使用</p><p>2、三方成套组件库与UI匹配度低：</p><p>则组件的实现，有以下两种方式</p><p>①尝试基于成套组件库，进行深度定制，如无法定制指定效果，放弃；</p><p>②使用与UI匹配度高的独立三方组件，进行快速定制；</p><h2 id="三、保持UI风格使用自己规范时，开源库选择标准"><a href="#三、保持UI风格使用自己规范时，开源库选择标准" class="headerlink" title="三、保持UI风格使用自己规范时，开源库选择标准"></a>三、保持UI风格使用自己规范时，开源库选择标准</h2><p>成套组件库 VS 各独立组件，我们主要从以下三点考虑：</p><p>一、后期维护性。维护性是避免该组件不进行维护，导致需要使用新的组件进行替换。从概览上讲成套组件的不维护风险比由多个独立组件组成的集体不维护风险概览大，从而产生的维护替换成本也会较高。</p><p>二、扩展性。扩展性是指该组件支持的可定制程度。为了避免有些组件早高度封装下，可定制程度不高，当后期需要补充定制其他功能时候，无法支撑需求，从而导致需要修改源码或使用新组件来替换，我们会优先考虑扩展性强的组件，从而节省后期的维护成本。</p><p>三、受众广度。指一个组件或一群组件组成的组件库在业内使用开发者的多少或流行度。以下以轻提示控件toast举例，单个toast和组件库里的toast，在<a href="https://pub.flutter-io.cn/上查到的受众广度分别如下：" target="_blank" rel="noopener">https://pub.flutter-io.cn/上查到的受众广度分别如下：</a></p><p><img src="/Architecture架构/UI组件选择历程/toast-fluttertoast.png" alt="toast-fluttertoast"></p><p><img src="/Architecture架构/UI组件选择历程/toast-Bruno.png" alt="toast-Bruno"></p><p>对于项目中前期已实现的组件，是优先以使用github上与我们匹配最高且Star最多的组件来进行二次封装，从而定制成App所需的实际样式。如无或只是简单封装，才使用一次封装和定制，为的是避免对只是简单封装的控件也产生不必要的依赖。就开发成本上来讲，与使用成套组件无实际差别，并不会多增加，且有降低成套组件后续维护性风险的好处。</p><h2 id="四、后续"><a href="#四、后续" class="headerlink" title="四、后续"></a>四、后续</h2><p>基于目前从产品、UI上已统一使用Bruno中的风格，所以后续对于前期未实现的组件（如后续可能需要的底部弹窗下拉关闭组件）会直接使用Bruno组件库中的组件；而前期已实现的部分，在产品和UI有需要更新风格的情况下，也会按需进行替换成组件库中的风格</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切为H5的标准</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E5%88%87%E4%B8%BAH5%E7%9A%84%E6%A0%87%E5%87%86/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E5%88%87%E4%B8%BAH5%E7%9A%84%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="切为H5的标准"><a href="#切为H5的标准" class="headerlink" title="切为H5的标准"></a>切为H5的标准</h1><p>针对指示的h5实现方式和空态页面体验优化问题，我们经讨论，处理方案如下</p><p>问题一：对目前app中存在的H5页面，哪些是需要处理成h5的，初步定为如下标准：</p><p>1、黄金主流程的必须保证flutter实现，更稳定；</p><p>2、对于强运营的、改动量比较频繁的采用h5，一般为活动页；</p><p>3、对于纯展示交互少的采用h5，如隐私协议、玩法说明等；</p><p>按以上标准，目前app中，需要处理成h5页面的有：</p><p>状态1：已由H5实现，无需修改；</p><p>状态2：待开发，直接开发成H5；</p><p>状态3：原生实现，后续优化时调整为H5；</p><p>1、注册协议、隐私政策、玩法说明：待开发，直接开发成H5；</p><p>2、频道页：目前只有潮物是h5，其他已用flutter实现，后续待频道页优化时调整为H5；</p><p>3、活动规则(百愿清单、愿望星规则等)：目前已有部分由flutter实现，后续逐步调整为H5；</p><p>4、大转盘、动物运动会、4大场景(生日、节日、结婚、生娃)：已由H5实现；</p><p>5、首页banner跳转的落地页：跳转百愿清单、愿望单为黄金主流程已由flutter实现；跳转电子邀请函、动物运动会已由H5实现；</p><p>问题二：对app中无数据的空态页面太空的体验优化问题，晚上产品会把所有页面都列出来，再跟您对一遍，然后我们再统一做修改。</p><p>方案陈述以上，如有描述不当或需要再补充的，感谢指点！</p>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构分层</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h1><p><img src="/Architecture架构/架构分层/./架构分层/架构分层.png" alt="架构分层"></p><p>其他架构</p><ul><li><p><a href="/Users/lichaoqian/Project/CQBook/iOS-wiki/page/iOS-Architecture.md">iOS-Architecture</a></p></li><li><p>iOS：<a href="https://github.com/dvlproad/CJStandardProject.git" target="_blank" rel="noopener">CJStandardProject</a> <a href="https://github.com/dvlproad/CJStandardProject/tree/master/Screenshots" target="_blank" rel="noopener">Screenshots</a>中含架构图</p></li><li><p><a href="https://www.bilibili.com/video/av32230326" target="_blank" rel="noopener">iOS_APM从入门到放弃,剖析移动端性能监控</a></p><blockquote><p>APM:Application performance managerment</p></blockquote></li></ul><p>其他参考文章</p><ul><li><a href="https://www.jianshu.com/p/7a31b317a56c" target="_blank" rel="noopener">iOS各种架构设计图</a></li><li><a href="https://www.jianshu.com/p/fc4b72399ccb" target="_blank" rel="noopener">纯 Flutter 工程的分层架构设计以及工程化实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
          <category> 第一章：架构分层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存优化方案汇总</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="缓存与数据库一致性"><a href="#缓存与数据库一致性" class="headerlink" title="缓存与数据库一致性"></a>缓存与数据库一致性</h1><p>参考文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/4W7vmICGx6a_WX701zxgPQ" target="_blank" rel="noopener">缓存和数据库一致性问题，看这篇就够了</a></li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
          <category> 第一章：架构分层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存优化方案汇总</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="优化方案汇总"><a href="#优化方案汇总" class="headerlink" title="优化方案汇总"></a>优化方案汇总</h1><h2 id="一、初始页面处理优化"><a href="#一、初始页面处理优化" class="headerlink" title="一、初始页面处理优化"></a>一、初始页面处理优化</h2><h3 id="1、数据缓存"><a href="#1、数据缓存" class="headerlink" title="1、数据缓存"></a>1、数据缓存</h3><h4 id="1-1、普通数据的缓存"><a href="#1-1、普通数据的缓存" class="headerlink" title="1.1、普通数据的缓存"></a>1.1、普通数据的缓存</h4><p>通过缓存框架，将数据缓存起来(key需携带uid)，下次界面展示时候，优先从缓存中获取。</p><p>附：缓存框架详见：<a href="../Flutter/9框架升级/组件的使用-Cache">flutter_cache_kit使用文档</a></p><h4 id="1-2、用户数据的缓存"><a href="#1-2、用户数据的缓存" class="headerlink" title="1.2、用户数据的缓存"></a>1.2、用户数据的缓存</h4><p>建立Service层，管理用户所有数据的变动。</p><p><strong>好处</strong>：与普通数据的缓存相比，能够在将来增加数据变动时候，通过本地通知系统，告知相关页面更新相应数据，而不用等到重新下载后才能显示已知道会更新的数据。</p><p>使用要点：</p><p>修改的时候，同步数据；下次界面需要数据，优先从用户管理服务中获取初始数据</p><p>eg1:用户愿望单收藏、商品收藏、品牌收藏、足迹数据</p><p>eg2:用户会员中心数据</p><h3 id="2、数据携带-数据参照"><a href="#2、数据携带-数据参照" class="headerlink" title="2、数据携带/数据参照"></a>2、数据携带/数据参照</h3><p>通过前一个页面的已获得数据，对所进入的新页面中的数据进行预填充。</p><p>eg1:商品列表 —&gt; 商品详情：使用数据携带</p><p>eg2:愿望星count个数：通过count的0与非0，知晓所进入的页面初始状态更有可能是哪种状态</p><p>1、如果所进入的页面没有缓存数据，则携带的数据在进入的时候直接使用，后台接口返回实时数据后，再更新</p><p>2、<strong>如果所进入的页面有缓存数据</strong>，则携带的数据只能给缓存数据，而不能是后台接口返回的实时数据</p><h3 id="3、默认数据"><a href="#3、默认数据" class="headerlink" title="3、默认数据"></a>3、默认数据</h3><p>使用与产品约定的默认数据来加载</p><h3 id="4、预览页：美团-饿了么的骨架屏灰底效果"><a href="#4、预览页：美团-饿了么的骨架屏灰底效果" class="headerlink" title="4、预览页：美团/饿了么的骨架屏灰底效果"></a>4、预览页：美团/饿了么的骨架屏灰底效果</h3><h3 id="5、空白-加载圈"><a href="#5、空白-加载圈" class="headerlink" title="5、空白+加载圈"></a>5、空白+加载圈</h3><h2 id="二、图片优化"><a href="#二、图片优化" class="headerlink" title="二、图片优化"></a>二、图片优化</h2><h3 id="1、降低图片质量"><a href="#1、降低图片质量" class="headerlink" title="1、降低图片质量"></a>1、降低图片质量</h3><ul><li><p>1.1、使用缩略图</p><p>让后台返回缩略图地址，而不是大图地址</p></li><li><p>1.2、图片地址加对应质量参数：</p><p><a href="https://cloud.tencent.com/document/product/436/44884" target="_blank" rel="noopener">腾讯云-对象存储-质量变换</a></p><p><a href="https://cloud.tencent.com/document/product/460/6929" target="_blank" rel="noopener">快速缩略模板</a></p><p>后台不是给缩略图地址的情况下，自己通过图片地址，配置对应的参数，来展示</p></li></ul><h3 id="2、图片缓存"><a href="#2、图片缓存" class="headerlink" title="2、图片缓存"></a>2、图片缓存</h3><p>2.1、直接图片视图加载</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TolerantNetworkImage(</span><br><span class="line">        imageUrl: networkUrl,</span><br><span class="line">        width: <span class="number">100</span>,</span><br><span class="line">        height: <span class="number">300</span>,</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>2.2、先加载图片数据，再赋值到图片视图上</p><p>eg:首页频道图片切换</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">ImageProvider imageProvider_network;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成数据</span></span><br><span class="line">imageProvider_network = CachedNetworkImageProvider(networkUrl);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数据</span></span><br><span class="line"><span class="keyword">return</span> Image(</span><br><span class="line">    image: imageProvider_network,</span><br><span class="line">    width: <span class="number">100</span>,</span><br><span class="line">    height: <span class="number">300</span>,</span><br><span class="line">    fit: BoxFit.cover,</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>2.3、去除多余的图片切换动画</p><p>eg：许个愿图片切换</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> CachedNetworkImage(</span><br><span class="line">     width: width,</span><br><span class="line">     height: height,</span><br><span class="line">     fit: fit,</span><br><span class="line">     imageUrl: imageUrl,</span><br><span class="line">     placeholderFadeInDuration: <span class="built_in">Duration</span>.zero,</span><br><span class="line">     fadeOutDuration: <span class="built_in">Duration</span>.zero,</span><br><span class="line">     fadeInDuration: <span class="built_in">Duration</span>.zero,</span><br><span class="line">     progressIndicatorBuilder: (context, url, progress) &#123;</span><br><span class="line">       <span class="keyword">return</span> Container(color: Color(<span class="number">0xFFF0F0F0</span>));</span><br><span class="line">     &#125;,</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><h3 id="3、图片占位图、异常图"><a href="#3、图片占位图、异常图" class="headerlink" title="3、图片占位图、异常图"></a>3、图片占位图、异常图</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> CachedNetworkImage(</span><br><span class="line">     width: width,</span><br><span class="line">     height: height,</span><br><span class="line">     fit: fit,</span><br><span class="line">     imageUrl: imageUrl,</span><br><span class="line">     placeholder: placeholder,</span><br><span class="line">     errorWidget: (context, url, error) &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.errorWidget != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.errorWidget(context, url, error);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> Container();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><h3 id="4、图片加载动画"><a href="#4、图片加载动画" class="headerlink" title="4、图片加载动画"></a>4、图片加载动画</h3><p>可适当在图片视图本身加入loading动画</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">return CachedNetworkImage(</span><br><span class="line">        width: width,</span><br><span class="line">        height: height,</span><br><span class="line">        fit: fit,</span><br><span class="line">        imageUrl: imageUrl,</span><br><span class="line">        placeholder: placeholder,</span><br><span class="line">        errorWidget: (context, url, error) &#123;</span><br><span class="line">          if (this.errorWidget != null) &#123;</span><br><span class="line">            return this.errorWidget(context, url, error);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            return Container();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        placeholderFadeInDuration: placeholderFadeInDuration,</span><br><span class="line">        fadeOutDuration: fadeOutDuration,</span><br><span class="line">        fadeInDuration: fadeInDuration,</span><br><span class="line">        progressIndicatorBuilder: (context, url, progress) &#123;</span><br><span class="line">          if (this.progressIndicatorBuilder != null) &#123;</span><br><span class="line">            return this.progressIndicatorBuilder(context, url, progress);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            return Container(color: Color(0xFFF0F0F0));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br></pre></td></tr></table></figure><h2 id="三、按钮点击区域"><a href="#三、按钮点击区域" class="headerlink" title="三、按钮点击区域"></a>三、按钮点击区域</h2><p>eg：返回键的点击</p><h2 id="四、样式"><a href="#四、样式" class="headerlink" title="四、样式"></a>四、样式</h2><p>loading加载动画按需添加</p><p>返回按钮统一</p><p>toast提示统一</p><p>底部弹窗统一</p><h2 id="五、网络"><a href="#五、网络" class="headerlink" title="五、网络"></a>五、网络</h2><p>api数据缓存</p><h2 id="六、底层异常处理"><a href="#六、底层异常处理" class="headerlink" title="六、底层异常处理"></a>六、底层异常处理</h2><h3 id="1、图片的404错误"><a href="#1、图片的404错误" class="headerlink" title="1、图片的404错误"></a>1、图片的404错误</h3><p>错误示例：</p><p><a href="https://img.alicdn.com/bao/uploaded/i1/1799996758/TB2YYnmoFXXXXatXFXXXXXXXXXX_!!1799996758.jpg" target="_blank" rel="noopener">https://img.alicdn.com/bao/uploaded/i1/1799996758/TB2YYnmoFXXXXatXFXXXXXXXXXX_!!1799996758.jpg</a></p><p>错误提示：</p><p>flutter: CacheManager: Failed to download file from <a href="https://img.alicdn.com/bao/uploaded/i3/791232018/TB2_zAjsVXXXXaNXXXXXXXXXXXX_!!791232018.jpg" target="_blank" rel="noopener">https://img.alicdn.com/bao/uploaded/i3/791232018/TB2_zAjsVXXXXaNXXXXXXXXXXXX_!!791232018.jpg</a> with error:</p><p><img src="/Architecture架构/缓存优化方案汇总/image_error_404.png" alt="image-20220119162152615"></p><p>修改方案：</p><p><a href="https://blog.csdn.net/a18339063397/article/details/117960301" target="_blank" rel="noopener">Flutter cached_network_image图片缓存异常/加载失败优化</a></p><h2 id="六、代码优化"><a href="#六、代码优化" class="headerlink" title="六、代码优化"></a>六、代码优化</h2><p>屏幕适配写法</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
          <category> 第一章：架构分层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络ApiMock</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E7%BD%91%E7%BB%9CApiMock/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E7%BD%91%E7%BB%9CApiMock/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="网络Api-mock"><a href="#网络Api-mock" class="headerlink" title="网络Api mock"></a>网络Api mock</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>为了避免后端因为其他任务，来不及开发接口，特意建立mock环境，以此来保证后续出现类似情况，app也能够正常的开发，并能够在后端开发结束时候，快速完成整体的联调，从而在某个环节断档的情况下，也能够保证整体的进度。</p><h2 id="二、功能介绍"><a href="#二、功能介绍" class="headerlink" title="二、功能介绍"></a>二、功能介绍</h2><ul><li>远程模拟</li><li>本地模拟</li></ul><h2 id="三、远程模拟"><a href="#三、远程模拟" class="headerlink" title="三、远程模拟"></a>三、远程模拟</h2><h3 id="1、远程界面样式"><a href="#1、远程界面样式" class="headerlink" title="1、远程界面样式"></a>1、远程界面样式</h3><p>目前该环境，已对现有所有app接口实现mock。</p><p><img src="/Architecture架构/网络ApiMock/apimock1.png" alt="image-20220119193932769"></p><h3 id="2、使用简介"><a href="#2、使用简介" class="headerlink" title="2、使用简介"></a>2、使用简介</h3><h4 id="2-1、修改地址"><a href="#2-1、修改地址" class="headerlink" title="2.1、修改地址"></a>2.1、修改地址</h4><p>如果你已在<strong>api mock后台</strong>创建了模拟的接口，则只需要在项目中进行如下修改即可，其会自动将所请求的地址进行模拟。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">String</span> getVirtualList = <span class="string">"/account/wallet/virtualAsset/page"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟时候，在字符串尾部加上`.toSimulateApi()`即可</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">String</span> getVirtualList = <span class="string">"/account/wallet/virtualAsset/page"</span>.toSimulateApi();</span><br></pre></td></tr></table></figure><h4 id="2-2、修改mock数据"><a href="#2-2、修改mock数据" class="headerlink" title="2.2、修改mock数据"></a>2.2、修改mock数据</h4><p>因为从Swagger同步过来的接口，其返回值不是完整的response结构。</p><p>完整的response={“code”:0, “msg”: “成功”, data:xxx};</p><p>同步的response=data</p><p>所以为避免每个接口都得重复的去添加response外层来调整结构，我们通过在本地网络上进行兼容，从而实现了即使你没对同步的接口进行操作，也能够直接调用请求，得到完整的数据结构。</p><h2 id="四、本地模拟"><a href="#四、本地模拟" class="headerlink" title="四、本地模拟"></a>四、本地模拟</h2><h3 id="1、使用简介"><a href="#1、使用简介" class="headerlink" title="1、使用简介"></a>1、使用简介</h3><p>以模拟<code>/account/wallet/wishStar/page</code>接口为例</p><h4 id="1-1、添加本地json"><a href="#1-1、添加本地json" class="headerlink" title="1.1、添加本地json"></a>1.1、添加本地json</h4><p>在项目中asset下的的data文件夹里添加该以请求路径命名的json文件。</p><p><img src="/Architecture架构/网络ApiMock/%E7%BD%91%E7%BB%9CApiMock/image-20220322134145737.png" alt="image-20220322134145737"></p><h4 id="1-2、修改地址"><a href="#1-2、修改地址" class="headerlink" title="1.2、修改地址"></a>1.2、修改地址</h4><p>将请求地址的尾部加上<code>.toLocalApi()</code>，即可自动将所请求的地址进行本地数据模拟。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">String</span> wishStar = <span class="string">"/account/wallet/wishStar/page"</span>; <span class="comment">//愿望星流水明细</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟时候，在字符串尾部加上`.toLocalApi()`即可</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">String</span> wishStar = <span class="string">"/account/wallet/wishStar/page"</span>.toLocalApi(); <span class="comment">//愿望星流水明细</span></span><br></pre></td></tr></table></figure><p>#### </p><p> <em>_random.nextDouble() 获取的是0-1之间不为负数的小数</em></p><p>四舍五入</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">6.28</span>;</span><br><span class="line"><span class="built_in">print</span>(foo.round()); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
          <category> 第一章：架构分层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI组件选择历程</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="路由相关"><a href="#路由相关" class="headerlink" title="路由相关"></a>路由相关</h1><h2 id="一、Flutter里的viewWillAppear"><a href="#一、Flutter里的viewWillAppear" class="headerlink" title="一、Flutter里的viewWillAppear"></a>一、Flutter里的viewWillAppear</h2><ul><li><a href="https://www.jianshu.com/p/75b62c3c996b" target="_blank" rel="noopener">Flutter里的viewWillAppear</a></li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E8%A7%86%E9%A2%91/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="1、播放器选择之路"><a href="#1、播放器选择之路" class="headerlink" title="1、播放器选择之路"></a>1、播放器选择之路</h3><p>音视频播放对于现在的互联网应用来说，已经是不可或缺的功能之一。作为一个 App 开发者，开发一个音视频播放功能，说难不难，说简单也不简单，我们常常会面临几个抉择：</p><ol><li>使用原生视频组件（如：MediaPlayer）</li><li>使用原生硬解码/FFmpeg软解，定制视频播放组件</li><li>使用完全开源的第三方组件（如：ijkplayer）</li><li>使用商业第三方组件（如：腾讯云播放器，阿里云播放器）</li></ol><h3 id="2、视频地址获取网站"><a href="#2、视频地址获取网站" class="headerlink" title="2、视频地址获取网站"></a>2、视频地址获取网站</h3><ul><li><a href="http://www.m3u8play.com/" target="_blank" rel="noopener">m3u8网站</a></li><li><a href="http://blog.luckly-mjw.cn/tool-show/m3u8-downloader/index.html?source=http:\u002F\u002F36689.live-vod.cdn.aodianyun.com\u002Fm3u8\u002F0x0\u002Faqes_36689.aqes0.1628058327\u002Faqes_36689.aqes0.1628058327.m3u8" target="_blank" rel="noopener">m3u8 视频在线提取工具</a></li></ul><h2 id="一、腾讯云播放器"><a href="#一、腾讯云播放器" class="headerlink" title="一、腾讯云播放器"></a>一、腾讯云播放器</h2><ul><li><a href="https://cloud.tencent.com/document/product/266/58778" target="_blank" rel="noopener">腾讯-超级播放器</a></li><li><a href="https://zhuanlan.zhihu.com/p/96706072" target="_blank" rel="noopener">功能强大的Flutter 视频播放插件</a></li></ul><p>flutter_tencentplayer_plus</p><ul><li><a href="https://www.modb.pro/db/415035" target="_blank" rel="noopener">Flutter 音视频开发新思路</a></li></ul><ul><li><a href="https://cloud.tencent.com/developer/article/1908904?from=15425" target="_blank" rel="noopener">腾讯云点播 SDK 集成接入之踩坑&amp;填坑记</a></li></ul><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><ul><li><a href="https://www.shuzhiduo.com/A/WpdK3wlMdV/" target="_blank" rel="noopener">videoToolbox：硬解码</a></li><li><a href="https://www.ui.cn/detail/610000.html" target="_blank" rel="noopener"><strong>VAP动效实现方案</strong></a></li></ul><ul><li><a href="http://t.zoukankan.com/cui-cui-p-6207956.html" target="_blank" rel="noopener">iOS开发查看手机app本地存储的文件</a></li></ul><h2 id="视频帧"><a href="#视频帧" class="headerlink" title="视频帧"></a>视频帧</h2><ul><li><p><a href="https://cloud.tencent.com/developer/ask/sof/390883" target="_blank" rel="noopener">Flutter使用视频播放器或ffmpeg获取视频帧</a></p></li><li><p><a href="http://t.zoukankan.com/wanghuaijun-p-5575255.html" target="_blank" rel="noopener">iOS视频录制、压缩导出、取帧</a></p></li><li><p><a href="https://blog.csdn.net/a_zhon/article/details/119546032" target="_blank" rel="noopener">Flutter视频编辑轨道</a></p></li><li><p><a href="https://github.com/Xie-Yin/video_crop_track" target="_blank" rel="noopener"></a></p><blockquote><h3 id="实现的功能"><a href="#实现的功能" class="headerlink" title="实现的功能"></a>实现的功能</h3><ul><li>视频轨道最大截取3分钟</li><li>视频轨道最小截取3秒钟</li><li>如果小于3分钟则充满整个轨道</li><li>如果大于3分钟，则轨道上的展示的帧图片可以左右滑动来截取</li></ul></blockquote></li></ul><h2 id="音频降噪"><a href="#音频降噪" class="headerlink" title="音频降噪"></a>音频降噪</h2><ul><li><a href="https://www.volcengine.com/docs/6489/72099" target="_blank" rel="noopener">火山引擎-音频降噪与增强能力集</a></li></ul><table><thead><tr><th><strong>枚举值名称</strong></th><th><strong>枚举值</strong></th><th><strong>枚举类型描述</strong></th><th>类</th></tr></thead><tbody><tr><td>V2TIM_ELEM_TYPE_NONE</td><td>0</td><td>没有元素</td><td></td></tr><tr><td>V2TIM_ELEM_TYPE_TEXT</td><td>1</td><td>文本消息</td><td><a href="https://comm.qq.com/im/doc/flutter/zh/SDKAPI/Class/Message/V2TimTextElem.html" target="_blank" rel="noopener">V2TimTextElem</a></td></tr><tr><td>V2TIM_ELEM_TYPE_CUSTOM</td><td>2</td><td>自定义消息</td><td><a href="https://comm.qq.com/im/doc/flutter/zh/SDKAPI/Class/Message/V2TimCustomElem.html" target="_blank" rel="noopener">V2TimCustomElem</a></td></tr><tr><td>V2TIM_ELEM_TYPE_IMAGE</td><td>3</td><td>图片消息</td><td><a href="https://comm.qq.com/im/doc/flutter/zh/SDKAPI/Class/Message/V2TimImageElem.html" target="_blank" rel="noopener">V2TimImageElem</a></td></tr><tr><td>V2TIM_ELEM_TYPE_SOUND</td><td>4</td><td>语音消息</td><td><a href="https://comm.qq.com/im/doc/flutter/zh/SDKAPI/Class/Message/V2TimSoundElem.html" target="_blank" rel="noopener">V2TimSoundElem</a></td></tr><tr><td>V2TIM_ELEM_TYPE_VIDEO</td><td>5</td><td>视频消息</td><td><a href="https://comm.qq.com/im/doc/flutter/zh/SDKAPI/Class/Message/V2TimVideoElem.html" target="_blank" rel="noopener">V2TimVideoElem</a></td></tr><tr><td>V2TIM_ELEM_TYPE_FILE</td><td>6</td><td>文件消息</td><td><a href="https://comm.qq.com/im/doc/flutter/zh/SDKAPI/Class/Message/V2TimFileElem.html" target="_blank" rel="noopener">V2TimFileElem</a></td></tr><tr><td>V2TIM_ELEM_TYPE_LOCATION</td><td>7</td><td>地理位置消息</td><td><a href="https://comm.qq.com/im/doc/flutter/zh/SDKAPI/Class/Message/V2TimLocationElem.html" target="_blank" rel="noopener">V2TimLocationElem</a></td></tr><tr><td>V2TIM_ELEM_TYPE_FACE</td><td>8</td><td>表情消息</td><td><a href="https://comm.qq.com/im/doc/flutter/zh/SDKAPI/Class/Message/V2TimFaceElem.html" target="_blank" rel="noopener">V2TimFaceElem</a></td></tr><tr><td>V2TIM_ELEM_TYPE_GROUP_TIPS</td><td>9</td><td>群 Tips 消息（存消息列表）</td><td><a href="https://comm.qq.com/im/doc/flutter/zh/SDKAPI/Class/Group/V2TimGroupTipsElem.html" target="_blank" rel="noopener">V2TimGroupTipsElem</a></td></tr><tr><td>V2TIM_ELEM_TYPE_MERGER</td><td>10</td><td>合并消息</td><td><a href="https://comm.qq.com/im/doc/flutter/zh/SDKAPI/Class/Message/V2TimMergerElem.html" target="_blank" rel="noopener">V2TimMergerElem</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基础语法</title>
      <link href="/README/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/README/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>参考文章：</p><ul><li><p><a href="https://www.jianshu.com/p/0b257de21eb5" target="_blank" rel="noopener">Markdown进阶语法整理</a></p></li><li><p><a href="https://www.cnblogs.com/byho/p/10570145.html" target="_blank" rel="noopener">MarkDown折叠语法</a></p></li></ul><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>详情查看：<a href="#Attachment1">附一：StateEasyPage.js 与 StateNormalPage.js</a></p><h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><h3 id="1、语法代码："><a href="#1、语法代码：" class="headerlink" title="1、语法代码："></a>1、语法代码：</h3><p>基础语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;测试的简要标题&lt;/summary&gt;</span><br><span class="line">  测试的详细内容</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><p>加工语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;&lt;mark&gt;&lt;font color=darkred&gt;点击查看详细内容&lt;/font&gt;&lt;/mark&gt;&lt;/summary&gt;</span><br><span class="line">  &lt;p&gt; - 测试 测试测试&lt;/p&gt;</span><br><span class="line">  &lt;pre&gt;&lt;code&gt;  </span><br><span class="line">for i in a:</span><br><span class="line"><span class="code">    print(i)</span></span><br><span class="line">  &lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><h3 id="2、上述语法代码效果展示"><a href="#2、上述语法代码效果展示" class="headerlink" title="2、上述语法代码效果展示"></a>2、上述语法代码效果展示</h3><ul><li><p>代码块1的效果</p></li><li><details><br><summary>测试的简要标题</summary><br>测试的详细内容<br></details></li><li><p>代码块2的效果</p></li><li><details><br>  <summary><mark><font color="darkred">点击查看详细内容</font></mark></summary><br>  <p> - 测试 测试测试</p><br>  <pre><code><br>for i in a:<br>    print(i)<br>  </code></pre><br></details></li></ul><h3 id="3、自己常用"><a href="#3、自己常用" class="headerlink" title="3、自己常用"></a>3、自己常用</h3><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p><a name="Attachment1"></a></p><h3 id="附一：StateEasyPage-js-与-StateNormalPage-js"><a href="#附一：StateEasyPage-js-与-StateNormalPage-js" class="headerlink" title="附一：StateEasyPage.js 与 StateNormalPage.js"></a>附一：StateEasyPage.js 与 StateNormalPage.js</h3>]]></content>
      
      
      <categories>
          
          <category> README </category>
          
      </categories>
      
      
        <tags>
            
            <tag> README </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI组件选择历程</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E7%95%8C%E9%9D%A2/IM%E7%9B%B8%E5%85%B3/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E7%95%8C%E9%9D%A2/IM%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="IM相关"><a href="#IM相关" class="headerlink" title="IM相关"></a>IM相关</h1><h2 id="一、腾讯云IM"><a href="#一、腾讯云IM" class="headerlink" title="一、腾讯云IM"></a>一、腾讯云IM</h2><ul><li><a href="https://cloud.tencent.com/document/product/269/68823#step2" target="_blank" rel="noopener">腾讯云IM-Flutter</a></li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI组件选择历程</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E7%95%8C%E9%9D%A2/%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E7%95%8C%E9%9D%A2/%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="图片相关"><a href="#图片相关" class="headerlink" title="图片相关"></a>图片相关</h1><h2 id="一、数据万象"><a href="#一、数据万象" class="headerlink" title="一、数据万象"></a>一、数据万象</h2><ul><li><a href="https://cloud.tencent.com/document/product/460/6929" target="_blank" rel="noopener">腾讯云数据万象-快速缩略模板</a></li></ul><h2 id="二、图片歪了"><a href="#二、图片歪了" class="headerlink" title="二、图片歪了"></a>二、图片歪了</h2><p><a href="http://image.xihuanwu.com/wish/1649949264711187.jpg" target="_blank" rel="noopener">http://image.xihuanwu.com/wish/1649949264711187.jpg</a> 需使用Chrome打开才是横着的，Safari会自动转正<br><a href="http://image.xihuanwu.com/wish/1649949264711187.jpg?imageView2/format/webp/1/h/720" target="_blank" rel="noopener">http://image.xihuanwu.com/wish/1649949264711187.jpg?imageView2/format/webp/1/h/720</a></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI组件选择历程</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E7%95%8C%E9%9D%A2/%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E7%95%8C%E9%9D%A2/%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="事件响应相关"><a href="#事件响应相关" class="headerlink" title="事件响应相关"></a>事件响应相关</h1><p>参考文章：</p><ul><li><a href="https://mengqd.blog.csdn.net/article/details/105440465?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=1" target="_blank" rel="noopener">Flutter AbsorbPointer 与 IgnorePointer的区别</a></li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI组件选择历程</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E7%95%8C%E9%9D%A2/%E8%AE%BE%E5%A4%87%E7%9B%B8%E5%85%B3/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E7%95%8C%E9%9D%A2/%E8%AE%BE%E5%A4%87%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="设备相关"><a href="#设备相关" class="headerlink" title="设备相关"></a>设备相关</h1><h2 id="一、分辨率与尺寸"><a href="#一、分辨率与尺寸" class="headerlink" title="一、分辨率与尺寸"></a>一、分辨率与尺寸</h2><h3 id="最新iPhone全机型分辨率和尺寸收录"><a href="#最新iPhone全机型分辨率和尺寸收录" class="headerlink" title="最新iPhone全机型分辨率和尺寸收录"></a>最新iPhone全机型分辨率和尺寸收录</h3><table><thead><tr><th>手机机型 (iPhone)</th><th>屏幕尺寸 (inch)</th><th>逻辑分辨率 (pt)</th><th>设备分辨率 (px)</th><th>缩放因子 (Scale Factor)</th></tr></thead><tbody><tr><td>3G(s)</td><td>3.5</td><td>320x480</td><td>320x480</td><td>@1x</td></tr><tr><td>4(s)</td><td>3.5</td><td>320x480</td><td>640x960</td><td>@2x</td></tr><tr><td>5(s/se)</td><td>4</td><td>320x568</td><td>640x1136</td><td>@2x</td></tr><tr><td>6(s)/7/8</td><td>4.7</td><td>375x667</td><td>750x1334</td><td>@2x</td></tr><tr><td>6(s)/7/8 Plus</td><td>5.5</td><td>414x736</td><td>1242x2208</td><td>@3x</td></tr><tr><td>X/Xs /11 Pro</td><td>5.8</td><td>375x812</td><td>1125x2436</td><td>@3x</td></tr><tr><td>Xr /11\</td><td>6.1</td><td>6.1</td><td>414x896</td><td>828×1792</td><td>@2x</td></tr><tr><td>Xs Max /11 Pro Max</td><td>6.5</td><td>414x896</td><td>1242×2688</td><td>@3x</td></tr><tr><td>12 mini</td><td>5.4</td><td>360x780</td><td>1080x2340</td><td>@3x</td></tr><tr><td>12/12 Pro</td><td>6.1</td><td>390x844</td><td>1170x2532</td><td>@3x</td></tr><tr><td>12 Pro Max</td><td>6.7</td><td>428x926</td><td>1284x2778</td><td>@3x</td></tr><tr><td>13 mini</td><td>5.4</td><td>360x780</td><td>1080x2340</td><td>@3x</td></tr><tr><td>13/13 Pro</td><td>6.1</td><td>390x844</td><td>1170x2532</td><td>@3x</td></tr><tr><td>13 Pro Max</td><td>6.7</td><td>428x926</td><td>1284x2778</td><td>@3x</td></tr></tbody></table><p>iPhone X系列随着机型增多，屏幕尺寸也发生了改变，安全距离也不同。竖屏状态下有44、48、47等（可能还有其他数值）；横竖屏切换时也不相同：横屏时左右的安全距离相同，由原来竖屏下底部安全距离34改为与顶部安全距离相同。即横屏时左右安全距离相同，都为竖屏下顶部安全距离。<br>适配方案：如果项目中带SceneDelegate文件可添加以下代码，不带该文件的项目可去除iOS13的判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (UIEdgeInsets)getIphoneSafeInsets &#123;</span><br><span class="line">    UIEdgeInsets safeInsets = UIEdgeInsetsMake(20, 0, 0, 0);</span><br><span class="line">    if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">        if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">            safeInsets = [UIApplication sharedApplication].windows.firstObject.safeAreaInsets;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            safeInsets = [[UIApplication sharedApplication] delegate].window.safeAreaInsets;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (safeInsets.top &lt; 20) &#123;</span><br><span class="line">        safeInsets.top = 20;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return safeInsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI组件选择历程</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E7%95%8C%E9%9D%A2/%E5%9C%B0%E5%9B%BE%E7%9B%B8%E5%85%B3/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E7%95%8C%E9%9D%A2/%E5%9C%B0%E5%9B%BE%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="地图相关"><a href="#地图相关" class="headerlink" title="地图相关"></a>地图相关</h1><h2 id="一、百度地图"><a href="#一、百度地图" class="headerlink" title="一、百度地图"></a>一、百度地图</h2><ul><li><a href="https://lbsyun.baidu.com/index.php?title=flutter/loc/create-project/configure" target="_blank" rel="noopener">百度地图官网-Flutter </a></li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装包大小</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F/%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F/%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="安装包大小"><a href="#安装包大小" class="headerlink" title="安装包大小"></a>安装包大小</h1><p>assets_generator</p><ul><li><a href="https://blog.csdn.net/weixin_41779718/article/details/110109456" target="_blank" rel="noopener">FlutterAssetsGenerator</a></li></ul><ul><li><a href="https://blog.csdn.net/lebsharing/article/details/122969878" target="_blank" rel="noopener">Flutter中图片管理及使用–静态引用</a></li></ul><ul><li><a href="https://blog.csdn.net/lebsharing/article/details/122967490" target="_blank" rel="noopener">Flutter项目中无用图片的检测及清理</a></li></ul><h2 id="Python3安装xlsxwriter"><a href="#Python3安装xlsxwriter" class="headerlink" title="Python3安装xlsxwriter"></a>Python3安装xlsxwriter</h2><ul><li><p><a href="https://coco56.blog.csdn.net/article/details/107754226?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107754226-blog-95179896.pc_relevant_multi_platform_whitelistv4eslandingctr&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107754226-blog-95179896.pc_relevant_multi_platform_whitelistv4eslandingctr&amp;utm_relevant_index=2" target="_blank" rel="noopener">Python3安装xlsxwriter</a></p></li><li><p><a href=""></a> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Pillow # 获取图片大小</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>界面</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E7%95%8C%E9%9D%A2/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：Swift扩展(Extensions)</title>
      <link href="/iOS/Swift/1%E5%85%A5%E9%97%A8/2.Swift%E6%89%A9%E5%B1%95(Extensions)/"/>
      <url>/iOS/Swift/1%E5%85%A5%E9%97%A8/2.Swift%E6%89%A9%E5%B1%95(Extensions)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="入门二"><a href="#入门二" class="headerlink" title="入门二"></a>入门二</h1><ul><li>一、Swift扩展(Extensions)</li></ul><h2 id="一、Swift扩展-Extensions"><a href="#一、Swift扩展-Extensions" class="headerlink" title="一、Swift扩展(Extensions)"></a>一、Swift扩展(Extensions)</h2><p>Swift基础部门：<a href="http://www.swift51.com/swift4.0/chapter2/01_The_Basics.html" target="_blank" rel="noopener">http://www.swift51.com/swift4.0/chapter2/01_The_Basics.html</a></p><p>详见：<a href="http://www.swift51.com/swift4.0/chapter2/21_Extensions.html中的2.21扩展" target="_blank" rel="noopener">http://www.swift51.com/swift4.0/chapter2/21_Extensions.html中的2.21扩展</a></p><p>在swift中<strong>extension(扩展)</strong>与Objective-C的<strong>category(分类/扩展/类别)</strong>有点类似，但是extension比起category来说更加强大和灵活，它不仅可以扩展某种类型或结构体的方法，同时它还可以与protocol等结合使用，编写出更加灵活和强大的代码。</p><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p><a href="https://www.jianshu.com/p/460b5424942a" target="_blank" rel="noopener">Swift3.0语法变化</a></p><p><a href="https://www.jianshu.com/p/808d7b71bf70" target="_blank" rel="noopener">swift 枚举的取值</a></p><p><a href="https://www.jianshu.com/p/da44d1fd8440" target="_blank" rel="noopener">Swift中协议的可选方法的实现判断</a></p><h2 id="二、第三方库"><a href="#二、第三方库" class="headerlink" title="二、第三方库"></a>二、第三方库</h2><p><strong>OC第三方库需要在桥街文件中引入，swift第三方库需要import model方式引入！桥街文件不能引入swift第三方库</strong></p><ul><li>Network:</li></ul><p>Alamofire：著名的AFNetworking网络基础库Swift版 - Alamofire/Alamofire · GitHub</p><p>SwiftyJSON：最为开发者认可的JSON解析类 - SwiftyJSON/SwiftyJSON · GitHub</p><ul><li>Storage：</li></ul><p>SQLite.swift：简单、轻量，使用上最SQL的SQLite封装库 - stephencelis/SQLite.swift · GitHub</p><p>SugarRecord：基于CoreData与REALM的好用封装 - SugarRecord/SugarRecord · GitHub</p><ul><li>UI：</li></ul><p>SweetAlert：带动画效果弹窗封装类 - codestergit/SweetAlert-iOS · GitHub</p><p>RAMAnimatedTabBarController：灵动的动画标签栏类库 - Ramotion/animated-tab-bar · GitHub</p><p>PNChart-Swift：带动画效果的图表控件库 - kevinzhow/PNChart-Swift · GitHub</p><p>LTMorphingLabel：各种文字动画效果 - lexrus/LTMorphingLabel · GitHub</p><p>Cartography：用代码解决麻烦的AutoLayout - robb/Cartography · GitHub</p><p>other:</p><p>pod ‘SVProgressHUD’</p><p>pod ‘MJRefresh’</p><p>pod ‘SnapKit’</p><p><a href="https://www.jianshu.com/p/f4282df18537" target="_blank" rel="noopener">Swift常用第三方库</a></p><p><a href="https://www.sohu.com/a/217501815_635110" target="_blank" rel="noopener">2017最受欢迎的30个Swift 库，你关注到了吗？</a></p><p><a href="https://www.jianshu.com/p/f4282df18537" target="_blank" rel="noopener">Swift常用第三方库</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发随笔</title>
      <link href="/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/AVPlayer%E7%9B%B8%E5%85%B3%E9%9A%8F%E7%AC%94/"/>
      <url>/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/AVPlayer%E7%9B%B8%E5%85%B3%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="开发随笔"><a href="#开发随笔" class="headerlink" title="开发随笔"></a>开发随笔</h1><p>使用AVPlayerViewController之前先导入AVKit头文件</p><p>支持的视频编码格式很有限：H.264、MPEG-4，扩展名（压缩格式）：.mp4、.mov、.m4v、.m2v、.3gp、.3g2等，如果是RMVB就不行了，需要借助第三方的框架来实现更多格式的支持。</p><p><strong>iOS视频播放的基本方法</strong></p><p><a href="https://www.jianshu.com/p/b304694af77a" target="_blank" rel="noopener"><strong>https://www.jianshu.com/p/b304694af77a</strong></a></p><p><strong>浅谈iOS的AVPlayerViewController播放视频</strong></p><p><a href="https://www.jianshu.com/p/3f8e5045c087" target="_blank" rel="noopener"><strong>https://www.jianshu.com/p/3f8e5045c087</strong></a></p><p><strong>AVPlayer 循环播放本地视频</strong></p><p><a href="https://blog.csdn.net/tailoffairylu/article/details/83142802" target="_blank" rel="noopener">https://blog.csdn.net/tailoffairylu/article/details/83142802</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发随笔</title>
      <link href="/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3%E9%9A%8F%E7%AC%94/"/>
      <url>/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="计时器相关随笔"><a href="#计时器相关随笔" class="headerlink" title="计时器相关随笔"></a>计时器相关随笔</h1><p><strong>iOS 倒计时实现</strong></p><p><a href="https://www.jianshu.com/p/f36aaf232887" target="_blank" rel="noopener">https://www.jianshu.com/p/f36aaf232887</a></p><p><strong>iOS按钮倒计时在进入后台不继续计时的处理</strong></p><p><a href="https://blog.csdn.net/weixin_33816611/article/details/91928414" target="_blank" rel="noopener"><strong>https://blog.csdn.net/weixin_33816611/article/details/91928414</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发随笔</title>
      <link href="/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
      <url>/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="开发随笔"><a href="#开发随笔" class="headerlink" title="开发随笔"></a>开发随笔</h1><h1 id="iOS研发助手DoraemonKit"><a href="#iOS研发助手DoraemonKit" class="headerlink" title="iOS研发助手DoraemonKit"></a>iOS研发助手DoraemonKit</h1><p><strong>iOS研发助手DoraemonKit技术实现（一）</strong></p><p><a href="https://www.jianshu.com/p/00763123dbc4" target="_blank" rel="noopener"><strong>https://www.jianshu.com/p/00763123dbc4</strong></a></p><p><a href="https://www.jianshu.com/p/7d1ec700e903" target="_blank" rel="noopener">iOS 常用调试方法：LLDB命令</a></p><p><a href="https://www.jianshu.com/p/90717a308f61" target="_blank" rel="noopener">iOS 线程保活</a></p><p><a href="https://www.jianshu.com/p/413811babe1e" target="_blank" rel="noopener">iOS RunLoop（一）</a></p><p><a href="https://www.jianshu.com/p/cffd3ace0653" target="_blank" rel="noopener">iOS中NSOperation详解</a></p><p><a href="https://www.jianshu.com/p/c3811f5a6baf" target="_blank" rel="noopener">iOS 逆向开发16：HOOK原理上（HOOK 系统C函数）</a></p><p><a href="https://www.jianshu.com/p/eace8a1b7c93" target="_blank" rel="noopener">另类iOS上的C函数hook</a></p><p><a href="https://www.jianshu.com/p/05aad21e319e" target="_blank" rel="noopener">iOS被开发者遗忘在角落的NSException-其实它很强大</a></p><h3 id="UITextView对齐"><a href="#UITextView对齐" class="headerlink" title="UITextView对齐"></a>UITextView对齐</h3><p>textView中的文字默认离顶部和底部是有间距的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UITextView *textView = [[UITextView alloc] init];</span><br><span class="line">NSLog(@&quot;...%@&quot;, NSStringFromUIEdgeInsets(textView.textContainerInset));// 默认值&#123;8, 0, 8, 0&#125;</span><br><span class="line"></span><br><span class="line">textView.textContainerInset = UIEdgeInsetsZero;</span><br></pre></td></tr></table></figure><p><strong>iOS 侧滑返回详解FDFullscreenPopGesture</strong></p><p><a href="https://www.jianshu.com/p/62015b4c9076" target="_blank" rel="noopener"><strong>https://www.jianshu.com/p/62015b4c9076</strong></a></p><p><strong>哆啦A梦 只能显示nslog，无法显示</strong>debugPrint</p><p><strong>podfile中 use_frameworks! 和 #use_frameworks!区别</strong></p><p><a href="https://www.jianshu.com/p/ac629a1cb8f5" target="_blank" rel="noopener"><strong>https://www.jianshu.com/p/ac629a1cb8f5</strong></a></p><p><strong>iOS 效果处理（内阴影、外阴影、外发光、内发光、投影）</strong></p><p><a href="https://blog.csdn.net/qq_34534179/article/details/109180717" target="_blank" rel="noopener"><strong>https://blog.csdn.net/qq_34534179/article/details/109180717</strong></a></p><p><strong>IOS微信分享调起微信后立刻返回到app中无法分享的问题</strong></p><p><a href="https://blog.csdn.net/qq_35153373/article/details/112285261" target="_blank" rel="noopener"><strong>https://blog.csdn.net/qq_35153373/article/details/112285261</strong></a></p><p><strong>iOS 14 popToRootViewControllerAnimated 底部tabbar消失</strong></p><p><a href="https://www.jianshu.com/p/c6b3ccff9e5b" target="_blank" rel="noopener"><strong>https://www.jianshu.com/p/c6b3ccff9e5b</strong></a></p><p>美图秀秀的拼图功能</p><p><a href="https://github.com/hxxyyangyong/MeituDemo" target="_blank" rel="noopener"><strong>https://github.com/hxxyyangyong/MeituDemo</strong></a></p><p><strong>iOS 不规则（多边形）图形，贝塞尔曲线绘制自定义图形</strong></p><p><a href="https://www.jianshu.com/p/6786cc4d28a7?from=groupmessage" target="_blank" rel="noopener"><strong>https://www.jianshu.com/p/6786cc4d28a7?from=groupmessage</strong></a></p><p><strong>iOS UIButton 渐变色、边框渐变色、字体渐变色</strong></p><p><a href="https://blog.csdn.net/liwenjie0912/article/details/87548692" target="_blank" rel="noopener"><strong>https://blog.csdn.net/liwenjie0912/article/details/87548692</strong></a></p><p><strong>textfield</strong></p><p><strong>1、不要delloc</strong></p><p><strong>2、不要delegate = self. shouldchange不调用</strong></p><p><strong>3、二分法查找</strong></p><p><strong>iOS根据网络图片的size大小设置UIImageView的大小</strong></p><p><a href="https://www.cnblogs.com/sunfuyou/p/6284986.html" target="_blank" rel="noopener"><strong>https://www.cnblogs.com/sunfuyou/p/6284986.html</strong></a></p><p><strong>iOS 如何让button上的字体居左居右对齐</strong></p><p><a href="https://www.jianshu.com/p/737553cd8eb5" target="_blank" rel="noopener">https://www.jianshu.com/p/737553cd8eb5</a></p><p><strong>iOS 使用CGAffineTransform 使视图平移|旋转|缩放</strong></p><p><a href="https://www.jianshu.com/p/58d810cec41d" target="_blank" rel="noopener">https://www.jianshu.com/p/58d810cec41d</a></p><p>UILabel *titleLabel = [UILabel alloc]; 空指针</p><p>UILabel *titleLabel = [[UILabel alloc] init];</p><p>  [container addSubview:titleLabel];</p><p>iOS开发 怎么删除UICollectionView的cell</p><p><a href="https://jingyan.baidu.com/article/ceb9fb10bd32a08cac2ba053.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/ceb9fb10bd32a08cac2ba053.html</a></p><p><strong>UICollectionView执行performBatchUpdates 奔溃</strong></p><p><a href="https://blog.csdn.net/jamy08/article/details/50505859?utm_source=blogxgwz7" target="_blank" rel="noopener"><strong>https://blog.csdn.net/jamy08/article/details/50505859?utm_source=blogxgwz7</strong></a></p><p><strong>ios扩大按钮的点击区域</strong></p><p><a href="https://www.jianshu.com/p/9107be4cd84a" target="_blank" rel="noopener"><strong>https://www.jianshu.com/p/9107be4cd84a</strong></a></p><p><strong>iOS 利用UICollectionView横向滚动、余弦函数曲线特性实现居中放大的卡片浏览工具 XLCardSwitch</strong></p><p><a href="https://blog.csdn.net/u013282507/article/details/54136812" target="_blank" rel="noopener"><strong>https://blog.csdn.net/u013282507/article/details/54136812</strong></a></p><p><strong>iOS之事件穿透</strong></p><p><a href="https://www.jianshu.com/p/0bece5f27650" target="_blank" rel="noopener"><strong>https://www.jianshu.com/p/0bece5f27650</strong></a></p><p><strong>iOS 13-beta presentViewController 样式变化</strong></p><p><a href="https://www.jianshu.com/p/67901ae2323d" target="_blank" rel="noopener"><strong>https://www.jianshu.com/p/67901ae2323d</strong></a></p><p><strong>cocoapods 1.8.0版本之后，CDN: trunk 推荐解决方法</strong></p><p><a href="https://blog.csdn.net/ZHFDBK/article/details/106949342" target="_blank" rel="noopener"><strong>https://blog.csdn.net/ZHFDBK/article/details/106949342</strong></a></p><p>Commond + alt + /</p><p><img src="blob:file:///3b907321-24e9-4d91-8a0d-f0478f49c393" alt="Pasted Graphic.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发规范</title>
      <link href="/iOS/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/iOS/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS-够逼格的注释总结"><a href="#iOS-够逼格的注释总结" class="headerlink" title="iOS 够逼格的注释总结"></a>iOS 够逼格的注释总结</h1><p><a href="https://blog.csdn.net/yusirxiaer/article/details/52511059" target="_blank" rel="noopener">https://blog.csdn.net/yusirxiaer/article/details/52511059</a></p><h1 id="正确使用NS-DESIGNATED-INITIALIZER"><a href="#正确使用NS-DESIGNATED-INITIALIZER" class="headerlink" title="正确使用NS_DESIGNATED_INITIALIZER"></a>正确使用NS_DESIGNATED_INITIALIZER</h1><p><a href="https://blog.csdn.net/zcube/article/details/51657417" target="_blank" rel="noopener">https://blog.csdn.net/zcube/article/details/51657417</a></p><p>NS_REQUIRES_SUPER：表示类的这个方法在子类重写时，必须在方法内部使用super调用父类的这个方法。</p><h1 id="Swift中-0、-1的实际含义"><a href="#Swift中-0、-1的实际含义" class="headerlink" title="Swift中$0、$1的实际含义"></a>Swift中$0、$1的实际含义</h1><p><a href="https://www.jianshu.com/p/b36a0f8108aa" target="_blank" rel="noopener">https://www.jianshu.com/p/b36a0f8108aa</a></p><p><a href="https://swift.gg/2016/08/03/swift-prettify-your-print-statements-pt-1/" target="_blank" rel="noopener">Swift:如何优雅地使用 print()（一）</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识</title>
      <link href="/iOS/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/iOS/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS-宏定义-获取状态栏、导航栏、tabBar高度"><a href="#iOS-宏定义-获取状态栏、导航栏、tabBar高度" class="headerlink" title="iOS 宏定义-获取状态栏、导航栏、tabBar高度"></a>iOS 宏定义-获取状态栏、导航栏、tabBar高度</h1><p><a href="https://www.jianshu.com/p/801bdea428f8" target="_blank" rel="noopener">https://www.jianshu.com/p/801bdea428f8</a></p><p><img src="/iOS/开发规范/基础知识/image-20201121001108987.png" alt="image-20201121001108987"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> screenHeight = <span class="type">UIScreen</span>.main.bounds.size.height</span><br><span class="line"><span class="keyword">let</span> statusBarHeight = <span class="type">UIApplication</span>.shared.statusBarFrame.size.height</span><br><span class="line"><span class="keyword">let</span> navigationBarHeight = <span class="keyword">self</span>.navigationController?.navigationBar.frame.size.height ?? <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> tabbarHeight = <span class="keyword">self</span>.tabBarController?.tabBar.frame.height ?? <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> screenWidth = <span class="type">UIScreen</span>.main.bounds.size.width</span><br><span class="line"><span class="keyword">let</span> iphoneX = screenWidth &gt;= <span class="number">375.0</span> &amp;&amp; screenHeight &gt;= <span class="number">812.0</span></span><br><span class="line"><span class="keyword">let</span> bottomGuideHeight: <span class="type">CGFloat</span> = iphoneX ? <span class="number">34</span> : <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>让你不知道怎么死的RAC</title>
      <link href="/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/1%E6%9E%B6%E6%9E%84%E7%BB%86%E8%8A%82/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8RAC%E5%90%97/"/>
      <url>/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/1%E6%9E%B6%E6%9E%84%E7%BB%86%E8%8A%82/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8RAC%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h1 id="让你不知道怎么死的RAC"><a href="#让你不知道怎么死的RAC" class="headerlink" title="让你不知道怎么死的RAC"></a>让你不知道怎么死的RAC</h1><p>[TOC]</p><h2 id="前言：RAC学习起来的特点"><a href="#前言：RAC学习起来的特点" class="headerlink" title="前言：RAC学习起来的特点"></a>前言：RAC学习起来的特点</h2><ul><li>学习起来比较难</li><li>团队开发的时候需要谨慎使用</li><li>团队代码需要不断的评审,保证团队中所有人代码的风格一致!避免阅读代码的困难</li></ul><h2 id="一、RAC双向绑定UITextField的正确姿势"><a href="#一、RAC双向绑定UITextField的正确姿势" class="headerlink" title="一、RAC双向绑定UITextField的正确姿势"></a>一、RAC双向绑定UITextField的正确姿势</h2><h4 id="1、先说结果"><a href="#1、先说结果" class="headerlink" title="1、先说结果"></a>1、先说结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// textField1: 键盘修改textField有问题的例子</span><br><span class="line">RACChannelTo(self.viewModel, text1) = RACChannelTo(self.textField1, text);</span><br><span class="line"></span><br><span class="line">// textField2: 代码修改textField有问题的例子</span><br><span class="line">RACChannelTo(self.viewModel, text2) = self.textField2.rac_newTextChannel;</span><br><span class="line"></span><br><span class="line">// textField3: 键盘和代码修改textField都没问题的例子</span><br><span class="line">RACChannelTo(self.viewModel, text3) = RACChannelTo(self.textField3, text);</span><br><span class="line">[self.textField3.rac_textSignal subscribe:RACChannelTo(self.textField3, text)];</span><br></pre></td></tr></table></figure><p>比较结果如下列表所示：</p><table><thead><tr><th></th><th>未完整的双向绑定1</th><th>未完整的双向绑定2</th><th>完整的双向绑定</th></tr></thead><tbody><tr><td>代码文本</td><td><img src="/iOS/架构相关/1架构细节/你真的会用RAC吗/RACBindTextField1.png" alt="RACBindTextField1"></td><td><img src="/iOS/架构相关/1架构细节/你真的会用RAC吗/RACBindTextField2.png" alt="RACBindTextField2"></td><td><img src="/iOS/架构相关/1架构细节/你真的会用RAC吗/RACBindTextField3.png" alt="RACBindTextField3"></td></tr><tr><td>代码截图</td><td><figure class="highlight plain"><figcaption><span>textField1: 键盘修改textField有问题的例子```<br>```RACChannelTo(self.viewModel, text1) </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">| textField               | textField1: 键盘修改textField有问题的例子                    | textField2: 代码修改textField有问题的例子                    | textField3: 键盘和代码修改textField都没问题的例子            |</span><br><span class="line">| (通过代码)改变model时   | textField会改变                                              | textField会改变                                              | textField会改变                                              |</span><br><span class="line">| 通过代码改变textField时 | model会改变                                                  | &lt;u&gt;model不会改变&lt;/u&gt;                                         | model会改变                                                  |</span><br><span class="line">| 通过键盘改变textField时 | &lt;u&gt;model不会改变&lt;/u&gt;                                         | model会改变                                                  | model会改变                                                  |</span><br><span class="line"></span><br><span class="line">#### 2、分析原因</span><br><span class="line"></span><br><span class="line">要弄清为什么通过如上两种方式分别对textField1和textField2进行双向绑定会有问题，那么你需要先认识一下以下两个与textField有关的值的比较</span><br><span class="line"></span><br><span class="line">|      |                                                              |                                                              |</span><br><span class="line">| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |</span><br><span class="line">|      | ```RACChannelTo(self.textField, text)```                     | ```self.textField.rac_newTextChannel```                      |</span><br><span class="line">| 原理 | 当通过code改变self.textField.text的值的时候,才会把RACChannelTo(self.textField, text)这个值发送出去 | 当通过键盘改变self.textField.text的值的时候,才会把self.textField.rac_newTextChannel这个值发送出去 |</span><br><span class="line">| 后果 | 所以只使用这个时，键盘修改textField会有问题                  | 所以只使用这个时，代码修改textField会有问题                  |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果你还存疑惑，那么我们拿`textField1: 键盘修改textField有问题的例子`来说明：</span><br><span class="line"></span><br><span class="line">```objective-c</span><br><span class="line">    // textField1: 键盘修改textField有问题的例子</span><br><span class="line">    RACChannelTo(self.viewModel, text1) = RACChannelTo(self.textField1, text);</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>我们在<code>RACKVOProxy</code>中的<code>observeValueForKeyPath</code>处设置断点，会发现，当我们只设置如上代码时候，通过键盘改变textField的值的时，其并未走入所设断点中，即其此时并未能检测到文本框的文本已经改变了。所以，也就出现了只设置如上代码，会出现当通过键盘改变文本框(键盘未收起)的时候，viewModel中的值没法改变的情况。</p><blockquote><p><img src="/iOS/架构相关/1架构细节/你真的会用RAC吗/RACKVOProxy observeValueForKeyPath.png" alt="RACKVOProxy observeValueForKeyPath"></p></blockquote><p>同理，另一个的验证也如此。</p><h4 id="3、解决问题"><a href="#3、解决问题" class="headerlink" title="3、解决问题"></a>3、解决问题</h4><p>下面我们对<code>RACChannelTo(self.viewModel, text3) = RACChannelTo(self.textField3, text);</code>绑定方式进行键盘修改的完善，完善方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACChannelTo(self.viewModel, text3) = RACChannelTo(self.textField3, text);</span><br><span class="line">@weakify(self);</span><br><span class="line">[self.textField3.rac_textSignal subscribeNext:^(NSString * _Nullable x) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    self.viewModel.text3 = x;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>该部分代码，可简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RACChannelTo(self.viewModel, text3) = RACChannelTo(self.textField3, text);</span><br><span class="line">[self.textField3.rac_textSignal subscribe:RACChannelTo(self.textField3, text)];</span><br></pre></td></tr></table></figure><p>即我们上诉开头时候的正确代码。</p><h4 id="4、实际应用中还存在的bindViewModel的问题"><a href="#4、实际应用中还存在的bindViewModel的问题" class="headerlink" title="4、实际应用中还存在的bindViewModel的问题"></a>4、实际应用中还存在的bindViewModel的问题</h4><h6 id="4-1、在RAC绑定常见view中的textField的例子RACBindNorTextFieldViewController中"><a href="#4-1、在RAC绑定常见view中的textField的例子RACBindNorTextFieldViewController中" class="headerlink" title="4.1、在RAC绑定常见view中的textField的例子RACBindNorTextFieldViewController中"></a>4.1、在RAC绑定常见view中的textField的例子<code>RACBindNorTextFieldViewController</code>中</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    self.title = NSLocalizedString(@&quot;RAC Bind Normal TextField&quot;, nil);</span><br><span class="line">    [self setupViews];</span><br><span class="line">    </span><br><span class="line">    [self bindViewModel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2、在RAC绑定tableView中的textField的例子RACBindTvTextFieldViewController中"><a href="#4-2、在RAC绑定tableView中的textField的例子RACBindTvTextFieldViewController中" class="headerlink" title="4.2、在RAC绑定tableView中的textField的例子RACBindTvTextFieldViewController中"></a>4.2、在RAC绑定tableView中的textField的例子<code>RACBindTvTextFieldViewController</code>中</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    RACTextFieldBindTableViewCell *cell = (RACTextFieldBindTableViewCell *)[tableView dequeueReusableCellWithIdentifier:@&quot;RACTextFieldBindTableViewCell&quot; forIndexPath:indexPath];</span><br><span class="line">    cell.backgroundColor = [UIColor greenColor];</span><br><span class="line">    </span><br><span class="line">    if (indexPath.row == 0) &#123;</span><br><span class="line">        self.textField1 = cell.textField;</span><br><span class="line">    &#125; else if (indexPath.row == 1) &#123;</span><br><span class="line">        self.textField2 = cell.textField;</span><br><span class="line">    &#125; else if (indexPath.row == 2) &#123;</span><br><span class="line">        self.textField3 = cell.textField;</span><br><span class="line">    &#125;</span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么bindViewModel的时机比较容易出错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    self.title = NSLocalizedString(@&quot;RAC Bind TableView TextField&quot;, nil);</span><br><span class="line">    </span><br><span class="line">    [self setupViews];</span><br><span class="line">    //[self bindViewModel]; //textField未获取，无法进行绑定</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    //[self bindViewModel]; //textField未获取，无法进行绑定</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">    [self bindViewModel];   //tableView中的textField绑定的正确时机</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、遗留问题"><a href="#5、遗留问题" class="headerlink" title="5、遗留问题"></a>5、遗留问题</h4><p>遗留问题1：为什么只有键盘没回收时候的修改文本框值才有问题，而键盘回收时候不会也存在问题？</p><h2 id="二、RAC监听的属性如何正确改变值-KVO的坑"><a href="#二、RAC监听的属性如何正确改变值-KVO的坑" class="headerlink" title="二、RAC监听的属性如何正确改变值(KVO的坑)"></a>二、RAC监听的属性如何正确改变值(KVO的坑)</h2><p>假设有如下需求，根据viewModel中的<code>@property (nonatomic, assign) BOOL textFieldValid;</code>值修改UIViewController中textField的自定义属性<code>leftButtonSelected</code>的值，怎么做？？？</p><p>答：<code>RAC(self.textField, leftButtonSelected) = RACObserve(viewModel, textFieldValid);</code></p><p>问题是：<strong>是不是只要实现了这行代码就没什么问题了？或者说在实现这行代码前，你有什么需要注意的？如果你不知道，你不搞清楚原因，那么有一天RAC让你怎么死的，你都不知道。</strong></p><h4 id="1、下面将常见的你修改属性时候使用的代码及其效果，列举如下："><a href="#1、下面将常见的你修改属性时候使用的代码及其效果，列举如下：" class="headerlink" title="1、下面将常见的你修改属性时候使用的代码及其效果，列举如下："></a>1、下面将常见的你修改属性时候使用的代码及其效果，列举如下：</h4><table><thead><tr><th>修改属性时候使用的代码</th><th>代码位置</th><th>效果</th></tr></thead><tbody><tr><td><code>self.inTextFieldValid1 = inTextFieldValid1;</code></td><td>viewModel中</td><td>正确</td></tr><tr><td><del>_inTextFieldValid2 = inTextFieldValid2;</del></td><td>viewModel中</td><td>错误</td></tr><tr><td><code>[self setValue:@(inTextFieldValid3) forKey:@&quot;inTextFieldValid3&quot;];</code></td><td>viewModel中</td><td>正确</td></tr><tr><td><del>[self setValue:@(inTextFieldValid4) forKey:@”_inTextFieldValid4”];</del></td><td>viewModel中</td><td>错误</td></tr><tr><td><code>self.viewModel.outTextFieldValid1 = outTextFieldValid1;</code></td><td>UIViewController中</td><td>正确</td></tr><tr><td><code>[self.viewModel setValue:@(outTextFieldValid2) forKey:@&quot;outTextFieldValid2&quot;];</code></td><td>UIViewController中</td><td>正确</td></tr><tr><td><del>[self.viewModel setValue:@(outTextFieldValid3) forKey:@”_outTextFieldValid3”];</del></td><td>UIViewController中</td><td>错误</td></tr></tbody></table><p>上面正确与否的判断标准是什么？</p><p>其实如果熟悉KVO机制的你，应该知道<strong>KVO的本质是通过<code>isa-swizzling</code>新建了一个子类，并且重写了属性的<code>setter</code>方法，在<code>setter</code>方法的头和尾分别执行了<code>willChangeValueForKey:</code>和<code>didChangevlueForKey:</code>两个方法来实现监听的。</strong></p><p>所以，如果你修改属性时候使用的代码不会走setter方法，那么也就无法触发监听了。因而也就出现了你明明监听了属性，却无法正确运行的情况。</p><p>如上表格中的错误方法皆是不会走setter的。</p><p>下面是一张别人的图：</p><p><img src="/iOS/架构相关/1架构细节/你真的会用RAC吗/KVO机制.png" alt="img"></p><h4 id="2、有无规避方法"><a href="#2、有无规避方法" class="headerlink" title="2、有无规避方法"></a>2、有无规避方法</h4><p>问：<em>通过如上解析，我们知道问题的根源是没调用setter，那我们可否通过编译器提示不能使用<code>_xxx</code>来规避？？？</em></p><p>在这里我们补充讲下<code>@synthesize</code></p><table><thead><tr><th></th><th>写法1</th><th>写法2</th></tr></thead><tbody><tr><td>源代码</td><td>@synthesize student;</td><td>@synthesize student = _student;</td></tr><tr><td>等价代码</td><td>@synthesize student = student;</td><td>—-同上—-</td></tr></tbody></table><p>synthesize的作用就是让student = ？中的后者这个变量来“代替”属性，从而可以通过操作变量来进行属性的操作。但是有一点最关键的是，使用变量进行操作，属性本身的引用计数是不会增加的，因为没有经过调用setter方法或者是getter方法。但是如果使用self.student这种操作方式的话，实质上是通过setter或者是getter方法进行操作，引用计数会随着不同的操作而改变，了解了这点后就能够更好的避免内存泄露问题。</p><h2 id="三、RAC监听数组的变化-KVO的坑"><a href="#三、RAC监听数组的变化-KVO的坑" class="headerlink" title="三、RAC监听数组的变化(KVO的坑)"></a>三、RAC监听数组的变化(KVO的坑)</h2><p>iOS默认不支持KVO的形式来监听数组的变化，数组改变的时候，只是数组里面的值变化，但数组的地址没有变化，KVO监听的对象地址的变化。</p><p>由于不支持KVO来监听数组变化，就无法使用RAC来监听数组。</p><h6 id="1、传统方式-我们不需要监听时候常使用的代码-："><a href="#1、传统方式-我们不需要监听时候常使用的代码-：" class="headerlink" title="1、传统方式(我们不需要监听时候常使用的代码)："></a>1、传统方式(我们不需要监听时候常使用的代码)：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 只是修改数组，无法触发监听</span><br><span class="line">if (self.flawArray.count) &#123;</span><br><span class="line">   [self.flawArray removeLastObject];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="2、需要使用监听时候的数组修改"><a href="#2、需要使用监听时候的数组修改" class="headerlink" title="2、需要使用监听时候的数组修改"></a>2、需要使用监听时候的数组修改</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   // 修改数组时候同时能确保触发KVO的操作</span><br><span class="line">if (self.okArray.count) &#123;</span><br><span class="line">       NSMutableArray *kvo_okArray = [self mutableArrayValueForKey:@&quot;okArray&quot;];</span><br><span class="line">       [kvo_okArray removeLastObject];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="四、RAC中监听通知的坑"><a href="#四、RAC中监听通知的坑" class="headerlink" title="四、RAC中监听通知的坑"></a>四、RAC中监听通知的坑</h2><p>请查看：<a href="https://blog.csdn.net/qinqi376990311/article/details/79031581" target="_blank" rel="noopener">RAC中监听通知的坑！</a></p><h2 id="五、结束语"><a href="#五、结束语" class="headerlink" title="五、结束语"></a>五、结束语</h2><p>暂时到此！感谢查阅！</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>明道</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E6%98%8E%E9%81%93/%E6%98%8E%E9%81%93%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E6%98%8E%E9%81%93/%E6%98%8E%E9%81%93%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>任务划分示例</p><p><img src="/实用工具/明道/明道任务划分/任务划分示例.png" alt="任务划分示例"></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活常识</title>
      <link href="/%E5%B8%B8%E8%AF%86%E7%B1%BB/%E7%94%9F%E6%B4%BB%E5%B8%B8%E8%AF%86/%E6%A5%BC%E6%88%BF%E5%B8%B8%E8%AF%86/"/>
      <url>/%E5%B8%B8%E8%AF%86%E7%B1%BB/%E7%94%9F%E6%B4%BB%E5%B8%B8%E8%AF%86/%E6%A5%BC%E6%88%BF%E5%B8%B8%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="高楼晃动正常吗？买房可能遇到哪些质量问题"><a href="#高楼晃动正常吗？买房可能遇到哪些质量问题" class="headerlink" title="高楼晃动正常吗？买房可能遇到哪些质量问题"></a>高楼晃动正常吗？买房可能遇到哪些质量问题</h2><p>文章来源：<a href="https://zhidao.baidu.com/special/view?id=7ca55a24626975510400" target="_blank" rel="noopener">https://zhidao.baidu.com/special/view?id=7ca55a24626975510400</a></p><blockquote><p> 专业人士称，超高层建筑来回摇动是正常的，有利于楼体安全，高层建筑大部分都是钢结构，对于侧向压力会起到缓冲作用。高层建筑“打太极”，摇摆而“定”，也是对风压的一种缓冲。高层建筑不会摇摆才是危险的，一般来说越高的建筑，摇摆幅度越大。</p><p>在建造高层建筑时，风是首先要考虑的要素之一，高空风力增大的原因是高楼林立的“狭管效应”。由于高楼阻挡，如果风的通行面减小一半的话，其穿行速度则会增加约一倍。遇见高楼狭小的通道，风就更猛烈了。因此，超高层建筑顶部一般都会有位移表现，只是幅度不同。楼层越高，幅度越大。因此住在顶楼的居民感觉晃动是正常的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新项目实施步骤</title>
      <link href="/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%96%BD%E6%AD%A5%E9%AA%A4/"/>
      <url>/iOS/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%96%BD%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="新项目实施步骤"><a href="#新项目实施步骤" class="headerlink" title="新项目实施步骤"></a>新项目实施步骤</h1><h2 id="一、建立项目工程-0-5h"><a href="#一、建立项目工程-0-5h" class="headerlink" title="一、建立项目工程(0.5h)"></a>一、建立项目工程(0.5h)</h2><h3 id="1、工程配置"><a href="#1、工程配置" class="headerlink" title="1、工程配置"></a>1、工程配置</h3><h4 id="1-1、pod处理–Podfile"><a href="#1-1、pod处理–Podfile" class="headerlink" title="1.1、pod处理–Podfile"></a>1.1、pod处理–Podfile</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pod 'SnapKit'</span><br><span class="line">pod 'Masonry'</span><br><span class="line">pod 'CJBaseUIKit'</span><br><span class="line">pod 'CJFoundation'</span><br><span class="line">pod 'CJBaseHelper'</span><br></pre></td></tr></table></figure><h4 id="1-2、混编处理"><a href="#1-2、混编处理" class="headerlink" title="1.2、混编处理"></a>1.2、混编处理</h4><h5 id="①、OC-调用-Swift"><a href="#①、OC-调用-Swift" class="headerlink" title="①、OC 调用 Swift"></a>①、OC 调用 Swift</h5><p>1、建立XXX-Swift.h</p><p>附：如果你是OC工程中第一次创建swift文件，则系统会在自动帮你搭建XXX-Bridging-Header.h的同时，为你生成该文件。即那种情况下，此步可略过</p><p>2、Defines Module 设置为YES</p><p><img src="/iOS/架构相关/新项目实施步骤/image-20201106181320734.png" alt="image-20201106181320734"></p><p>3、oc 文件中 #import “XXX-Swift.h”</p><h5 id="②、Swift-调用-OC"><a href="#②、Swift-调用-OC" class="headerlink" title="②、Swift 调用 OC"></a>②、Swift 调用 OC</h5><blockquote><p>XXX-Bridging-Header.h</p></blockquote><h3 id="2、工程入口"><a href="#2、工程入口" class="headerlink" title="2、工程入口"></a>2、工程入口</h3><h4 id="2-1、入口首页：方便他人进入开发"><a href="#2-1、入口首页：方便他人进入开发" class="headerlink" title="2.1、入口首页：方便他人进入开发"></a>2.1、入口首页：方便他人进入开发</h4><h2 id="二、架构设计"><a href="#二、架构设计" class="headerlink" title="二、架构设计"></a>二、架构设计</h2><h3 id="1、架构文件管理"><a href="#1、架构文件管理" class="headerlink" title="1、架构文件管理"></a>1、架构文件管理</h3><ul><li><p>AppDelegate</p><blockquote><p>AppDelegate+StartUp.swift</p></blockquote></li><li><p>CommonUI</p></li><li>CommonUtil</li><li>Service</li><li>Module</li><li>Resources</li></ul><h2 id="三、功能模块规划"><a href="#三、功能模块规划" class="headerlink" title="三、功能模块规划"></a>三、功能模块规划</h2><h3 id="1、登录模块-Page5-24h"><a href="#1、登录模块-Page5-24h" class="headerlink" title="1、登录模块 Page5 24h"></a>1、登录模块 Page5 24h</h3><h4 id="1-1、登录模块"><a href="#1-1、登录模块" class="headerlink" title="1.1、登录模块"></a>1.1、登录模块</h4><p>Page 5 24h</p><ul><li>登录的首页<ul><li>隐私政策弹窗页</li></ul></li><li>登录方式选择页面<ul><li>本机号码获取</li><li>第三方登录（微信、）</li></ul></li><li>登录的手机号码输入页</li><li>登录的手机验证码输入页</li></ul><h4 id="1-2、登录后的信息完善"><a href="#1-2、登录后的信息完善" class="headerlink" title="1.2、登录后的信息完善"></a>1.2、登录后的信息完善</h4><p>Page </p><ul><li>欢迎页 -&gt; 内容介绍页1 -&gt; 内容介绍页2</li><li>个人信息完善<ul><li>个人性别 + 交往喜好(性别+年龄)</li></ul></li></ul><h4 id="1-3、信息完善后的使用引导"><a href="#1-3、信息完善后的使用引导" class="headerlink" title="1.3、信息完善后的使用引导"></a>1.3、信息完善后的使用引导</h4><p>Page3 1d</p><h3 id="2、主页模块-Page1-4h"><a href="#2、主页模块-Page1-4h" class="headerlink" title="2、主页模块 Page1 4h"></a>2、主页模块 Page1 4h</h3><h4 id="2-1、主页框架-Page1-4h"><a href="#2-1、主页框架-Page1-4h" class="headerlink" title="2.1、主页框架 Page1 4h"></a>2.1、主页框架 Page1 4h</h4><p>Page1    4h</p><h3 id="3、发现模块"><a href="#3、发现模块" class="headerlink" title="3、发现模块"></a>3、发现模块</h3><p>Page 17 = 11 +  6 + 2</p><p>h        40 = 28 + 8 + 4  </p><h4 id="3-1、更好使用的信息完善-表-Page11-28h"><a href="#3-1、更好使用的信息完善-表-Page11-28h" class="headerlink" title="3.1、更好使用的信息完善-表 Page11 28h+"></a>3.1、更好使用的信息完善-表 Page11 28h+</h4><p>涉及的组件开发 8</p><ul><li>完善进度组件 2</li><li>照片弹窗组件 6</li><li>照片列表组件 3</li></ul><p>涉及的页面开发（不含请求）20+</p><ul><li><p>昵称完善页 1</p></li><li><p>生日完善页(日期选择 + 年龄 + 星座)  4</p></li><li><p>身高完善页 1</p></li><li><p>家乡完善页 4</p></li><li><p>学校完善页</p></li><li><p>职业完善页(选一选+自定义)  4+2</p></li><li><p>日常完善页</p></li><li><p>愿望完善页</p></li><li><p>照片完善页 1</p></li></ul><h4 id="3-2、更好使用的信息完善-里-Page6-8h"><a href="#3-2、更好使用的信息完善-里-Page6-8h" class="headerlink" title="3.2、更好使用的信息完善-里 Page6 8h"></a>3.2、更好使用的信息完善-里 Page6 8h</h4><h4 id="3-3、更好使用的信息完善-匹配偏好-Page2-4h"><a href="#3-3、更好使用的信息完善-匹配偏好-Page2-4h" class="headerlink" title="3.3、更好使用的信息完善-匹配偏好 Page2 4h"></a>3.3、更好使用的信息完善-匹配偏好 Page2 4h</h4><h3 id="4、我的模块"><a href="#4、我的模块" class="headerlink" title="4、我的模块"></a>4、我的模块</h3><h4 id="4-1、我的首页"><a href="#4-1、我的首页" class="headerlink" title="4.1、我的首页"></a>4.1、我的首页</h4><h4 id="4-2、资料信息-表"><a href="#4-2、资料信息-表" class="headerlink" title="4.2、资料信息-表"></a>4.2、资料信息-表</h4><p>涉及的组件开发 2</p><ul><li>完善进度组件 2</li><li>照片弹窗组件 已在上述完成</li><li>照片列表组件 已在上述完成</li></ul><p>涉及的页面开发（不含请求）</p><ul><li>表资料 2*8</li><li>照片</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他小工具</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="一、截图"><a href="#一、截图" class="headerlink" title="一、截图"></a>一、截图</h2><ul><li><p><a href="https://zh.xnipapp.com/scrolling-capture/" target="_blank" rel="noopener">官网：Mac的滚动截图工具- Xnip的滚动截图教程</a></p></li><li><p>其他参考：<a href="https://blog.csdn.net/u013067756/article/details/80551649" target="_blank" rel="noopener">Mac的滚动截图工具- Xnip</a></p></li></ul><h2 id="二、翻译"><a href="#二、翻译" class="headerlink" title="二、翻译"></a>二、翻译</h2><ul><li><a href="https://github.com/ripperhe/Bob" target="_blank" rel="noopener">Bob</a></li></ul><h2 id="三、录屏"><a href="#三、录屏" class="headerlink" title="三、录屏"></a>三、录屏</h2><h2 id="1、五款好用的Mac录屏软件推荐"><a href="#1、五款好用的Mac录屏软件推荐" class="headerlink" title="1、五款好用的Mac录屏软件推荐"></a>1、五款好用的Mac录屏软件推荐</h2><p><a href="http://baijiahao.baidu.com/s?id=1602506514171503088&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">五款好用的Mac录屏软件推荐</a></p><h3 id="2、Mac使用imovie合成音频和视频"><a href="#2、Mac使用imovie合成音频和视频" class="headerlink" title="2、Mac使用imovie合成音频和视频"></a>2、Mac使用imovie合成音频和视频</h3><p><a href="https://jingyan.baidu.com/article/851fbc3784d8e93e1e15ab65.html" target="_blank" rel="noopener">Mac使用imovie合成音频和视频</a></p><h2 id="四、音频转换"><a href="#四、音频转换" class="headerlink" title="四、音频转换"></a>四、音频转换</h2><h3 id="1、在线音频视频转换器"><a href="#1、在线音频视频转换器" class="headerlink" title="1、在线音频视频转换器"></a>1、在线音频视频转换器</h3><p><a href="https://www.media.io/zh/" target="_blank" rel="noopener">https://www.media.io/zh/</a></p><p><img src="/实用工具/其他小工具/其他小工具/在线音频视频转换器.png" alt="在线音频视频转换器"></p><p>点击下载：</p><p><img src="/实用工具/其他小工具/其他小工具/在线音频视频转换器2.png" alt="在线音频视频转换器2"></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> 其他小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：Flutter控件Widget的自定义与封装</title>
      <link href="/Flutter/6%E8%BF%9B%E9%98%B6/Flutter%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85/"/>
      <url>/Flutter/6%E8%BF%9B%E9%98%B6/Flutter%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你不是没有任何开发经验，那么你一定知道任何app里都有可能有重用性比较高的控件。所以对于那么重用性比较高的，或者需要你自定义的控件的，我们需要将它们给封装起来，以便下次或者其他app中继续使用。这也正式本节想要说的内容Flutter中如何封装Widget。</p><p>下面我从自己实现一个满意的封装，分别介绍你可能用到的三种封装方式</p><ul><li>1、函数式封装</li><li>2、以继承 StatefulWidget 的方式封装</li><li>3、继承父类式封装（推荐）</li></ul><p>下面我们以登录页的文本框的自定义来谈封装。</p><p><img src="/Flutter/6进阶/Flutter控件的封装/用户名登录的UI图.png" alt="用户名登录的UI图"></p><h2 id="一、函数式封装"><a href="#一、函数式封装" class="headerlink" title="一、函数式封装"></a>一、函数式封装</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// 蓝色背景按钮(常用于：登录按钮)</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// 方法1:以函数的方法实现</span></span></span><br><span class="line">FlatButton blueButton(<span class="built_in">String</span> text, <span class="built_in">bool</span> enable, VoidCallback enableOnPressed) &#123;</span><br><span class="line">  <span class="keyword">return</span> FlatButton(</span><br><span class="line">    child: Text(text),</span><br><span class="line">    splashColor: Colors.transparent,</span><br><span class="line">    color: Color(<span class="number">0xff01adfe</span>),</span><br><span class="line">    textColor: Colors.white,</span><br><span class="line">    highlightColor: Color(<span class="number">0xff1393d7</span>),</span><br><span class="line">    disabledColor: Color(<span class="number">0xffd3d3d5</span>),</span><br><span class="line">    disabledTextColor: Colors.white,</span><br><span class="line">    shape: RoundedRectangleBorder(</span><br><span class="line">        borderRadius: BorderRadius.circular(<span class="number">5.0</span>)</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment">//onPressed: enable ? enableOnPressed : null,</span></span><br><span class="line">    onPressed: enable ?  () &#123;</span><br><span class="line">      enableOnPressed();</span><br><span class="line">    &#125; : <span class="keyword">null</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍看没什么问题，好像很简洁。但当你也用这种方式来实现文本框的时候，其代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// 文本框(常用于：登录用户名、密码文本框)</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// 方法1:以函数的方法实现</span></span></span><br><span class="line">TextField loginTextField(<span class="built_in">String</span> placeholder, <span class="built_in">String</span> prefixIconImageName, ValueChanged&lt;<span class="built_in">String</span>&gt; onSubmitted) &#123;</span><br><span class="line">  <span class="keyword">return</span> TextField(</span><br><span class="line">    <span class="comment">//autofocus: shouldAutofocusUserNameTextField,</span></span><br><span class="line">    style: TextStyle(color: Colors.black, fontSize: <span class="number">17.0</span>),</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">      contentPadding: EdgeInsets.all(<span class="number">0.0</span>),</span><br><span class="line">      <span class="comment">//labelText: "用户名",</span></span><br><span class="line">      hintText: placeholder,</span><br><span class="line">      <span class="comment">//prefixIcon: Icon(Icons.person),</span></span><br><span class="line">      prefixIcon: <span class="keyword">new</span> Image.asset(</span><br><span class="line">        prefixIconImageName,</span><br><span class="line">        width: <span class="number">14.0</span>,</span><br><span class="line">        height: <span class="number">15.0</span>,</span><br><span class="line">      ),</span><br><span class="line">      enabledBorder: loginTextFieldDecorationBorder(),</span><br><span class="line">      focusedBorder: loginTextFieldDecorationBorder(),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// keyboardType: TextInputType.text,</span></span><br><span class="line">      <span class="comment">// controller: _usernameController,</span></span><br><span class="line">      <span class="comment">// textInputAction: TextInputAction.next,</span></span><br><span class="line">      <span class="comment">// focusNode: usernameFocusNode,</span></span><br><span class="line">      <span class="comment">// onSubmitted: (text) &#123;</span></span><br><span class="line">      <span class="comment">//   print("current userName:" + text);</span></span><br><span class="line">      <span class="comment">//   if (null == currentFocusNode) &#123;</span></span><br><span class="line">      <span class="comment">//     currentFocusNode = FocusScope.of(context);</span></span><br><span class="line">      <span class="comment">//   &#125;</span></span><br><span class="line">      <span class="comment">//   currentFocusNode.requestFocus(passwordFocusNode);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      onSubmitted: onSubmitted,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文本框border</span></span><br><span class="line">InputBorder loginTextFieldDecorationBorder() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> OutlineInputBorder(</span><br><span class="line">      borderSide: <span class="keyword">new</span> BorderSide(color: Color(<span class="number">0xffd2d2d2</span>), width: <span class="number">0.6</span>),</span><br><span class="line">      borderRadius: <span class="keyword">new</span> BorderRadius.circular(<span class="number">6.0</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见这种函数的方式，没办法处理过多属性的自定义。因为它并不像我们iOS中的UIView，可以对得到的控件在后续再定制。所以，在Flutter中这种函数式的封装不适合，因为它无法满足使用。</p><p>附：以下是iOS中的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (CJTextField *)userNameTextField &#123;</span><br><span class="line">    if (_userNameTextField == nil) &#123;</span><br><span class="line">        UIImage *normalImage = [UIImage imageNamed:@&quot;login_username_gray&quot;];</span><br><span class="line">        UIImage *selectedImage = [UIImage imageNamed:@&quot;login_username_blue&quot;];</span><br><span class="line">        _userNameTextField = [CJDemoTextFieldFactory textFieldWithNormalImage:normalImage selectedImage:selectedImage];</span><br><span class="line">        _userNameTextField.placeholder = NSLocalizedString(@&quot;用户名&quot;, nil);</span><br><span class="line">        _userNameTextField.returnKeyType = UIReturnKeyNext;</span><br><span class="line">        _userNameTextField.clearButtonMode = UITextFieldViewModeWhileEditing;</span><br><span class="line">        _userNameTextField.delegate = self;</span><br><span class="line">    &#125;</span><br><span class="line">    return _userNameTextField;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIButton *)loginButton &#123;</span><br><span class="line">    if (_loginButton == nil) &#123;</span><br><span class="line">        _loginButton = [CJDemoButtonFactory blueButton];</span><br><span class="line">        [_loginButton setTitle:NSLocalizedString(@&quot;登录&quot;, nil) forState:UIControlStateNormal];</span><br><span class="line">        _loginButton.enabled = NO;</span><br><span class="line">        [_loginButton addTarget:self action:@selector(loginButtonAction) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    &#125;</span><br><span class="line">    return _loginButton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、以继承-StatefulWidget-的方式封装"><a href="#二、以继承-StatefulWidget-的方式封装" class="headerlink" title="二、以继承 StatefulWidget 的方式封装"></a>二、以继承 StatefulWidget 的方式封装</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// 文本框(常用于：登录用户名、密码文本框)</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// 方法2:以继承 StatefulWidget 的方式实现</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginTextField</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> placeholder;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> prefixIconImageName;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> autofocus;</span><br><span class="line">  <span class="keyword">final</span> TextEditingController controller;</span><br><span class="line">  <span class="keyword">final</span> TextInputAction textInputAction;</span><br><span class="line">  <span class="keyword">final</span> FocusNode focusNode;</span><br><span class="line">  <span class="keyword">final</span> ValueChanged&lt;<span class="built_in">String</span>&gt; onSubmitted;</span><br><span class="line">  <span class="keyword">final</span> TextInputType keyboardType;</span><br><span class="line"></span><br><span class="line">  LoginTextField(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.placeholder,</span><br><span class="line">    <span class="keyword">this</span>.prefixIconImageName,</span><br><span class="line">    <span class="keyword">this</span>.autofocus,</span><br><span class="line">    <span class="keyword">this</span>.keyboardType,</span><br><span class="line">    <span class="keyword">this</span>.controller,</span><br><span class="line">    <span class="keyword">this</span>.textInputAction,</span><br><span class="line">    <span class="keyword">this</span>.focusNode,</span><br><span class="line">    <span class="keyword">this</span>.onSubmitted</span><br><span class="line"></span><br><span class="line">&#125;)  :  <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _LoginTextFieldState createState() =&gt; _LoginTextFieldState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LoginTextFieldState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LoginTextField</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: TextField(</span><br><span class="line">        autofocus: widget.autofocus,</span><br><span class="line">        style: TextStyle(color: Colors.black, fontSize: <span class="number">17.0</span>),</span><br><span class="line">        decoration: InputDecoration(</span><br><span class="line">          contentPadding: EdgeInsets.all(<span class="number">0.0</span>),</span><br><span class="line">          <span class="comment">//labelText: "用户名",</span></span><br><span class="line">          hintText: widget.placeholder,</span><br><span class="line">          <span class="comment">//prefixIcon: Icon(Icons.person),</span></span><br><span class="line">          prefixIcon: <span class="keyword">new</span> Image.asset(</span><br><span class="line">            widget.prefixIconImageName,</span><br><span class="line">            width: <span class="number">14.0</span>,</span><br><span class="line">            height: <span class="number">15.0</span>,</span><br><span class="line">          ),</span><br><span class="line">          enabledBorder: loginTextFieldDecorationBorder(),</span><br><span class="line">          focusedBorder: loginTextFieldDecorationBorder(),</span><br><span class="line">        ),</span><br><span class="line">        keyboardType: widget.keyboardType,</span><br><span class="line">        controller: widget.controller,</span><br><span class="line">        textInputAction: widget.textInputAction,</span><br><span class="line">        focusNode: widget.focusNode,</span><br><span class="line">        onSubmitted: widget.onSubmitted</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文本框border</span></span><br><span class="line">InputBorder loginTextFieldDecorationBorder() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> OutlineInputBorder(</span><br><span class="line">      borderSide: <span class="keyword">new</span> BorderSide(color: Color(<span class="number">0xffd2d2d2</span>), width: <span class="number">0.6</span>),</span><br><span class="line">      borderRadius: <span class="keyword">new</span> BorderRadius.circular(<span class="number">6.0</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">TextField userNameTextField() &#123;</span><br><span class="line">    <span class="keyword">return</span>  TextField(</span><br><span class="line">        autofocus: shouldAutofocusUserNameTextField,</span><br><span class="line">        style: TextStyle(color: Colors.black, fontSize: <span class="number">17.0</span>),</span><br><span class="line">        decoration: InputDecoration(</span><br><span class="line">          contentPadding: EdgeInsets.all(<span class="number">0.0</span>),</span><br><span class="line">          <span class="comment">//labelText: "用户名",</span></span><br><span class="line">          hintText: <span class="string">"用户名"</span>,</span><br><span class="line">          <span class="comment">//prefixIcon: Icon(Icons.person),</span></span><br><span class="line">          prefixIcon: <span class="keyword">new</span> Image.asset(</span><br><span class="line">            userNameValid ? <span class="string">'lib/Resources/login/login_username_blue.png'</span> : <span class="string">'lib/Resources/login/login_username_gray.png'</span>,</span><br><span class="line">            width: <span class="number">14.0</span>,</span><br><span class="line">            height: <span class="number">15.0</span>,</span><br><span class="line">          ),</span><br><span class="line">          enabledBorder: loginTextFieldDecorationBorder(),</span><br><span class="line">          focusedBorder: loginTextFieldDecorationBorder(),</span><br><span class="line">        ),</span><br><span class="line">        keyboardType: TextInputType.text,</span><br><span class="line">        controller: _usernameController,</span><br><span class="line">        textInputAction: TextInputAction.next,</span><br><span class="line">        focusNode: usernameFocusNode, <span class="comment">//usernameFocusNode</span></span><br><span class="line">        onSubmitted: (text) &#123;</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">"current userName:"</span> + text);</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> == currentFocusNode) &#123;</span><br><span class="line">            currentFocusNode = FocusScope.of(context);</span><br><span class="line">          &#125;</span><br><span class="line">          currentFocusNode.requestFocus(passwordFocusNode);</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>虽然使用上看似没什么问题，但是整个TextField的继承代码难道你不觉得有更简洁的写法吗？</p><p>所以下面将讲解直接继承TextFiled的方法。</p><h2 id="三、继承父类式封装（推荐）"><a href="#三、继承父类式封装（推荐）" class="headerlink" title="三、继承父类式封装（推荐）"></a>三、继承父类式封装（推荐）</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// 文本框(常用于：登录用户名、密码文本框)</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// 方法3:以继承 TextField 的方式实现</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginTextField</span> <span class="keyword">extends</span> <span class="title">TextField</span> </span>&#123;</span><br><span class="line">  LoginTextField(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="built_in">String</span> text,</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> placeholder, </span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/// prefix icon </span></span></span><br><span class="line">    <span class="built_in">bool</span> prefixIconSelected,</span><br><span class="line">    <span class="built_in">String</span> prefixIconNormalImageName,</span><br><span class="line">    <span class="built_in">String</span> prefixIconSelectedImageName,</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> autofocus = <span class="keyword">false</span>,</span><br><span class="line">    <span class="built_in">bool</span> obscureText = <span class="keyword">false</span>,</span><br><span class="line">    TextInputType keyboardType,</span><br><span class="line">    TextEditingController controller,</span><br><span class="line">    <span class="built_in">bool</span> showClear = <span class="keyword">false</span>,</span><br><span class="line">    TextInputAction textInputAction,</span><br><span class="line">    FocusNode focusNode,</span><br><span class="line">    ValueChanged&lt;<span class="built_in">String</span>&gt; onSubmitted,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(</span><br><span class="line">    key: key,</span><br><span class="line">    autofocus: autofocus,</span><br><span class="line">    obscureText: obscureText,</span><br><span class="line">    style: TextStyle(color: Colors.black, fontSize: <span class="number">17.0</span>),</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">      contentPadding: EdgeInsets.all(<span class="number">0.0</span>),</span><br><span class="line">      <span class="comment">//labelText: "用户名",</span></span><br><span class="line">      hintText: placeholder,</span><br><span class="line">      <span class="comment">//prefixIcon: Icon(Icons.person),</span></span><br><span class="line">      prefixIcon: <span class="keyword">new</span> Image.asset(</span><br><span class="line">        !prefixIconSelected ? prefixIconNormalImageName :prefixIconSelectedImageName,</span><br><span class="line">        width: <span class="number">14.0</span>,</span><br><span class="line">        height: <span class="number">15.0</span>,</span><br><span class="line">      ),</span><br><span class="line">      suffixIcon: !showClear ? <span class="keyword">null</span> : clearButtonWithOnPressed(controller.clear),</span><br><span class="line">      enabledBorder: loginTextFieldDecorationBorder(),</span><br><span class="line">      focusedBorder: loginTextFieldDecorationBorder(),</span><br><span class="line">    ),</span><br><span class="line">    keyboardType: keyboardType,</span><br><span class="line">    controller: controller,</span><br><span class="line">    textInputAction: textInputAction,</span><br><span class="line">    focusNode: focusNode,</span><br><span class="line">    onSubmitted: onSubmitted</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// selected Image</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectedImage</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">  SelectedImage(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="built_in">bool</span> selected,</span><br><span class="line">    <span class="built_in">String</span> normalImageName,</span><br><span class="line">    <span class="built_in">String</span> selectedImageName,</span><br><span class="line">  &#125;) :<span class="keyword">super</span> (</span><br><span class="line">      key: key,</span><br><span class="line">      image: AssetImage(!selected ? normalImageName :selectedImageName)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// 文本框border</span></span></span><br><span class="line">InputBorder loginTextFieldDecorationBorder() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> OutlineInputBorder(</span><br><span class="line">      borderSide: <span class="keyword">new</span> BorderSide(color: Color(<span class="number">0xffd2d2d2</span>), width: <span class="number">0.6</span>),</span><br><span class="line">      borderRadius: <span class="keyword">new</span> BorderRadius.circular(<span class="number">6.0</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时候</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户名文本框</span></span><br><span class="line">LoginTextField userNameTextField() &#123;</span><br><span class="line">  <span class="keyword">return</span> LoginTextField(</span><br><span class="line">      placeholder: <span class="string">"用户名"</span>,</span><br><span class="line">      prefixIconSelected: userNameValid,</span><br><span class="line">      prefixIconNormalImageName: <span class="string">'assets/images/login/login_username_gray.png'</span>,</span><br><span class="line">      prefixIconSelectedImageName: <span class="string">'assets/images/login/login_username_blue.png'</span>,</span><br><span class="line">      autofocus: shouldAutofocusUserNameTextField,</span><br><span class="line">      keyboardType: TextInputType.text,</span><br><span class="line">      controller: _usernameController,</span><br><span class="line">      textInputAction: TextInputAction.next,</span><br><span class="line">      focusNode: usernameFocusNode,</span><br><span class="line">      onSubmitted: (text) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"current userName:"</span> + text);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == currentFocusNode) &#123;</span><br><span class="line">          currentFocusNode = FocusScope.of(context);</span><br><span class="line">        &#125;</span><br><span class="line">        currentFocusNode.requestFocus(passwordFocusNode);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见使用<strong>继承父类式封装</strong>这种方式，不管在封装时候，还是在使用时候，写的代码都是最简洁的。<strong>而且后期如果要直接使用系统样式，也只需要改回类名，其他结构和属性都不用动即可</strong>。</p><h2 id="四、强调自定义类的设计规范"><a href="#四、强调自定义类的设计规范" class="headerlink" title="四、强调自定义类的设计规范"></a>四、强调自定义类的设计规范</h2><p>在前面，我们已经知道<strong>使用<code>继承父类式封装</code>这种方式，不管在封装时候，还是在使用时候，写的代码都是最简洁的。而且后期如果要直接使用系统样式，也只需要改回类名，其他结构和属性都不用动即可</strong>。</p><p>所以，<strong>即使是你所定义的类只有一个入参，也一定要遵守使用<code>继承父类式封装</code>的设计规范。</strong></p><p>以下以按钮中 textStyle 的传值为例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_baseui_kit/flutter_baseui_kit.dart'</span>;</span><br><span class="line"></span><br><span class="line">ThemeBGButton(</span><br><span class="line">          <span class="comment">//width: 300, // 不设置会根据内容自适应</span></span><br><span class="line">          <span class="comment">//height: 80, // 不设置会根据内容自适应</span></span><br><span class="line">          bgColorType: ThemeBGType.pink,</span><br><span class="line">          title: <span class="string">'红底白字的按钮'</span>,</span><br><span class="line">          <span class="comment">//titleStyle: ButtonThemeUtil.PingFang_FontSize_Bold(18.0),// bad</span></span><br><span class="line">          titleStyle: ButtonBoldTextStyle(fontSize: <span class="number">18.0</span>), <span class="comment">// good</span></span><br><span class="line">          cornerRadius: <span class="number">20</span>,</span><br><span class="line">          <span class="comment">//enable: true, // 不设置,默认true</span></span><br><span class="line">          onPressed: () &#123;&#125;,</span><br><span class="line">        ),</span><br></pre></td></tr></table></figure><p>附：bad 和 good 两种实现方式的代码分别如下：</p><p>bad:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮上的文本样式(按钮上的文字颜色，已通过其他属性设置；不需要 TextStyle 中设置;其他类的文本需要在 TextStyle 设置文本颜色，所以此类最多只提供给按钮使用)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButtonThemeUtil</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 类命名注意：系统有 ButtonTheme 类，别取重名，否则外部取不到</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> TextStyle PingFang_FontSize_Medium(<span class="built_in">double</span> fontSize) &#123;</span><br><span class="line">    <span class="keyword">return</span> TextStyle(</span><br><span class="line">      fontFamily: <span class="string">'PingFang SC'</span>,</span><br><span class="line">      fontSize: fontSize,</span><br><span class="line">      fontWeight: FontWeight.w500,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>good:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// medium 的文本样式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButtonMediumTextStyle</span> <span class="keyword">extends</span> <span class="title">TextStyle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> fontSize;</span><br><span class="line">  <span class="comment">// final Color color;</span></span><br><span class="line"></span><br><span class="line">  ButtonMediumTextStyle(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.fontSize,</span><br><span class="line">    <span class="comment">// this.color,</span></span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(fontSize != <span class="keyword">null</span>),</span><br><span class="line">        <span class="comment">// assert(color != null),</span></span><br><span class="line">        <span class="keyword">super</span>(</span><br><span class="line">          fontFamily: <span class="string">'PingFang SC'</span>,</span><br><span class="line">          fontSize: fontSize,</span><br><span class="line">          fontWeight: FontWeight.w500,</span><br><span class="line">          <span class="comment">// color: color,</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，综上在Flutter中对于一个Widget的封装，我们采用直接继承其父类的方式来处理，且其具体的写法如上。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第六章：进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从登录页进入Flutter的开发规范</title>
      <link href="/Flutter/7%E8%A7%84%E8%8C%83/Flutter%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/Flutter/7%E8%A7%84%E8%8C%83/Flutter%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>良好的规范让你的代码不仅看上来更简洁，也让你的代码更加具有可读性，及大大的减少了后期维护的成本。</p><p>以下从几个方面谈谈我对Flutter良好的规范的理解。</p><h2 id="一、页面Page规范前后效果对比"><a href="#一、页面Page规范前后效果对比" class="headerlink" title="一、页面Page规范前后效果对比"></a>一、页面Page规范前后效果对比</h2><p>我们先从页面开始(以登录页的优化为例)，然后逐步的从点到面铺开描述。</p><p><strong>目标</strong>：页面布局、控件定义、事件处理分离。</p><h3 id="1、演示的Page的UI图"><a href="#1、演示的Page的UI图" class="headerlink" title="1、演示的Page的UI图"></a>1、演示的Page的UI图</h3><p><img src="/Flutter/7规范/Flutter开发规范/用户名登录的UI图.png" alt="用户名登录的UI图"></p><h3 id="2、规范前的效果"><a href="#2、规范前的效果" class="headerlink" title="2、规范前的效果"></a>2、规范前的效果</h3><p><strong>规范前</strong>：未进行任何处理的时候，你的代码是这样的。</p><p><img src="/Flutter/7规范/Flutter开发规范/LoginPage_widgetUnsplit.jpg" alt="LoginPage_widgetUnsplit"></p><h3 id="3、规范后的效果"><a href="#3、规范后的效果" class="headerlink" title="3、规范后的效果"></a>3、规范后的效果</h3><p>规范后**：按规范处理后你代码的效果是这样的，</p><p><img src="/Flutter/7规范/Flutter开发规范/LoginPage_widgetSplit.jpg" alt="LoginPage_widgetSplit"></p><p>可见通过处理后Page的整体代码更加简洁了。</p><h2 id="二、页面Page开发规范的细则"><a href="#二、页面Page开发规范的细则" class="headerlink" title="二、页面Page开发规范的细则"></a>二、页面Page开发规范的细则</h2><h3 id="1、规范一：将每个Widget的定义整理到单独的函数里"><a href="#1、规范一：将每个Widget的定义整理到单独的函数里" class="headerlink" title="1、规范一：将每个Widget的定义整理到单独的函数里"></a>1、规范一：将每个Widget的定义整理到单独的函数里</h3><p>写：</p><p><img src="/Flutter/7规范/Flutter开发规范/Flutter规范_Widget_right.jpg" alt="Flutter规范_Widget_right"></p><p>不写：</p><p><img src="/Flutter/7规范/Flutter开发规范/Flutter规范_Widget_wrong.jpg" alt="Flutter规范_Widget_wrong"></p><h3 id="2、规范二：将各个Widget组成界面的布局放到widgets-方法里处理"><a href="#2、规范二：将各个Widget组成界面的布局放到widgets-方法里处理" class="headerlink" title="2、规范二：将各个Widget组成界面的布局放到widgets()方法里处理"></a>2、规范二：将各个Widget组成界面的布局放到<code>widgets()</code>方法里处理</h3><p>写法如下：</p><p><img src="/Flutter/7规范/Flutter开发规范/Flutter规范_Widgets布局_right.jpg" alt="Flutter规范_Widgets布局_right"></p><p>如此通过以上两步后，<code>Widget build</code>中的代码即会变为如下：</p><p><img src="/Flutter/7规范/Flutter开发规范/Flutter规范_WidgetBuild_right.jpg" alt="Flutter规范_WidgetBuild_right"></p><p>如此通过以上几个拆分，我们的Page页面就显得很简洁和很好维护了。</p><h3 id="3、规范三、Widget的封装"><a href="#3、规范三、Widget的封装" class="headerlink" title="3、规范三、Widget的封装"></a>3、规范三、Widget的封装</h3><p>细心的你，可能发现了我们这里有一个系统没有的<code>LoginTextField</code>文本框类。是的，该类是我们自定义封装到Package后来使用的。</p><p>对于一个控件怎么封装，详情查看之前的文章<a href="../6进阶/Flutter控件的封装">《Flutter进阶(2)：控件Widget的自定义与封装》</a></p><h3 id="三、页面Page规范小结"><a href="#三、页面Page规范小结" class="headerlink" title="三、页面Page规范小结"></a>三、页面Page规范小结</h3><ul><li>1、Widget build方法</li></ul><p>在<em><code>build</code></em>方法里尽量用最少的代码实现整体视图。如下，我们将登录页中的所有Widget通过<em><code>loginWidgets()</code></em>函数封装起来。</p><ul><li>2、各个Widget组成的视图布局</li></ul><p>在<em><code>loginWidgets()</code></em>方法里实现页面Widgets的布局。而对于Widget的定义为了不让<strong>页面布局</strong>与<strong>控件定义</strong>因写在一堆，而造成代码一大坨。我们对每个Widget单独提供定义的函数，如<em><code>userNameTextField()</code></em>即为定义用户文本框的函数。</p><ul><li><p>3、抽离每个Widget的定义</p></li><li><p>4、封装单个Widget</p></li></ul><h2 id="四、业务逻辑的开发规范"><a href="#四、业务逻辑的开发规范" class="headerlink" title="四、业务逻辑的开发规范"></a>四、业务逻辑的开发规范</h2><p>说完了页面上的Widgets的开发规范，下面就轮到页面上的业务逻辑的开发规范了。</p><p>拿登录页需要获取上次登录的账号来说，它的业务是<code>getDefaultLoginAccountAction</code>，下面以混编时候的项目为例</p><h3 id="1、未去解耦业务时候的登录页"><a href="#1、未去解耦业务时候的登录页" class="headerlink" title="1、未去解耦业务时候的登录页"></a>1、未去解耦业务时候的登录页</h3><p><code>getDefaultLoginAccountAction</code>在Page中的实现一般为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// LoginPage.dart 中的业务代码</span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> callNativeMethodChannel = <span class="keyword">const</span> MethodChannel(<span class="string">'com.dvlproad.ciyouzen/callNativeLoginMethodChannel'</span>);</span><br><span class="line">  Future&lt;<span class="built_in">Null</span>&gt; _getDefaultLoginAccountAction() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Map</span> nativeResponse = <span class="keyword">await</span> callNativeMethodChannel.invokeMethod(<span class="string">'getDefaultLoginAccountAction'</span>);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Map</span> nativeResult = callNativeNativeResult(nativeResponse);</span><br><span class="line"></span><br><span class="line">      setState(() &#123;</span><br><span class="line">        userName = nativeResult[<span class="string">"userName"</span>];</span><br><span class="line">        password = nativeResult[<span class="string">"password"</span>];</span><br><span class="line">        <span class="built_in">print</span>(userName + <span class="string">":"</span> + password);</span><br><span class="line">        _usernameController.text = userName;</span><br><span class="line">        _passwordController.text = password;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; on PlatformException &#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>相应的它的调用为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// LoginPage.dart 未去解耦时候的登录页</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLoginPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyLoginPage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyLoginPageState createState() =&gt; _MyLoginPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyLoginPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyLoginPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement initState</span></span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Login Page initState"</span>);</span><br><span class="line"></span><br><span class="line">    _getDefaultLoginAccountAction();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// other things</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见上述的业务处理<code>getDefaultLoginAccountAction</code>中，掺杂了对页面Page的<code>setState</code>操作，这不适合我们以后只对业务或者只对页面做修改的处理。所以下面我们将它们解耦。</p><h3 id="2、解耦业务时候的登录页"><a href="#2、解耦业务时候的登录页" class="headerlink" title="2、解耦业务时候的登录页"></a>2、解耦业务时候的登录页</h3><p><img src="/Flutter/7规范/Flutter开发规范/Flutter的ViewModel.png" alt="Flutter的ViewModel"></p><p><code>getDefaultLoginAccountAction</code>在ChannelModel中的实现一般为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// LoginChannelModel.dart 文件</span></span></span><br><span class="line">Future&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt;&gt; getDefaultLoginAccountAction() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Map</span> nativeResponse = <span class="keyword">await</span> callNativeMethodChannel.invokeMethod(<span class="string">'getDefaultLoginAccountAction'</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Map</span> nativeResult = callNativeNativeResult(nativeResponse);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nativeResult;</span><br><span class="line">  &#125; on PlatformException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的它的调用为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// LoginPage.dart 解耦时候的登录页</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLoginPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyLoginPage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyLoginPageState createState() =&gt; _MyLoginPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyLoginPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyLoginPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement initState</span></span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Login Page initState"</span>);</span><br><span class="line"></span><br><span class="line">    getDefaultLoginAccountAction().then((nativeResult)&#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        userName = nativeResult[<span class="string">"userName"</span>];</span><br><span class="line">        password = nativeResult[<span class="string">"password"</span>];</span><br><span class="line">        <span class="built_in">print</span>(userName + <span class="string">":"</span> + password);</span><br><span class="line">        _usernameController.text = userName;</span><br><span class="line">        _passwordController.text = password;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// other things</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、Flutter-Channel的数据规范"><a href="#五、Flutter-Channel的数据规范" class="headerlink" title="五、Flutter Channel的数据规范"></a>五、Flutter Channel的数据规范</h2><p>在使用Flutter与原生项目混编的时候，因为涉及到数据传输，所以我们有必要在前期就对传输数据的进行规范统一。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第七章：规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL问题整理</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/MySQL/MySQL%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/MySQL/MySQL%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MySQL的下载安装"><a href="#一、MySQL的下载安装" class="headerlink" title="一、MySQL的下载安装"></a>一、MySQL的下载安装</h2><p>1、进入官网MySQL地址：<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a> 以下载安装包</p><p><img src="/实用工具/MySQL/MySQL问题整理/MySQL安装1.png" alt="MySQL安装1"></p><p>2、选择适合您系统的指定MySQL版本，下载安装</p><p><img src="/实用工具/MySQL/MySQL问题整理/MySQL安装2.png" alt="MySQL安装2"></p><p>3、MySQL安装成功后的截图如下：</p><p><img src="/实用工具/MySQL/MySQL问题整理/MySQL安装3.png" alt="MySQL安装成功"></p><h2 id="二、终端操作MySQL的问题"><a href="#二、终端操作MySQL的问题" class="headerlink" title="二、终端操作MySQL的问题"></a>二、终端操作MySQL的问题</h2><h3 id="1、终端-bash-mysql-command-not-found"><a href="#1、终端-bash-mysql-command-not-found" class="headerlink" title="1、终端 -bash: mysql: command not found"></a>1、终端 -bash: mysql: command not found</h3><p>遇上<code>-bash: mysql: command not found</code>的情况别着急，这个是因为/usr/local/bin目录下缺失mysql导致，只需要一下方法建立软链接，即可以解决：把mysql安装目录，映射到/usr/local/bin目录下即可，即将本要链接到/usr/bin下的改链接到/usr/local/bin下就好了。命令如下：</p><p><code>sudo ln -s /usr/local/mysql/bin/mysql /usr/local/bin</code></p><p><img src="/实用工具/MySQL/MySQL问题整理/MySQL -bash- mysql- command not found.png" alt="MySQL -bash- mysql- command not found"></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：iOS项目集成Flutter高级</title>
      <link href="/Flutter/6%E8%BF%9B%E9%98%B6/iOS%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90Flutter%E9%AB%98%E7%BA%A7/"/>
      <url>/Flutter/6%E8%BF%9B%E9%98%B6/iOS%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90Flutter%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要想知道怎么去高级的进行混编，那么久需要你首先对官网的混编方式进行分析。所以，下面我们先对官网的混编方式进行分析，然后在进行正式的高级混编。</p><h2 id="一、官网的混编方式分析"><a href="#一、官网的混编方式分析" class="headerlink" title="一、官网的混编方式分析"></a>一、官网的混编方式分析</h2><h3 id="1、Podfile"><a href="#1、Podfile" class="headerlink" title="1、Podfile"></a>1、Podfile</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Flutter项目路径</span></span><br><span class="line">flutter_application_path = <span class="string">"../../cj_nativeflutter_fluttermodule"</span></span><br><span class="line">eval(File.read(File.join(flutter_application_path, <span class="string">'.ios'</span>, <span class="string">'Flutter'</span>, <span class="string">'podhelper.rb'</span>)), binding)</span><br></pre></td></tr></table></figure><h3 id="2、podhelper-rb"><a href="#2、podhelper-rb" class="headerlink" title="2、podhelper.rb"></a>2、podhelper.rb</h3><h4 id="2-1、podhelper-rb的位置"><a href="#2-1、podhelper-rb的位置" class="headerlink" title="2.1、podhelper.rb的位置"></a>2.1、podhelper.rb的位置</h4><p><strong><em>podhelper.rb</em></strong>在flutter SDK中的路径为：<a href="/Applications/flutter/packages/flutter_tools/templates/module/ios/library/Flutter.tmpl">/Applications/flutter/packages/flutter_tools/templates/module/ios/library/Flutter.tmpl</a></p><p><img src="/Flutter/6进阶/iOS项目集成Flutter高级/iOS项目集成Flutter高级_flutter_tools.png" alt="flutter_tools"></p><p><img src="/Flutter/6进阶/iOS项目集成Flutter高级/iOS项目集成Flutter高级_podhelper1.png" alt="Flutter SDK中的podhelper.rb"></p><p>在项目中的路径为：</p><p><img src="/Flutter/6进阶/iOS项目集成Flutter高级/iOS项目集成Flutter高级1.png" alt="项目中的podhelper.rb"></p><h4 id="2-2、podhelper-rb处理的事情"><a href="#2-2、podhelper-rb处理的事情" class="headerlink" title="2.2、podhelper.rb处理的事情"></a>2.2、podhelper.rb处理的事情</h4><p><img src="/Flutter/6进阶/iOS项目集成Flutter高级/iOS项目集成Flutter高级4.png" alt="podhelper.rb的内容1"></p><h5 id="事情①：获取Flutter-podspec和FlutterPluginRegistrant-podspec，然后pod"><a href="#事情①：获取Flutter-podspec和FlutterPluginRegistrant-podspec，然后pod" class="headerlink" title="事情①：获取Flutter.podspec和FlutterPluginRegistrant.podspec，然后pod"></a>事情①：获取<em>Flutter.podspec</em>和<em>FlutterPluginRegistrant.podspec</em>，然后<code>pod</code></h5><p>获取<em>Flutter.podspec</em></p><p><img src="/Flutter/6进阶/iOS项目集成Flutter高级/iOS项目集成Flutter高级2.png" alt="image-20190310171127737"></p><p>获取<em>FlutterPluginRegistrant.podspec</em></p><p><img src="/Flutter/6进阶/iOS项目集成Flutter高级/iOS项目集成Flutter高级3.png" alt="image-20190310171011325"></p><h6 id="情况1问题：如果engine文件夹不存在，即不存在我们需要的Flutter-podspec和Flutter-framework"><a href="#情况1问题：如果engine文件夹不存在，即不存在我们需要的Flutter-podspec和Flutter-framework" class="headerlink" title="情况1问题：如果engine文件夹不存在，即不存在我们需要的Flutter.podspec和Flutter.framework"></a>情况1问题：如果engine文件夹不存在，即不存在我们需要的<code>Flutter.podspec</code>和<code>Flutter.framework</code></h6><p>如果engine文件夹不存在，即不存在我们需要的<code>Flutter.podspec</code>和<code>Flutter.framework</code>，则我们需要从flutter sdk中的如下目录拷贝<code>Flutter.podspec</code>和<code>Flutter.framework</code>，那么Flutter SDK的根目录从哪里找呢？</p><p><a href="/Applications/flutter/bin/cache/artifacts/engine/ios/">/Applications/flutter/bin/cache/artifacts/engine/ios/</a></p><p><img src="/Flutter/6进阶/iOS项目集成Flutter高级/iOS项目集成Flutter高级5.png" alt="image-20190310174505419"></p><h6 id="情况1解决：获取flutter-sdk的根目录flutter-root-dir"><a href="#情况1解决：获取flutter-sdk的根目录flutter-root-dir" class="headerlink" title="情况1解决：获取flutter sdk的根目录flutter_root_dir"></a>情况1解决：获取flutter sdk的根目录flutter_root_dir</h6><p>而这个flutter sdk目录<code>flutter_root_dir</code>的获取，我们只需要从根据flutter_application_path路径下的<code>Generated.xcconfig</code>文件中的<code>FLUTTER_ROOT</code>获取即可。</p><p><img src="/Flutter/6进阶/iOS项目集成Flutter高级/iOS项目集成Flutter高级6.png" alt="image-20190310181117074"></p><p>获取的方法为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter_root_dir = flutter_root(flutter_application_path)</span><br></pre></td></tr></table></figure><p>该flutter_root函数的方法为：</p><p><img src="/Flutter/6进阶/iOS项目集成Flutter高级/iOS项目集成Flutter高级7.png" alt="podhelper.rb的内容2"></p><p><code>Generated.xcconfig</code>数组的获取方法为：</p><p><img src="/Flutter/6进阶/iOS项目集成Flutter高级/iOS项目集成Flutter高级8.png" alt="podhelper.rb的内容3"></p><h3 id="3、xcode-backend-sh"><a href="#3、xcode-backend-sh" class="headerlink" title="3、xcode_backend.sh"></a>3、xcode_backend.sh</h3><h4 id="3-1、xcode-backend-sh的位置"><a href="#3-1、xcode-backend-sh的位置" class="headerlink" title="3.1、xcode_backend.sh的位置"></a>3.1、xcode_backend.sh的位置</h4><p><em>xcode_backend.sh</em>的目录为<a href="/Applications/flutter/packages/flutter_tools/bin">/Applications/flutter/packages/flutter_tools/bin/</a></p><p><img src="/Flutter/6进阶/iOS项目集成Flutter高级/iOS项目集成Flutter高级_sh1.png" alt="Flutter SDK中的xcode_backend.sh"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第六章：进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Script README</title>
      <link href="/Script/Script%20README/"/>
      <url>/Script/Script%20README/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://www.cnblogs.com/liangxiaofeng/p/4912022.html" target="_blank" rel="noopener">主流脚本编程语言大比拼 优缺点一目了然</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Script </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常见问题</title>
      <link href="/Script/Python/Python%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/Script/Python/Python%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Python常见问题"><a href="#Python常见问题" class="headerlink" title="Python常见问题"></a>Python常见问题</h1>]]></content>
      
      
      <categories>
          
          <category> Script </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Script </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript入门</title>
      <link href="/Script/JavaScript/JavaScript%E5%85%A5%E9%97%A8/"/>
      <url>/Script/JavaScript/JavaScript%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="eval-string"><a href="#eval-string" class="headerlink" title="eval(string)"></a>eval(string)</h4><p>eval() 函数计算某个字符串，并执行其中的的 JavaScript 代码。</p><p><a href="http://www.w3school.com.cn/jsref/jsref_eval.asp" target="_blank" rel="noopener">JavaScript eval() 函数</a></p>]]></content>
      
      
      <categories>
          
          <category> Script </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Script </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python入门</title>
      <link href="/Script/Python/Python%E5%85%A5%E9%97%A8/"/>
      <url>/Script/Python/Python%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>Python正则re模块介绍</p><table><thead><tr><th></th><th>含义</th><th>语法格式</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/python/python-reg-expressions.html" target="_blank" rel="noopener">re.compile</a></td><td>编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用</td><td>re.compile(pattern[, flags])</td></tr><tr><td><a href="http://www.runoob.com/python/python-reg-expressions.html" target="_blank" rel="noopener">re.findall</a></td><td>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。</td><td>findall(string[, pos[, endpos]])</td></tr><tr><td></td><td></td></tr></tbody></table><p>关于</p><table><thead><tr><th></th><th>含义</th><th>示例</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/python/python-func-repr.html" target="_blank" rel="noopener">repr()</a></td><td>函数将对象转化为供解释器读取的形式</td><td>repr(object)</td><td>对象</td><td>该对象的 string 格式</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">print(<span class="string">'Negative changed to zero'</span>)</span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">print(<span class="string">'Zero'</span>)</span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">1</span>:</span><br><span class="line">print(<span class="string">'Single'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">'More'</span>)</span><br></pre></td></tr></table></figure><h2 id="Python脚本增加返回值"><a href="#Python脚本增加返回值" class="headerlink" title="Python脚本增加返回值"></a>Python脚本增加返回值</h2><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/jinxin521125/article/details/78314778" target="_blank" rel="noopener">shell脚本中执行python脚本并接收其返回值的例子</a></li></ul><p>场景：打包的shell脚本中，需要加入修改文件的py脚本。在shell中要根据py脚本的处理结果进行判断。</p><h3 id="1、实例说明"><a href="#1、实例说明" class="headerlink" title="1、实例说明"></a>1、实例说明</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># py_modify_env.py</span></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">"__main__"</span>:</span><br><span class="line">    findTargetLine = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> findTargetLine:</span><br><span class="line">      print(<span class="string">'findTargetLine = '</span> + <span class="string">"True"</span>)</span><br><span class="line">      sys.exit(<span class="number">0</span>) <span class="comment"># 已找到，并修改成功</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      print(<span class="string">'findTargetLine = '</span> + <span class="string">"False"</span>)</span><br><span class="line">      sys.exit(<span class="number">1</span>) <span class="comment"># 没找到，修改失败</span></span><br></pre></td></tr></table></figure><p>sh文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sc_build.sh</span></span><br><span class="line">APPENVIRONMENT=$1           # app的打包环境</span><br><span class="line"></span><br><span class="line">echo ""</span><br><span class="line">echo ""</span><br><span class="line">echo "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; step1：begin change ProjectEnviroment to APPENVIRONMENT &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span><br><span class="line">python py_modify_env.py $&#123;APPENVIRONMENT&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 特别注意：如果这里想把命令退出状态的返回值$?，赋值给一个变量(如modifyEnvPyResult)，然后使用<span class="built_in">echo</span>打印出来，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 则因为使用了<span class="built_in">echo</span>命令，那么此时$?的值就会变成是<span class="built_in">echo</span>这个命令的退出状态，而不是python这个命令的退出状态了，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 即此时判断python脚本的退出状态就不能用$?，而得用相应的变量，如<span class="variable">$&#123;modifyEnvPyResult&#125;</span></span></span><br><span class="line">if [ $? = 0 ]   # 上个命令的退出状态，或函数的返回值。</span><br><span class="line">then</span><br><span class="line">    echo "-------- 打包环境切换到$&#123;APPENVIRONMENT&#125;成功，继续进行 --------"</span><br><span class="line">else</span><br><span class="line">    echo "-------- Failure：打包环境切换到$&#123;APPENVIRONMENT&#125;失败，不再继续 --------"</span><br><span class="line">    echo "-------- Failure：打包环境切换到$&#123;APPENVIRONMENT&#125;失败，不再继续 --------"</span><br><span class="line">    echo "-------- Failure：打包环境切换到$&#123;APPENVIRONMENT&#125;失败，不再继续 --------"</span><br><span class="line">    exit_script</span><br><span class="line">fi</span><br><span class="line">echo "&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; step1：end change ProjectEnviroment to APPENVIRONMENT &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span><br></pre></td></tr></table></figure><p>终端执行的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh sc_build.sh Develop1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Script </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Script </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ruby入门</title>
      <link href="/Script/Ruby/Ruby%E5%85%A5%E9%97%A8/"/>
      <url>/Script/Ruby/Ruby%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h1><h2 id="一、安装-升级Ruby"><a href="#一、安装-升级Ruby" class="headerlink" title="一、安装/升级Ruby"></a>一、安装/升级Ruby</h2><p>查看Ruby版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash"> ruby -v <span class="comment"># 或 ruby --version</span></span></span><br><span class="line">ruby 3.1.1p18 (2022-02-18 revision 53f5fc4236) [x86_64-darwin21]</span><br></pre></td></tr></table></figure><p>安装/升级Ruby</p><p><img src="/Script/Ruby/Ruby入门/Ruby%E5%85%A5%E9%97%A8/image-20220427000442104.png" alt="image-20220427000442104"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、打开环境变量配置文件</span></span><br><span class="line">open ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、在文件中添加一行以下配置</span></span><br><span class="line">export PATH="/usr/local/opt/ruby/bin:$PATH"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、让环境变量生效</span></span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p>先看Ruby参考里面对eval和binding的解释：</p><p>eval(expr[, binding[, fname[, lineno=1]]])</p><p>​    把字符串expr当作Ruby程序来运行并返回其结果。</p><p>binding</p><p>​    生成并返回Binding对象。该对象包含变量、方法等的环境信息，它通常用作Eval的第二参数。</p><ul><li><a href="/Applications/flutter/packages/flutter_tools/templates/module/ios/library/Flutter.tmpl/podhelper.rb">/Applications/flutter/packages/flutter_tools/templates/module/ios/library/Flutter.tmpl/podhelper.rb</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Script </category>
          
          <category> Ruby </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Script </tag>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4节：Flutter自动化测试</title>
      <link href="/Flutter/6%E8%BF%9B%E9%98%B6/Flutter%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
      <url>/Flutter/6%E8%BF%9B%E9%98%B6/Flutter%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><ul><li><a href="https://www.jianshu.com/p/6170999fb16c" target="_blank" rel="noopener">Flutter 单元测试</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第六章：进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4节：Flutter设计模式</title>
      <link href="/Flutter/6%E8%BF%9B%E9%98%B6/Flutter%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Flutter/6%E8%BF%9B%E9%98%B6/Flutter%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、单例"><a href="#一、单例" class="headerlink" title="一、单例"></a>一、单例</h2><p>参照<strong><em>SharedPreferences</em></strong>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPreferences</span> </span>&#123;</span><br><span class="line">  SharedPreferences._(<span class="keyword">this</span>._preferenceCache);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> _prefix = <span class="string">'flutter.'</span>;</span><br><span class="line">  <span class="keyword">static</span> SharedPreferences _instance;</span><br><span class="line">  <span class="keyword">static</span> Future&lt;SharedPreferences&gt; getInstance() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, <span class="built_in">Object</span>&gt; fromSystem =</span><br><span class="line">          <span class="keyword">await</span> _kChannel.invokeMethod(<span class="string">'getAll'</span>);</span><br><span class="line">      <span class="keyword">assert</span>(fromSystem != <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// Strip the flutter. prefix from the returned preferences.</span></span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; preferencesMap = &lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;&#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">String</span> key <span class="keyword">in</span> fromSystem.keys) &#123;</span><br><span class="line">        <span class="keyword">assert</span>(key.startsWith(_prefix));</span><br><span class="line">        preferencesMap[key.substring(_prefix.length)] = fromSystem[key];</span><br><span class="line">      &#125;</span><br><span class="line">      _instance = SharedPreferences._(preferencesMap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>创建一个单例的Manager类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 工厂模式</span></span><br><span class="line">  <span class="keyword">factory</span> Manager() =&gt;_getInstance();</span><br><span class="line">  <span class="keyword">static</span> Manager <span class="keyword">get</span> instance =&gt; _getInstance();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> Manager _instance;</span><br><span class="line">  Manager._internal() &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Manager _getInstance() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _instance = <span class="keyword">new</span> Manager._internal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论如何初始化，取到的都是同一个对象</span></span><br><span class="line">Manager manager = <span class="keyword">new</span> Manager();</span><br><span class="line">Manager manager2 = Manager.instance;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第六章：进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终端命令使用</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Terminal/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Terminal/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、工具-软件包安装"><a href="#一、工具-软件包安装" class="headerlink" title="一、工具/软件包安装"></a>一、工具/软件包安装</h2><p>详见《终端命令安装》章节</p><h2 id="二、用户相关操作"><a href="#二、用户相关操作" class="headerlink" title="二、用户相关操作"></a>二、用户相关操作</h2><p>使用mac的时候需要像<code>linux</code>一样对用户和群组进行操作，但是<strong>linux使用的<code>gpasswd</code>和<code>usermod</code>在mac上都不可以使用，mac使用dscl来对group和user操作</strong>。</p><p>参考文章：</p><ul><li><p><a href="https://www.cnblogs.com/zhuiluoyu/p/5455919.html" target="_blank" rel="noopener">mac下用户用户组命令行操作</a></p></li><li><p><a href="https://blog.csdn.net/handsomerocco/article/details/8511278" target="_blank" rel="noopener">Mac下如何添加User到group中</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>终端命令安装</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Terminal/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Terminal/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="How-to-install-apt-get-or-YUM-on-Mac-OS-X"><a href="#How-to-install-apt-get-or-YUM-on-Mac-OS-X" class="headerlink" title="How to install apt-get or YUM on Mac OS X"></a>How to install apt-get or YUM on Mac OS X</h3><p>参考文章：<a href="https://unix.stackexchange.com/questions/80711/how-to-install-apt-get-or-yum-on-mac-os-x" target="_blank" rel="noopener">How to install apt-get or YUM on Mac OS X</a></p><p>如果要在Mac OS X上安装apt-get或yum类似的软件，你有两种选择：</p><ol><li>Homebrew：<a href="https://vimsky.com/link.php?source=http%3A//brew.sh" target="_blank" rel="noopener">http://brew.sh</a></li><li>Macports：<a href="https://vimsky.com/link.php?source=http%3A//www.macports.org" target="_blank" rel="noopener">http://www.macports.org</a></li></ol><p>安装了上面的程序之后(一个就行)，您可以使用<code>brew install PACKAGE_NAME</code>或<code>port install PACKAGE_NAME</code>安装可用的软件包。</p><p> rpm -qa |grep yum</p><h4 id="Zentao发送邮件问题的终端检测"><a href="#Zentao发送邮件问题的终端检测" class="headerlink" title="Zentao发送邮件问题的终端检测"></a>Zentao发送邮件问题的终端检测</h4><p><img src="/实用工具/Terminal/终端命令安装/Zentao发送邮件问题的终端检测.png" alt="image-20190305171822375"></p><h4 id="bash-rpm-command-not-found"><a href="#bash-rpm-command-not-found" class="headerlink" title="-bash: rpm: command not found"></a>-bash: rpm: command not found</h4><p>brew install rpm</p><h4 id="bash-yum-command-not-found"><a href="#bash-yum-command-not-found" class="headerlink" title="-bash: yum: command not found"></a>-bash: yum: command not found</h4><p><em>Mac OS X是基于Unix的，它可以使用非常多Linux平台上开源的优秀工具，比如wget，比如dos2unix脚本工具等。<br> 但是OS X系统本身却缺少Linux下得包管理器。比如Fedora的yum与dnf，比如Ubuntu的apt-get，比如ArchLinux的Pacman等。是这些优秀的开源软件在Mac上的安装只能通过下载源码，编译，安装，配置环境变量的步骤来完成安装。对于大部分的软件，在安装过程中是需要很多的依赖库的，手动去解决这些依赖库是十分痛苦的事情。包管理器干的就是这样的事情：解决软件安装过程中的依赖关系。<br> 有一个开源的项目叫Homebrew，完美解决了Mac OS X上没有包管理器的尴尬。</em><a href="https://www.jianshu.com/p/f40eca496592" target="_blank" rel="noopener">参考文档：为什么要使用Homebrew</a></p><p>Mac下自己试的是无法安装yum，相应的yum install，改为了brew install。</p><p><img src="/实用工具/Terminal/终端命令安装/telnet的安装.png" alt="image-20190305171015368"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Zentao问题整理</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Zentao/Zentao%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Zentao/Zentao%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、Zentao的安装"><a href="#一、Zentao的安装" class="headerlink" title="一、Zentao的安装"></a>一、Zentao的安装</h2><p>请到<a href="https://www.zentao.net下载开源版" target="_blank" rel="noopener">https://www.zentao.net下载开源版</a></p><p>如：<img src="/实用工具/Zentao/Zentao问题整理/Zentao安装1.png" alt="image-20190305105851487"></p><p>在浏览器中访问项目地址：<a href="http://localhost/zentaopms/www/index.php，进入系统安装程序，点击开始安装。" target="_blank" rel="noopener">http://localhost/zentaopms/www/index.php，进入系统安装程序，点击开始安装。</a></p><h2 id="二、Zentao访问问题"><a href="#二、Zentao访问问题" class="headerlink" title="二、Zentao访问问题"></a>二、Zentao访问问题</h2><h3 id="1、访问问题"><a href="#1、访问问题" class="headerlink" title="1、访问问题"></a>1、访问问题</h3><p>请确保你的服务器是打开的，比如你使用的是XAMPP</p><p><img src="/实用工具/Zentao/Zentao问题整理/Zentao的XAMPP.png" alt="Zentao的XAMPP"></p><h3 id="2、Zentao访问问题：Unknown-database-‘zentao’"><a href="#2、Zentao访问问题：Unknown-database-‘zentao’" class="headerlink" title="2、Zentao访问问题：Unknown database ‘zentao’"></a>2、Zentao访问问题：Unknown database ‘zentao’</h3><p>问题描述如下截图：</p><p><img src="/实用工具/Zentao/Zentao问题整理/Zentao访问问题1.png" alt="image-20190305102934706"></p><p>原因是：<a href="http://localhost/phpmyadmin/下原本的zentao数据库缺失了，即原本的应该是有如下的zentao数据库的。" target="_blank" rel="noopener">http://localhost/phpmyadmin/下原本的zentao数据库缺失了，即原本的应该是有如下的zentao数据库的。</a></p><p><img src="/实用工具/Zentao/Zentao问题整理/Zentao访问问题2.png" alt="image-20190305102829575"></p><p>或者你也可以看到<code>xamppfiles\var\mysql</code>下缺少了zentao数据库文件夹了，有的时候是如下样子的：</p><p><img src="/实用工具/Zentao/Zentao问题整理/Zentao访问问题3.png" alt="image-20190305104603201"></p><p>解决办法：赋值一份原本的到<code>xamppfiles\var\mysql</code>下，或者你重新安装禅道吧。</p><h2 id="三、如何配置email发信"><a href="#三、如何配置email发信" class="headerlink" title="三、如何配置email发信"></a>三、如何配置email发信</h2><p>请参考官网操作：<a href="https://www.zentao.net/book/zentaopmshelp/96/p2.html" target="_blank" rel="noopener">官网：如何配置email发信</a></p><p>附：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的网易授权码是`Auth0987`、</span><br><span class="line">QQ邮箱授权码`**nazr****mrbz****naox****bbhg**`即nazr mrbz naox bbhg</span><br></pre></td></tr></table></figure><p><img src="/实用工具/Zentao/Zentao问题整理/Zentao自动发送邮件1.png" alt="image-20190305173747142"></p><p>为看起来更好，你可以更改发信人</p><p><img src="/实用工具/Zentao/Zentao问题整理/Zentao自动发送邮件2.png" alt="image-20190305174930068"></p><h2 id="四、备份禅道"><a href="#四、备份禅道" class="headerlink" title="四、备份禅道"></a>四、备份禅道</h2><p>备份禅道：<a href="https://www.zentao.net/book/zentaopmshelp/42.html" target="_blank" rel="noopener">https://www.zentao.net/book/zentaopmshelp/42.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Zentao </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XAMPP问题整理</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/XAMPP/XAMPP%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/XAMPP/XAMPP%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、XAMPP-下载地址"><a href="#一、XAMPP-下载地址" class="headerlink" title="一、XAMPP 下载地址"></a>一、XAMPP 下载地址</h2><p>点击进入：<a href="https://www.apachefriends.org/zh_cn/download.html" target="_blank" rel="noopener">XAMPP 下载地址</a></p><p><img src="/实用工具/XAMPP/XAMPP问题整理/XAMPP 下载地址1.png" alt="XAMPP 下载地址1"></p><p>进入后的页面如下</p><p><img src="/实用工具/XAMPP/XAMPP问题整理/XAMPP安装后界面不一样.png" alt="image-20190304181710320"></p><p><strong>注意：这里要下载-installer.dmg的安装，不要下载-vm.dmg的安装。</strong></p><p>否则，会造成<em>XAMPP安装后界面不一样</em>。</p><h2 id="二、问题整理"><a href="#二、问题整理" class="headerlink" title="二、问题整理"></a>二、问题整理</h2><h3 id="问题一、mac-XAMPP-mysql无法启动的问题"><a href="#问题一、mac-XAMPP-mysql无法启动的问题" class="headerlink" title="问题一、mac XAMPP mysql无法启动的问题"></a>问题一、mac XAMPP mysql无法启动的问题</h3><h5 id="可能原因一：-Applications-XAMPP-xamppfiles-xampp文件问题。"><a href="#可能原因一：-Applications-XAMPP-xamppfiles-xampp文件问题。" class="headerlink" title="可能原因一：/Applications/XAMPP/xamppfiles/xampp文件问题。"></a>可能原因一：/Applications/XAMPP/xamppfiles/xampp文件问题。</h5><p>解决方法：<br>1、打开/Applications/XAMPP/xamppfiles/xampp进行编辑<br>2、找到这一行：$XAMPP_ROOT/bin/mysql.server start &gt; /dev/null &amp;<br>3、添加如下一行在找到的那一行上面：unset DYLD_LIBRARY_PATH<br>然后启动mysql，如果无效果跳到解决方法二</p><h5 id="可能原因二：mysql进程已经存在"><a href="#可能原因二：mysql进程已经存在" class="headerlink" title="可能原因二：mysql进程已经存在"></a>可能原因二：mysql进程已经存在</h5><p>解决方法：杀死与mysql有关的进程后，重新尝试启动mysql</p><p>方法一：打开终端，输入<code>ps aux | grep mysql</code>，拿到进程号pid(如这里是pid=120)后，执行杀死进程的命令<code>kill -9 进程号</code>即如 kill -9 120即可重新启动mysql。</p><p><img src="/实用工具/XAMPP/XAMPP问题整理/XAMPP mysql无法启动1.png" alt="image-20190304220653289">方法二：打开活动监视器，搜索mysql，关闭对应进程即可。<br><img src="/实用工具/XAMPP/XAMPP问题整理/XAMPP mysql无法启动2.png" alt="image-20190304183828300"></p><h4 id="mysql进程关不掉"><a href="#mysql进程关不掉" class="headerlink" title="mysql进程关不掉"></a>mysql进程关不掉</h4><p>有时候如果你发现活动监视器关掉mysql后，又自己生成了，而造成你的mysql一直关不掉，那么请检查是不是你开着如下的mysql。那么我们关掉后即可。</p><p><img src="/实用工具/XAMPP/XAMPP问题整理/XAMPP mysql无法启动3.png" alt="image-20190304223329375"></p><p><img src="/实用工具/XAMPP/XAMPP问题整理/XAMPP mysql无法启动4.png" alt="image-20190304223959685"></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> XAMPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Nginx/Nginx/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Nginx/Nginx/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Mac环境：Nginx入门"><a href="#Mac环境：Nginx入门" class="headerlink" title="Mac环境：Nginx入门"></a>Mac环境：Nginx入门</h1><p>参考文章：<a href="https://www.jianshu.com/p/a633d8fbe113" target="_blank" rel="noopener">https://www.jianshu.com/p/a633d8fbe113</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> XAMPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无瑕疵的混编登录页</title>
      <link href="/Flutter/%E6%97%A0%E7%91%95%E7%96%B5%E7%9A%84%E6%B7%B7%E7%BC%96%E7%99%BB%E5%BD%95%E9%A1%B5/"/>
      <url>/Flutter/%E6%97%A0%E7%91%95%E7%96%B5%E7%9A%84%E6%B7%B7%E7%BC%96%E7%99%BB%E5%BD%95%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p>最终实现的效果及需要实现的内容，如下图所示：</p><p><img src="/Flutter/无瑕疵的混编登录页/用户名登录的UI图.png" alt="用户名登录的UI图"></p><p>用户名登录的流程图如下：</p><p><img src="/Flutter/无瑕疵的混编登录页/用户名登录的流程图.png" alt="用户名登录的流程图"></p><p>相应的代码实现如下：</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 无瑕疵的混编登录页 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结</title>
      <link href="/Flutter/Flutter%E6%80%BB%E7%BB%93/"/>
      <url>/Flutter/Flutter%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.cndartlang.com/" target="_blank" rel="noopener">Dart语言中文社区官网</a></p><p><a href="http://www.cndartlang.com/708.html" target="_blank" rel="noopener">Dart学习笔记（31）：Future和异常处理</a></p><p><a href="https://www.jianshu.com/p/d538ef5ff6a3" target="_blank" rel="noopener">自定义Flutter控件</a></p><p><a href="https://www.jianshu.com/p/a8710368c1e1" target="_blank" rel="noopener">利用ScrollView实现TableView效果（实现复用）</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第4节：Dart语言必备基础知识</title>
      <link href="/Flutter/1%E5%85%A5%E9%97%A8/Dart%E8%AF%AD%E8%A8%80%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/Flutter/1%E5%85%A5%E9%97%A8/Dart%E8%AF%AD%E8%A8%80%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你只是写界面可能你看Flutter的Widget就够了。</p><p>可是当你写业务的时候，你不去了解Dart语言那么你讲寸步难行。</p><p>本文致力于以最小的篇幅介绍Flutter的敲门砖：Dart最必备的基础知识。</p><ul><li><p>在Dart中，一切都是对象，一切对象都是class的实例，哪怕是数字类型、方法甚至null都是对象，所有的对象都是继承自Object</p></li><li><p>跟Java不同的是，Dart没有public protected private等关键字，如果某个变量以下划线（_）开头，代表这个变量在库中是私有的</p></li></ul><h2 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h2><h3 id="1、变量定义"><a href="#1、变量定义" class="headerlink" title="1、变量定义"></a>1、变量定义</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">String</span> s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">dynamic</span> c = <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure><p>可以明确指定某个变量的类型，如int bool String，也可以用var或 dynamic来声明一个变量，Dart会自动推断其数据类型。</p><p>dynamic 则是告诉编译器，我们知道自己在做什么，<strong>不用做类型检测</strong> 。</p><h3 id="2、变量类型检测"><a href="#2、变量类型检测" class="headerlink" title="2、变量类型检测"></a>2、变量类型检测</h3><p>为了在运行时检测进行类型检测，Dart 提供了一个关键字 is：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="built_in">Map</span>) &#123;</span><br><span class="line">  <span class="comment">// 进过类型判断后，Dart 知道 obj 是一个 Map，所以这里再不用强制转换 obj 的类型为Map。</span></span><br><span class="line">  obj[<span class="string">'foo'</span>] = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然 Dart 也提供了 as 让我们进行类型的强制转换，但为了进来更安全的转换，更推荐使用 is</span></span><br><span class="line"><span class="keyword">var</span> map = obj <span class="keyword">as</span> <span class="built_in">Map</span>;</span><br></pre></td></tr></table></figure><h3 id="3、类型互转"><a href="#3、类型互转" class="headerlink" title="3、类型互转"></a>3、类型互转</h3><h4 id="3-1-String与int互转"><a href="#3-1-String与int互转" class="headerlink" title="3.1 String与int互转"></a>3.1 String与int互转</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>.parse(<span class="string">"100"</span>);</span><br><span class="line"><span class="number">123.</span>toString();</span><br></pre></td></tr></table></figure><h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><h3 id="1、函数的写法"><a href="#1、函数的写法" class="headerlink" title="1、函数的写法"></a>1、函数的写法</h3><p>以下三种函数的写法，都是正确的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法1：声明返回值(推荐)</span></span><br><span class="line"><span class="built_in">int</span> add(<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2：不声明返回值（不加返回值的函数同样可以正常工作）</span></span><br><span class="line">add2(<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法3：你还可以用`=&gt;`代替return语句（=&gt;是return语句的简写）</span></span><br><span class="line"><span class="comment">// 此写法只能执行单行</span></span><br><span class="line">add3(a, b) =&gt; a + b; </span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">print</span>(add2(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 5</span></span><br><span class="line">  <span class="built_in">print</span>(add3(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的函数都有返回值，如果没有指定return语句，那么该函数的返回值为null。</p><h4 id="1-1、类方法-实例方法"><a href="#1-1、类方法-实例方法" class="headerlink" title="1.1、类方法/实例方法"></a>1.1、类方法/实例方法</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line"><span class="built_in">int</span> method1(<span class="built_in">int</span> x);<span class="comment">// 实例方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> method2(<span class="built_in">int</span> y); <span class="comment">// 类方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">a = A().method1(<span class="number">1</span>);</span><br><span class="line">b = A.method2(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="2、函数的参数-可选-默认值-必选"><a href="#2、函数的参数-可选-默认值-必选" class="headerlink" title="2、函数的参数(可选/默认值/必选)"></a>2、函数的参数(可选/默认值/必选)</h3><h4 id="2-1、基本的函数参数写法"><a href="#2-1、基本的函数参数写法" class="headerlink" title="2.1、基本的函数参数写法"></a>2.1、基本的函数参数写法</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(defalut_foo1(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 结果为3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种常见的写法，参数默认都是必填的，而且没法给默认值</span></span><br><span class="line"><span class="built_in">int</span> defalut_foo1(<span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2、标记参数为可选-默认值"><a href="#2-2、标记参数为可选-默认值" class="headerlink" title="2.2、标记参数为可选/默认值"></a>2.2、标记参数为可选/默认值</h4><p>知识点：</p><p>①要设置参数的默认值，只有该参数为可选的时候，才能够设置。</p><p>②参数可选的方法有两种，常规的参数加上[]，或者使用具名参数</p><p>1、常规的参数加上[]，标记为可选</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(option_foo1(<span class="number">1</span>)); <span class="comment">// 结果为1,x</span></span><br><span class="line">  <span class="built_in">print</span>(option_foo1(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 结果为11， x+10y，而不会是x+100z</span></span><br><span class="line">  <span class="built_in">print</span>(option_foo1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 结果为111,x+10y+100z</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选参数</span></span><br><span class="line"><span class="comment">// 使用可选参数的函数写法1：含可选参数的函数</span></span><br><span class="line"><span class="built_in">int</span> option_foo1(<span class="built_in">int</span> x, [<span class="built_in">int</span> y, <span class="built_in">int</span> z]) &#123;</span><br><span class="line">  <span class="built_in">int</span> iResult = x;</span><br><span class="line">  <span class="keyword">if</span> (y != <span class="keyword">null</span>) &#123; <span class="comment">// 是的，int 也可以是 null</span></span><br><span class="line">    iResult += <span class="number">10</span>*y;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (z != <span class="keyword">null</span>) &#123; <span class="comment">// 是的，int 也可以是 null</span></span><br><span class="line">    iResult += <span class="number">100</span>*z;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> iResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可选参数的函数写法2：可选参数支持有默认值</span></span><br><span class="line"><span class="built_in">int</span> option_foo2(<span class="built_in">int</span> x, [<span class="built_in">int</span> y = <span class="number">0</span>]) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用具名参数（named parameters），使得参数为可选</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具名参数（named parameters）的用法，调用时候具名参数的顺序可以是任意的</span></span><br><span class="line"><span class="comment">// 使用具名参数的函数参数写法1：</span></span><br><span class="line"><span class="built_in">int</span> named_foo1(&#123;<span class="built_in">int</span> x, <span class="built_in">int</span> y&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用具名参数的函数参数写法2：所有的具名参数本身就都是可选的，而且具名参数也可以有默认参数</span></span><br><span class="line"><span class="built_in">int</span> named_foo2(&#123;<span class="built_in">int</span> x = <span class="number">0</span>, <span class="built_in">int</span> y = <span class="number">0</span>&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 具名参数的顺序可以是任意的</span></span><br><span class="line">  <span class="built_in">print</span>(named_foo1(x: <span class="number">1</span>, y: <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">print</span>(named_foo1(y: <span class="number">3</span>, x: <span class="number">4</span>));</span><br><span class="line">  <span class="built_in">print</span>(named_foo1()); <span class="comment">//错误：会导致 foo() 在运行时抛异常</span></span><br><span class="line">  <span class="built_in">print</span>(named_foo2(x: <span class="number">1</span>, y: <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">print</span>(named_foo2()); <span class="comment">// 正确：不会导致 foo() 在运行时抛异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3、如果想告诉用户某个参数是必须的"><a href="#2-3、如果想告诉用户某个参数是必须的" class="headerlink" title="2.3、如果想告诉用户某个参数是必须的"></a>2.3、如果想告诉用户某个参数是必须的</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须参数(如果想告诉用户某个具名参数是必须的，可以使用注解 @require)</span></span><br><span class="line"><span class="comment">// 不是具名参数，默认就是 @required 必填。</span></span><br><span class="line"><span class="built_in">int</span> require_foo1(<span class="meta">@required</span> <span class="built_in">int</span> x, <span class="meta">@required</span> <span class="built_in">int</span> y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是具名参数，默认就是 非必填，非 @required</span></span><br><span class="line"><span class="built_in">int</span> require_foo2(&#123;<span class="meta">@required</span> <span class="built_in">int</span> x, <span class="meta">@required</span> <span class="built_in">int</span> y&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(require_foo1(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 结果为3</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(require_foo2(x:<span class="number">1</span>, y:<span class="number">2</span>)); <span class="comment">// 结果为3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、回调-函数做参数-返回值"><a href="#3、回调-函数做参数-返回值" class="headerlink" title="3、回调/函数做参数/返回值"></a>3、回调/函数做参数/返回值</h3><h4 id="3-1、回调"><a href="#3-1、回调" class="headerlink" title="3.1、回调"></a>3.1、回调</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用typedef用于定义函数类型的别名</span></span><br><span class="line"><span class="keyword">typedef</span> ClickCallBack = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">int</span> x, <span class="built_in">int</span> y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例：将a和b两个数，经过指定的操作返回</span></span><br><span class="line"><span class="built_in">String</span> onButtonPress1(<span class="built_in">int</span> a, <span class="built_in">int</span> b, ClickCallBack callback) &#123;</span><br><span class="line">  <span class="built_in">int</span> iResult = callback(a, b);</span><br><span class="line">  <span class="keyword">return</span> iResult.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> string = onButtonPress1(<span class="number">1</span>,  <span class="number">2</span>, (x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"string = "</span> + string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2、函数参数"><a href="#3-2、函数参数" class="headerlink" title="3.2、函数参数"></a>3.2、函数参数</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用typedef用于定义函数类型的别名</span></span><br><span class="line"><span class="keyword">typedef</span> Adder = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">int</span>, <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> <span class="built_in">Function</span>(<span class="built_in">String</span> msg) cancelHandle;<span class="comment">// 实际场景中的应用</span></span><br><span class="line"></span><br><span class="line">Adder makeAdder1(<span class="built_in">int</span> extra) &#123;</span><br><span class="line">  <span class="built_in">int</span> adder(<span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + extra;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> adder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dart 里面不仅变量支持类型推断，lambda 的参数也支持自动推断。上面的代码还可以进一步简化为：</span></span><br><span class="line">Adder makeAdder2(<span class="built_in">int</span> extra) &#123;</span><br><span class="line">  <span class="comment">// 我们要返回的类型是 Adder，所以 Dart 知道 x, y 都是 int</span></span><br><span class="line">  <span class="keyword">return</span> (x, y) =&gt; x + y + extra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> adder1 = makeAdder1(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder1(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">var</span> adder2 = makeAdder2(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder2(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、函数类型"><a href="#4、函数类型" class="headerlink" title="4、函数类型"></a>4、函数类型</h3><p>Dart是一个面向对象的编程语言，所以即使是函数也是一个对象，也有一种类型Function，这就意味着函数可以赋值给某个变量或者作为参数传给另外的函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">printNum(<span class="built_in">int</span> a) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$a<span class="string">");</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">test(Function callback) &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  callback("</span></span>hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = printNum;</span><br><span class="line">  <span class="built_in">Function</span> f2 = printNum;</span><br><span class="line">  <span class="keyword">var</span> f3 = (<span class="built_in">int</span> a) =&gt; <span class="built_in">print</span>(<span class="string">"a = <span class="subst">$a<span class="string">");</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  f1(1);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  f2(2);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  f3(6);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure><h2 id="三、类"><a href="#三、类" class="headerlink" title="三、类"></a>三、类</h2><h3 id="1、类的定义"><a href="#1、类的定义" class="headerlink" title="1、类的定义"></a>1、类的定义</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 成员变量写法1：</span></span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line">  <span class="built_in">String</span> gender;</span><br><span class="line">  <span class="comment">// 成员变量写法2：使用getter/setter声明的成员变量</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> uid =&gt; <span class="string">"24210853532539238"</span>;</span><br><span class="line">  <span class="keyword">set</span> right(<span class="built_in">String</span> uid) =&gt; left = value - width;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过创建一个与其类同名的函数来声明构造函数。如果您未声明构造函数，则会为您提供默认构造函数。默认构造函数没有参数，并在超类中调用无参数构造函数。</span></span><br><span class="line">  <span class="comment">// 构造方法写法1:跟类名相同的构造方法</span></span><br><span class="line">  User(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.gender);</span><br><span class="line">  <span class="comment">// 构造方法写法2:命名的构造方法</span></span><br><span class="line">  User.defaultUser() &#123;</span><br><span class="line">    name = <span class="string">"dvlp"</span>;</span><br><span class="line">    age = <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 成员方法写法1:有方法体(是非抽象方法)</span></span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello, this is <span class="subst">$name</span>, I am <span class="subst">$age</span> years old, I am a <span class="subst">$gender<span class="string">");</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  // 成员方法写法2:没有方法体(是抽象方法，需要子类去实现)</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  void doSomething();</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">// 抽象类（无法实例化的类）,如果希望抽象类看起来是可实例化的，请定义工厂构造函数。</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">// 抽象类通常有抽象方法，如下：</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">// 此类声明为abstract，因此是抽象类，即也就无法实例化</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">abstract class Test &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  //定义构造函数，字段，方法...</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    </span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  // 抽象方法</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  void test();</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure><p>说明类中的构造方法<code>Person(this.name, this.age, this.gender);</code>的这种语法是Dart比较独特而简洁的构造方法声明方式，它等同于下面的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User(<span class="built_in">String</span> name, <span class="built_in">int</span> age, <span class="built_in">String</span> gender) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他声明成员变量的方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用getter/setter声明的成员变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left, top, width, height;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造方法传入left, top, width, height几个参数</span></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// right, bottom两个成员变量提供getter/setter方法</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right =&gt; left + width;</span><br><span class="line">  <span class="keyword">set</span> right(<span class="built_in">num</span> value) =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom =&gt; top + height;</span><br><span class="line">  <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、类的使用"><a href="#2、类的使用" class="headerlink" title="2、类的使用"></a>2、类的使用</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> user1 = <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>, <span class="number">20</span>, <span class="string">"male"</span>);</span><br><span class="line">  user.age = <span class="number">30</span>;</span><br><span class="line">  user.gender = <span class="string">"female"</span>;</span><br><span class="line">  user.sayHello();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">var</span> user2 = <span class="keyword">new</span> Person.defaultUser()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用一个不存在的方法时，会执行 noSuchMethod() 方法，默认情况下它会抛出 NoSuchMethodError。你也可以重写<code>noSuchMethod()</code>，改成你输出你希望的错误提示</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 除非你重写noSuchMethod，否则使用不存在的成员会导致NoSuchMethodError</span></span><br><span class="line">  <span class="comment">// Unless you override noSuchMethod, using a</span></span><br><span class="line">  <span class="comment">// non-existent member results in a NoSuchMethodError.</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> noSuchMethod(Invocation invocation) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'You tried to use a non-existent member: '</span> +</span><br><span class="line">        <span class="string">'<span class="subst">$&#123;invocation.memberName&#125;</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、类的继承"><a href="#3、类的继承" class="headerlink" title="3、类的继承"></a>3、类的继承</h3><p>Dart中使用extends关键字做类的继承。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Developer</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实现了父类的抽象方法</span></span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I'm developing..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 Dart 是单继承的，但它也提供了一定程度的多重继承支持：</p><p>使用<code>@override</code>注解声明你要重写的函数，在这个函数内部可以使用super调用重写的这个父类的函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterDeveloper</span> <span class="keyword">extends</span> <span class="title">Developer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span><span class="comment">// 表示doSomething是重写父类的方法</span></span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="keyword">super</span>.doSomething();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I'm developing Flutter..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iOSDeveloper</span> <span class="keyword">extends</span> <span class="title">Developer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span> <span class="comment">// 表示doSomething是重写父类的方法</span></span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="keyword">super</span>.doSomething();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I'm developing iOS..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FullStackDeveloper</span> <span class="keyword">extends</span> <span class="title">Developer</span> <span class="title">with</span> <span class="title">iOSDeveloper</span> <span class="title">with</span> <span class="title">FlutterDeveloper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span><span class="comment">// 表示doSomething是重写父类的方法</span></span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="keyword">super</span>.doSomething();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I'm developing..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h2><p>mixins是一个重复使用类中代码的方式，比如下面的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  a() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"A's a()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  b() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"B's b()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with关键字，表示类C是由类A和类B混合而构成</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> = <span class="title">A</span> <span class="title">with</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">main</span>() </span>&#123;</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  c.a(); <span class="comment">// A's a()</span></span><br><span class="line">  c.b(); <span class="comment">// B's b()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、库"><a href="#四、库" class="headerlink" title="四、库"></a>四、库</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用import语句来导入某个包</span></span><br><span class="line"><span class="comment">// 如果你想导入自己写的某个代码文件，使用相对路径即可</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./util.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以使用as关键字为导入的某个包设置一个前缀，或者说别名</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入包时使用deferred as可以让这个包懒加载，懒加载的包只会在该包被使用时得到加载，而不是一开始就加载，比如</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:greetings/hello.dart'</span> deferred <span class="keyword">as</span> hello;</span><br></pre></td></tr></table></figure><h3 id="1、问题一：在同一工程中可否有两个同名的类"><a href="#1、问题一：在同一工程中可否有两个同名的类" class="headerlink" title="1、问题一：在同一工程中可否有两个同名的类"></a>1、问题一：在同一工程中可否有两个同名的类</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uses Element from lib1.</span></span><br><span class="line"><span class="built_in">Element</span> element1 = <span class="built_in">Element</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uses Element from lib2.</span></span><br><span class="line">lib2.<span class="built_in">Element</span> element2 = lib2.<span class="built_in">Element</span>();</span><br></pre></td></tr></table></figure><h3 id="2、问题二、如何只允许-只不允许使用某个包中的部分功能"><a href="#2、问题二、如何只允许-只不允许使用某个包中的部分功能" class="headerlink" title="2、问题二、如何只允许/只不允许使用某个包中的部分功能"></a>2、问题二、如何只允许/只不允许使用某个包中的部分功能</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只导入lib1中的foo功能</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span> show foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入lib2中的除了foo外的所有其他部分</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> hide foo;</span><br></pre></td></tr></table></figure><h2 id="五、运算符"><a href="#五、运算符" class="headerlink" title="五、运算符"></a>五、运算符</h2><h3 id="1、常见的"><a href="#1、常见的" class="headerlink" title="1、常见的"></a>1、常见的</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td><code>++var</code></td><td><code>var=var+1</code>表达式的值为<code>var+1</code></td></tr><tr><td><code>var++</code></td><td><code>var=var+1</code>表达式的值为<code>var</code></td></tr><tr><td><code>--var</code></td><td><code>var=var-1</code>表达式的值为<code>var-1</code></td></tr><tr><td><code>var--</code></td><td><code>var=var-1</code>表达式的值为<code>var</code></td></tr></tbody></table><p>++a</p><p>a == b</p><p>b ? a : b</p><h3 id="2、特殊的"><a href="#2、特殊的" class="headerlink" title="2、特殊的"></a>2、特殊的</h3><h4 id="2-1、-运算符（级联操作）"><a href="#2-1、-运算符（级联操作）" class="headerlink" title="2.1、..运算符（级联操作）"></a>2.1、..运算符（级联操作）</h4><p>使用..调用某个对象的方法（或者成员变量）时，返回值是这个对象本身，所以你可以接着使用..调用这个对象的其他方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I am eating..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sleep() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I am sleeping..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  study() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I am studying..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">// 依次打印</span></span><br><span class="line">  <span class="comment">//  I am eating...</span></span><br><span class="line">  <span class="comment">//  I am sleeping...</span></span><br><span class="line">  <span class="comment">//  I am studying...</span></span><br><span class="line">  <span class="keyword">new</span> Person()..eat()</span><br><span class="line">      ..sleep()</span><br><span class="line">      ..study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、控制流程"><a href="#六、控制流程" class="headerlink" title="六、控制流程"></a>六、控制流程</h2><table><thead><tr><th>语句</th><th>说明</th></tr></thead><tbody><tr><td>if / else</td><td>略</td></tr><tr><td>switch</td><td>略(switch 也支持 String 和 enum)</td></tr><tr><td>for /while</td><td>略</td></tr><tr><td>try / catch</td><td>略</td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch语句</span></span><br><span class="line">  <span class="built_in">String</span> a = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="comment">// case语句中的数据类型必须是跟switch中的类型一致</span></span><br><span class="line">  <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"haha"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"heihei"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"WTF"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="七、异步"><a href="#七、异步" class="headerlink" title="七、异步"></a>七、异步</h2><p>如果一个方法中有耗时的操作，你需要将这个方法设置成async，并给其中的耗时操作加上await关键字，如果这个方法有返回值，你需要将返回值塞到Future中并返回，如下代码所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="keyword">return</span> version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、其他-奇技淫巧"><a href="#八、其他-奇技淫巧" class="headerlink" title="八、其他/奇技淫巧"></a>八、其他/奇技淫巧</h2><h3 id="1、静态成员变量和静态成员方法"><a href="#1、静态成员变量和静态成员方法" class="headerlink" title="1、静态成员变量和静态成员方法"></a>1、静态成员变量和静态成员方法</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的静态成员变量和静态成员方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cons</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> name = <span class="string">"zhangsan"</span>;</span><br><span class="line">  <span class="keyword">static</span> sayHello() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello, this is <span class="subst">$&#123;Cons.name&#125;</span>"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  Cons.sayHello(); <span class="comment">// hello, this is zhangsan</span></span><br><span class="line">  <span class="built_in">print</span>(Cons.name); <span class="comment">// zhangsan</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、修饰符final和const"><a href="#2、修饰符final和const" class="headerlink" title="2、修饰符final和const"></a>2、修饰符final和const</h3><p>final 跟 Java 里的 final 一样，表示一个运行时常量（在程序运行的时候赋值，赋值后值不再改变）。const 表示一个编译时常量，在程序编译的时候它的值就确定了。</p><table><thead><tr><th>修饰符</th><th>作用</th></tr></thead><tbody><tr><td>final</td><td>一个被final修饰的变量只能被赋值一次，</td></tr><tr><td>const</td><td>一个被const修饰的变量是一个编译时常量（const常量毫无疑问也是final常量）</td></tr></tbody></table><p> final和const的区别：</p><p>区别一：final 要求变量只能初始化一次，并不要求赋的值一定是编译时常量，可以是常量也可以不是。而 const 要求在声明时初始化，并且赋值必需为编译时常量。</p><p>区别二：final 是惰性初始化，即在运行时第一次使用前才初始化。而 const 是在编译时就确定值了。</p><h3 id="3、泛型"><a href="#3、泛型" class="headerlink" title="3、泛型"></a>3、泛型</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br></pre></td></tr></table></figure><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>其他参考文档：</p><ul><li><a href="http://www.cndartlang.com/" target="_blank" rel="noopener">Dart语言中文社区官网</a></li><li><a href="http://www.cndartlang.com/708.html" target="_blank" rel="noopener">Dart学习笔记（31）：Future和异常处理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第一章：Flutter入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3节：Package的使用、开发与发布</title>
      <link href="/Flutter/6%E8%BF%9B%E9%98%B6/Package%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E5%BC%80%E5%8F%91%E4%B8%8E%E5%8F%91%E5%B8%83/"/>
      <url>/Flutter/6%E8%BF%9B%E9%98%B6/Package%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E5%BC%80%E5%8F%91%E4%B8%8E%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、常用的第三方Package"><a href="#一、常用的第三方Package" class="headerlink" title="一、常用的第三方Package"></a>一、常用的第三方Package</h2><p>参考文章：</p><ul><li><a href="https://www.jianshu.com/p/559d0b4edce5" target="_blank" rel="noopener">Flutter 常用的第三方模块</a></li></ul><h2 id="二、第三方库的导入"><a href="#二、第三方库的导入" class="headerlink" title="二、第三方库的导入"></a>二、第三方库的导入</h2><ul><li>1、添加依赖：在<code>pubspec.yaml</code>文件中找到<code>dependencies</code>在里面添加要导入的第三方库。</li></ul><p><img src="/Flutter/6进阶/Package的使用、开发与发布/Package使用1.png" alt="Package使用1.png"></p><p>注意①：导入的位置要与dependencies下面的flutter上下对齐，不然会不通过。</p><p>注意②：一般写在dependencies下面即可，dependencies 与dev_dependencies 分别是代表用户发布环境与本地环境开发。</p><ul><li><p>2、安装依赖：在 terminal中: 运行 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter packages get</span><br><span class="line">或者</span><br><span class="line">flutter packages upgrade</span><br></pre></td></tr></table></figure><p>或者在IntelliJ等开发工具中点击<code>pubspec.yaml</code>文件顶部的<code>Packages Get</code>即可安装。</p></li><li><p>3、使用依赖：在您的Dart代码中添加相应的<code>import</code>语句。</p></li></ul><p><img src="/Flutter/6进阶/Package的使用、开发与发布/分割图1.jpg" alt="分割图1"></p><h2 id="三、如何依赖未发布的packages"><a href="#三、如何依赖未发布的packages" class="headerlink" title="三、如何依赖未发布的packages"></a>三、如何依赖未发布的packages</h2><p>即使未在Pub上发布，软件包也可以使用。对于不用于公开发布的专用插件，或者尚未准备好发布的软件包，可以使用其他依赖项选项。</p><ul><li><p><strong>路径</strong> 依赖: 一个Flutter应用可以依赖一个插件通过文件系统的<code>path:</code>依赖。路径可以是相对的，也可以是绝对的。例如，要依赖位于应用相邻目录中的插件’plugin1’，请使用以下语法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  plugin1:</span><br><span class="line">    path: ../plugin1/</span><br></pre></td></tr></table></figure></li><li><p><strong>Git</strong> 依赖: 你也可以依赖存储在Git仓库中的包。如果软件包位于仓库的根目录中，请使用以下语法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  plugin1:</span><br><span class="line">    git:</span><br><span class="line">      url: git:<span class="comment">//github.com/flutter/plugin1.git</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Git</strong> 依赖于文件夹中的包: 默认情况下，Pub假定包位于Git存储库的根目录中。如果不是这种情况，您可以使用path参数指定位置，例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  package1:</span><br><span class="line">    git:</span><br><span class="line">      url: git:<span class="comment">//github.com/flutter/packages.git</span></span><br><span class="line">      path: packages/package1</span><br></pre></td></tr></table></figure></li></ul><p><img src="/Flutter/6进阶/Package的使用、开发与发布/分割图1.jpg" alt="分割图1"></p><h2 id="四、开发Packages"><a href="#四、开发Packages" class="headerlink" title="四、开发Packages"></a>四、开发Packages</h2><h3 id="Step-1-创建package工程"><a href="#Step-1-创建package工程" class="headerlink" title="Step 1: 创建package工程"></a>Step 1: 创建package工程</h3><p>要创建Dart包，请使用<code>--template=package</code> 来执行 <code>flutter create</code>，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create --template=package adapt_cjhelper</span><br></pre></td></tr></table></figure><p><img src="/Flutter/6进阶/Package的使用、开发与发布/Package开发1.png" alt="image-20190306143736118"></p><p>这将在<code>adapt_cjhelper/</code>文件夹下创建一个具有以下专用内容的package工程：</p><p><img src="/Flutter/6进阶/Package的使用、开发与发布/Package开发2.png" alt="image-20190306143536586"></p><h3 id="Step-2-实现package功能"><a href="#Step-2-实现package功能" class="headerlink" title="Step 2: 实现package功能"></a>Step 2: 实现package功能</h3><p>对于纯Dart包，只需在主<code>lib/&lt;package name&gt;.dart</code>文件内或<code>lib</code>目录中的文件中添加功能 。</p><p><img src="/Flutter/6进阶/Package的使用、开发与发布/分割图1.jpg" alt="分割图1"></p><h3 id="五、发布Packages"><a href="#五、发布Packages" class="headerlink" title="五、发布Packages"></a>五、发布Packages</h3><h3 id="1、处理pubspec-yaml"><a href="#1、处理pubspec-yaml" class="headerlink" title="1、处理pubspec.yaml"></a>1、处理pubspec.yaml</h3><p><img src="/Flutter/6进阶/Package的使用、开发与发布/Package发布1.png" alt="image-20190306154221495"></p><h4 id="问题1：处理包的相互依赖"><a href="#问题1：处理包的相互依赖" class="headerlink" title="问题1：处理包的相互依赖"></a>问题1：处理包的相互依赖</h4><p>如果您正在开发一个<code>hello</code>包，它依赖于另一个包，则需要将该依赖包添加到<code>pubspec.yaml</code>文件的<code>dependencies</code>部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  url_launcher:</span> <span class="string">^0.4.2</span></span><br></pre></td></tr></table></figure><h3 id="2、验证-packages"><a href="#2、验证-packages" class="headerlink" title="2、验证 packages"></a>2、验证 packages</h3><p>运行 dry-run 命令以查看是否都准备OK了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> flutter packages pub publish --dry-run</span></span><br></pre></td></tr></table></figure><p><img src="/Flutter/6进阶/Package的使用、开发与发布/Package发布2.png" alt="image-2019030615434995"></p><h3 id="3、发布-packages"><a href="#3、发布-packages" class="headerlink" title="3、发布 packages"></a>3、发布 packages</h3><p>最后, 运行发布命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> flutter packages pub publish</span></span><br></pre></td></tr></table></figure><p>第一次上传，会要求登录谷歌账号。这个时候终端会出现一个url地址，类似这样：</p><p><img src="/Flutter/6进阶/Package的使用、开发与发布/Package发布3.png" alt="image-20190306155251926"></p><p>将地址复制出来，在浏览器URL中输入打开这个地址，允许登录谷歌账号就可以了。确认登录后，终端将开始连接谷歌并上传我们的插件包。如下：</p><p><img src="/Flutter/6进阶/Package的使用、开发与发布/Package发布4.png" alt="image-20190306160117171"></p><p>此步有可能会执行失败，提示如下错误，这是因为谷歌被屏蔽而导致的失败。</p><p><img src="/Flutter/6进阶/Package的使用、开发与发布/Package发布5.png" alt="image-20190306160634807"></p><p>原因是虽然你网页成功了，但是终端<code>ping google.com</code>还没翻成功。</p><p><img src="/Flutter/6进阶/Package的使用、开发与发布/ping google 1.png" alt="ping google 1"></p><p>相关原理详细见：<a href="https://www.cnblogs.com/unixcs/p/11274435.html" target="_blank" rel="noopener"><strong>为什么ping不通google.com</strong></a></p><p>此时你去执行<code>curl ip.gs</code>，得到的是不成功的超时结果。</p><p><img src="/Flutter/6进阶/Package的使用、开发与发布/Users/lichaoqian/Project/CQBook/dvlproadHexo/source/_posts/Flutter/6进阶/Package的使用、开发与发布/ping google 2.png" alt="image-20200821151008710"></p><p>这个时候我们需要设置终端的HTTP代理。查看我们的代理，并在终端中设置对应的值，如下：</p><p><img src="/Flutter/6进阶/Package的使用、开发与发布/Package发布6.png" alt="image-01903061622041"></p><p>在终端中执行如下命令配置代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set http_proxy=http://127.0.0.1:1080</span><br><span class="line">set https_proxy=https://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>配置好后重新执行发布命令<code>flutter packages pub publish</code>即可。</p><p><img src="/Flutter/6进阶/Package的使用、开发与发布/分割图1.jpg" alt="分割图1"></p><h2 id="附：macOS-终端设置http和https代理"><a href="#附：macOS-终端设置http和https代理" class="headerlink" title="附：macOS 终端设置http和https代理"></a>附：macOS 终端设置http和https代理</h2><p>1、运行命令  <code>vim ~/.bashrc</code> ， 写入如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy="http://127.0.0.1:4780"</span><br><span class="line">export https_proxy="https://127.0.0.1:4780"</span><br><span class="line">export socket_proxy="socks://127.0.0.1:4781"</span><br><span class="line">export socks_proxy="socks://127.0.0.1:4781"</span><br></pre></td></tr></table></figure><p>4780为本地http代理端口，可能会有所偏差，需要查询代理配置。</p><p>当通过软件启动代理的时候，其启动按键，会为你的网络设置开启如下三个代理。而上面的代理接口为下：</p><p><img src="Package的使用、开发与发布/终端设置http和https代理1.png" alt="image-20200821155621945"></p><p>2、运行命令 <code>vim ~/.bash_profile</code>，写入如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>3、重启终端，运行命令<code>curl ip.gs</code>显示当前ip和所属地区查看是否代理成功。成功的话，国家是United States</p><p><img src="Package的使用、开发与发布/终端设置http和https代理.png" alt="image-20190306174914736"></p><p>其他参考文章：<a href="https://www.jianshu.com/p/08faf29c4165" target="_blank" rel="noopener">终端连代理方法</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第六章：进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5节：Package的私有库</title>
      <link href="/Flutter/6%E8%BF%9B%E9%98%B6/Package%E7%A7%81%E6%9C%89%E5%BA%93/"/>
      <url>/Flutter/6%E8%BF%9B%E9%98%B6/Package%E7%A7%81%E6%9C%89%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、私有库"><a href="#一、私有库" class="headerlink" title="一、私有库"></a>一、私有库</h2><p>参考文章：</p><ul><li><p><a href="https://www.jianshu.com/p/9ee523958b23" target="_blank" rel="noopener">Flutter Pub私有仓库搭建</a></p></li><li><p><a href="https://www.cnblogs.com/mjhelloworld/p/12975776.html" target="_blank" rel="noopener">简短的Flutter Pub私有仓库搭建</a></p></li></ul><p><a href="https://pub.dev/publishers/devdart.club/packages" target="_blank" rel="noopener">我的私有库地址 devdart.club</a></p><p><img src="/Flutter/6进阶/Package私有库/Package私有库1.png" alt="image-20200821143158258"></p><p><img src="/Flutter/6进阶/Package私有库/阿里云1.png" alt="image-20200821142749198"></p><p><img src="/Flutter/6进阶/Package私有库/Package私有库2.png" alt="image-20200821142359255"></p><p><img src="/Flutter/6进阶/Package私有库/Package私有库3.png" alt="Package私有库3"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第六章：进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4节：Plugin插件的开发与发布</title>
      <link href="/Flutter/6%E8%BF%9B%E9%98%B6/Plugin%E6%8F%92%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%E4%B8%8E%E5%8F%91%E5%B8%83/"/>
      <url>/Flutter/6%E8%BF%9B%E9%98%B6/Plugin%E6%8F%92%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%E4%B8%8E%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文一个比 <a href="https://flutterchina.club/developing-packages/#plugin" target="_blank" rel="noopener">Flutter中文网的开发Packages和插件</a> 和 <a href="https://book.flutterchina.club/chapter12/" target="_blank" rel="noopener">《Flutter实战》的包与插件</a> 都更简单的Plugin插件教学。</p><p>让你在毫无思想准备下3分钟就不知不觉不仅学会还理解了Plugin的开发和发布。</p><p>题外话：一个完整的Plugin插件本质上最后其实就是一个Package。</p><h2 id="一、Plugin插件的创建"><a href="#一、Plugin插件的创建" class="headerlink" title="一、Plugin插件的创建"></a>一、Plugin插件的创建</h2><p>终端执行以下命令，进行Plugin插件的创建</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create --org com.dvlproad --template=plugin cj_monitor_flutter</span><br></pre></td></tr></table></figure><p>执行完此条命令后，其实你的<code>cj_monitor_flutter</code>插件就已经开发完成，可以进行发布了。</p><h3 id="1、理解命令所做的事情"><a href="#1、理解命令所做的事情" class="headerlink" title="1、理解命令所做的事情"></a>1、理解命令所做的事情</h3><p>该命令，会生成以下文件。其执行的效果为：</p><p>1、创建了一个package库，带有默认功能；</p><p><img src="/Flutter/6进阶/Plugin插件的开发与发布/Plugin插件的开发与发布1.png" alt="Plugin插件的开发与发布1"></p><p>2、并创建一个example工程，来在工程中测试本地的package库；</p><p><img src="/Flutter/6进阶/Plugin插件的开发与发布/Plugin插件的开发与发布2.png" alt="Plugin插件的开发与发布2"></p><h3 id="2、使用该插件"><a href="#2、使用该插件" class="headerlink" title="2、使用该插件"></a>2、使用该插件</h3><h4 id="2-1、本地工程使用可立即使用"><a href="#2-1、本地工程使用可立即使用" class="headerlink" title="2.1、本地工程使用可立即使用"></a>2.1、本地工程使用可立即使用</h4><p>此时就可以在你的<strong>本地其他工程</strong>中使用这个插件了。使用的方法和该命令中example对该插件的使用一致，即使用本地路径来引入库。</p><p><img src="/Flutter/6进阶/Plugin插件的开发与发布/Plugin插件的开发与发布3.png" alt="Plugin插件的开发与发布3"></p><p>即：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dependencies:</span></span><br><span class="line">  <span class="symbol">flutter:</span></span><br><span class="line">    <span class="symbol">sdk:</span> flutter</span><br><span class="line"></span><br><span class="line">  <span class="symbol">CJMonitorFlutter:</span></span><br><span class="line">    <span class="symbol">path:</span> ../</span><br></pre></td></tr></table></figure><h4 id="2-2、非本地工程需发布后使用"><a href="#2-2、非本地工程需发布后使用" class="headerlink" title="2.2、非本地工程需发布后使用"></a>2.2、非本地工程需发布后使用</h4><p>package的发布，同前一章一样。这里只简单描述。即：</p><p>1、在发布之前，检查pubspec.yaml、README.md以及CHANGELOG.md文件，以确保其内容的完整性和正确性。</p><p>2、然后, 运行 dry-run 命令以查看是否都准备OK了:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter packages pub publish --dry-run</span><br></pre></td></tr></table></figure><p>3、最后, 运行发布命令:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter packages pub publish</span><br></pre></td></tr></table></figure><p><img src="/Flutter/6进阶/Plugin插件的开发与发布/Package的使用、开发与发布/分割图1.jpg" alt="分割图1"></p><h2 id="二、Plugin插件的新功能开发"><a href="#二、Plugin插件的新功能开发" class="headerlink" title="二、Plugin插件的新功能开发"></a>二、Plugin插件的新功能开发</h2><p>好了，下面我们来说重点。为我们刚才创建的Plugin插件开发新功能。</p><p>1、添加提供给【外部】的新功能dart方法。（这部很简单）</p><p><img src="/Flutter/6进阶/Plugin插件的开发与发布/Plugin插件的开发与发布4.png" alt="Plugin插件的开发与发布4"></p><p>2、去android和ios中实现新功能呢方法的内部与原生交互代码（这部是功能代码的核心）。</p><p><img src="/Flutter/6进阶/Plugin插件的开发与发布/Plugin插件的开发与发布5.png" alt="Plugin插件的开发与发布5"></p><p>至此，您的新功能就发布完毕，可以在其他本地工程中使用啦。</p><h3 id="问：我的新功能已经用原生库实现了。怎么继续用库？？"><a href="#问：我的新功能已经用原生库实现了。怎么继续用库？？" class="headerlink" title="问：我的新功能已经用原生库实现了。怎么继续用库？？"></a>问：我的新功能已经用原生库实现了。怎么继续用库？？</h3><p><img src="/Flutter/6进阶/Plugin插件的开发与发布/Plugin插件的开发与发布6.png" alt="image-20200820020901951"></p><p>附：如果是私有库呢？</p><p>答：同理。和你正常使用私有库一样。和这里相比只是多了在<code>XXXX.xcworkspace</code>中加入私有库的source而已。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第六章：进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5节：详解Animation-5疑难杂症</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Animation-5%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Animation-5%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/</url>
      
        <content type="html"><![CDATA[<h2 id="一、疑难杂症"><a href="#一、疑难杂症" class="headerlink" title="一、疑难杂症"></a>一、疑难杂症</h2><h3 id="1、gif-如何停止播放"><a href="#1、gif-如何停止播放" class="headerlink" title="1、gif 如何停止播放"></a>1、gif 如何停止播放</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Image.asset(<span class="string">"assets/tasky_logo.gif"</span>,</span><br><span class="line">            gaplessPlayback: <span class="keyword">false</span>, fit: BoxFit.fill)</span><br></pre></td></tr></table></figure><p>以上来源于：<a href="https://stackoverflow.com/questions/58620804/how-to-stop-gif-loop-in-flutter" target="_blank" rel="noopener">How to stop GIF loop in flutter?</a></p><h3 id="1、重新打开对话框时，Flutter-gif不会再次播放"><a href="#1、重新打开对话框时，Flutter-gif不会再次播放" class="headerlink" title="1、重新打开对话框时，Flutter gif不会再次播放"></a>1、<a href="https://cloud.tencent.com/developer/ask/sof/1360686" target="_blank" rel="noopener">重新打开对话框时，Flutter gif不会再次播放</a></h3><p>我有一个设置，其中我有一个带有gif的警告对话框。当对话框打开时，我希望gif只播放一次，这是我用这篇文章中最好的答案实现的：</p><p><a href="https://stackoverflow.com/questions/58620804/how-to-stop-gif-loop-in-flutter" target="_blank" rel="noopener">How to stop GIF loop in flutter?</a></p><p>问题是，当我重新打开对话框时，gif不会再次播放。解决如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AssetImage image;</span><br><span class="line"></span><br><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">  super.initState();</span><br><span class="line">  image = AssetImage(widget.asset);</span><br><span class="line">  print(&apos;$&#123;widget.asset&#125; initState&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@override</span><br><span class="line">void dispose() &#123;</span><br><span class="line">  print(&apos;$&#123;widget.asset&#125; dispose&apos;);</span><br><span class="line">  image.evict();</span><br><span class="line">  super.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上参考来源于：<a href="https://github.com/flutter/flutter/issues/51775" target="_blank" rel="noopener">Load gif animation multiple times, not play from the first frame</a></p><h3 id="3、【Flutter】控制GIF播放"><a href="#3、【Flutter】控制GIF播放" class="headerlink" title="3、【Flutter】控制GIF播放"></a>3、【Flutter】控制GIF播放</h3><p><a href="https://juejin.cn/post/6881589444194140173" target="_blank" rel="noopener">【Flutter】控制GIF播放</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Visibility(</span><br><span class="line">     visible: isPlay,</span><br><span class="line">     child: Image.asset(&quot;images/gif_player_demo.gif&quot;),</span><br><span class="line">     replacement: Image.asset(&quot;images/gif_player_demo.png&quot;),</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第五章：详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5节：详解其他</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3%E5%85%B6%E4%BB%96/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3%E5%85%B6%E4%BB%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第五章：详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章：Shell高级技巧</title>
      <link href="/Script/Shell/Shell%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
      <url>/Script/Shell/Shell%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Shell高级技巧"><a href="#Shell高级技巧" class="headerlink" title="Shell高级技巧"></a>Shell高级技巧</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [shell替换和去掉换行符](http://www.noobyard.com/article/p-ahlemikj-nz.html)</span></span><br><span class="line">featureBranceNamesString=$(echo $&#123;featureBranceNamesString&#125; |sed 's/ /\n/g'|awk '&#123;&#123;printf"%s",$0&#125;&#125;')</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [Shell 命令变量去除空格方法](https://blog.csdn.net/jjc120074203/article/details/126663391)</span></span><br><span class="line">FileContent=$&#123;FileContent// /&#125;</span><br></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li><a href="https://www.jianshu.com/p/a55480b793b0" target="_blank" rel="noopener">Mac环境下shell脚本中的map</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [Mac环境下shell脚本中的map](https://www.jianshu.com/p/a55480b793b0)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="built_in">declare</span> -A myMap=([<span class="string">"my00"</span>]=<span class="string">"00"</span> [<span class="string">"my01"</span>]=<span class="string">"01"</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    myMap[<span class="string">"my02"</span>]=<span class="string">"02"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    myMap[<span class="string">"my03"</span>]=<span class="string">"03"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="built_in">declare</span> -A targetBranchConfig_realMap=()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    targetBranchConfig_realMap[<span class="string">"uploadChannelShortcut"</span>]=<span class="string">"<span class="variable">$&#123;packagePgyerChannelShortcutResult_upload&#125;</span>"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    targetBranchConfig_realMap[<span class="string">"uploadChannelKey"</span>]=<span class="string">"<span class="variable">$&#123;packagePgyerChannelKeyResult_upload&#125;</span>"</span></span></span><br><span class="line">    </span><br><span class="line">    uploadChannelShortcut_key="uploadChannelShortcut"</span><br><span class="line">    uploadChannelKey_key="uploadChannelKey"</span><br><span class="line">    targetBranchConfig_realMap="&#123;"</span><br><span class="line">    targetBranchConfig_realMap+="\"$&#123;uploadChannelShortcut_key&#125;\":\"$&#123;packagePgyerChannelShortcutResult_upload&#125;\", \"$&#123;uploadChannelKey_key&#125;\":\"$&#123;packagePgyerChannelKeyResult_upload&#125;\""</span><br><span class="line">    if [ -z "$&#123;packagePgyerChannelShortcutResult_download&#125;" ] || [ "$&#123;packagePgyerChannelShortcutResult_download&#125;" == "null" ]; then</span><br><span class="line">        packagePgyerChannelShortcutResult_download=$&#123;packagePgyerChannelShortcutResult_upload&#125;</span><br><span class="line">        packagePgyerChannelKeyResult_download=$&#123;packagePgyerChannelKeyResult_upload&#125;</span><br><span class="line">    fi</span><br><span class="line">    targetBranchConfig_realMap+=","</span><br><span class="line">    targetBranchConfig_realMap+="\"downloadChannelShortcut\":\"$&#123;packagePgyerChannelShortcutResult_download&#125;\", \"downloadChannelKey\":\"$&#123;packagePgyerChannelKeyResult_download&#125;\""</span><br><span class="line">    targetBranchConfig_realMap+="&#125;"</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.dianjilingqu.com/623928.html" target="_blank" rel="noopener">shell 使用jq解析json字符串数组</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">获取键值对的个数，或者数组长度：</span></span><br><span class="line">cat json.txt | jq '.[0].employees|length'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取键foo的值：</span></span><br><span class="line">echo '&#123;"foo": 42, "bar": "less interesting data"&#125;' | jq '.foo'</span><br><span class="line">42</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取json所有键：</span></span><br><span class="line">echo '&#123;"foo": 42, "bar": "less interesting data"&#125;' | jq 'keys'</span><br><span class="line">[</span><br><span class="line">"bar",</span><br><span class="line">"foo"</span><br><span class="line">]</span><br><span class="line"><span class="meta">#</span><span class="bash"> has判断是否存在某个key</span></span><br><span class="line">echo '&#123;"foo": 42, "bar": "less interesting data"&#125;' | jq 'has("foo")' </span><br><span class="line">true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取键值对的个数，或者数组长度</span></span><br><span class="line">echo '&#123;"foo": 42, "bar": "less interesting data"&#125;' | jq 'length'</span><br></pre></td></tr></table></figure><h2 id="一、主要用法"><a href="#一、主要用法" class="headerlink" title="一、主要用法"></a>一、主要用法</h2><h3 id="删除所有的空格"><a href="#删除所有的空格" class="headerlink" title="删除所有的空格"></a>删除所有的空格</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buildContainBranchsString=(`echo $&#123;buildContainBranchsString&#125; | sed s/[[:space:]]//g`) # 删除所有的空格,修复所填分支信息有空格</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="string">"buildContainBranchsString=<span class="variable">$&#123;buildContainBranchsString&#125;</span>"</span></span></span><br><span class="line">buildContainBranchArray=(`echo $&#123;buildContainBranchsString&#125; | tr '#' ' '`) # 字符串拆分成数组</span><br></pre></td></tr></table></figure><h2 id="字符串转换数组"><a href="#字符串转换数组" class="headerlink" title="字符串转换数组"></a>字符串转换数组</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nocodeBranceNamesString=$(cat $&#123;FILE_PATH&#125; | $&#123;JQ_EXEC&#125; '.nocode_brances' | $&#123;JQ_EXEC&#125; '.[].name')</span><br><span class="line">echo $&#123;nocodeBranceNamesString&#125;</span><br><span class="line"></span><br><span class="line">nocodeBranceNamesArray=($&#123;nocodeBranceNamesString//,/&#125;) # 字符串转数组</span><br></pre></td></tr></table></figure><h1 id="shell-使用jq解析json字符串数组"><a href="#shell-使用jq解析json字符串数组" class="headerlink" title="shell 使用jq解析json字符串数组"></a>shell 使用jq解析json字符串数组</h1><ul><li><a href="https://www.dianjilingqu.com/623928.html" target="_blank" rel="noopener">shell 使用jq解析json字符串数组</a></li></ul><p>如何在shell中使用jq cmd变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">    branchMapArray=$(<span class="built_in">echo</span> <span class="variable">$&#123;branchRootMap&#125;</span> | <span class="variable">$&#123;JQ_EXEC&#125;</span> -r <span class="string">'.online_brances'</span>) <span class="comment"># -r 去除字符串引号</span></span></span><br><span class="line">    # [如何在shell中使用jq cmd变量](https://www.5axxw.com/questions/content/5ucfc4)</span><br><span class="line">   branchMapArray=$(echo $&#123;branchRootMap&#125; | jq -r --arg branchsKey "$branchsKey" '.[$branchsKey]')</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install shc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shc -r -f hello_script.sh</span><br><span class="line">或</span><br><span class="line">shc -r -f hello_script.sh -o hello_script</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shell 单括号运算符号：</span><br><span class="line">a=$(date);</span><br><span class="line">等同于：</span><br><span class="line">a=date;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">双括号运算符:</span><br><span class="line">a=$((1+2));</span><br><span class="line">echo $a;</span><br><span class="line">等同于：</span><br><span class="line">a=expr 1 + 2</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除所有的空格</span></span><br><span class="line">sed s/[[:space:]]//g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除行末空格</span></span><br><span class="line">sed 's/[ \t]*$//g'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除行首空格</span></span><br><span class="line">sed 's/^[ \t]*//g'</span><br></pre></td></tr></table></figure><h1 id="shell中使用jq命令修改json文件-合并-修改等"><a href="#shell中使用jq命令修改json文件-合并-修改等" class="headerlink" title="shell中使用jq命令修改json文件(合并,修改等)"></a>shell中使用jq命令修改json文件(合并,修改等)</h1><ol><li>目标</li></ol><p>文件package.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;menus&quot;: &#123;</span><br><span class="line">        &quot;commandPalette&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;command&quot;: &quot;go.test.refresh&quot;,</span><br><span class="line">                &quot;when&quot;: &quot;false&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件add.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;add_menu&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;command&quot;: &quot;go.explorer.refresh&quot;,</span><br><span class="line">            &quot;when&quot;: &quot;false&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;command&quot;: &quot;go.explorer.open&quot;,</span><br><span class="line">            &quot;when&quot;: &quot;false&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希望把add.json文件里的add_menu合并到package.json的 menus.commandPalette中, 得到一下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;menus&quot;: &#123;</span><br><span class="line">        &quot;commandPalette&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;command&quot;: &quot;go.test.refresh&quot;,</span><br><span class="line">                &quot;when&quot;: &quot;false&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;command&quot;: &quot;go.explorer.refresh&quot;,</span><br><span class="line">                &quot;when&quot;: &quot;false&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;command&quot;: &quot;go.explorer.open&quot;,</span><br><span class="line">                &quot;when&quot;: &quot;false&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-上脚本"><a href="#2-上脚本" class="headerlink" title="2.上脚本"></a>2.上脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jq -s &apos;.[0].menus.commandPalette = .[0].menus.commandPalette + .[1].add_menu | .[0]&apos; ./package.json ./add.json</span><br></pre></td></tr></table></figure><h2 id="3-解释"><a href="#3-解释" class="headerlink" title="3.解释"></a>3.解释</h2><h3 id="参数-s"><a href="#参数-s" class="headerlink" title="参数-s"></a>参数-s</h3><p>表示读取多个json对象, 放入一个数组里在一起出来, 开始的.表示整个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ jq -s &apos;.&apos; ./package.json ./add.json</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;menus&quot;: &#123;</span><br><span class="line">      &quot;commandPalette&quot;: [</span><br><span class="line">        ...</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;add_menu&quot;: [</span><br><span class="line">      ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="定位取值"><a href="#定位取值" class="headerlink" title="定位取值"></a>定位取值</h3><p>数组使用中括号加索引读取等读取, 如 [0] [1], 原命令里的.[0]和.[1]就分别是表示package.json和info.json里的json对象, 其中的.则是表示合并后数组.</p><p>要获取json更深层级的对象时, key之间用点号拼接即可. 如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jq &apos;.add_menu[0].command&apos; ./add.json </span><br><span class="line">&quot;go.explorer.refresh&quot;</span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道|"></a>管道|</h3><p>基本和shell里的管道概念是一致的, 管道左侧命令的输出, 将变成管道右侧命令的输入. 如原命令里, .[0].menus.commandPalette = .[0].menus.commandPalette + .[1].add_menu | .[0] 就有一个管道, 左侧的命令是修改合并后的数组中第一个单元的某些值, 然后输出整个数组(包含两个单元, 有package.json和info.json的信息), 然后管道右侧命令接收到整个数组后, 只筛选出第一个单元进行输出 </p><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><ul><li>针对数组, 是拼接效果(如原命令)</li><li>针对数字, 则是正常加法</li><li>针对{}对象, 合并, 相同key覆盖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 数组加法</span><br><span class="line">$ echo &apos;[1,2] [3,4]&apos;|jq -s &apos;.[0] + .[1]&apos;</span><br><span class="line">[</span><br><span class="line">  1,</span><br><span class="line">  2,</span><br><span class="line">  3,</span><br><span class="line">  4</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 数字加法</span><br><span class="line">$ echo &apos;1 2&apos;|jq -s &apos;.[0] + .[1]&apos;</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"># &#123;&#125;对象, 相同key后面覆盖前面</span><br><span class="line">$ echo &apos;&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125; &#123;&quot;b&quot;:21, &quot;c&quot;:3&#125;&apos;|jq -s &apos;.[0] + .[1]&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;a&quot;: 1,</span><br><span class="line">  &quot;b&quot;: 21,</span><br><span class="line">  &quot;c&quot;: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>从某个数据源读取一些json信息, 并以此针对某个json的制定位置进行修改, 基本思路就是使用-s参数, 先把所有数据合并为一个大数组, 然后就行修改, 过后通过管道筛选出需要的数据. </p><p>jq是一个非常强悍的处理json的命令行工具, 完全可以把它当做一门语言来学. 我也正在学习当中, 你若有jq相关需求解决不了, 我很乐意帮忙研究解决.</p><h2 id="二、超时"><a href="#二、超时" class="headerlink" title="二、超时"></a>二、超时</h2><p>MacOS超时指令-gtimeout</p><p>在linux下面可以使用timeout命令设置命令的超时时间，macos下同样也有，只不过不是timeout而是gtimeout命令</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>coreutils</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gtimeout 10 sh ./demo.sh <span class="comment"># 指令脚本，10秒后超时退出</span></span><br></pre></td></tr></table></figure><p>也可以使用别名，将gtimeout设置为timeout</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> timeout=gtimeout</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Script </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Script </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章：Shell入门</title>
      <link href="/Script/Shell/Shell%E5%85%A5%E9%97%A8/"/>
      <url>/Script/Shell/Shell%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Shell入门"><a href="#Shell入门" class="headerlink" title="Shell入门"></a>Shell入门</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li><p><a href="https://www.runoob.com/linux/linux-shell-array.html" target="_blank" rel="noopener">shell数组</a></p><blockquote><p>MentionedList=(“zhangsan” “lisi”)</p></blockquote></li></ul><h2 id="一、主要用法"><a href="#一、主要用法" class="headerlink" title="一、主要用法"></a>一、主要用法</h2><h3 id="1、获取值"><a href="#1、获取值" class="headerlink" title="1、获取值"></a>1、获取值</h3><ul><li><a href="https://blog.csdn.net/d1240673769/article/details/122072963" target="_blank" rel="noopener">shell获取文件名和文件目录</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、修改值"><a href="#2、修改值" class="headerlink" title="2、修改值"></a>2、修改值</h3><h4 id="2-1、修改文件名"><a href="#2-1、修改文件名" class="headerlink" title="2.1、修改文件名"></a>2.1、修改文件名</h4><ul><li><a href="https://blog.csdn.net/d1240673769/article/details/122072963" target="_blank" rel="noopener">修改文件名</a></li></ul><h3 id="1、传参并修改app-info-json文件内容"><a href="#1、传参并修改app-info-json文件内容" class="headerlink" title="1、传参并修改app_info.json文件内容"></a>1、传参并修改app_info.json文件内容</h3><p>如修改以下app_info.json文件内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"version"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"unknow time"</span>,</span><br><span class="line"><span class="attr">"brance"</span>: <span class="string">"unknow brance"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">sed -i <span class="string">''</span> <span class="string">'s/unknow brance/dev_1.0.0_fix/g'</span> app_info.json</span></span><br></pre></td></tr></table></figure><p>如果要使用传入的参数，则命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用传入的参数方法1:把单引号改为双引号(因为单引号会阻止转义)</span></span><br><span class="line">sed -i '' "s/unknow brance/$1/g" app_info.json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用传入的参数方法2:变量<span class="variable">$&#123;&#125;</span>外的字符串全都用单引号<span class="string">''</span>圈住</span></span><br><span class="line">sed -i '' 's/unknow brance/'$1'/g' app_info.json</span><br></pre></td></tr></table></figure><p>update_app_info.sh脚本的核心命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> update_app_info.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> app信息中加入打包的分支名称，便于知晓当前包的来源分支</span></span><br><span class="line">BranceName=$1</span><br><span class="line">echo "BranceName=$BranceName"</span><br><span class="line">sed -i '' "s/unknow brance/$BranceName/g" app_info.json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将含信息的文件拷贝到app中，以便在app可以获取这些信息</span></span><br><span class="line">cp app_info.json ../wish/asset/data</span><br></pre></td></tr></table></figure><p>update_app_info.sh脚本的完整命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FullBranceName=$1</span><br><span class="line">ShortBranceName=$&#123;FullBranceName##*/&#125;</span><br><span class="line">echo "ShortBranceName=$ShortBranceName"</span><br><span class="line">sed -i '' 's/unknow brance/'$&#123;ShortBranceName&#125;'/g' app_info.json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">cp app_info.json ../flutter_updateversion_kit/assets/data</span></span><br><span class="line">app_info_dir_home="../flutter_updateversion_kit/assets"</span><br><span class="line">if [ ! -d "$app_info_dir_home" ];then</span><br><span class="line">mkdir $app_info_dir_home</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="string">"assets文件夹创建成功"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="string">"assets文件夹已经存在"</span></span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app_info_dir="$app_info_dir_home/data"</span><br><span class="line">if [ ! -d "$app_info_dir" ];then</span><br><span class="line">mkdir $app_info_dir</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="string">"assets/data文件夹创建成功"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="string">"assets/data文件夹已经存在"</span></span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">fileName="app_info.json"</span><br><span class="line">app_info_file_path=$app_info_dir/$fileNam</span><br><span class="line">cp $fileName $app_info_file_path</span><br></pre></td></tr></table></figure><p>jenkins中，直接取定义分支名时候的名称作为变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $WORKSPACE/bulidScript</span><br><span class="line">sh update_app_info.sh $BRANCH</span><br></pre></td></tr></table></figure><h3 id="2、读取Json及其属性值"><a href="#2、读取Json及其属性值" class="headerlink" title="2、读取Json及其属性值"></a>2、读取Json及其属性值</h3><p>假设json文件内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">"package_create_time"</span>: <span class="string">"package unknow time"</span>,</span><br><span class="line">    <span class="attr">"package_from_brance"</span>: <span class="string">"package unknow brance"</span>,</span><br><span class="line">    <span class="attr">"package_default_env"</span>: <span class="string">"package unknow env"</span>,</span><br><span class="line">    <span class="attr">"brances_record_time"</span>: <span class="string">"03.18"</span>,</span><br><span class="line">    <span class="attr">"feature_brances"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"dev_1.0.0_fix"</span>,</span><br><span class="line">            <span class="attr">"des"</span>: <span class="string">"线上版问题修复或优化"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前提：</p><p>必须安装jq，安装方法如下：</p><p>mac上安装brew后，执行brew install jq安装jq</p><h4 id="2-1、如果是json文件"><a href="#2-1、如果是json文件" class="headerlink" title="2.1、如果是json文件"></a>2.1、如果是json文件</h4><p>则读取 version、package_create_time、feature_brances.name 的值分别如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">JQ_EXEC=`which jq`</span><br><span class="line">FILE_PATH=app_info.json</span><br><span class="line"></span><br><span class="line">packageVersion=$(cat $FILE_PATH | $&#123;JQ_EXEC&#125; .version | sed 's/\"//g')</span><br><span class="line">packageCreateTime=$(cat $FILE_PATH | $&#123;JQ_EXEC&#125; .package_create_time | sed 's/\"//g')</span><br><span class="line">echo "packageVersion=$packageVersion,packageCreateTime=$packageCreateTime"</span><br><span class="line"></span><br><span class="line">featureBranceName=$(cat $FILE_PATH | $&#123;JQ_EXEC&#125; .feature_brances.name | sed 's/\"//g')</span><br><span class="line">echo "featureBranceName=$featureBranceName"</span><br></pre></td></tr></table></figure><h4 id="2-2、如果是json数据"><a href="#2-2、如果是json数据" class="headerlink" title="2.2、如果是json数据"></a>2.2、如果是json数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">responseResult=$(\</span><br><span class="line">curl $ROBOTURL \</span><br><span class="line">   -H 'Content-Type: application/json' \</span><br><span class="line">   -d "</span><br><span class="line">   &#123;</span><br><span class="line">        \"msgtype\": \"text\",</span><br><span class="line">        \"text\": &#123;</span><br><span class="line">            \"content\": \"$&#123;LastNotificationText&#125;\"</span><br><span class="line">            \"mentioned_list\":$MentionedList</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;"</span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line">responseResultCode=$(**echo** $&#123;responseResult&#125; | jq '.errcode') # mac上安装brew后，执行brew install jq安装jq</span><br></pre></td></tr></table></figure><h1 id="Shell脚本8种字符串截取方法总结"><a href="#Shell脚本8种字符串截取方法总结" class="headerlink" title="Shell脚本8种字符串截取方法总结"></a>Shell脚本8种字符串截取方法总结</h1><ul><li><a href="https://www.jb51.net/article/56563.htm" target="_blank" rel="noopener">Shell脚本8种字符串截取方法总结</a></li></ul><h2 id="一、shell-中的与、或表达式"><a href="#一、shell-中的与、或表达式" class="headerlink" title="一、shell 中的与、或表达式"></a>一、<em>shell</em> 中的与、<em>或</em>表达式</h2><ul><li>逻辑与的表达：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）、if [ $xxx=a -a $xx=b ]</span><br><span class="line"></span><br><span class="line">注：-a表示and的意思</span><br><span class="line">2）、if [ $xxx=a ] &amp;&amp; [  $xx=b ]</span><br></pre></td></tr></table></figure><ul><li>逻辑或的表达：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）、if [ $xxx=a -o $xx=b ]</span><br><span class="line"></span><br><span class="line">注：-o表示or的意思</span><br><span class="line">2）、if [ $xxx=a ] || [  $xx=b ]</span><br></pre></td></tr></table></figure><h2 id="一、Shell的特殊变量"><a href="#一、Shell的特殊变量" class="headerlink" title="一、Shell的特殊变量"></a>一、Shell的特殊变量</h2><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数。</td></tr><tr><td>$n</td><td>传递给脚本或函数的第n个参数</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td></tr></tbody></table><h3 id="1、-和-的区别"><a href="#1、-和-的区别" class="headerlink" title="1、 \$* 和 \$@ 的区别"></a>1、 \$* 和 \$@ 的区别</h3><p>\$* 和 \$@ 都表示传递给函数或脚本的所有参数</p><p>情况①：不被双引号(“ “)包含时，都以”\$1” “\$2” … “\$n” 的形式输出所有参数。</p><p>情况②：但是当它们被双引号(“ “)包含时，”\$*” 会将所有的参数作为一个整体，以”\$1 \$2 … \$n”的形式输出所有参数；”\$@” 会将各个参数分开，以”\$1” “\$2” … “\$n” 的形式输出所有参数。</p><h3 id="2、shell中的重定向-1-gt-amp-2等"><a href="#2、shell中的重定向-1-gt-amp-2等" class="headerlink" title="2、shell中的重定向 1&gt;&amp;2等"></a>2、shell中的重定向 <em>1&gt;&amp;2</em>等</h3><h2 id="二、echo"><a href="#二、echo" class="headerlink" title="二、echo"></a>二、echo</h2><h3 id="1、超级终端的字体背景和颜色显示"><a href="#1、超级终端的字体背景和颜色显示" class="headerlink" title="1、超级终端的字体背景和颜色显示"></a>1、超级终端的字体背景和颜色显示</h3><p>格式: echo -e “\033[字背景颜色;字体颜色m字符串\033[0m”</p><p>例如:<br>echo -e “\033[41;36m something here \033[0m” </p><p>其中41的位置代表底色, 36的位置是代表字的颜色 </p><p>那些ascii code 是对颜色调用的始末.<br>\033[ ; m …… \033[0m </p><p>参考：</p><p><a href="https://blog.csdn.net/panpan639944806/article/details/23930553" target="_blank" rel="noopener">https://blog.csdn.net/panpan639944806/article/details/23930553</a></p><p><a href="https://blog.csdn.net/u014470361/article/details/81512330" target="_blank" rel="noopener">https://blog.csdn.net/u014470361/article/details/81512330</a></p><table><thead><tr><th>颜色</th><th>字色值</th><th>背景色值</th></tr></thead><tbody><tr><td>黑色</td><td>30</td><td>40</td></tr><tr><td>紅色</td><td>31</td><td>41</td></tr><tr><td>綠色</td><td>32</td><td>42</td></tr><tr><td>黃色</td><td>33</td><td>43</td></tr><tr><td>藍色</td><td>34</td><td>44</td></tr><tr><td>紫紅色</td><td>35</td><td>45</td></tr><tr><td>青藍色</td><td>36</td><td>46</td></tr><tr><td>白色</td><td>37</td><td>47</td></tr></tbody></table><h2 id="三、判断语句"><a href="#三、判断语句" class="headerlink" title="三、判断语句"></a>三、判断语句</h2><h3 id="1、对字符串的判断"><a href="#1、对字符串的判断" class="headerlink" title="1、对字符串的判断"></a>1、对字符串的判断</h3><h3 id="判断参数个数"><a href="#判断参数个数" class="headerlink" title="判断参数个数"></a>判断参数个数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if [[ -z $2 ]]</span><br><span class="line">then</span><br><span class="line">    echo 'Error:参数数量过少,请重新输入'</span><br><span class="line">    exit_script</span><br><span class="line">fi</span><br><span class="line">if [[ -n $3 ]]</span><br><span class="line">then</span><br><span class="line">    echo 'Error:参数数量过多,请重新输入'</span><br><span class="line">    exit_script</span><br><span class="line">fi</span><br><span class="line">if [ -z $&#123;xcarchive_file_path&#125; ] \</span><br><span class="line">    || [ -z $&#123;APPENVIRONMENT&#125; ];</span><br><span class="line">then</span><br><span class="line">    echo 'Error:上述2个参数都不能为空'</span><br><span class="line">    echo '请重新执行：sh base_exportArchive.sh $&#123;xcarchive_file_path&#125; $&#123;APPENVIRONMENT&#125;'</span><br><span class="line">    exit_script</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="1-1、截取字符串"><a href="#1-1、截取字符串" class="headerlink" title="1.1、截取字符串"></a>1.1、截取字符串</h4><ul><li><a href="https://www.jb51.net/article/56563.htm" target="_blank" rel="noopener">Shell脚本8种字符串截取方法总结</a></li></ul><p><strong>注意赋值等号两边不能有空格</strong></p><p><strong>注意赋值等号两边不能有空格</strong></p><p><strong>注意赋值等号两边不能有空格</strong></p><h5 id="1-1-1、根据路径取目录和文件名"><a href="#1-1-1、根据路径取目录和文件名" class="headerlink" title="1.1.1、根据路径取目录和文件名"></a>1.1.1、根据路径取目录和文件名</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">file_path=d/dir1/dir2/file.png</span><br><span class="line">file_dir=$&#123;file_path%/*&#125;</span><br><span class="line">file_name=$&#123;file_path##*/&#125;</span><br><span class="line">echo "file_dir = $&#123;file_dir&#125;"</span><br><span class="line">echo "file_name = $&#123;file_name&#125;"</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">APPPROJECT_NAME=$&#123;workspace_file_path##*/&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xcarchive_file_path=./aaa/bbb/ccc/App1Enterprise.xcarchive</span><br><span class="line">xcarchive_file_dir=$&#123;xcarchive_file_path%/*&#125;# 文件目录</span><br><span class="line">xcarchive_file_name_withSuffix=$&#123;xcarchive_file_path##*/&#125; # 文件主名+文件后缀名</span><br><span class="line">xcarchive_file_name=$&#123;xcarchive_file_name_withSuffix%.*&#125;# 文件主名</span><br><span class="line">xcarchive_file_suffix=$&#123;xcarchive_file_name_withSuffix##*.&#125;# 文件后缀名</span><br><span class="line">echo "xcarchive_file_dir:           $&#123;xcarchive_file_dir&#125;"</span><br><span class="line">echo "xcarchive_file_name:          $&#123;xcarchive_file_name&#125;"</span><br><span class="line">echo "xcarchive_file_suffix:        $&#123;xcarchive_file_suffix&#125;"</span><br></pre></td></tr></table></figure><h5 id="1-1-2、根据1-0-0-100去版本号和编译号"><a href="#1-1-2、根据1-0-0-100去版本号和编译号" class="headerlink" title="1.1.2、根据1.0.0+100去版本号和编译号"></a>1.1.2、根据1.0.0+100去版本号和编译号</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version=1.0.0+100</span><br><span class="line">app_bundle_version=$&#123;version%+*&#125;    # 取+号左侧，结果1.0.0()</span><br><span class="line">app_build_version=$&#123;version#*+&#125;    # 取+号右侧，结果100(注意赋值等号两边不能有空格)</span><br><span class="line">echo "app_bundle_version    = $&#123;app_bundle_version&#125;"</span><br><span class="line">echo "app_build_version     = $&#123;app_build_version&#125;"</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="1、环境判断"><a href="#1、环境判断" class="headerlink" title="1、环境判断"></a>1、环境判断</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">APPENVIRONMENT=$2           # app的打包环境</span><br><span class="line">echo "app的打包环境APPENVIRONMENT:   $&#123;APPENVIRONMENT&#125;"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CUR_DIR=$PWD    #$PWD代表获取当前路径，当cd后，$PWD也会跟着更新到新的cd路径。这个和在终端操作是一样的道理的</span><br><span class="line">if [ $APPENVIRONMENT == "Product" ];        # 生产环境</span><br><span class="line">then</span><br><span class="line">    ExportOptionsPlist_PATH=$CUR_DIR/ExportOptions_inhouse.plist</span><br><span class="line">elif [ $APPENVIRONMENT == "PreProduct" ];   # 预生产环境</span><br><span class="line">then</span><br><span class="line">    ExportOptionsPlist_PATH=$CUR_DIR/ExportOptions_adhoc.plist</span><br><span class="line">elif [ $APPENVIRONMENT == "Develop1" -o $APPENVIRONMENT == "Develop2" -o $APPENVIRONMENT == "Develop3" ];</span><br><span class="line">then                                        # 测试环境</span><br><span class="line">    ExportOptionsPlist_PATH=$CUR_DIR/ExportOptions_dev.plist</span><br><span class="line">else                                        # 不是允许/支持的环境</span><br><span class="line">    echo "-------- Error：所执行的脚本命令中，输入的$&#123;APPENVIRONMENT&#125;不是允许/支持的环境，故不再继续执行 --------"</span><br><span class="line">    exit</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="1、判断字符串是否以某个字符串结尾"><a href="#1、判断字符串是否以某个字符串结尾" class="headerlink" title="1、判断字符串是否以某个字符串结尾"></a>1、判断字符串是否以某个字符串结尾</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 判断字符串是否以某个字符串结尾</span></span><br><span class="line">endWithSuffix() &#123; </span><br><span class="line">    fullString=$1</span><br><span class="line">    suffixString=$2</span><br><span class="line">    echo "判断 $&#123;fullString&#125; 是否以 $&#123;suffixString&#125; 结尾"</span><br><span class="line">    file_name_withSuffix=$&#123;fullString##*/&#125; # 文件主名+文件后缀名</span><br><span class="line">    #file_name=$&#123;file_name_withSuffix%.*&#125;    # 文件主名</span><br><span class="line">    file_suffix=$&#123;file_name_withSuffix##*.&#125; # 文件后缀名</span><br><span class="line">    #echo "file_name:          $&#123;file_name&#125;"</span><br><span class="line">    echo "file_suffix:        $&#123;file_suffix&#125;"</span><br><span class="line">    echo "suffixString:       $&#123;suffixString&#125;"</span><br><span class="line">    if [ $&#123;file_suffix&#125; == $&#123;suffixString&#125; ]; then</span><br><span class="line">        echo 'suffix correct'</span><br><span class="line">        return 1</span><br><span class="line">    else</span><br><span class="line">        echo 'suffix error'</span><br><span class="line">        return 0</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用示例：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> endWithSuffix <span class="string">"./aaa/bbb/ccc/App1Enterprise.xcarchive"</span> <span class="string">'xcarchive'</span></span></span><br><span class="line">endWithSuffix "./aaa/bbb/ccc/App1Enterprise.ipa" 'xcarchive'</span><br><span class="line">if [ $? == 0 ]; then</span><br><span class="line">    echo '执行失败：文件后缀错误，请重新输入'</span><br><span class="line">    exit</span><br><span class="line">fi</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h4 id="1-1、判断是不是以http开头"><a href="#1-1、判断是不是以http开头" class="headerlink" title="1.1、判断是不是以http开头"></a>1.1、判断是不是以http开头</h4><p>if [[$1 =~^http.* ]]; then<br>    commond<br>else<br>    commond<br>fi</p><h2 id="1、shell中-和-的主要区别"><a href="#1、shell中-和-的主要区别" class="headerlink" title="1、shell中[[]]和[]的主要区别"></a>1、shell中[[]]和[]的主要区别</h2><ul><li style="list-style: none"><input type="checkbox" checked> 实际上是bash 中 test 命令的简写。即所有的 [ expr ] 等于 test expr</li><li style="list-style: none"><input type="checkbox" checked> [[ expr ]] 是bash中真正的条件判断语句</li></ul><h3 id="2、对文件名filename的判断"><a href="#2、对文件名filename的判断" class="headerlink" title="2、对文件名filename的判断"></a>2、对文件名filename的判断</h3><h4 id="1、获取当前文件路径"><a href="#1、获取当前文件路径" class="headerlink" title="1、获取当前文件路径"></a>1、获取当前文件路径</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curPath=$(cd "$(dirname "$0")"; pwd) # 获取当前文件路径</span><br><span class="line">echo "curPath=$&#123;curPath&#125;"</span><br></pre></td></tr></table></figure><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>-e filename</td><td>如果 filename存在，则为真</td></tr><tr><td>-d filename</td><td>如果 filename为目录，则为真</td></tr><tr><td>-f filename</td><td>如果 filename为常规文件，则为真</td></tr><tr><td>-L filename</td><td>如果 filename为符号链接，则为真</td></tr><tr><td>-h filename</td><td>如果文件是软链接，则为真</td></tr></tbody></table><p>使用举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AssertExists() &#123;</span><br><span class="line">  if [[ ! -e "$1" ]]; then</span><br><span class="line">    if [[ -h "$1" ]]; then</span><br><span class="line">      EchoError "The path $1 is a symlink to a path that does not exist"</span><br><span class="line">    else</span><br><span class="line">      EchoError "The path $1 does not exist"</span><br><span class="line">    fi</span><br><span class="line">    exit -1</span><br><span class="line">  fi</span><br><span class="line">  return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他表达式：</p><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>-r filename</td><td>如果 filename可读，则为真</td></tr><tr><td>-w filename</td><td>如果 filename可写，则为真</td></tr><tr><td>-x filename</td><td>如果 filename可执行，则为真</td></tr><tr><td>-s filename</td><td>如果文件长度不为0，则为真</td></tr><tr><td>filename1 -nt filename2</td><td>如果 filename1比 filename2新，则为真。</td></tr><tr><td>filename1 -ot filename2</td><td>如果 filename1比 filename2旧，则为真。</td></tr></tbody></table><h3 id="3、对字符串str的判断"><a href="#3、对字符串str的判断" class="headerlink" title="3、对字符串str的判断"></a>3、对字符串str的判断</h3><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>if [ str1 = str2 ]</td><td>当两个串有相同内容、长度时为真</td></tr><tr><td>if [ str1 != str2 ]</td><td>当串str1和str2不等时为真</td></tr><tr><td>if [ -n str1 ]</td><td>当串的长度大于0时为真(串非空)</td></tr><tr><td>if [ -z str1 ]</td><td>当串的长度为0时为真(空串)</td></tr><tr><td>if [ str1 ]</td><td>当串str1为非空时为真</td></tr></tbody></table><p>shell 中利用 -n 来判定字符串非空。</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RunCommand() &#123;</span><br><span class="line">  if [[ -n "$VERBOSE_SCRIPT_LOGGING" ]]; then</span><br><span class="line">    echo "♦ $*"</span><br><span class="line">  fi</span><br><span class="line">  "$@"</span><br><span class="line">  return $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果<span class="variable">$VERBOSE_SCRIPT_LOGGING</span>值不为空，则通过<span class="string">"$*"</span>打印传递给脚本或函数的所有参数(将所有的参数作为一个整体输出)，如果为空，则通过<span class="string">"<span class="variable">$@</span>"</span>传递给脚本或函数的所有参数(将所有的参数依次分开输出)，并通过$?返回上个命令的退出状态，或函数的返回值。</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>使用[]和[[]]的时候不要吝啬空格，每一项两边都要有空格，[[ 1 == 2 ]]的结果为“假”，但[[ 1==2 ]]的结果为“真”！</li></ul><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><h3 id="1、数组里是否包含某个元素"><a href="#1、数组里是否包含某个元素" class="headerlink" title="1、数组里是否包含某个元素"></a>1、数组里是否包含某个元素</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">noBranchNames=("HEAD" "-&gt;")</span><br><span class="line">if [[ "$&#123;noBranchNames[*]&#125;" =~ $&#123;devBranchName&#125; ]]; then</span><br><span class="line">       #echo "devBranceMapString=$&#123;devBranceMapString&#125;"</span><br><span class="line">       packageMergerBranchString+="$&#123;devBranceName&#125;:$&#123;devBranceDes&#125;#"</span><br><span class="line">   else</span><br><span class="line">       echo $&#123;PackageErrorCode&#125;:$&#123;PackageErrorMessage&#125;</span><br><span class="line">       exit_script</span><br><span class="line">   fi</span><br></pre></td></tr></table></figure><h2 id="文件包含-公用代码"><a href="#文件包含-公用代码" class="headerlink" title="文件包含/公用代码"></a>文件包含/公用代码</h2><ul><li><p>权威知识请查看：</p><p><a href="https://www.runoob.com/linux/linux-shell-include-file.html" target="_blank" rel="noopener">Shell 文件包含</a></p><blockquote><p>testReturn1.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> OUTPUT_ARCHIVE_PATH=<span class="string">"/User/xxx/output/abc"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>d</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#!/bin/bash</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> . ./testReturn1.sh</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># source ./testReturn1.sh # 此种方式也可以</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># sh ./testReturn1.sh # 此种方式无法拿到另一个shell中的变量</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"OUTPUT_ARCHIVE_PATH=<span class="variable">$&#123;OUTPUT_ARCHIVE_PATH&#125;</span>"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote></li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="1、mkdir-p中的-p有什么用"><a href="#1、mkdir-p中的-p有什么用" class="headerlink" title="1、mkdir -p中的 p有什么用"></a>1、mkdir -p中的 p有什么用</h3><p>-p, –parents 需要时创建上层目录，如目录早已存在则不当作错误</p><p>命令格式：mkdir [-p] DirName</p><p>说明：建立一个子目录。</p><p>参数：-p 确保目录名称存在，如果目录不存在的就新创建一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="获取当前文件所在的目录"><a href="#获取当前文件所在的目录" class="headerlink" title="获取当前文件所在的目录"></a>获取当前文件所在的目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注意：$&#123;0&#125; 指的是执行这个方法的那个文件的所在目录。</span><br><span class="line"># 所以当外部不是执行脚本，而只是引用脚本，即使用如 source ./xx.sh 的时候，所以无法获取我们真正想要的当前文件的所在目录</span><br><span class="line">curdir=$(cd $(dirname $0); pwd)</span><br><span class="line">echo &quot;脚本$0当前文件所在的目录:$&#123;curdir&#125;&quot;</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Script </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Script </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4节：详解Future</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Future/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Future/</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter学习之三方库-网络库-轮播图库-下拉刷新库-跳转传值库-BaseWidght封装"><a href="#Flutter学习之三方库-网络库-轮播图库-下拉刷新库-跳转传值库-BaseWidght封装" class="headerlink" title="Flutter学习之三方库,网络库,轮播图库,下拉刷新库,跳转传值库,BaseWidght封装"></a>Flutter学习之三方库,网络库,轮播图库,下拉刷新库,跳转传值库,BaseWidght封装</h1><ul><li><a href="https://blog.csdn.net/qq1021380645/article/details/88790078" target="_blank" rel="noopener">Flutter学习之三方库,网络库,轮播图库,下拉刷新库,跳转传值库,BaseWidght封装</a></li></ul><p>Flutter的网络请求库：Dio</p><ul><li><a href="https://www.cnblogs.com/darecy/p/12863080.html" target="_blank" rel="noopener">《Flutter实战入门》下拉刷新组件的使用方法</a></li></ul><p>RefreshIndicator是Material风格的下拉刷新组件。</p><p>CupertinoSliverRefreshControl 是ios风格的下拉刷新控件。</p><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/yuzhiqiang_1993/article/details/89155870" target="_blank" rel="noopener">Flutter中的异步（Future、async、await、FutureBuilder）和 网络请求</a></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:dio/dio.dart'</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; getData() <span class="keyword">async</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"123"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Flutter中的网络请求<br>网络请求是非常典型的异步任务，下面我们就来结合网络请求来看看Flutter中的异步是如何使用的。</p><p>网络请求的方式有很多，这里我就直接用目前比较好用的DIO网络请求库 了，你也可以使用官方文档中的网络请求 ，都是可以的。</p><p>下面我们来简单用一用网络请求。</p><p>这里我使用的聚合上的一个接口</p><p>接口地址：<a href="http://v.juhe.cn/toutiao/index?type=keji&amp;key=4c52313fc9247e5b4176aed5ddd56ad7" target="_blank" rel="noopener">http://v.juhe.cn/toutiao/index?type=keji&amp;key=4c52313fc9247e5b4176aed5ddd56ad7</a></p><p>关于DIO如何使用这里就不讲了，Github上文档很详细，使用起来也很简单。<br>下面我们直接用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:dio/dio.dart'</span>; <span class="comment">// 导包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// 请求接口获取数据的方法</span></span></span><br><span class="line">Future&lt;Response&gt; getData() <span class="keyword">async</span> &#123;</span><br><span class="line"><span class="built_in">String</span> url = <span class="string">"http://v.juhe.cn/toutiao/index"</span>;</span><br><span class="line">    <span class="built_in">String</span> key = <span class="string">"4c52313fc9247e5b4176aed5ddd56ad7"</span>;</span><br><span class="line">    <span class="built_in">String</span> type = <span class="string">"keji"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"开始请求数据"</span>);</span><br><span class="line">  Response response = <span class="keyword">await</span> Dio().<span class="keyword">get</span>(url, queryParameters: &#123;<span class="string">"type"</span>: type, <span class="string">"key"</span>: key&#125;);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"请求完成"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意一下几点：</p><p>网络请求是耗时操作<br>要使用async来标明getData这个函数是一个异步函数<br>await 用于等待请求返回的结果，此时会阻塞掉后面的代码，只有当请求结束后面的代码才会执行<br>async标注的函数其返回值类型是Future<br>然后我们就可以在main函数中来接收网络请求后的结果了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  getData().then((result) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"接口返回的数据是:<span class="subst">$&#123;result&#125;</span>"</span>);</span><br><span class="line">  &#125;).whenComplete(()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"异步任务处理完成"</span>);</span><br><span class="line">  &#125;).catchError(()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"出现异常了"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我是在请求数据后面的代码呦！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看执行的结果：</p><p>这样一来，我们就完成了Flutter中的异步操作了，可以看到，相对于原生Android来讲，Flutter中的异步是非常简单的。</p><p>Flutter 请求网络数据时显示加载中<br>一个很常见的需求，在首次进入页面时，此时数据还需要从网络上获取，我们希望在网络请求完成之前显示一个加载页面，请求完成之后再显示数据。此时，我们就可以使用FutureBuilder来完成了</p><p>首先是接口请求函数，为了更明显的能看到加载控件的显示，这里的异步请求函数中我延时3秒后再请求数据，代码如下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:dio/dio.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_async/widget/loading.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This widget is the root of your application.</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'新闻列表'</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: MyHomePage(title: <span class="string">'新闻列表'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyHomePage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(widget.title),</span><br><span class="line">        ),</span><br><span class="line">        body: FutureBuilder(</span><br><span class="line">          future: _getNews(),</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot&lt;Response&gt; snapshot) &#123;</span><br><span class="line">            <span class="comment">/*表示数据成功返回*/</span></span><br><span class="line">            <span class="keyword">if</span> (snapshot.hasData) &#123;</span><br><span class="line">              Response response = snapshot.data;</span><br><span class="line">              <span class="keyword">return</span> Text(<span class="string">"<span class="subst">$&#123;response.data.toString()&#125;</span>"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> LoadingWidget();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * 请求接口获取数据</span></span></span><br><span class="line"><span class="comment"><span class="markdown">   */</span></span></span><br><span class="line">   Future&lt;Response&gt; _getNews() <span class="keyword">async</span> &#123;</span><br><span class="line">     <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">3</span>), () &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"延时三秒后请求数据"</span>);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> url = <span class="string">"http://v.juhe.cn/toutiao/index"</span>;</span><br><span class="line">  <span class="built_in">String</span> key = <span class="string">"4c52313fc9247e5b4176aed5ddd56ad7"</span>;</span><br><span class="line">  <span class="built_in">String</span> type = <span class="string">"keji"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"开始请求数据"</span>);</span><br><span class="line">  Response response =</span><br><span class="line">      <span class="keyword">await</span> Dio().<span class="keyword">get</span>(url, queryParameters: &#123;<span class="string">"type"</span>: type, <span class="string">"key"</span>: key&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"请求完成"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：<br><img src="https://img-blog.csdnimg.cn/20190411130933761.gif" alt="在这里插入图片描述"></p><p>下面是demo，需要的可以下载：<br><strong><a href="https://download.csdn.net/download/yuzhiqiang_1993/11106514" target="_blank" rel="noopener">flutter_async Demo</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第五章：详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3节：详解Platform Channel</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Platform%20Channel/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Platform%20Channel/</url>
      
        <content type="html"><![CDATA[<p>参考文章：</p><ul><li><p><a href="https://book.flutterchina.club/chapter11/platform-channel.html" target="_blank" rel="noopener">Flutter官方文档1：插件开发：平台通道简介</a></p></li><li><p><a href="https://www.jianshu.com/p/39575a90e820" target="_blank" rel="noopener">咸鱼技术：深入理解Flutter Platform Channel</a></p></li><li><p><a href="https://www.kikt.top/posts/flutter/channel/flutter-channel3/" target="_blank" rel="noopener">Flutter 原生通信 (三) - Flutter 调用 iOS</a></p></li><li><p><a href="https://www.kikt.top/posts/flutter/channel/flutter-channel4/" target="_blank" rel="noopener">Flutter 原生通信 (四) - iOS 通知 Flutter</a></p></li></ul><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><h3 id="1、Channel"><a href="#1、Channel" class="headerlink" title="1、Channel"></a>1、Channel</h3><p>Flutter定义了三种不同类型的Channel，分别如下：</p><table><thead><tr><th>Channel类型</th><th>用途</th></tr></thead><tbody><tr><td>BasicMessageChannel</td><td>用于传递字符串和半结构化的信息</td></tr><tr><td>MethodChannel</td><td>用于传递方法调用（method invocation）</td></tr><tr><td>EventChannel</td><td>用于数据流（event streams）的通信</td></tr></tbody></table><ul><li>MethodChannel传递的数据支持什么类型？</li><li>Dart数据类型与Android，iOS类型的对应关系是怎样的？</li></ul><p>这两个问题的答案同样来自官方文档：</p><table><thead><tr><th>Dart</th><th>Android</th><th>iOS</th></tr></thead><tbody><tr><td>null</td><td>null</td><td>nil (NSNull when nested)</td></tr><tr><td>bool</td><td>java.lang.Boolean</td><td>NSNumber numberWithBool:</td></tr><tr><td>int</td><td>java.lang.Integer</td><td>NSNumber numberWithInt:</td></tr><tr><td>int if 32 bits not enough</td><td>java.lang.Long</td><td>NSNumber numberWithLong:</td></tr><tr><td>double</td><td>java.lang.Double</td><td>NSNumber numberWithDouble:</td></tr><tr><td>String</td><td>java.lang.String</td><td>NSString</td></tr><tr><td>Uint8List</td><td>byte[]</td><td>FlutterStandardTypedData typedDataWithBytes:</td></tr><tr><td>Int32List</td><td>int[]</td><td>FlutterStandardTypedData typedDataWithInt32:</td></tr><tr><td>Int64List</td><td>long[]</td><td>FlutterStandardTypedData typedDataWithInt64:</td></tr><tr><td>Float64List</td><td>double[]</td><td>FlutterStandardTypedData typedDataWithFloat64:</td></tr><tr><td>List</td><td>java.util.ArrayList</td><td>NSArray</td></tr><tr><td>Map</td><td>java.util.HashMap</td><td>NSDictionary</td></tr></tbody></table><table><thead><tr><th>Class</th><th>Note</th></tr></thead><tbody><tr><td>BinaryCodec</td><td>二进制数据类型，泛型对应 ByteBuffer,传递 byte 数组时使用</td></tr><tr><td>JSONMessageCodec</td><td>Json消息类型，泛型对应 Object。传递 Json时可使用</td></tr><tr><td>StringCodec</td><td>字符串消息类型，泛型对应 String。传递字符串</td></tr><tr><td>StandardMessageCodec</td><td>标准消息类型，泛型对应 Object。传递 Map 等的时候可使用此类型</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第五章：详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：详解布局</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>参考文章：</p><ul><li><a href="https://www.jianshu.com/p/f2ce8842f39e" target="_blank" rel="noopener">Flutter了解之布局组件</a></li></ul><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><p>1.spaceEvently</p><p>一行中如果有2个widget(五个五角星暂且看成1个widget),那么除去2widget所占据的宽度，3个红色方块宽度是一样的， 如下图所示</p><p><img src="/Flutter/5详解/详解布局/20190708173715300.png" alt="img"></p><p>2.spaceBetween</p><p>一行中如果有2个widget,那么分布2端，如下图所示</p><p><img src="/Flutter/5详解/详解布局/20190708173455532.png" alt="img"></p><p>3.spaceAround</p><p>一行中如果有2个widget,那么每个widget左右都是相同的方块，如下图所示</p><p><img src="/Flutter/5详解/详解布局/20190708173628232.png" alt="img"></p><ul><li><a href="https://yuzhiqiang.blog.csdn.net/article/details/86496145?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscan&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscan&amp;utm_relevant_index=1" target="_blank" rel="noopener">Flutter中MainAxisAlignment和CrossAxisAlignment详解</a></li></ul><table><thead><tr><th>类型</th><th>含义</th><th>row举例</th><th>column举例</th></tr></thead><tbody><tr><td>start<br>(default)</td><td><strong>从行首开始排列。</strong>每行第一个弹性元素与行首对齐，同时所有后续的弹性元素与前一个对齐</td><td><img src="/Flutter/5详解/详解布局/row_start.png" alt="在这里插入图片描述" style="zoom:25%;"></td><td><img src="/Flutter/5详解/详解布局/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/column_start.png" alt="在这里插入图片描述" style="zoom:25%;"></td></tr><tr><td>start<br>textDirection: TextDirection.rtl,</td><td><strong>textDirection</strong>的值为从右至左</td><td><img src="/Flutter/5详解/详解布局/row_start-rtl.png" alt="row_start-rtl"></td><td><img src="/Flutter/5详解/详解布局/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/column_start-rtl.png" alt="在这里插入图片描述" style="zoom: 67%;"></td></tr><tr><td>center</td><td><strong>伸缩元素向每行中点排列。</strong>每行第一个元素到行首的距离将与每行最后一个元素到行尾的距离相同。</td><td><img src="/Flutter/5详解/详解布局/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/row_center.png" alt="在这里插入图片描述" style="zoom:25%;"></td><td><img src="/Flutter/5详解/详解布局/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/column_center.png" alt="在这里插入图片描述"></td></tr><tr><td>end</td><td><strong>从行尾开始排列。</strong>每行最后一个弹性元素与行尾对齐，其他元素将与后一个对齐。</td><td><img src="/Flutter/5详解/详解布局/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/row_end.png" alt="在这里插入图片描述" style="zoom:25%;"></td><td><img src="/Flutter/5详解/详解布局/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/column_end.png" alt="在这里插入图片描述"></td></tr><tr><td>space-between</td><td>在每行上均匀分配弹性元素。相邻元素间距离相同。<strong>每行第一个元素与行首对齐，每行最后一个元素与行尾对齐。</strong></td><td><img src="/Flutter/5详解/详解布局/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/row_space-between.png" alt="在这里插入图片描述" style="zoom:25%;"></td><td><img src="/Flutter/5详解/详解布局/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/column_space-between.png" alt="在这里插入图片描述"></td></tr><tr><td>space-around</td><td>在每行上均匀分配弹性元素。相邻元素间距离相同。<strong>每行第一个元素到行首的距离和每行最后一个元素到行尾的距离将会是相邻元素之间距离的一半。</strong></td><td><img src="/Flutter/5详解/详解布局/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/row_space-around.png" alt="在这里插入图片描述" style="zoom:25%;"></td><td><img src="/Flutter/5详解/详解布局/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/column_space-around.png" alt="在这里插入图片描述"></td></tr><tr><td>spaceEvenly</td><td>将主轴空白区域均分，使各个子控件间距相等</td><td><img src="/Flutter/5详解/详解布局/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/row_spaceEvenly.png" alt="在这里插入图片描述" style="zoom:25%;"></td><td><img src="/Flutter/5详解/详解布局/%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/column_spaceEvenly.png" alt="在这里插入图片描述"></td></tr></tbody></table><p>expand 要再column或row中使用</p><p>层叠</p><p><a href="https://book.flutterchina.club/chapter4/stack.html" target="_blank" rel="noopener">4.6 层叠布局 Stack、Positioned</a></p><p>eg：在视图上，显示loading动画</p><p>问：flutter text 左对齐_如何在Flutter中将文本垂直和水平居中？</p><p>答：首先可以使用Center让控件居中，其次使用textAlign设置水平居中，示例代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">child: Center(</span><br><span class="line">    child: Text(</span><br><span class="line">        <span class="string">"Hello World"</span>,</span><br><span class="line">         textAlign: TextAlign.center,</span><br><span class="line">    ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><h1 id="flutter-隐藏显示控件"><a href="#flutter-隐藏显示控件" class="headerlink" title="flutter 隐藏显示控件"></a>flutter 隐藏显示控件</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Offstage(</span><br><span class="line">  offstage: <span class="keyword">true</span>, <span class="comment">//true隐藏,false显示</span></span><br><span class="line">  child: <span class="string">'子控件'</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第五章：详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7节：详解Animation-1基础</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Animation-1%E5%9F%BA%E7%A1%80/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Animation-1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="详解Animation-1基础"><a href="#详解Animation-1基础" class="headerlink" title="详解Animation-1基础"></a>详解Animation-1基础</h1><p>参考文章：</p><ul><li><a href="https://flutterchina.club/tutorials/animation/" target="_blank" rel="noopener">Flutter中文网–教程：Flutter中的动画</a></li></ul><h2 id="一、动画入门"><a href="#一、动画入门" class="headerlink" title="一、动画入门"></a>一、动画入门</h2><p>请点击进入阅读：<a href="https://blog.csdn.net/shulianghan/article/details/115263070" target="_blank" rel="noopener">【Flutter】Animation 动画 ( Flutter 动画基本流程 | 创建动画控制器 | 创建动画 | 设置值监听器 | 设置状态监听器 | 布局中使用动画值 | 动画运行 )</a></p><h2 id="二、Animation、AnimationController、Tween"><a href="#二、Animation、AnimationController、Tween" class="headerlink" title="二、Animation、AnimationController、Tween"></a>二、Animation、AnimationController、Tween</h2><p>以下内容摘自：<a href="https://www.jianshu.com/p/92271239b7f6" target="_blank" rel="noopener">Flutter动画 2 - Animation、Tween 详解</a></p><p>Tween的唯一职责就是定义从输入范围到输出范围的映射。输入范围通常为0.0到1.0</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Tween doubleTween = <span class="keyword">new</span> Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">-200.0</span>, end: <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure><p><strong>AnimationController</strong> 首先是继承于 Animation 的, 相对Animation而言,AnimationController作用则是控制动画.它可以设置动画的时长,并且包含动画的执行方法,具体如下表格所示.</p><p>AnimationController 的常用操作说明:</p><table><thead><tr><th style="text-align:left">动画执行方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">forward()</td><td style="text-align:left">正向开始执行动画</td></tr><tr><td style="text-align:left">reverse()</td><td style="text-align:left">反向开始执行动画</td></tr><tr><td style="text-align:left">reset()</td><td style="text-align:left">重置动画到初始状态</td></tr><tr><td style="text-align:left">dispose()</td><td style="text-align:left">取消/停止动画</td></tr></tbody></table><p>flutter AnimationStatus 动画状态说明：</p><table><thead><tr><th style="text-align:left">AnimationStatus 动画状态值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">AnimationStatus.forward</td><td style="text-align:left">执行 controller.forward() 会回调此状态</td></tr><tr><td style="text-align:left">AnimationStatus.reverse</td><td style="text-align:left">执行 controller.reverse() 会回调此状态</td></tr><tr><td style="text-align:left">AnimationStatus.dismissed</td><td style="text-align:left">动画从 controller.reverse() 反向执行 结束时会回调此方法</td></tr><tr><td style="text-align:left">AnimationStatus.completed</td><td style="text-align:left">动画从 controller.forward() 正向执行 结束时会回调此方法</td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_animationController = AnimationController(duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">300</span>), </span><br><span class="line">                                           </span><br><span class="line"><span class="comment">// 位移动画</span></span><br><span class="line">_positionAnimation = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0</span>, end: <span class="number">50</span>).animate(_animationController)</span><br><span class="line">  ..addListener(() &#123;</span><br><span class="line">    setState(() &#123;&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色动画</span></span><br><span class="line">_colorAnimation = ColorTween(begin: Colors.orangeAccent, end: Colors.redAccent).animate(_animationController)</span><br><span class="line">  ..addListener(() &#123;</span><br><span class="line">    setState(() &#123;&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">                                           </span><br><span class="line">_animationController.addStatusListener((status) &#123;</span><br><span class="line"><span class="keyword">if</span> (status == AnimationStatus.completed) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"动画完成"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="三、旋转动画-RotationTransition"><a href="#三、旋转动画-RotationTransition" class="headerlink" title="三、旋转动画 RotationTransition"></a>三、旋转动画 RotationTransition</h2><ul><li><p><a href="https://blog.csdn.net/zl18603543572/article/details/95317780" target="_blank" rel="noopener">flutter RotationTransition实现旋转动画</a></p></li><li><p><a href="https://www.jianshu.com/p/4827b8dcf7ea" target="_blank" rel="noopener">Flutter动画 5 - Flutter内置动画组件</a></p></li><li><a href="https://www.manongdao.com/article-1309861.html" target="_blank" rel="noopener">flutter 旋转指定角度的动画组件</a></li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第五章：详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7节：详解Animation-2动画组</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Animation-2%E5%8A%A8%E7%94%BB%E7%BB%84/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Animation-2%E5%8A%A8%E7%94%BB%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="详解Animation-2动画组"><a href="#详解Animation-2动画组" class="headerlink" title="详解Animation-2动画组"></a>详解Animation-2动画组</h1><p>参考文章：</p><ul><li><a href="https://flutterchina.club/tutorials/animation/" target="_blank" rel="noopener">Flutter中文网–教程：Flutter中的动画</a></li></ul><h3 id="一、Animation动画组-串行"><a href="#一、Animation动画组-串行" class="headerlink" title="一、Animation动画组-串行"></a>一、Animation动画组-串行</h3><p>参考文档：</p><ul><li><a href="https://www.jianshu.com/p/c9fe6424f6c0" target="_blank" rel="noopener">Flutter动画 3 - Animation动画组</a></li></ul><p>串行动画的实现方案总共有三种,分别是 监听状态法, Interval时间间隔法, TweenSequence动画序列法.</p><h3 id="1、监听状态法"><a href="#1、监听状态法" class="headerlink" title="1、监听状态法"></a>1、监听状态法</h3><p>状态监听法主要通过AnimationController监听动画的<strong>completed</strong>状态,然后再去执行下一个动画,如此往复,直到所有动画完成.</p><p>例如现在我们需要实现先执行组件在0.3秒钟往下偏移50个单位,然后再执行在0.6s中组件的颜色由 橘色 变为 红色.</p><p>整体Demo代码如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterAnimationWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  TurnTableLotteryPage(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _FlutterAnimationWidgetState createState() =&gt; _FlutterAnimationWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FlutterAnimationWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FlutterAnimationWidget</span>&gt; <span class="title">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ①声明位移动画控制器和颜色动画控制器以及位移动画和颜色动画</span></span><br><span class="line">  AnimationController _animationController;</span><br><span class="line">  Animation&lt;<span class="built_in">double</span>&gt; _animation;</span><br><span class="line">  AnimationController _colorAnimationController;</span><br><span class="line">  Animation&lt;Color&gt; _colorAnimation;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ②分别创建位移、颜色的动画控制器和动画</span></span><br><span class="line">    _animationController = AnimationController(duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">300</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// Tween对象调用`animate()`函数直接传入上面的AnimationController</span></span><br><span class="line">    _animation = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0</span>, end: <span class="number">50</span>).animate(_animationController)</span><br><span class="line">      ..addListener(() &#123;</span><br><span class="line">        setState(() &#123;&#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    _colorAnimationController = AnimationController(duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">600</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line">    _colorAnimation = ColorTween(begin: Colors.orangeAccent, end: Colors.redAccent).animate(_colorAnimationController)</span><br><span class="line">      ..addListener(() &#123;</span><br><span class="line">        setState(() &#123;&#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ③最后,我们只需要监听位移动画完成状态之后执行颜色动画即可,</span></span><br><span class="line">    _animationController.addStatusListener((status) &#123;</span><br><span class="line">      <span class="keyword">if</span> (status == AnimationStatus.completed) &#123;</span><br><span class="line">        _colorAnimationController.forward();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> startEasyAnimation() &#123;</span><br><span class="line">    _animationController.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _animationController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">200</span>,</span><br><span class="line">              height: <span class="number">50</span>,</span><br><span class="line">              color: _colorAnimation.value,</span><br><span class="line">              margin: EdgeInsets.only(top: _animation.value),</span><br><span class="line">            ),</span><br><span class="line">            FlatButton(</span><br><span class="line">              onPressed: startEasyAnimation,</span><br><span class="line">              child: Text(</span><br><span class="line">                <span class="string">"点击执行最简单动画"</span>,</span><br><span class="line">                style: TextStyle(color: Colors.black38),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、Interval时间间隔法"><a href="#2、Interval时间间隔法" class="headerlink" title="2、Interval时间间隔法"></a>2、Interval时间间隔法</h3><p>上面的状态监听需要一个动画过程就写一个Controller,而且基本上还要每一个Controller都监听执行完成然后再去启动下一个Controller.如果一个动画过程有十几个,自己想想都是脑瓜子嗡嗡的.所以接下来我们就来介绍第二种方案 - <strong>Interval时间间隔法</strong> .</p><p><strong>Interval时间间隔法</strong> 的整体思路是一个动画Controller控制所有动画的执行.然后每一个动画只需要确认自己在整个动画的时间比重即可.</p><p>整体Demo代码如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterAnimationWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  TurnTableLotteryPage(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _FlutterAnimationWidgetState createState() =&gt; _FlutterAnimationWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FlutterAnimationWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FlutterAnimationWidget</span>&gt; <span class="title">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ①声明一个动画Controller和多个动画.</span></span><br><span class="line">  AnimationController _animationController;</span><br><span class="line">  Animation&lt;<span class="built_in">double</span>&gt; _animation;</span><br><span class="line">  Animation&lt;Color&gt; _colorAnimation;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 然初始化AnimationController,AnimationController的动画时间(**duration**)要设置成所有动画的总时长,例如这里我设定为600毫秒(_animation时长:300毫秒,_colorAnimation时长:300毫秒).</span></span><br><span class="line">    _animationController = AnimationController(duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">600</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// Tween对象调用`animate()`函数不再是直接传入上面的AnimationController,而是传入一个 CurvedAnimation 对象。</span></span><br><span class="line">    <span class="comment">// 其中CurvedAnimation构建过程中需要传入两个参数一个是 parent ,用于指定AnimationController. 另外一个是 curve,用于指定动画曲线函数.我们可以使用常用的动画曲线函数,也可以自己生成,这里我们就自己生成.指定动画执行的时间区间.</span></span><br><span class="line">    _animation = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0</span>, end: <span class="number">50</span>).animate(</span><br><span class="line">      CurvedAnimation(</span><br><span class="line">        parent: _animationController,</span><br><span class="line">        curve: Interval(<span class="number">0.0</span>, <span class="number">0.5</span>), <span class="comment">// 由于两个动画时间长度是对分的,每一个都是300毫秒,所以 curve 参数中的值就分别是 **Interval(0.0, 0.5)**、**Interval(0.5, 1.0)**</span></span><br><span class="line">      ),</span><br><span class="line">    )..addListener(() &#123;</span><br><span class="line">        setState(() &#123;&#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    _colorAnimation = ColorTween(begin: Colors.orangeAccent, end: Colors.redAccent).animate(</span><br><span class="line">      CurvedAnimation(</span><br><span class="line">        parent: _animationController,</span><br><span class="line">        curve: Interval(<span class="number">0.5</span>, <span class="number">1.0</span>),<span class="comment">// 由于两个动画时间长度是对分的,每一个都是300毫秒,所以 curve 参数中的值就分别是 **Interval(0.0, 0.5)**、**Interval(0.5, 1.0)**</span></span><br><span class="line">      ),</span><br><span class="line">    )..addListener(() &#123;</span><br><span class="line">        setState(() &#123;&#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> startEasyAnimation() &#123;</span><br><span class="line">    _animationController.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _animationController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">200</span>,</span><br><span class="line">              height: <span class="number">50</span>,</span><br><span class="line">              color: _colorAnimation.value,</span><br><span class="line">              margin: EdgeInsets.only(top: _animation.value),</span><br><span class="line">            ),</span><br><span class="line">            FlatButton(</span><br><span class="line">              onPressed: startEasyAnimation,</span><br><span class="line">              child: Text(</span><br><span class="line">                <span class="string">"点击执行最简单动画"</span>,</span><br><span class="line">                style: TextStyle(color: Colors.black38),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、TweenSequence动画序列法"><a href="#3、TweenSequence动画序列法" class="headerlink" title="3、TweenSequence动画序列法"></a>3、TweenSequence动画序列法</h3><p>上面的两种方案虽然能解决动画组的问题,但是都太过于繁琐,那么有没有一种比较优雅的方案呢?这就需要使用到 <strong>TweenSequence</strong> 和 <strong>TweenSequenceItem</strong> 这两个类了. 其中 <strong>TweenSequence</strong> 是动画组类,<strong>TweenSequenceItem</strong> 则是用来定义每一个动画的具体实现的类.但是<strong>TweenSequence</strong> 和 <strong>TweenSequenceItem</strong>也不是尽善尽美的,它最大的问题就是前后变化的属性值类型必须是一致的.</p><p>下面,我们仍然以改变Margin为例, 先让视图组件往上移动50,再让视图 来看看如何使用 <strong>TweenSequence</strong> 和 <strong>TweenSequenceItem</strong> 来实现这个动画.</p><p>整体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterAnimationWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  TurnTableLotteryPage(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">_FlutterAnimationWidgetState <span class="title">createState</span><span class="params">()</span> </span>=&gt; _FlutterAnimationWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FlutterAnimationWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FlutterAnimationWidget</span>&gt; <span class="title">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ①声明一个 动画控制器AnimationController 和 动画Animation.</span></span><br><span class="line">  AnimationController _animationController;</span><br><span class="line">  Animation&lt;<span class="keyword">double</span>&gt; _animation;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 仍然以两者的动画总时长为600毫秒为例</span></span><br><span class="line">    _animationController = AnimationController(duration: Duration(milliseconds: <span class="number">600</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 然后,我们通过 **TweenSequence** 和 **TweenSequenceItem** 这两个类对 动画Animation 进行实现.</span></span><br><span class="line">    <span class="comment">// 实现两个 **TweenSequenceItem**, **TweenSequenceItem**中的 &lt;font color=red&gt;weight&lt;/font&gt; 属性是来设定动画执行的时间权重.也就是在整个动画过程,当前动画执行时长占总时长的比例.例如下面 第一个动画插值占的时间比例为 `50/(50 + 100)`. 第二个动画插值占的时间比例为 `100/(50 + 100)` .</span></span><br><span class="line">    TweenSequenceItem downMarginItem = TweenSequenceItem&lt;<span class="keyword">double</span>&gt;(</span><br><span class="line">      tween: Tween(begin: <span class="number">1.0</span>, end: <span class="number">50.0</span>),</span><br><span class="line">      weight: <span class="number">50</span>,</span><br><span class="line">    );</span><br><span class="line">    TweenSequenceItem upMarginItem = TweenSequenceItem&lt;<span class="keyword">double</span>&gt;(</span><br><span class="line">      tween: Tween(begin: <span class="number">50.0</span>, end: <span class="number">100.0</span>),</span><br><span class="line">      weight: <span class="number">100</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 然后创建一个动画插值组,把上面两个动画插值放入组中.</span></span><br><span class="line">    TweenSequence tweenSequence = TweenSequence&lt;<span class="keyword">double</span>&gt;([</span><br><span class="line">      downMarginItem,</span><br><span class="line">      upMarginItem,</span><br><span class="line">    ]);</span><br><span class="line">    <span class="comment">// 最后,生成动画就OK了.</span></span><br><span class="line">    _animation = tweenSequence.animate(_animationController);</span><br><span class="line">    _animation.addListener(() &#123;</span><br><span class="line">      setState(() &#123;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">startEasyAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _animationController.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _animationController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">200</span>,</span><br><span class="line">              height: <span class="number">50</span>,</span><br><span class="line">              color: Colors.orangeAccent,</span><br><span class="line">              margin: EdgeInsets.only(top: _animation.value),</span><br><span class="line">            ),</span><br><span class="line">            FlatButton(</span><br><span class="line">              onPressed: startEasyAnimation,</span><br><span class="line">              child: Text(</span><br><span class="line">                <span class="string">"点击执行最简单动画"</span>,</span><br><span class="line">                style: TextStyle(color: Colors.black38),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="动画组实现总结"><a href="#动画组实现总结" class="headerlink" title="动画组实现总结"></a>动画组实现总结</h5><p>上面三种实现动画组基本上已经说完了,接下来我们就来对比其不同点.</p><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:center">监听状态法</th><th style="text-align:center">Interval时间间隔法</th><th style="text-align:center">TweenSequence动画序列法</th></tr></thead><tbody><tr><td style="text-align:left">代码简洁度</td><td style="text-align:center">🔅🔅</td><td style="text-align:center">🔅🔅🔅</td><td style="text-align:center">🔅🔅🔅🔅🔅</td></tr><tr><td style="text-align:left">动画是否可交织</td><td style="text-align:center">❌</td><td style="text-align:center">✅</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:left">动画属性是否可以多变</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">❌</td></tr></tbody></table><blockquote><p><strong>动画是否可交织</strong> : 动画可否交织主要是说两个动画之间是否需要上一个动画完全执行完成之后,下一个动画才能执行.</p></blockquote><blockquote><p><strong>动画属性是否可以多变</strong> : 动画属性多变是指当前动画过程中可变化的属性是否可以有多个,例如同时变化尺寸和颜色等等.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第五章：详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7节：详解Animation-3转场</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Animation-3%E8%BD%AC%E5%9C%BA/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Animation-3%E8%BD%AC%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="详解Animation-3转场"><a href="#详解Animation-3转场" class="headerlink" title="详解Animation-3转场"></a>详解Animation-3转场</h1><p>参考文章：</p><ul><li><a href="https://flutterchina.club/tutorials/animation/" target="_blank" rel="noopener">Flutter中文网–教程：Flutter中的动画</a></li></ul><h2 id="一、动画入门"><a href="#一、动画入门" class="headerlink" title="一、动画入门"></a>一、动画入门</h2><ul><li><a href="https://www.jianshu.com/p/323e8ef6ba07" target="_blank" rel="noopener">Flutter动画 4 -转场动画比较常见的飞入飞出动画 - Hero动画</a></li><li><a href="https://www.jianshu.com/p/4827b8dcf7ea" target="_blank" rel="noopener">Flutter动画 5 - Flutter内置动画组件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第五章：详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7节：详解Animation-4曲线Curves</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Animation-4%E6%9B%B2%E7%BA%BFCurves/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Animation-4%E6%9B%B2%E7%BA%BFCurves/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="详解Animation-4曲线Curves"><a href="#详解Animation-4曲线Curves" class="headerlink" title="详解Animation-4曲线Curves"></a>详解Animation-4曲线Curves</h1><h2 id="Flutter-Curves详解"><a href="#Flutter-Curves详解" class="headerlink" title="Flutter Curves详解"></a>Flutter Curves详解</h2><ul><li><a href="https://www.jianshu.com/p/ef1b6212bcb8" target="_blank" rel="noopener">Flutter Curves详解</a></li></ul><p>1.linear 匀速，线性</p><p><img src="https://upload-images.jianshu.io/upload_images/14121842-f87a9b40cbcf103e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200" alt="img"></p><p>linear</p><p>2.decelerate f(t) = √2</p><p><img src="https:////upload-images.jianshu.io/upload_images/14121842-f9149545ba497aaa.png?imageMogr2/auto-orient/strip|imageView2/2/w/467" alt="img"></p><p>decelerate </p><p>3.ease</p><p><img src="https:////upload-images.jianshu.io/upload_images/14121842-ae2fc1a725cc4556.png?imageMogr2/auto-orient/strip|imageView2/2/w/464" alt="img"></p><p>ease</p><p>4.easeIn</p><p><img src="https:////upload-images.jianshu.io/upload_images/14121842-aa1216315847db93.png?imageMogr2/auto-orient/strip|imageView2/2/w/474" alt="img"></p><p>easeIn</p><p>5.easeInToLinear</p><p><img src="https:////upload-images.jianshu.io/upload_images/14121842-36fc01dc5b86df49.png?imageMogr2/auto-orient/strip|imageView2/2/w/464" alt="img"></p><p>easeInToLinear</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第五章：详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：详解Image</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Image/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Image/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>参考文章：</p><ul><li><a href="https://www.jianshu.com/p/a9d91a55d48c" target="_blank" rel="noopener">Image</a></li><li><a href="https://flutter.cn/docs/reference/widgets" target="_blank" rel="noopener">Flutter Widget 目录</a></li></ul><h2 id="7、gaplessPlayback"><a href="#7、gaplessPlayback" class="headerlink" title="7、gaplessPlayback"></a>7、gaplessPlayback</h2><p>当ImageProvider发生变化后，重新加载图片的过程中，原图片的展示是否保留。若值为true，保留，若为false，不保留，直接空白等待下一张图片加载。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第五章：详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：详解TextField</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3TextField/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3TextField/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>参考文章：</p><ul><li><a href="https://docs.flutter.io/flutter/material/TextField-class.html" target="_blank" rel="noopener">Flutter官方文档：TextField class</a></li></ul><h2 id="一、TextField-class"><a href="#一、TextField-class" class="headerlink" title="一、TextField class"></a>一、TextField class</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TextField(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.controller,<span class="comment">// 文本控制器，详见下文</span></span><br><span class="line">    <span class="keyword">this</span>.focusNode,<span class="comment">// 焦点，详见下文</span></span><br><span class="line">    <span class="keyword">this</span>.decoration = <span class="keyword">const</span> InputDecoration(),<span class="comment">// 输入框装饰器，详见下文</span></span><br><span class="line">    TextInputType keyboardType,</span><br><span class="line">    <span class="keyword">this</span>.textInputAction,<span class="comment">//更改键盘本身的操作按钮，详见下文</span></span><br><span class="line">    <span class="keyword">this</span>.textCapitalization = TextCapitalization.none, <span class="comment">//提供了一些有关如何使用户输入中的字母大写的选项</span></span><br><span class="line">    <span class="keyword">this</span>.style,</span><br><span class="line">    <span class="keyword">this</span>.textAlign = TextAlign.start,</span><br><span class="line">    <span class="keyword">this</span>.textDirection,</span><br><span class="line">    <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,<span class="comment">// 是否自动获取焦点</span></span><br><span class="line">    <span class="keyword">this</span>.obscureText = <span class="keyword">false</span>,<span class="comment">// 是否隐藏正在编辑的文本，如用于输入密码的场景等，文本内容会用“•”替换。</span></span><br><span class="line">    <span class="keyword">this</span>.autocorrect = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.maxLines = <span class="number">1</span>,<span class="comment">// 能写入的最大行数</span></span><br><span class="line">    <span class="keyword">this</span>.maxLength,<span class="comment">// 能写入的最大字符数</span></span><br><span class="line">    <span class="keyword">this</span>.maxLengthEnforced = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.onChanged,<span class="comment">// 文本框事件：文字改变触发</span></span><br><span class="line">    <span class="keyword">this</span>.onEditingComplete,<span class="comment">// 文本框事件：当用户提交可编辑内容时调用(常用于“焦点(FocusNode)”变更)</span></span><br><span class="line">    <span class="keyword">this</span>.onSubmitted,<span class="comment">// 文本框事件：文字提交触发（键盘按键）</span></span><br><span class="line">    <span class="keyword">this</span>.inputFormatters,</span><br><span class="line">    <span class="keyword">this</span>.enabled,</span><br><span class="line">    <span class="keyword">this</span>.cursorWidth = <span class="number">2.0</span>,<span class="comment">// 光标宽度 Colors.red</span></span><br><span class="line">    <span class="keyword">this</span>.cursorRadius,<span class="comment">// 光标半径 Radius.circular(16.0)</span></span><br><span class="line">    <span class="keyword">this</span>.cursorColor,<span class="comment">// 光标颜色 16.0</span></span><br><span class="line">    <span class="keyword">this</span>.keyboardAppearance,</span><br><span class="line">    <span class="keyword">this</span>.scrollPadding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">    <span class="keyword">this</span>.enableInteractiveSelection = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.onTap,<span class="comment">// 文本框事件：</span></span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(textAlign != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(autofocus != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(obscureText != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(autocorrect != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(maxLengthEnforced != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(scrollPadding != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(maxLines == <span class="keyword">null</span> || maxLines &gt; <span class="number">0</span>),</span><br><span class="line">       <span class="keyword">assert</span>(maxLength == <span class="keyword">null</span> || maxLength &gt; <span class="number">0</span>),</span><br><span class="line">       keyboardType = keyboardType ?? (maxLines == <span class="number">1</span> ? TextInputType.text : TextInputType.multiline),</span><br><span class="line">       <span class="keyword">assert</span>(enableInteractiveSelection != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">super</span>(key: key);</span><br></pre></td></tr></table></figure><h2 id="二、文本框的输入器装饰-InputDecoration-decoration"><a href="#二、文本框的输入器装饰-InputDecoration-decoration" class="headerlink" title="二、文本框的输入器装饰 InputDecoration decoration"></a>二、文本框的输入器装饰 InputDecoration decoration</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> InputDecoration(&#123;</span><br><span class="line">    <span class="keyword">this</span>.icon,</span><br><span class="line">    <span class="keyword">this</span>.labelText,</span><br><span class="line">    <span class="keyword">this</span>.labelStyle,</span><br><span class="line">    <span class="keyword">this</span>.helperText,</span><br><span class="line">    <span class="keyword">this</span>.helperStyle,</span><br><span class="line">    <span class="keyword">this</span>.hintText,</span><br><span class="line">    <span class="keyword">this</span>.hintStyle,</span><br><span class="line">    <span class="keyword">this</span>.errorText,</span><br><span class="line">    <span class="keyword">this</span>.errorStyle,</span><br><span class="line">    <span class="keyword">this</span>.errorMaxLines,</span><br><span class="line">    <span class="keyword">this</span>.hasFloatingPlaceholder = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.isDense,</span><br><span class="line">    <span class="keyword">this</span>.contentPadding,</span><br><span class="line">    <span class="keyword">this</span>.prefixIcon,</span><br><span class="line">    <span class="keyword">this</span>.prefix,</span><br><span class="line">    <span class="keyword">this</span>.prefixText,</span><br><span class="line">    <span class="keyword">this</span>.prefixStyle,</span><br><span class="line">    <span class="keyword">this</span>.suffixIcon,</span><br><span class="line">    <span class="keyword">this</span>.suffix,</span><br><span class="line">    <span class="keyword">this</span>.suffixText,</span><br><span class="line">    <span class="keyword">this</span>.suffixStyle,</span><br><span class="line">    <span class="keyword">this</span>.counterText,</span><br><span class="line">    <span class="keyword">this</span>.counterStyle,</span><br><span class="line">    <span class="keyword">this</span>.filled,</span><br><span class="line">    <span class="keyword">this</span>.fillColor,</span><br><span class="line">    <span class="keyword">this</span>.errorBorder,</span><br><span class="line">    <span class="keyword">this</span>.focusedBorder,</span><br><span class="line">    <span class="keyword">this</span>.focusedErrorBorder,</span><br><span class="line">    <span class="keyword">this</span>.disabledBorder,</span><br><span class="line">    <span class="keyword">this</span>.enabledBorder,</span><br><span class="line">    <span class="keyword">this</span>.border,</span><br><span class="line">    <span class="keyword">this</span>.enabled = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.semanticCounterText,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(enabled != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(!(prefix != <span class="keyword">null</span> &amp;&amp; prefixText != <span class="keyword">null</span>), <span class="string">'Declaring both prefix and prefixText is not allowed'</span>),</span><br><span class="line">       <span class="keyword">assert</span>(!(suffix != <span class="keyword">null</span> &amp;&amp; suffixText != <span class="keyword">null</span>), <span class="string">'Declaring both suffix and suffixText is not allowed'</span>),</span><br><span class="line">       isCollapsed = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>图解如下：</p><p><img src="/Flutter/5详解/详解TextField/Screenshots/Flutter TextField.png" alt="Flutter TextField"></p><p>输入器装饰 <strong>InputDecoration decoration</strong>的其他参数</p><table><thead><tr><th>参数</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>contentPadding</td><td>内容的边距，默认是有一个边距的</td><td>contentPadding: new EdgeInsets.all(0.0)</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="2、文本控制器-TextEditingController-controller"><a href="#2、文本控制器-TextEditingController-controller" class="headerlink" title="2、文本控制器 TextEditingController controller"></a>2、文本控制器 TextEditingController controller</h3><p><code>controller.clear()</code> 清空了用户名输入框中的内容</p><h3 id="3、键盘输入类型-TextInputType-keyboardType"><a href="#3、键盘输入类型-TextInputType-keyboardType" class="headerlink" title="3、键盘输入类型 TextInputType keyboardType"></a>3、键盘输入类型 TextInputType keyboardType</h3><p>键盘输入类型（数字，文本等各种类型）：设置TextField获得焦点的时候弹出的键盘</p><table><thead><tr><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>TextInputType.number</td><td>数字键盘</td></tr><tr><td>TextInputType.text</td><td>普通完整键盘</td></tr><tr><td>TextInputType.emailAddress</td><td>带有“@”的普通键盘</td></tr><tr><td>TextInputType.datetime</td><td>带有“/”和“：”的数字键盘</td></tr><tr><td>TextInputType.multiline</td><td>带有选项以启用有符号和十进制模式的数字键盘</td></tr></tbody></table><h3 id="4、键盘本身的操作按钮-TextInputAction"><a href="#4、键盘本身的操作按钮-TextInputAction" class="headerlink" title="4、键盘本身的操作按钮 TextInputAction"></a>4、键盘本身的操作按钮 TextInputAction</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  textInputAction: TextInputAction.search,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><h3 id="5、TextCapitalization"><a href="#5、TextCapitalization" class="headerlink" title="5、TextCapitalization"></a>5、TextCapitalization</h3><table><thead><tr><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>TextCapitalization.characters</td><td>大写句子中的所有字符</td></tr><tr><td>TextCapitalization.words</td><td>将每个单词的首字母大写</td></tr><tr><td></td></tr></tbody></table><h3 id="6、文本框的其他参数"><a href="#6、文本框的其他参数" class="headerlink" title="6、文本框的其他参数"></a>6、文本框的其他参数</h3><p>见类结构</p><h2 id="二、键盘"><a href="#二、键盘" class="headerlink" title="二、键盘"></a>二、键盘</h2><p>Flutter | 滚动 PageView 自动关闭键盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageView(</span><br><span class="line">onPageChanged: (index) &#123;</span><br><span class="line">WidgetsBinding.instance?.focusManager.primaryFocus?.unfocus();</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第五章：详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：详解Button</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Button/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/%E8%AF%A6%E8%A7%A3Button/</url>
      
        <content type="html"><![CDATA[<p>参考文章：</p><ul><li><a href="https://docs.flutter.io/flutter/material/FlatButton-class.html" target="_blank" rel="noopener">Flutter官方文档：FlatButton class</a></li></ul><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><h3 id="1、继承关系"><a href="#1、继承关系" class="headerlink" title="1、继承关系"></a>1、继承关系</h3><p>Object &gt; Diagnosticable &gt; DiagnosticableTree &gt; Widget &gt; StatelessWidget &gt; MaterialButton &gt; RaisedButton、FlatButton、OutlineButton</p><ul><li>2021-12-18</li></ul><p>TextButton 是 1.20.0 推出的一个新的按钮</p><p><a href="https://zhuanlan.zhihu.com/p/278330232" target="_blank" rel="noopener">Flutter TextButton 详细使用配置、Flutter ButtonStyle概述实践</a></p><p>flutter 2.0版本新增了三个按钮</p><blockquote><p>TextButton、OutlinedButton、ElevatedButton</p></blockquote><h3 id="2、类"><a href="#2、类" class="headerlink" title="2、类"></a>2、类</h3><table><thead><tr><th>类</th><th></th></tr></thead><tbody><tr><td>RaisedButton</td><td>Material Design中的button， 一个凸起的材质矩形按钮。</td></tr><tr><td>FlatButton</td><td>Material Design中的button，一个没有阴影的材质设计按钮。</td></tr><tr><td>OutlineButton</td><td>Material Design中的button，RaisedButton和FlatButton之间的交叉：一个带边框的背景透明的按钮，当按下按钮时，其高度增加，背景变得不透明。</td></tr><tr><td><a href="https://docs.flutter.io/flutter/material/IconButton-class.html" target="_blank" rel="noopener">IconButton</a></td><td>用于创建仅包含图标的按钮，参数就不再讲解</td></tr><tr><td>DropdownButton</td><td>一个显示可供选择的选项的按钮</td></tr><tr><td>FloatingActionButton</td><td>材质应用程序中的圆形按钮</td></tr><tr><td>InkWell</td><td>实现平面按钮的墨水飞溅部分</td></tr></tbody></table><p>RaisedButton、FlatButton、OutlineButton三个控件都继承于MaterialButton，查看源码会发现MaterialButton由RawMaterialButton（无主题Button）构建的。而RawMaterialButton与CupertinoButton是一对button组合，都继承于StatefulWidget，前者是google风格，后者iOS风格！</p><p>附：使用CupertionBUtton要注意导入库：import ‘package:flutter/cupertino.dart’;</p><h2 id="二、-MaterialButton参数详解"><a href="#二、-MaterialButton参数详解" class="headerlink" title="二、 MaterialButton参数详解"></a>二、 MaterialButton参数详解</h2><p>这里我们仅对个别不好理解的做解释。</p><table><thead><tr><th>属性</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>VoidCallback onPressed</td><td>点击激活按钮时调用的方法</td><td></td></tr><tr><td>ValueChanged<bool> onHighlightChanged</bool></td><td>按下和抬起时都会调用的方法，详看后面示例</td><td></td></tr><tr><td>ButtonTextTheme textTheme</td><td>定义按钮的基色，以及按钮的最小尺寸，内部填充和形状的默认值。</td><td></td></tr><tr><td>Color disabledTextColor</td><td>未设置按钮点击回调时使用的文本颜色</td><td></td></tr><tr><td>Color splashColor</td><td>按钮被按下的水波纹颜色，默认是有值的，<strong>不要要水波纹效果设置透明颜色即可！</strong></td><td></td></tr><tr><td>colorBrightness</td><td>按钮的主题亮度，当设置了textColor、color颜色，此值无效!</td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>更多内容参考：<a href="https://blog.csdn.net/chenlove1/article/details/84828049" target="_blank" rel="noopener">Flutter RaisedButton、FlatButton、OutlineButton 参数详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第五章：详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：详解Platform Channel</title>
      <link href="/Flutter/5%E8%AF%A6%E8%A7%A3/README/"/>
      <url>/Flutter/5%E8%AF%A6%E8%A7%A3/README/</url>
      
        <content type="html"><![CDATA[<p>本章介绍</p><ul><li>①详解Button</li><li>②详解TextField</li><li>③详解Platform Channel</li></ul><p><a href="https://docs.flutter.io/flutter/material/material-library.html" target="_blank" rel="noopener">官网文档：material library</a></p><hr><p><a href="/Flutter/5详解/详解Platform Channel">点击此处，进入本章第1节的正式学习 &gt;</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：Swift基础知识</title>
      <link href="/iOS/Swift/1%E5%85%A5%E9%97%A8/1.Swift%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/iOS/Swift/1%E5%85%A5%E9%97%A8/1.Swift%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><ul><li>一、基础部分</li><li>二、基本运算符</li></ul><h2 id="OC与Swift混编"><a href="#OC与Swift混编" class="headerlink" title="OC与Swift混编"></a>OC与Swift混编</h2><p>原本在 swift 3 中除了手动添加 @objc 声明函数支持 OC 调用还有另外一种方式：继承 NSObject。</p><p>即class 继承了 NSObject 后，编译器就会默认给这个类中的所有函数都标记为 @objc ，支持 OC 调用。</p><p>然而在实际项目中，一个 swift 类虽然继承了 NSObject，但是其中还是有很多函数不会在 OC 中被调用，这里有很大的优化空间。</p><p>于是根据 SE160 的建议，苹果修改了自动添加 @objc 的逻辑：<strong>现在一个继承 NSObject 的 swift 类不再默认给所有函数添加 @objc。只在实现 OC 接口和重写 OC 方法时才自动给函数添加 @objc 标识。</strong></p><p>XCode 9会在运行过程中自行检测类中函数是被 OC 调用，然后提示添加 @objc。下图中的 vc 是 swift 中的类，showStatus 也是 swift 函数，现在编译器会提示需要手动添加 @objc：</p><h2 id="Swift概念新增-区别"><a href="#Swift概念新增-区别" class="headerlink" title="Swift概念新增/区别"></a>Swift概念新增/区别</h2><p>swift的guard语句的时候，我当时不太理解以后会有什么理由能用到它。这个语句的介绍如下：</p><blockquote><p>与if语句相同的是，guard也是基于一个表达式的布尔值去判断一段代码是否该被执行。与if语句不同的是，guard只有在条件不满足的时候才会执行这段代码。你可以把guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。</p></blockquote><ul><li><a href="https://blog.csdn.net/feng2qing/article/details/53614708" target="_blank" rel="noopener">Swift中函数的默认值和传参省略</a>：有默认值才可以省略参数</li></ul><h2 id="一、基础部分"><a href="#一、基础部分" class="headerlink" title="一、基础部分"></a>一、基础部分</h2><p>Swift基础部门：<a href="http://www.swift51.com/swift4.0/chapter2/01_The_Basics.html" target="_blank" rel="noopener">http://www.swift51.com/swift4.0/chapter2/01_The_Basics.html</a></p><h3 id="1、声明常量和变量"><a href="#1、声明常量和变量" class="headerlink" title="1、声明常量和变量"></a>1、声明常量和变量</h3><p><strong>声明变量时在类型后添加？或者！，就是告诉编译器这是一个Optional的变量，如果没有初始化，你就将其初始化为nil</strong></p><p>常量和变量必须在使用前声明，用 <code>let</code> 来声明常量，用 <code>var</code> 来声明变量。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maximumNumberOfLoginAttempts = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> currentLoginAttempt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在一行中声明多个常量或者多个变量，用逗号隔开：</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span>, z = <span class="number">0.0</span></span><br></pre></td></tr></table></figure><p>与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> languageName = <span class="string">"Swift"</span></span><br><span class="line">languageName = <span class="string">"Swift++"</span></span><br><span class="line"><span class="comment">// 这会报编译时错误 - languageName 不可改变</span></span><br></pre></td></tr></table></figure><h4 id="附：类型标注"><a href="#附：类型标注" class="headerlink" title="附：类型标注"></a>附：类型标注</h4><p>Swift可以根据赋值推断出类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">PI</span> = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">Str</span> = <span class="string">"string"</span></span><br></pre></td></tr></table></figure><p>你也可以使用类型标注（type annotation）来指定类型。在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。声明中的冒号代表着<em>“是…类型”</em></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcomeMessage: <span class="type">String</span> = <span class="string">"string"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：</span></span><br><span class="line"><span class="keyword">var</span> red, green, blue: <span class="type">Double</span></span><br></pre></td></tr></table></figure><h3 id="2、输出print"><a href="#2、输出print" class="headerlink" title="2、输出print"></a>2、输出print</h3><p>Swift使用<a href="http://www.swift51.com/swift4.0/chapter2/03_Strings_and_Characters.html#string_interpolation" target="_blank" rel="noopener">字符串插值</a>（string interpolation）的方式将常量或变量当作占位符加入到长字符串中，我们可以借此拼接长字符。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">var</span> value2 = <span class="number">345</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"value1 = \(value1) , value2 = \(value2)"</span>)</span><br><span class="line"><span class="comment">// 输出： value1 = 123 , value2 = 345</span></span><br></pre></td></tr></table></figure><h3 id="3、数据类型（布尔值、数组、字典、元组、可选类型）"><a href="#3、数据类型（布尔值、数组、字典、元组、可选类型）" class="headerlink" title="3、数据类型（布尔值、数组、字典、元组、可选类型）"></a>3、数据类型（布尔值、数组、字典、元组、可选类型）</h3><h4 id="3-1、布尔值"><a href="#3-1、布尔值" class="headerlink" title="3.1、布尔值"></a>3.1、布尔值</h4><p>和OC不同，Swift中的布尔值使用<code>true</code>和<code>false</code>表示真、假</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> boolValue = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> boolValue &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"value is true"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明的是，<strong>Swift不能像OC中那样，数值为0即表示布尔值<code>NO</code>，非0即为<code>YES</code></strong>，因此下面OC代码可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float value = 0.001;</span><br><span class="line">if (value) &#123;</span><br><span class="line">    NSLog(@&quot;value:%f&quot;,value);</span><br><span class="line">&#125;</span><br><span class="line">// 输出： value:0.001000</span><br></pre></td></tr></table></figure><p>而在Swift中会编译报错</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> boolValue = <span class="number">0.001</span></span><br><span class="line"><span class="keyword">if</span> boolValue &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"value is true"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2、可选类型"><a href="#3-2、可选类型" class="headerlink" title="3.2、可选类型"></a>3.2、可选类型</h4><h5 id="3-2-1、可选类型"><a href="#3-2-1、可选类型" class="headerlink" title="3.2.1、可选类型"></a>3.2.1、可选类型</h5><p>使用<em>可选类型（optionals）</em>来处理值可能缺失的情况。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleNumber = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">let</span> convertedNumber = <span class="type">Int</span>(possibleNumber)</span><br><span class="line"><span class="comment">// convertedNumber 被推测为类型 "Int?"， 或者类型 "optional Int"</span></span><br></pre></td></tr></table></figure><p>因为该构造器可能会失败，所以它返回一个<em>可选类型</em>（optional）<code>Int</code>，而不是一个 <code>Int</code>。一个可选的 <code>Int</code> 被写作 <code>Int?</code> 而不是 <code>Int</code>。问号暗示包含的值是可选类型，也就是说可能包含 <code>Int</code> 值也可能<em>不包含值</em>。（不能包含其他任何值比如 <code>Bool</code> 值或者 <code>String</code> 值。只能是 <code>Int</code> 或者什么都没有。）</p><h5 id="3-2-2、隐式解析可选类型"><a href="#3-2-2、隐式解析可选类型" class="headerlink" title="3.2.2、隐式解析可选类型"></a>3.2.2、隐式解析可选类型</h5><p>可选类型 <code>String</code> 和隐式解析可选类型 <code>String</code> 之间的区别：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String</span>? = <span class="string">"An optional string."</span></span><br><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> = possibleString! <span class="comment">// 需要感叹号来获取值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! = <span class="string">"An implicitly unwrapped optional string."</span></span><br><span class="line"><span class="keyword">let</span> implicitString: <span class="type">String</span> = assumedString  <span class="comment">// 不需要感叹号</span></span><br></pre></td></tr></table></figure><p>你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。</p><h3 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h3><p>Swift 的 <code>nil</code> 和 Objective-C 中的 <code>nil</code> 并不一样。</p><table><thead><tr><th></th><th>Objective-C</th><th>Swift</th></tr></thead><tbody><tr><td>nil</td><td>在 Objective-C 中，<code>nil</code> 是一个指向不存在对象的指针。<br>只有对象类型能被设置为<code>nil</code>。</td><td>在 Swift 中，<code>nil</code> 不是指针——它是一个确定的值，用来表示值缺失。<br>任何类型的可选状态都可以被设置为 <code>nil</code>，不只是对象类型。</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>你可以给可选变量赋值为<code>nil</code>来表示它没有值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverResponseCode: <span class="type">Int</span>? = <span class="number">404</span></span><br><span class="line"><span class="comment">// serverResponseCode 包含一个可选的 Int 值 404</span></span><br><span class="line">serverResponseCode = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// serverResponseCode 现在不包含值</span></span><br></pre></td></tr></table></figure><h3 id="强制解析"><a href="#强制解析" class="headerlink" title="强制解析"></a>强制解析</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//let possibleNumber = "123"</span></span><br><span class="line"><span class="comment">//let convertedNumber = Int(possibleNumber)</span></span><br><span class="line"><span class="keyword">var</span> convertedNumber: <span class="type">Int</span>? = <span class="number">123</span></span><br><span class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber has an integer value of \(convertedNumber!)."</span>) <span class="comment">//当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析（forced unwrapping）：</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "convertedNumber has an integer value of 123."</span></span><br></pre></td></tr></table></figure><h3 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h3><p>在 <code>if</code> 语句中写一个可选绑定：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> constantName = someOptional &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber = <span class="type">Int</span>(possibleNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'\(possibleNumber)\' has an integer value of \(actualNumber)"</span>) <span class="comment">//转换成功，因为它已经被可选类型 包含的 值初始化过，所以不需要再使用 ! 后缀来获取它的值。</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'\(possibleNumber)\' could not be converted to an integer"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "'123' has an integer value of 123"</span></span><br></pre></td></tr></table></figure><p>这段代码可以被理解为：“如果 <code>Int(possibleNumber)</code> 返回的可选 <code>Int</code> 包含一个值，创建一个叫做 <code>actualNumber</code> 的新常量并将可选包含的值赋给它。”</p><h2 id="二、基本运算符"><a href="#二、基本运算符" class="headerlink" title="二、基本运算符"></a>二、基本运算符</h2><h3 id="1、赋值运算符"><a href="#1、赋值运算符" class="headerlink" title="1、赋值运算符"></a>1、赋值运算符</h3><p>与 C 语言和 Objective-C 不同，Swift 的赋值操作并不返回任何值。所以以下代码是错误的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x = y &#123;</span><br><span class="line">    <span class="comment">// 此句错误, 因为 x = y 并不返回任何值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个特性使你无法把（<code>==</code>）错写成（<code>=</code>），由于 <code>if x = y</code> 是错误代码，Swift 能帮你避免此类错误发生。</p><p>如果赋值的右边是一个多元组，它的元素可以马上被分解成多个常量或变量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 现在 x 等于 1，y 等于 2</span></span><br></pre></td></tr></table></figure><h3 id="2、算术运算符"><a href="#2、算术运算符" class="headerlink" title="2、算术运算符"></a>2、算术运算符</h3><p>加法运算符也可用于 <code>String</code> 的拼接：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello, "</span> + <span class="string">"world"</span>  <span class="comment">// 等于 "hello, world"</span></span><br></pre></td></tr></table></figure><p>在新版Swift中，++ 和 – 运算符被取消，因此 i++ 这种形式的累加需要换成 i += 1 这种形式。</p><h3 id="3、一元正号-负号运算符"><a href="#3、一元正号-负号运算符" class="headerlink" title="3、一元正号/负号运算符"></a>3、一元正号/负号运算符</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tempValue = -<span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> plusSix = -tempValue<span class="comment">// plusSix 等于 6</span></span><br><span class="line"><span class="keyword">let</span> minusSix = +tempValue <span class="comment">// minusSix 等于 -6</span></span><br><span class="line"><span class="comment">//当你在使用一元负号来表达负数时，你可以使用一元正号来表达正数，如此你的代码会具有对称美。</span></span><br></pre></td></tr></table></figure><h3 id="4、比较运算符（Comparison-Operators）"><a href="#4、比较运算符（Comparison-Operators）" class="headerlink" title="4、比较运算符（Comparison Operators）"></a>4、比较运算符（Comparison Operators）</h3><p>比较运算多用于条件语句，如<code>if</code>条件：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"world"</span></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"world"</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello, world"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I'm sorry \(name), but I don't recognize you"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "hello, world", 因为 `name` 就是等于 "world"</span></span><br></pre></td></tr></table></figure><h3 id="5、空合运算符（Nil-Coalescing-Operator）"><a href="#5、空合运算符（Nil-Coalescing-Operator）" class="headerlink" title="5、空合运算符（Nil Coalescing Operator）"></a>5、空合运算符（Nil Coalescing Operator）</h3><p><em>空合运算符</em>（<code>a ?? b</code>）将对可选类型 <code>a</code> 进行空判断，如果 <code>a</code> 包含一个值就进行解封，否则就返回一个默认值 <code>b</code>。表达式 <code>a</code> 必须是 Optional 类型。默认值 <code>b</code> 的类型必须要和 <code>a</code> 存储值的类型保持一致。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a ?? b<span class="comment">// 空合运算符</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">a != <span class="literal">nil</span> ? a! : b<span class="comment">// 三目运算符</span></span><br></pre></td></tr></table></figure><blockquote><p>注意： 如果 <code>a</code> 为非空值（<code>non-nil</code>），那么值 <code>b</code> 将不会被计算。这也就是所谓的<em>短路求值</em>。</p></blockquote><h3 id="6、区间运算符（Range-Operators）"><a href="#6、区间运算符（Range-Operators）" class="headerlink" title="6、区间运算符（Range Operators）"></a>6、区间运算符（Range Operators）</h3><table><thead><tr><th></th><th>写法</th><th>示例</th></tr></thead><tbody><tr><td>闭区间运算符</td><td>a…b</td><td>for index in 1…5 {}</td></tr><tr><td>闭区间运算符的单侧形式</td><td>[a…]或[…b]</td><td>for name in names[2…] {     print(name) }</td></tr><tr><td>半开区间运算符</td><td>a..&lt;b</td><td>for i in 0..&lt;count {}</td></tr><tr><td>半开区间运算符的单侧形式</td><td>[..&lt;b]</td></tr></tbody></table><h3 id="7、逻辑运算符（Logical-Operators）"><a href="#7、逻辑运算符（Logical-Operators）" class="headerlink" title="7、逻辑运算符（Logical Operators）"></a>7、逻辑运算符（Logical Operators）</h3><blockquote><p>注意： Swift 逻辑操作符 <code>&amp;&amp;</code> 和 <code>||</code> 是左结合的，这意味着拥有多元逻辑操作符的复合表达式优先计算最左边的子表达式。为使得代码更加可读，建议<strong>使用括号来明确优先级</strong></p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">if</span> (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、溢出运算符"><a href="#8、溢出运算符" class="headerlink" title="8、溢出运算符"></a>8、溢出运算符</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxInt = <span class="type">Int8</span>.<span class="built_in">max</span><span class="comment">// Int8 型整数能容纳的最大值是 +127，以二进制表示即 01111111。</span></span><br><span class="line"><span class="keyword">var</span> minInt = <span class="type">Int8</span>.<span class="built_in">min</span><span class="comment">// Int8 型整数能容纳的最小值是 -128，以二进制表示即 10000000。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Int8.max:\(maxInt), Int8.min:\(minInt)"</span>)</span><br><span class="line"><span class="comment">// 输出 Int.max:127, Int.min:-128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算的错误写法：</span></span><br><span class="line">maxInt += <span class="number">1</span>     <span class="comment">// 编译错误</span></span><br><span class="line">minInt -= <span class="number">1</span>     <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算的正确写法：</span></span><br><span class="line">minInt = minInt &amp;- <span class="number">1</span>    <span class="comment">// 当使用溢出减法运算符对其(二进制10000000)进行减 1 运算时，得到二进制数值 01111111，也就是十进制数值的 127(符号位被翻转了)，这个值也是 Int8 型整数所能容纳的最大值。</span></span><br></pre></td></tr></table></figure><h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><p>Swift的函数使用 <code>func</code> 声明一个函数，形式为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameters)</span></span> -&gt; <span class="keyword">return</span> type &#123;</span><br><span class="line">    function body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的函数形式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello, world"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多参数函数，无返回值（ -&gt; Void 可以省略 ）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">personInfo</span><span class="params">(name: String, age: Int)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：严格上来说，虽然没有返回值被定义，greet(person:) 函数依然返回了值。没有定义返回类型的函数会返回一个特殊的Void值。它其实是一个空的元组（tuple），没有任何元素，可以写成()。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重返回值，这里返回一个元组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (array.<span class="built_in">min</span>()!, array.<span class="built_in">max</span>()!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选返回类型，‘_’ 表示忽略参数标签</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(<span class="number">_</span> array: [Int])</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> array.<span class="built_in">max</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定参数标签（参数说明，和参数名以空格分隔），区别于参数名，默认参数名就是外部的标签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(parameterDescription parameter: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(parameter)</span><br><span class="line">&#125;</span><br><span class="line">someFunction(parameterDescription: <span class="string">"parameter"</span>)</span><br><span class="line"><span class="comment">// 可以看到参数标签只供外部调用显示使用，而参数名parameter可以供内部函数使用</span></span><br><span class="line"><span class="comment">// 默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumFunc</span><span class="params">(a: Int, b: Int = <span class="number">12</span>)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &amp;+ b</span><br><span class="line">    <span class="comment">// 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sumFunc(a: <span class="number">3</span>))    <span class="comment">// 输出 15</span></span><br><span class="line"><span class="comment">// 可变参数，使用（...）的方式接收可变参数，并且必须作为左后一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumFunc2</span><span class="params">(<span class="number">_</span> numbers: Int ...)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 和OC实现不定参数不同，Swift已将不定参转换为数组</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(sumFunc2(1,2,3,4,5))"</span>) <span class="comment">// 输出 15</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 输入输出参数</span></span><br><span class="line"><span class="comment"> 如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就可以将这个参数定义为输入输出参数</span></span><br><span class="line"><span class="comment"> 这有点类似OC中常见的NSError的使用，他们的本质是接受一个地址，直接操作内存地址进行修改和访问</span></span><br><span class="line"><span class="comment"> 可是使用 inout 关键字来定义输入输出参数，需要注意的是，在新版本中，已经将 inout 放在了 '参数名:' 后面，而不是前面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoObj</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> String, <span class="number">_</span> b : <span class="keyword">inout</span> String)</span></span> &#123;</span><br><span class="line">    (a, b) = (b, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">"456"</span></span><br><span class="line">swapTwoObj(&amp;str1, &amp;str2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"str1:\(str1),str2:\(str2)"</span>)  <span class="comment">// 输出 str1:456,str2:123</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/iOS/Swift/1%E5%85%A5%E9%97%A8/3.Swift%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863/"/>
      <url>/iOS/Swift/1%E5%85%A5%E9%97%A8/3.Swift%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><ul><li>一、修饰符</li><li>二、通知、代理、block</li></ul><h2 id="一、修饰符"><a href="#一、修饰符" class="headerlink" title="一、修饰符"></a>一、修饰符</h2><p>Swift基础部门：<a href="http://www.swift51.com/swift4.0/chapter2/01_The_Basics.html" target="_blank" rel="noopener">http://www.swift51.com/swift4.0/chapter2/01_The_Basics.html</a></p><p>修饰符：</p><table><thead><tr><th>修饰符</th><th>所修饰的属性或者方法的作用范围</th><th></th></tr></thead><tbody><tr><td>private</td><td>只能在当前类里访问</td><td></td></tr><tr><td>fileprivate</td><td>在当前的Swift源文件里可以访问</td><td></td></tr><tr><td>internal<br>(默认访问级别)<br>此修饰符可写可不写</td><td>在源代码所在的整个模块都可以访问。<br>①如果是框架或者库代码，则在整个框架内部都可以访问，框架由外部代码所引用时，则不可以访问。<br>②如果是App代码，也是在整个App代码，也是在整个App内部可以访问。</td><td></td></tr><tr><td>public</td><td>可以被任何人访问。<br>①其他module中不可以被override和继承，<br>②而在module内可以被override和继承</td><td></td></tr><tr><td>open</td><td>可以被任何人使用，包括override和继承</td></tr></tbody></table><p>访问顺序：<br>现在的访问权限则依次为：open &gt; public &gt; internal &gt; fileprivate &gt; private。</p><h2 id="swift-–-静态变量static"><a href="#swift-–-静态变量static" class="headerlink" title="swift – 静态变量static"></a>swift – 静态变量static</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态变量  swift中的static静态变量,只能在这里声明,不能在方法中声明,会报错</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> i : <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用静态变量</span></span><br><span class="line">        <span class="comment">//print(self.i)  错</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="type">ViewController</span>.i)     <span class="comment">//这样调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒加载-amp-Readonly"><a href="#懒加载-amp-Readonly" class="headerlink" title="懒加载 &amp; Readonly"></a>懒加载 &amp; Readonly</h2><p>1、lazy关键字修饰一个变量就可以实现懒加载<br>2、懒加载的本质是,在第一次使用的时候使用调用，只会赋值一次</p><p>示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lazy var btn : UIButton = UIButton();</span></span><br><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> btn : <span class="type">UIButton</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> btn = <span class="type">UIButton</span>()</span><br><span class="line">        <span class="keyword">return</span> btn</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure><p>ReadOnly</p><p><a href="https://www.jianshu.com/p/006b3a35fe2c" target="_blank" rel="noopener">Swift如何优雅的的设置只读（readOnly）属性</a></p><p><a href="https://www.jianshu.com/p/a56776a578fe" target="_blank" rel="noopener">优雅地使用 Selector - Swift</a></p><ul><li><p><a href="https://www.jianshu.com/p/d2b0b252b62f" target="_blank" rel="noopener">[iOS基础]Swift中下划线 _ 和＂#＂总结</a></p></li><li><p><a href="https://www.cnblogs.com/bhlsheji/p/4746072.html" target="_blank" rel="noopener">Swift——(三)Swift神奇的下划线</a></p></li></ul><h2 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h2><p>参考文章：</p><ul><li><a href="https://www.jianshu.com/p/bd4bcc717503" target="_blank" rel="noopener">Swift4.x 截取字符串、从字符串中查找子串位置</a></li></ul><h2 id="修改函数参数的值-让方法参数可修改方法"><a href="#修改函数参数的值-让方法参数可修改方法" class="headerlink" title="修改函数参数的值/让方法参数可修改方法"></a>修改函数参数的值/让方法参数可修改方法</h2><p>在swift中，我们常常对数据进行一些处理。因为swift的计算属性，所以如果不是大量重复性处理，基本可以在set及didSet中改变原数据的一些状态。但需要用到同样的算法处理大量数据的时候，仍然需要写方法来解决。在如C一类的传统语言中，指针变量能轻易帮我们处理并直接修改掉原数据，而apple本身期望siwft中尽量减少指针的出现，因此，swift常规方法中经常用到的是值传递。值传递最明显的后果便是无法对原数据进行直接修改。如果我们需要处理后的数据结果，那么就需要重新定义一个变量来接收值。在原数据被废弃的情况下，这样既增多了代码量，也产生了空间大量浪费。因此 siwft提供了关键字修饰inout来申明数据地址传递，也称之为引用传递。在siwft3.0中 inout的位置发生了改变，处于标签位置，不过其作用相同。具体作用如下图代码：</p><p>其他参考：<a href="https://www.cnblogs.com/lingluo/p/6020784.html" target="_blank" rel="noopener">swift之inout</a></p><p>举例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(with fixHeight: <span class="keyword">inout</span> CGFloat, blankBGColor: UIColor)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> maxHeight: <span class="type">CGFloat</span> = <span class="type">UIScreen</span>.main.bounds.height-<span class="number">60</span></span><br><span class="line">        <span class="keyword">if</span> fixHeight &gt; maxHeight &#123;</span><br><span class="line">            fixHeight = maxHeight</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTitle</span><span class="params">(text: String? = <span class="string">""</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 直接在方法中参数里赋默认值就好</span></span><br><span class="line">        <span class="comment">//if text == nil &#123;</span></span><br><span class="line">        <span class="comment">//    text = ""</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二、通知、代理、block"><a href="#二、通知、代理、block" class="headerlink" title="二、通知、代理、block"></a>二、通知、代理、block</h2><p>什么时候用通知,什么时候用代理,什么时候用block<br>通知 : 两者关系层次太深,八竿子打不着的那种最适合用通知.因为层级结构深了,用代理要一层一层往下传递,代码结构就复杂了</p><p>代理 : 父子关系,监听的方法较多的时候使用</p><p>block : 父子关系,监听的方法较少的时候使用</p><h3 id="1、代理"><a href="#1、代理" class="headerlink" title="1、代理"></a>1、代理</h3><ul><li>定义swift中代理的协议</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swift 中的代理必须继承自NSObjectProtocol</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">VisitorViewDelegate</span> : <span class="title">NSObjectProtocol</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 代理中的方法默认必须实现,有可以不实现的情况,以后整理</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">visitorViewDidClickRegisterBtn</span><span class="params">(visitorView : VisitorView)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">visitorViewDidClickLoginBtn</span><span class="params">(visitorView : VisitorView)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明代理</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理属性,与OC一样,用weak修饰</span></span><br><span class="line">   <span class="keyword">weak</span> <span class="keyword">var</span> delegate : <span class="type">VisitorViewDelegate</span>? <span class="comment">// 可选类型,代理可以有也可以没有</span></span><br></pre></td></tr></table></figure><ul><li>在按钮点击的事件中执行代理方法</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册按钮的点击</span></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">registerBtnClick</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 监听到点击,通知代理做事情</span></span><br><span class="line">        <span class="comment">// 代理中的方法默认是必须实现的(也有可选的,后面再说),所以这里没有判断代理有没有实现相应的方法</span></span><br><span class="line">        delegate?.visitorViewDidClickRegisterBtn(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录按钮的点击</span></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">loginBtnClick</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 监听到点击,通知代理做事情</span></span><br><span class="line">        delegate?.visitorViewDidClickLoginBtn(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>代理的具体实现</p><p>swift中为了让方法分类更清晰,实现代理或者数据源的方法单独写到分类中</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - VisitorViewDelegate代理方法</span></span><br><span class="line"><span class="comment">// swift 中为了区分不同类型的代理方法或者数据源方法,通过extension实现了更好的区分</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BaseTableViewController</span>: <span class="title">VisitorViewDelegate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">visitorViewDidClickRegisterBtn</span><span class="params">(visitorView : VisitorView)</span></span> &#123;</span><br><span class="line">        <span class="type">ChaosLog</span>(<span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">visitorViewDidClickLoginBtn</span><span class="params">(visitorView : VisitorView)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChaosLog</span>(<span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、block"><a href="#2、block" class="headerlink" title="2、block"></a>2、block</h2><p>作为类属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clickHandle: ((<span class="number">_</span> sheetModel: <span class="type">CJDemoActionSheetModel</span>, <span class="number">_</span> selectIndex: <span class="type">NSInteger</span>)-&gt;())?</span><br></pre></td></tr></table></figure><p>作为函数变量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(sheetModels:[<span class="type">CJDemoActionSheetModel</span>], clickHandle: @escaping (<span class="number">_</span> sheetModel: <span class="type">CJDemoActionSheetModel</span>, <span class="number">_</span> selectIndex: <span class="type">NSInteger</span>)-&gt;()) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他参考文章：</p><ul><li><p><a href="http://www.swift51.com/swift4.0/chapter2/07_Closures.html" target="_blank" rel="noopener">闭包（Closures）</a></p></li><li><p><a href="https://www.codercto.com/a/27275.html" target="_blank" rel="noopener">一个更优雅的 Swift Block 写法</a></p></li><li><p><a href="https://www.jianshu.com/p/5a3fd872257e" target="_blank" rel="noopener">Swift中的typealias(别名)的用法</a></p></li><li><a href="https://www.jianshu.com/p/5f98941b4c71" target="_blank" rel="noopener">swift中的block</a></li><li><a href="https://www.jianshu.com/p/1457a4894ec7" target="_blank" rel="noopener">swift中的闭包和oc中的block的定义和用法对比</a></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>获取类名</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CJDemoActionSheetTableViewCell</span>.<span class="keyword">self</span></span><br><span class="line"><span class="type">UIViewController</span>.<span class="keyword">self</span></span><br></pre></td></tr></table></figure><p><a href="http://www.it1352.com/540349.html" target="_blank" rel="noopener">如何在int和float之间的算术在Swift？</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myInt = 5;</span><br><span class="line">var myDouble = 3.4;</span><br><span class="line">var doubleResult = Double(myInt) + myDouble;</span><br><span class="line">var intResult = myInt + Int(myDouble)</span><br></pre></td></tr></table></figure><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>CFRelease</p><blockquote><p> 苹果的一些底层框架返回的对象有的是自动管理内存的（annotated APIs），有的是不自动管理内存。</p><p>如果一个函数名中包含<code>Create</code>或<code>Copy</code>，则调用者获得这个对象的同时也获得对象所有权，返回值<code>Unmanaged</code>需要调用<code>takeRetainedValue()</code>方法获得对象。调用者不再使用对象时候，Swift代码中不需要调用CFRelease函数放弃对象所有权，这是因为Swift仅支持ARC内存管理，这一点和OC略有不同。</p></blockquote><p>上文摘自：<a href="https://www.jianshu.com/p/103591adc3d1" target="_blank" rel="noopener">https://www.jianshu.com/p/103591adc3d1</a> 中 CFRoopLoop使用 的使用</p><h2 id="Swift-GCD延迟加载"><a href="#Swift-GCD延迟加载" class="headerlink" title="Swift GCD延迟加载"></a>Swift GCD延迟加载</h2><p>详细参考：</p><ul><li><a href="https://www.jianshu.com/p/98f33cf305f4" target="_blank" rel="noopener">Swift3.0中GCD延时函数asyncAfter的使用</a></li><li><a href="https://www.jianshu.com/p/5327d654a892" target="_blank" rel="noopener">Swift 4.0 GCD 中的 dispatch after 浅谈</a></li></ul><p>swift 自定义view的初始方法</p><h2 id="swift中的-objc的作用"><a href="#swift中的-objc的作用" class="headerlink" title="swift中的@objc的作用"></a><a href="https://www.cnblogs.com/yangzigege/p/8683097.html" target="_blank" rel="noopener">swift中的@objc的作用</a></h2><h2 id="Swift枚举的全用法"><a href="#Swift枚举的全用法" class="headerlink" title="Swift枚举的全用法"></a>Swift枚举的全用法</h2><ul><li><a href="https://www.jianshu.com/p/9c7a07163e5b" target="_blank" rel="noopener">Swift枚举的全用法</a></li></ul><h2 id="iOS-国际化全解-swift与OC"><a href="#iOS-国际化全解-swift与OC" class="headerlink" title="iOS 国际化全解-swift与OC"></a>iOS 国际化全解-swift与OC</h2><ul><li><a href="https://www.jianshu.com/p/a9ec43123860" target="_blank" rel="noopener">iOS 国际化全解-swift与OC</a></li></ul><ul><li><a href="https://blog.csdn.net/heat_cold/article/details/79630528" target="_blank" rel="noopener">Swift 判断系统版本</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目前痛点</title>
      <link href="/%E7%9B%AE%E5%89%8D%E7%97%9B%E7%82%B9/README/"/>
      <url>/%E7%9B%AE%E5%89%8D%E7%97%9B%E7%82%B9/README/</url>
      
        <content type="html"><![CDATA[<p>内容后续补充。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 目前痛点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 痛点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift</title>
      <link href="/iOS/Swift/README/"/>
      <url>/iOS/Swift/README/</url>
      
        <content type="html"><![CDATA[<p>内容后续补充。。。。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动分析</title>
      <link href="/iOS/%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/README/"/>
      <url>/iOS/%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/README/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 移动分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 移动分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>app安全</title>
      <link href="/iOS/app%E5%AE%89%E5%85%A8/README/"/>
      <url>/iOS/app%E5%AE%89%E5%85%A8/README/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> app安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> app安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化</title>
      <link href="/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/README/"/>
      <url>/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/README/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS</title>
      <link href="/iOS/README/"/>
      <url>/iOS/README/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS</title>
      <link href="/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/Swift%E7%9B%B8%E5%85%B3%E9%9A%8F%E7%AC%94/"/>
      <url>/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/Swift%E7%9B%B8%E5%85%B3%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="开发随笔"><a href="#开发随笔" class="headerlink" title="开发随笔"></a>开发随笔</h1><h1 id="Swift-变量对外只读，对内可读写"><a href="#Swift-变量对外只读，对内可读写" class="headerlink" title="Swift 变量对外只读，对内可读写"></a>Swift 变量对外只读，对内可读写</h1><p>项目中经常需要创建这样一种变量：对内可读写，但对外是只读的。在 OC 中，只需在 <code>.h</code> 文件中将属性定义为 <code>readonly</code>，而在 <code>.m</code> 文件中将该属性重新定义为 <code>readwrite</code> 即可。</p><p>可是在 Swift 中却没有这样让我们重新定义权限的机会，那么我们该如何去创建这样的变量呢？</p><p>Swift中的实现方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> name : <span class="type">String</span>!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别看有 <code>private</code> 就以为其他类不能访问 <code>name</code> 属性了，其实只是 <code>setter</code> 方法是私有的，所以在其他类中是可以访问 <code>name</code> 属性的，只是不能修改而已，而在 <code>Person</code> 类中是读写都可以。</p><h1 id="怎样优雅的禁用掉Swift中的方法"><a href="#怎样优雅的禁用掉Swift中的方法" class="headerlink" title="怎样优雅的禁用掉Swift中的方法"></a>怎样优雅的禁用掉Swift中的方法</h1><p><a href="https://www.jianshu.com/p/ab366b58b7a2?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">https://www.jianshu.com/p/ab366b58b7a2?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p><h1 id="尝试理解Swift中的-escaping"><a href="#尝试理解Swift中的-escaping" class="headerlink" title="尝试理解Swift中的@escaping"></a>尝试理解Swift中的@escaping</h1><p><a href="https://www.jianshu.com/p/dd0537a40fc6/" target="_blank" rel="noopener">https://www.jianshu.com/p/dd0537a40fc6/</a></p><h1 id="ios-–-Swift-–-UIButton重写setSelected"><a href="#ios-–-Swift-–-UIButton重写setSelected" class="headerlink" title="ios – Swift – UIButton重写setSelected"></a>ios – Swift – UIButton重写setSelected</h1><p><a href="http://www.voidcn.com/article/p-cdthfhqm-bte.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-cdthfhqm-bte.html</a></p><h1 id="swift函数参数指针传递inout和-escaping冲突的解决方法"><a href="#swift函数参数指针传递inout和-escaping冲突的解决方法" class="headerlink" title="swift函数参数指针传递inout和@escaping冲突的解决方法"></a>swift函数参数指针传递inout和@escaping冲突的解决方法</h1><p><a href="https://blog.csdn.net/boildoctor/article/details/111559223" target="_blank" rel="noopener">https://blog.csdn.net/boildoctor/article/details/111559223</a></p><h1 id="swift3-0-让方法参数可修改方法"><a href="#swift3-0-让方法参数可修改方法" class="headerlink" title="swift3.0 让方法参数可修改方法"></a>swift3.0 让方法参数可修改方法</h1><p><a href="https://blog.csdn.net/a1018875550/article/details/75174640" target="_blank" rel="noopener">https://blog.csdn.net/a1018875550/article/details/75174640</a></p><p><a href="http://cache.baiducontent.com/c?m=m-k2_l-4CMYfEg95YMMh3aMWxKOtc-cVq1Lq_EW6L9ND9ZVpKHWhid_jv2PzArzld_Ken3Rpbsi6Vq0C4j0mlD0T63lrtFzAqErGBjLPrPWxLoJPMvGcDO9IDiaLoRIFgKi0qnIw9jds8KCdPvoVqKaq9zxuJ0mTEj3E8veGxA-srcec28YT0zWiuMzfJgjc&amp;p=cb6ac54ad5c042b90be29628165dcb&amp;newp=8b2a970c82934eac5beee6261547c4231610db2151d7d5106b82c825d7331b001c3bbfb423291403d5c7796d04a44258e8f63271370923a3dda5c91d9fb4c57479c173&amp;s=1679091c5a880faf&amp;user=baidu&amp;fm=sc&amp;query=swift+%D0%DE%B8%C4%B7%BD%B7%A8%D0%CE%B2%CE&amp;qid=ac21cc5c00048b26&amp;p1=9" target="_blank" rel="noopener">http://cache.baiducontent.com/c?m=m-k2_l-4CMYfEg95YMMh3aMWxKOtc-cVq1Lq_EW6L9ND9ZVpKHWhid_jv2PzArzld_Ken3Rpbsi6Vq0C4j0mlD0T63lrtFzAqErGBjLPrPWxLoJPMvGcDO9IDiaLoRIFgKi0qnIw9jds8KCdPvoVqKaq9zxuJ0mTEj3E8veGxA-srcec28YT0zWiuMzfJgjc&amp;p=cb6ac54ad5c042b90be29628165dcb&amp;newp=8b2a970c82934eac5beee6261547c4231610db2151d7d5106b82c825d7331b001c3bbfb423291403d5c7796d04a44258e8f63271370923a3dda5c91d9fb4c57479c173&amp;s=1679091c5a880faf&amp;user=baidu&amp;fm=sc&amp;query=swift+%D0%DE%B8%C4%B7%BD%B7%A8%D0%CE%B2%CE&amp;qid=ac21cc5c00048b26&amp;p1=9</a></p><h1 id="Swift学习笔记-In-out形参"><a href="#Swift学习笔记-In-out形参" class="headerlink" title="Swift学习笔记 In-out形参"></a><a href="https://www.cnblogs.com/imhere/p/4252397.html" target="_blank" rel="noopener"><strong>Swift</strong>学习笔记 In-out<strong>形参</strong></a></h1><h1 id="swift-map-reduce-获取下标-index-的方法"><a href="#swift-map-reduce-获取下标-index-的方法" class="headerlink" title="swift map reduce 获取下标(index)的方法"></a>swift map reduce 获取下标(index)的方法</h1><p><a href="http://www.voidcn.com/article/p-cstjyafn-bmd.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-cstjyafn-bmd.html</a></p><p><strong>Swift 数组删除元素</strong>(删除多个)</p><p><a href="https://www.meiwen.com.cn/subject/jwpmbctx.html" target="_blank" rel="noopener">https://www.meiwen.com.cn/subject/jwpmbctx.html</a></p><h3 id="Swift中编写单例的正确方式"><a href="#Swift中编写单例的正确方式" class="headerlink" title="Swift中编写单例的正确方式"></a>Swift中编写单例的正确方式</h3><p><a href="http://www.cocoachina.com/articles/14584" target="_blank" rel="noopener">http://www.cocoachina.com/articles/14584</a></p><h1 id="Swift中的nil"><a href="#Swift中的nil" class="headerlink" title="Swift中的nil"></a>Swift中的nil</h1><p>Swift中的nil和OC中的nil不一样。OC中的nil表示不存在的对象，你无法给NSInteger类型的变量赋值nil，但是Swift中的nil表示不存在，可以给任何Optional的变量或者常量赋nil，即使是普通类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a: Int? = nil</span><br><span class="line">let b: Double? = nil</span><br></pre></td></tr></table></figure><p>但是，需要注意的是，无法给非Optional类型的变量或者常量赋nil：</p><h1 id="swift-数组的添加和删除"><a href="#swift-数组的添加和删除" class="headerlink" title="swift 数组的添加和删除"></a>swift 数组的添加和删除</h1><p>insert(_:at:) 在指定位置插入一个元素</p><p>insert(contentsOF:at)在指定位置插入多个元素</p><p><strong>swift 条件编译 自定义环境变量</strong></p><p><a href="https://www.jianshu.com/p/9a93e614a98e" target="_blank" rel="noopener"><strong>https://www.jianshu.com/p/9a93e614a98e</strong></a></p><p><strong>Swift initializer</strong></p><p><a href="https://www.jianshu.com/p/bdb07143d368" target="_blank" rel="noopener"><strong>https://www.jianshu.com/p/bdb07143d368</strong></a></p><p><strong>Swift - 实现动画</strong></p><p><a href="https://blog.csdn.net/weixin_43704791/article/details/86529516" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43704791/article/details/86529516</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS</title>
      <link href="/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/collection%E7%9B%B8%E5%85%B3%E9%9A%8F%E7%AC%94/"/>
      <url>/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/collection%E7%9B%B8%E5%85%B3%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="UICollectionView-SelectItem方法无效的原因"><a href="#UICollectionView-SelectItem方法无效的原因" class="headerlink" title="UICollectionView SelectItem方法无效的原因"></a>UICollectionView SelectItem方法无效的原因</h1><p><a href="https://blog.csdn.net/weixin_34127717/article/details/88010800" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34127717/article/details/88010800</a></p><ol><li>[collectionView reloadData];</li><li>[collectionView layoutIfNeeded];</li><li>[collectionView selectItemAtIndexPath:indexPath animated:YES scrollPosition:UICollectionViewScrollPositionNone];</li></ol><h4 id="UICollectionView删除数据更新"><a href="#UICollectionView删除数据更新" class="headerlink" title="UICollectionView删除数据更新"></a>UICollectionView删除数据更新</h4><p>前段时间在做商品收藏的时候，用UICollectionView展示收藏商品，删除收藏用到collection的删除方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">self.dataAry removeObjectAtIndex:indexPath.row</span>];</span><br><span class="line"></span><br><span class="line">[<span class="meta">collectionView deleteItemsAtIndexPaths:@[indexPath</span>]];</span><br></pre></td></tr></table></figure><p>发现一个问题，collection执行deleteItems后只会调用numberOfItemsInSection刷新一下item的数量，并不会调用cellForItemAtIndexPath来刷新数据，（因为只是删除，item的内容不会变，只会动一下位置），这就导致了一个问题，当我删除到最后一个cell的时候，发现数组越界。原因是dataAry只剩一个数据，但是indexPath.row=1。</p><p>解决方案：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[collectionView performBatchUpdates:^&#123;</span><br><span class="line">      [<span class="keyword">self</span>.dataAry removeObjectAtIndex:indexPath.row];</span><br><span class="line">      [collectionView deleteItemsAtIndexPaths:@[indexPath]];</span><br><span class="line">      </span><br><span class="line">  &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">      [collectionView reloadData];</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><p>每次删除执行完后刷新数据。大家有其他解决办法欢迎指正。</p><p>所以为了不执行reloadData,</p><p><a href="https://www.cnblogs.com/sandyzhang/p/5257905.html" target="_blank" rel="noopener"><strong>UICollectionView cellForItemAtIndexPath 方法不走</strong></a></p><p>在storyboard 中</p><p>UICollectionView cellForItemAtIndexPath not called</p><p>被坑了好久,各种问题点查找,终于解决了</p><p>解决办法：<a href="https://www.jianshu.com/p/cda4a7061cf9" target="_blank" rel="noopener">automaticallyAdjustsScrollViewInsets</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">self</span>.automaticallyAdjustsScrollViewInsets = <span class="literal">NO</span>;<span class="comment">//解决cellForItemAtIndexPath not called问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">   <span class="keyword">self</span>.scrollView.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentNever</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// Fallback on earlier versions</span></span><br><span class="line">   <span class="keyword">self</span>.automaticallyAdjustsScrollViewInsets = <span class="literal">NO</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS</title>
      <link href="/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/tableView%E7%9B%B8%E5%85%B3%E9%9A%8F%E7%AC%94/"/>
      <url>/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/tableView%E7%9B%B8%E5%85%B3%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>indexPath 返回nil</p><p>请检查是不是在如viewWillAppear的方法中执行了reload</p><p><strong>self</strong>.contentView.sendSubviewToBack(shadowView) // 请确保 shadowView 和 tableView 加到的是同一个父视图</p><p>否则，后添加的视图会盖住前面的视图。如tableView添加到cell上，shadowView添加到cell.contentView上</p><h2 id="一、cell的自适应高度"><a href="#一、cell的自适应高度" class="headerlink" title="一、cell的自适应高度"></a>一、cell的自适应高度</h2><h3 id="1、基础设置"><a href="#1、基础设置" class="headerlink" title="1、基础设置"></a>1、基础设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tableView.estimatedRowHeight = 60;</span><br><span class="line"></span><br><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    return UITableViewAutomaticDimension;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、某行不自适应"><a href="#2、某行不自适应" class="headerlink" title="2、某行不自适应"></a>2、某行不自适应</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    if (indexPath.section == CQDetailInfoTypeBase) &#123;</span><br><span class="line">        return 60;</span><br><span class="line">    &#125;</span><br><span class="line">    return UITableViewAutomaticDimension;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、如果自适应的cell的高度不够"><a href="#3、如果自适应的cell的高度不够" class="headerlink" title="3、如果自适应的cell的高度不够"></a>3、如果自适应的cell的高度不够</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make.height.greaterThanOrEqualTo(@60); // 为了自适应的时候，最小的cell高度不会小于指定值</span><br></pre></td></tr></table></figure><h2 id="二、tableView的headerInSectionView-不悬浮"><a href="#二、tableView的headerInSectionView-不悬浮" class="headerlink" title="二、tableView的headerInSectionView 不悬浮"></a>二、tableView的headerInSectionView 不悬浮</h2><p><a href="https://blog.csdn.net/wait_foryou/article/details/78256905" target="_blank" rel="noopener">https://blog.csdn.net/wait_foryou/article/details/78256905</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// UITableView的Style为Plain时, 当tableView上移顶端的tableHeaderView会跟着滑出窗口, 而headerInsectionView则会悬浮固定在窗口顶端不随着滑动继续上移.</span><br><span class="line">// UITableView的Style为Grouped时, 当tableView上移顶端的tableHeaderView会跟着滑出窗口, 而headerInsectionView则会随着滑动继续上移.</span><br><span class="line"></span><br><span class="line">// UITableView的Style为Plain时禁止headerInsectionView固定在顶端:</span><br><span class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;</span><br><span class="line">    CGFloat sectionHeaderHeight = 30;</span><br><span class="line">    if(scrollView.contentOffset.y &lt;= sectionHeaderHeight &amp;&amp; scrollView.contentOffset.y &gt;= 0) &#123;</span><br><span class="line">        scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0,0);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (scrollView.contentOffset.y &gt;= sectionHeaderHeight) &#123;</span><br><span class="line">        scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己的另一种方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 还是Group</span><br><span class="line"></span><br><span class="line">UITableView *tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStyleGrouped];</span><br><span class="line"></span><br><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section &#123;</span><br><span class="line">    UIView *view = [UIView new];</span><br><span class="line">    //view.backgroundColor = [UIColor greenColor];</span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、tableView等reloadData真正刷新结束后执行下一步操作"><a href="#三、tableView等reloadData真正刷新结束后执行下一步操作" class="headerlink" title="三、tableView等reloadData真正刷新结束后执行下一步操作"></a>三、tableView等reloadData真正刷新结束后执行下一步操作</h2><p>reloadData不会等tableView更新结束后才返回，而是立即返回，然后计算表高度，执行滚动之类的代码。<br>很明显这里的原因是因为数据比较大，一个run loop周期没执行完，tableView滚动时，表的高度不对。</p><p>问题场景：</p><p>情况1：reloadData后，scrollToRowAtIndexPath未滚动到指定区域</p><p>情况2：reloadData后，setContentOffset未滚动到指定区域</p><p>解决方法(两种)：</p><p>1、强制刷新</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.myTableView reloadData];</span><br><span class="line">[<span class="keyword">self</span>.myTableView layoutIfNeeded]; </span><br><span class="line">[<span class="keyword">self</span>.myTableView scrollToRowAtIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForRow:([<span class="keyword">self</span>.myTableView numberOfRowsInSection:<span class="number">2</span>]<span class="number">-1</span>) inSection:<span class="number">2</span>] atScrollPosition:<span class="built_in">UITableViewScrollPositionBottom</span> animated:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure><p>layoutIfNeeded会强制重绘并等待完成。</p><p>2、线程等待</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.myTableView reloadData];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          <span class="comment">// 刷新</span></span><br><span class="line">          [weakSelf.myTableView scrollToRowAtIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForRow:([weakSelf.myTableView numberOfRowsInSection:<span class="number">2</span>]<span class="number">-1</span>) inSection:<span class="number">2</span>] atScrollPosition:<span class="built_in">UITableViewScrollPositionBottom</span> animated:<span class="literal">NO</span>];</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>[tableView reloadData]在主队列执行，而dispatch_get_main_queue()会等待主队列空闲后才执行。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS</title>
      <link href="/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/%E5%AD%97%E7%AC%A6%E4%B8%B2:%E8%A1%A8%E6%83%85%E7%9B%B8%E5%85%B3%E9%9A%8F%E7%AC%94/"/>
      <url>/iOS/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/%E5%AD%97%E7%AC%A6%E4%B8%B2:%E8%A1%A8%E6%83%85%E7%9B%B8%E5%85%B3%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><p>散文网：<a href="http://www.ruiwen.com/wenxue/sanwen/" target="_blank" rel="noopener">瑞文网</a></p><h1 id="iOS输入框的字数统计-最大长度限制详解"><a href="#iOS输入框的字数统计-最大长度限制详解" class="headerlink" title="iOS输入框的字数统计/最大长度限制详解"></a>iOS输入框的字数统计/最大长度限制详解</h1><p><a href="https://www.jb51.net/article/142743.htm" target="_blank" rel="noopener">https://www.jb51.net/article/142743.htm</a></p><h1 id="iOS-计算表情的个数"><a href="#iOS-计算表情的个数" class="headerlink" title="iOS 计算表情的个数"></a>iOS 计算表情的个数</h1><p><a href="https://blog.csdn.net/u010913882/article/details/37568761" target="_blank" rel="noopener">https://blog.csdn.net/u010913882/article/details/37568761</a></p><p><strong>iOS带Emoji字符串的安全截取</strong></p><p><strong>【iOS】iOS OC截取字符串时emoji表情处理 取emoji表情的range</strong></p><p><a href="https://www.jianshu.com/p/416ff5e6fc67" target="_blank" rel="noopener"><strong>https://www.jianshu.com/p/416ff5e6fc67</strong></a></p><p>iOS字符截取（表情汉字）</p><p><a href="https://www.cnblogs.com/simple-life-no1/p/5340285.html" target="_blank" rel="noopener">https://www.cnblogs.com/simple-life-no1/p/5340285.html</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC+Swift混编问题</title>
      <link href="/iOS/%E6%B7%B7%E7%BC%96/OC+Swift%E6%B7%B7%E7%BC%96%E9%97%AE%E9%A2%98/"/>
      <url>/iOS/%E6%B7%B7%E7%BC%96/OC+Swift%E6%B7%B7%E7%BC%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、Property-has-a-previous-declaration"><a href="#一、Property-has-a-previous-declaration" class="headerlink" title="一、Property has a previous declaration"></a>一、Property has a previous declaration</h2><ul><li><a href="https://blog.csdn.net/horisea/article/details/79153112" target="_blank" rel="noopener">关于OC和Swift混编MJExtension第三方库莫名出错问题Property has a previous declaration</a></li></ul><p>将项目中#import “MJExtension.h”的部分，全部替换成</p><p>  #import &lt;MJExtension/MJExtension.h&gt; </p><p>  然后问题就解决了。</p><p><img src="/iOS/混编/OC+Swift混编问题/OC+Swift%E6%B7%B7%E7%BC%96%E9%97%AE%E9%A2%98/image-20220808144636522.png" alt="image-20220808144636522"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 混编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邓白氏编码申请</title>
      <link href="/iOS/%E8%AF%81%E4%B9%A6%E5%8F%91%E7%89%88/%E9%82%93%E7%99%BD%E6%B0%8F%E7%BC%96%E7%A0%81%E7%94%B3%E8%AF%B7/"/>
      <url>/iOS/%E8%AF%81%E4%B9%A6%E5%8F%91%E7%89%88/%E9%82%93%E7%99%BD%E6%B0%8F%E7%BC%96%E7%A0%81%E7%94%B3%E8%AF%B7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、邓白氏编码的申请"><a href="#一、邓白氏编码的申请" class="headerlink" title="一、邓白氏编码的申请"></a>一、邓白氏编码的申请</h2><h4 id="1、Enroll前的了解"><a href="#1、Enroll前的了解" class="headerlink" title="1、Enroll前的了解"></a>1、Enroll前的了解</h4><p><img src="/iOS/证书发版/邓白氏编码申请/1Enroll前的了解.png" alt="1Enroll前的了解"></p><h4 id="2、点击《Learn-More》后会进入如下界面：https-developer-apple-com-support-D-U-N-S-，界面截图如下："><a href="#2、点击《Learn-More》后会进入如下界面：https-developer-apple-com-support-D-U-N-S-，界面截图如下：" class="headerlink" title="2、点击《Learn More》后会进入如下界面：https://developer.apple.com/support/D-U-N-S/，界面截图如下："></a>2、点击《Learn More》后会进入如下界面：<a href="https://developer.apple.com/support/D-U-N-S/，界面截图如下：" target="_blank" rel="noopener">https://developer.apple.com/support/D-U-N-S/，界面截图如下：</a></h4><p><img src="/iOS/证书发版/邓白氏编码申请/2 D-U-N-S® Number Learn More.png" alt="2 D-U-N-S® Number Learn More"></p><h4 id="3、选择《D-U-N-S-Number-look-up-tool》后，会进入-https-developer-apple-com-enroll-cn-duns-lookup-search-查找页面，页面部分截图如下："><a href="#3、选择《D-U-N-S-Number-look-up-tool》后，会进入-https-developer-apple-com-enroll-cn-duns-lookup-search-查找页面，页面部分截图如下：" class="headerlink" title="3、选择《D-U-N-S Number look up tool》后，会进入 https://developer.apple.com/enroll/cn/duns-lookup/#!/search 查找页面，页面部分截图如下："></a>3、选择《D-U-N-S Number look up tool》后，会进入 <a href="https://developer.apple.com/enroll/cn/duns-lookup/#!/search" target="_blank" rel="noopener">https://developer.apple.com/enroll/cn/duns-lookup/#!/search</a> 查找页面，页面部分截图如下：</h4><p><img src="/iOS/证书发版/邓白氏编码申请/3 D-U-N-S® Number 查找页面选择创建.png" alt="3 D-U-N-S® Number 查找页面选择创建"></p><h4 id="4、选择《请提交您的信息》后会进入-https-developer-apple-com-enroll-cn-duns-lookup-request-页面"><a href="#4、选择《请提交您的信息》后会进入-https-developer-apple-com-enroll-cn-duns-lookup-request-页面" class="headerlink" title="4、选择《请提交您的信息》后会进入 https://developer.apple.com/enroll/cn/duns-lookup/#!/request 页面"></a>4、选择《请提交您的信息》后会进入 <a href="https://developer.apple.com/enroll/cn/duns-lookup/#!/request" target="_blank" rel="noopener">https://developer.apple.com/enroll/cn/duns-lookup/#!/request</a> 页面</h4><h3 id="二、申请公司身份开发app所需材料"><a href="#二、申请公司身份开发app所需材料" class="headerlink" title="二、申请公司身份开发app所需材料"></a>二、申请公司身份开发app所需材料</h3><p><img src="/iOS/证书发版/邓白氏编码申请/申请公司身份开发app所需材料.png" alt="申请公司身份开发app所需材料"></p><p>查找您的 D-U-N-S 编号：<a href="https://developer.apple.com/enroll/cn/duns-lookup/" target="_blank" rel="noopener">https://developer.apple.com/enroll/cn/duns-lookup/</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 证书发版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：ReactNative的Demo实践</title>
      <link href="/ReactNative/8%E5%AE%9E%E8%B7%B5/ReactNative%E7%9A%84Demo%E5%AE%9E%E8%B7%B5/"/>
      <url>/ReactNative/8%E5%AE%9E%E8%B7%B5/ReactNative%E7%9A%84Demo%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative的Demo实践"><a href="#ReactNative的Demo实践" class="headerlink" title="ReactNative的Demo实践"></a>ReactNative的Demo实践</h1><h2 id="一、工程创建"><a href="#一、工程创建" class="headerlink" title="一、工程创建"></a>一、工程创建</h2><p>创建APP(iOS &amp; Android)项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init TSDemoDemo</span><br></pre></td></tr></table></figure><h3 id="1、iOS工程"><a href="#1、iOS工程" class="headerlink" title="1、iOS工程"></a>1、iOS工程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd iOS项目</span><br><span class="line">pod install</span><br></pre></td></tr></table></figure><h3 id="2、Android工程"><a href="#2、Android工程" class="headerlink" title="2、Android工程"></a>2、Android工程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">终端运行cd myProject切换到项目根目录中，</span><br><span class="line">运行adb devices来确保有设备连接到了电脑上</span><br><span class="line"></span><br><span class="line">运行react-native run-android打包编译安卓项目，并部署到模拟器或开发机中</span><br><span class="line"></span><br><span class="line">运行上一条命令之前，要确保有设备连接到了电脑上，可以运行adb devices查看当前接入的设备列表；如果无法检查到设备列表，请先确保手机开启了开发者模式，同时要电脑上要安装手机的驱动程序；</span><br><span class="line"></span><br><span class="line">注意：首次打包时候，会联网下载gradle相关的文件，需要等待很长时间，大家可以直接从http://www.androiddevtools.cn/手动下载对应版本的gradle文件，并手动拷贝解压到C:\Users\自己的用户名\.gradle\wrapper\dists目录下；</span><br><span class="line"></span><br><span class="line">注意：接下来，如果是第一次打包，会从https://jcenter.bintray.com下载好多的依赖项，此时需要耐心等待，如果中间出现了长时间卡顿，大家需要Ctrl+C停止打包，并重新运行react-native run-android</span><br><span class="line"></span><br><span class="line">作者：白小白大白白</span><br><span class="line">链接：https://www.jianshu.com/p/ab8bf4128b0e</span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="二、添加路由"><a href="#二、添加路由" class="headerlink" title="二、添加路由"></a>二、添加路由</h2><p>参考文档</p><ul><li><p>官方文档：<a href="https://reactnavigation.org/docs/getting-started" target="_blank" rel="noopener">react-navigation Getting started</a></p></li><li><p><a href="https://segmentfault.com/a/1190000021753725" target="_blank" rel="noopener">React Navigation5.0系列一：StackNavigator的使用</a></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">①</span><br><span class="line">yarn add @react-navigation/native</span><br><span class="line"></span><br><span class="line">②</span><br><span class="line">yarn add react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view</span><br><span class="line"></span><br><span class="line">③在iOS工程中，重新 pod install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">④接下来，因为从React Navigation4.x版本开始，堆栈导航库就已经被分离出来，作为单独的依赖文件，所以要想添加StackNavigator的依赖</span><br><span class="line">yarn add @react-navigation/stack</span><br></pre></td></tr></table></figure><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>参考文章：</p><ul><li><p><a href="https://blog.csdn.net/shyzh_li/article/details/80238723" target="_blank" rel="noopener">iOS原生页面、ReactNative页面之间相互跳转</a></p></li><li><p><a href="https://www.jianshu.com/p/66eb84f13bd8" target="_blank" rel="noopener">React Native iOS混合开发</a> <strong>写得挺好，建议阅读下</strong></p><ul><li><p>Native到JS的通信(Native发送数据给JS)</p><p>eg：发送一个文本给JS</p></li><li><p>在JS中获取Native通过<code>RCTEventEmitter</code>传过来的数据</p></li></ul></li><li><p><a href="https://www.jianshu.com/p/f7b0e8e73f63" target="_blank" rel="noopener">iOS - React-Native : 原生跳转RN、RN跳转原生、RN界面嵌入原生</a> <strong>一定要读</strong></p><ul><li>原生界面嵌入到RN界面中，eg:原生界面作为RN tabBar中的一个界面</li></ul><p>步骤：</p><ol><li>将需要嵌入的界面/控制器 制作成RN的组件</li></ol></li></ul><h2 id="四、发布"><a href="#四、发布" class="headerlink" title="四、发布"></a>四、发布</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line"></span><br><span class="line">npm login</span><br><span class="line"></span><br><span class="line">npm publish --access=public</span><br></pre></td></tr></table></figure><p>详情查看：<a href="../../代码管理/库管理/npmjs/npmjs的发布.md">代码管理/库管理/npmjs/npmjs的发布</a></p>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第八章：ReactNative实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3节：登录页在Android工程中的代码</title>
      <link href="/Flutter/4%E7%99%BB%E5%BD%95%E9%A1%B5%E5%AE%9E%E6%88%98/%E7%99%BB%E5%BD%95%E9%A1%B5%E5%9C%A8Android%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
      <url>/Flutter/4%E7%99%BB%E5%BD%95%E9%A1%B5%E5%AE%9E%E6%88%98/%E7%99%BB%E5%BD%95%E9%A1%B5%E5%9C%A8Android%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="第3节：登录页在Android工程中的代码"><a href="#第3节：登录页在Android工程中的代码" class="headerlink" title="第3节：登录页在Android工程中的代码"></a>第3节：登录页在Android工程中的代码</h1>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第四章：Flutter登录页实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 登录页实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：登录页在iOS工程中的代码</title>
      <link href="/Flutter/4%E7%99%BB%E5%BD%95%E9%A1%B5%E5%AE%9E%E6%88%98/%E7%99%BB%E5%BD%95%E9%A1%B5%E5%9C%A8iOS%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
      <url>/Flutter/4%E7%99%BB%E5%BD%95%E9%A1%B5%E5%AE%9E%E6%88%98/%E7%99%BB%E5%BD%95%E9%A1%B5%E5%9C%A8iOS%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="第2节：登录页在iOS工程中的代码"><a href="#第2节：登录页在iOS工程中的代码" class="headerlink" title="第2节：登录页在iOS工程中的代码"></a>第2节：登录页在iOS工程中的代码</h1>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第四章：Flutter登录页实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 登录页实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：登录页在Flutter工程中的代码</title>
      <link href="/Flutter/4%E7%99%BB%E5%BD%95%E9%A1%B5%E5%AE%9E%E6%88%98/%E7%99%BB%E5%BD%95%E9%A1%B5%E5%9C%A8Flutter%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
      <url>/Flutter/4%E7%99%BB%E5%BD%95%E9%A1%B5%E5%AE%9E%E6%88%98/%E7%99%BB%E5%BD%95%E9%A1%B5%E5%9C%A8Flutter%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="第1节：登录页在Flutter工程中的代码"><a href="#第1节：登录页在Flutter工程中的代码" class="headerlink" title="第1节：登录页在Flutter工程中的代码"></a>第1节：登录页在Flutter工程中的代码</h1>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第四章：Flutter登录页实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 登录页实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：Flutter登录页实战</title>
      <link href="/Flutter/4%E7%99%BB%E5%BD%95%E9%A1%B5%E5%AE%9E%E6%88%98/README/"/>
      <url>/Flutter/4%E7%99%BB%E5%BD%95%E9%A1%B5%E5%AE%9E%E6%88%98/README/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章介绍</p><ul><li>①通过Flutter构建适用于多平台的登录页，并在Flutter工程中建立提供给原生项目的方法及接收从原生项目返回的值。</li><li>②原生iOS项目使用Flutter实现的登录页时候的交互代码编写</li><li>③原生Android使用Flutter实现的登录页时候的交互代码编写</li></ul><hr><p><a href="./登录页在Flutter工程中的代码.md">点击此处，进入本章第1节的正式学习 &gt;</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 登录页实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3节：交互时Android端的代码编写</title>
      <link href="/Flutter/3%E4%BA%A4%E4%BA%92/%E4%BA%A4%E4%BA%92%E6%97%B6Android%E7%AB%AF%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/"/>
      <url>/Flutter/3%E4%BA%A4%E4%BA%92/%E4%BA%A4%E4%BA%92%E6%97%B6Android%E7%AB%AF%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="第3节：交互时Android端的代码编写"><a href="#第3节：交互时Android端的代码编写" class="headerlink" title="第3节：交互时Android端的代码编写"></a>第3节：交互时Android端的代码编写</h1>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第三章：原生项目与Flutter的交互 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：交互时iOS端的代码编写</title>
      <link href="/Flutter/3%E4%BA%A4%E4%BA%92/%E4%BA%A4%E4%BA%92%E6%97%B6iOS%E7%AB%AF%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/"/>
      <url>/Flutter/3%E4%BA%A4%E4%BA%92/%E4%BA%A4%E4%BA%92%E6%97%B6iOS%E7%AB%AF%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="第2节：交互时iOS端的代码编写"><a href="#第2节：交互时iOS端的代码编写" class="headerlink" title="第2节：交互时iOS端的代码编写"></a>第2节：交互时iOS端的代码编写</h1><p>本节学习内容：原生iOS项目在交互时的代码编写。</p><p>本节学习用时：<strong>30分钟</strong></p><p>本节学习方式：动手实践</p><hr><p>本节目录：</p><p>一、本节内容介绍</p><p>二、本节代码解释</p><hr><h2 id="一、本节内容介绍"><a href="#一、本节内容介绍" class="headerlink" title="一、本节内容介绍"></a>一、本节内容介绍</h2><p>略！</p><h2 id="二、本节代码解释"><a href="#二、本节代码解释" class="headerlink" title="二、本节代码解释"></a>二、本节代码解释</h2><h4 id="1、本节代码"><a href="#1、本节代码" class="headerlink" title="1、本节代码"></a>1、本节代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (void)showMainFlutterViewControllerWithoutParam &#123;</span><br><span class="line">    self.navigationController.navigationBarHidden = YES;</span><br><span class="line">    </span><br><span class="line">    FlutterViewController *flutterViewController = [[FlutterViewController alloc] initWithProject:nil nibName:nil bundle:nil];</span><br><span class="line">    </span><br><span class="line">    NSString *channelName = @&quot;com.dvlproad.ciyouzen/platform_channel&quot;;// 要与.dart中一致</span><br><span class="line">    FlutterMethodChannel *messageChannel = [FlutterMethodChannel methodChannelWithName:channelName binaryMessenger:flutterViewController];</span><br><span class="line">    </span><br><span class="line">    [messageChannel setMethodCallHandler:^(FlutterMethodCall * _Nonnull call, FlutterResult  _Nonnull result) &#123;</span><br><span class="line">        // call.method获取flutter给回到的方法名,要匹配到channelName对应的多个 发送方法名,一般需要判断区分</span><br><span class="line">        // call.arguments获取到flutter给到的参数,(比如跳转到另一个页面所需要参数)</span><br><span class="line">        // result是给flutter的回调,只能回调一次</span><br><span class="line">        NSString *message = [NSString stringWithFormat:@&quot;flutter回调:\n nmethod = %@\n arguments = %@&quot;, call.method, call.arguments];</span><br><span class="line">        NSLog(@&quot;%@&quot;, message);</span><br><span class="line">        </span><br><span class="line">        if ([call.method isEqualToString:@&quot;showToast&quot;]) &#123;</span><br><span class="line">            [CJToast shortShowMessage:message];</span><br><span class="line">            return;</span><br><span class="line">            </span><br><span class="line">        &#125; else if ([call.method isEqualToString:@&quot;goBack&quot;]) &#123;</span><br><span class="line">            [self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">            return;</span><br><span class="line">            </span><br><span class="line">        &#125; else if ([call.method isEqualToString:@&quot;goiosPage&quot;]) &#123;</span><br><span class="line">            OCCallFlutterViewController *viewController = [[OCCallFlutterViewController alloc] init];</span><br><span class="line">            viewController.parames = call.arguments;</span><br><span class="line">            [self.navigationController pushViewController:viewController animated:YES];</span><br><span class="line">            return;</span><br><span class="line">            </span><br><span class="line">        &#125; else if ([call.method isEqualToString:@&quot;changeLeftBarButtonAction&quot;]) &#123;</span><br><span class="line">            NSDictionary *params = @&#123;@&quot;imageName&quot;:@&quot;lib/Resources/message_arrow.png&quot;&#125;;</span><br><span class="line">            result(params);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result(FlutterMethodNotImplemented);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [self.navigationController pushViewController:flutterViewController animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第三章：原生项目与Flutter的交互 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：原生项目与Flutter的交互</title>
      <link href="/Flutter/3%E4%BA%A4%E4%BA%92/README/"/>
      <url>/Flutter/3%E4%BA%A4%E4%BA%92/README/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章介绍</p><ul><li>①通过Flutter的平台通道在Flutter工程中建立提供给原生项目的方法及接收从原生项目返回的值。</li><li>②原生iOS项目在交互时的代码编写</li><li>③原生Android项目在交互时的代码编写</li></ul><hr><p><a href="./用于测试交互的Flutter项目.md">点击此处，进入本章第1节的正式学习 &gt;</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：用于测试与原生项目交互的Flutter项目</title>
      <link href="/Flutter/3%E4%BA%A4%E4%BA%92/%E7%94%A8%E4%BA%8E%E6%B5%8B%E8%AF%95%E4%BA%A4%E4%BA%92%E7%9A%84Flutter%E9%A1%B9%E7%9B%AE/"/>
      <url>/Flutter/3%E4%BA%A4%E4%BA%92/%E7%94%A8%E4%BA%8E%E6%B5%8B%E8%AF%95%E4%BA%A4%E4%BA%92%E7%9A%84Flutter%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="第1节：用于测试与原生项目交互的Flutter项目"><a href="#第1节：用于测试与原生项目交互的Flutter项目" class="headerlink" title="第1节：用于测试与原生项目交互的Flutter项目"></a>第1节：用于测试与原生项目交互的Flutter项目</h1><p>本节学习内容：通过Flutter的平台通道在Flutter工程中建立提供给原生项目的方法及接收从原生项目返回的值。</p><p>本节学习用时：<strong>30分钟</strong></p><p>本节学习方式：动手实践</p><hr><p>本节目录：</p><p>一、本节内容介绍</p><p>二、本节代码解释</p><hr><h2 id="一、本节内容介绍"><a href="#一、本节内容介绍" class="headerlink" title="一、本节内容介绍"></a>一、本节内容介绍</h2><h4 id="1、主要介绍的知识点有："><a href="#1、主要介绍的知识点有：" class="headerlink" title="1、主要介绍的知识点有："></a>1、主要介绍的知识点有：</h4><ul><li>在iOS界面中点击一个按钮跳转到Flutter页面，该Flutter页面有需要传参Main页面</li></ul><h4 id="2、要实现的效果如下图所示："><a href="#2、要实现的效果如下图所示：" class="headerlink" title="2、要实现的效果如下图所示："></a>2、要实现的效果如下图所示：</h4><blockquote><p><img src="/Flutter/3交互/用于测试交互的Flutter项目/OC跳到Flutter有需要传参的Main页面.png" alt="OC跳到Flutter有需要传参的Main页面"></p></blockquote><h4 id="3、实现本节效果的代码"><a href="#3、实现本节效果的代码" class="headerlink" title="3、实现本节效果的代码"></a>3、实现本节效果的代码</h4><p>本节所有代码文件为：<code>main.dart</code>、<code>StatelessMainPage.dart</code>、<code>StatefulMainPage.dart</code>、<code>NewRouteNoneParam.dart</code>、<code>NewRouteWithParam</code>。</p><blockquote><p>您可自己通过<code>flutter create materialappproject</code>创建materialappproject项目后，将其lib文件夹下的代码文件替换为如下即可。</p></blockquote><h6 id="3-1、其中完整的main-dart代码如下："><a href="#3-1、其中完整的main-dart代码如下：" class="headerlink" title="3.1、其中完整的main.dart代码如下："></a>3.1、其中完整的<code>main.dart</code>代码如下：</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'StatelessMainPage.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'StatefulMainPage.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'NewRouteNoneParam.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'NewRouteWithParam.dart'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Platform Channel Demo'</span>,</span><br><span class="line">      home: StatelessMainPage(), <span class="comment">//不需传参数的Flutter页面</span></span><br><span class="line">      <span class="comment">//home: StatefulMainPage(), //需传参数的Flutter页面</span></span><br><span class="line">      routes: &#123;</span><br><span class="line">        <span class="string">'StatelessMainPage'</span>:(context) =&gt; StatelessMainPage(),</span><br><span class="line">        <span class="string">'StatefulMainPage'</span>:(context) =&gt; StatefulMainPage(),</span><br><span class="line">        <span class="string">'NewRouteNoneParam'</span>:(context) =&gt; NewRouteNoneParam(),</span><br><span class="line">        <span class="string">'NewRouteWithParam'</span>:(context) =&gt; NewRouteWithParam()</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-2、其中完整的StatelessMainPage-dart代码如下："><a href="#3-2、其中完整的StatelessMainPage-dart代码如下：" class="headerlink" title="3.2、其中完整的StatelessMainPage.dart代码如下："></a>3.2、其中完整的<code>StatelessMainPage.dart</code>代码如下：</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'StatefulMainPage.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'NewRouteNoneParam.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'NewRouteWithParam.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已写在main.dart中</span></span><br><span class="line"><span class="comment">//void main() =&gt; runApp(MyApp());</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//class MyApp extends StatelessWidget &#123;</span></span><br><span class="line"><span class="comment">//  @override</span></span><br><span class="line"><span class="comment">//  Widget build(BuildContext context) &#123;</span></span><br><span class="line"><span class="comment">//    return MaterialApp(</span></span><br><span class="line"><span class="comment">//      title: 'Platform Channel Demo',</span></span><br><span class="line"><span class="comment">//      home: StatelessMainPage(),</span></span><br><span class="line"><span class="comment">//      routes: &#123;</span></span><br><span class="line"><span class="comment">//        'newRoute':(context) =&gt; NewRoute(),</span></span><br><span class="line"><span class="comment">//        'newRouteWithParam':(context) =&gt; NewRouteWithParam(),</span></span><br><span class="line"><span class="comment">//        'StatefulMainPage':(context) =&gt; StatefulMainPage()</span></span><br><span class="line"><span class="comment">//      &#125;</span></span><br><span class="line"><span class="comment">//    );</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatelessMainPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个给native的channel (类似iOS的通知）</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> methodChannel = <span class="keyword">const</span> MethodChannel(<span class="string">'com.dvlproad.ciyouzen/platform_channel'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给客户端发送一些东东, 这里先不用去拿回什么</span></span><br><span class="line">  Future&lt;<span class="built_in">Null</span>&gt; _showToast() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> methodChannel.invokeMethod(<span class="string">'showToast'</span>,<span class="string">'这是我在Flutter中写的文字'</span>);</span><br><span class="line">    &#125; on PlatformException &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">Null</span>&gt; _goBack() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> methodChannel.invokeMethod(<span class="string">'goBack'</span>);</span><br><span class="line">    &#125; on PlatformException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">Null</span>&gt; _goiosPage() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; map = &#123; <span class="string">"content"</span>: <span class="string">"flutter传给iOS的内容"</span>,<span class="string">"data"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]&#125;;</span><br><span class="line">      <span class="keyword">await</span> methodChannel.invokeMethod(<span class="string">'goiosPage'</span>, map);</span><br><span class="line">    &#125; on PlatformException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//Scaffold是Material中主要的布局组件.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">          leading: <span class="keyword">new</span> IconButton(</span><br><span class="line">            icon: <span class="keyword">new</span> Icon(Icons.menu),</span><br><span class="line">            tooltip: <span class="string">'Navigation menu'</span>,</span><br><span class="line">            onPressed: <span class="keyword">null</span>,</span><br><span class="line">          ),</span><br><span class="line">          title: <span class="keyword">new</span> Text(<span class="string">'platform channel Example title'</span>),</span><br><span class="line">          actions: &lt;Widget&gt;[</span><br><span class="line"><span class="comment">//            new IconButton(</span></span><br><span class="line"><span class="comment">//              icon: new Icon(Icons.search),</span></span><br><span class="line"><span class="comment">//              tooltip: 'Search',</span></span><br><span class="line"><span class="comment">//              //onPressed: null,</span></span><br><span class="line"><span class="comment">//              onPressed: () &#123;</span></span><br><span class="line"><span class="comment">//                goStatefulMainPage(context);</span></span><br><span class="line"><span class="comment">//              &#125;,</span></span><br><span class="line"><span class="comment">//            ),</span></span><br><span class="line">            <span class="keyword">new</span> FlatButton(</span><br><span class="line">                child: Image.asset(<span class="string">'lib/Resources/nav_right_gray_normal.png'</span>),</span><br><span class="line">                onPressed: ()&#123;</span><br><span class="line">                  goStatefulMainPage(context);</span><br><span class="line">                &#125;),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">//body占屏幕的大部分</span></span><br><span class="line">        body: <span class="keyword">new</span> Center(</span><br><span class="line">          child: Column(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              <span class="keyword">new</span> Text(<span class="string">'Hello, platform channel!'</span>),</span><br><span class="line">              <span class="keyword">new</span> RaisedButton(</span><br><span class="line">                  child: Text(<span class="string">'showToast'</span>),</span><br><span class="line">                  onPressed: ()&#123;</span><br><span class="line">                    _showToast();</span><br><span class="line">                  &#125;</span><br><span class="line">              ),</span><br><span class="line">              <span class="keyword">new</span> RaisedButton(</span><br><span class="line">                  child: Text(<span class="string">'goBack'</span>),</span><br><span class="line">                  onPressed: ()&#123;</span><br><span class="line">                    _goBack();</span><br><span class="line">                  &#125;</span><br><span class="line">              ),</span><br><span class="line">              <span class="keyword">new</span> RaisedButton(</span><br><span class="line">                  child: Text(<span class="string">'goiosPage'</span>),</span><br><span class="line">                  onPressed: ()&#123;</span><br><span class="line">                    _goiosPage();</span><br><span class="line">                  &#125;</span><br><span class="line">              ),</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">          tooltip: <span class="string">'Add'</span>, <span class="comment">// used by assistive technologies</span></span><br><span class="line">          child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">             goNextPageNoneParam(context);</span><br><span class="line">          &#125;,</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> goNextPageNoneParam(context) &#123;</span><br><span class="line">  Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NewRouteNoneParam();</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> goNextPageWithParams(context) &#123;</span><br><span class="line">  Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NewRouteWithParam();</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> goStatefulMainPage(context) &#123;</span><br><span class="line">  Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatefulMainPage();</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-3、其中完整的StatefulMainPage-dart代码如下："><a href="#3-3、其中完整的StatefulMainPage-dart代码如下：" class="headerlink" title="3.3、其中完整的StatefulMainPage.dart代码如下："></a>3.3、其中完整的<code>StatefulMainPage.dart</code>代码如下：</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'NewRouteNoneParam.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 已写在main.dart中</span></span><br><span class="line"><span class="comment">//void main() =&gt; runApp(MyApp());</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//class MyApp extends StatelessWidget &#123;</span></span><br><span class="line"><span class="comment">//  @override</span></span><br><span class="line"><span class="comment">//  Widget build(BuildContext context) &#123;</span></span><br><span class="line"><span class="comment">//    return MaterialApp(</span></span><br><span class="line"><span class="comment">//      title: 'Platform Channel Demo',</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      home: StatefulMainPage(),</span></span><br><span class="line"><span class="comment">//    );</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulMainPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement createState</span></span><br><span class="line">    <span class="keyword">return</span> StatefulMainPageState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulMainPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StatefulMainPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个给native的channel (类似iOS的通知）</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> methodChannel = <span class="keyword">const</span> MethodChannel(</span><br><span class="line">      <span class="string">'com.dvlproad.ciyouzen/platform_channel'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给客户端发送一些东东, 这里先不用去拿回什么</span></span><br><span class="line">  Future&lt;<span class="built_in">Null</span>&gt; _showToast() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> methodChannel.invokeMethod(<span class="string">'showToast'</span>,<span class="string">'这是我在Flutter中写的文字'</span>);</span><br><span class="line">    &#125; on PlatformException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">Null</span>&gt; _goBack() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> methodChannel.invokeMethod(<span class="string">'goBack'</span>);</span><br><span class="line">    &#125; on PlatformException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">Null</span>&gt; _goiosPage() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; map = &#123; <span class="string">"content"</span>: <span class="string">"flutter传给iOS的内容"</span>,<span class="string">"data"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]&#125;;</span><br><span class="line">      <span class="keyword">await</span> methodChannel.invokeMethod(<span class="string">'goiosPage'</span>, map);</span><br><span class="line">    &#125; on PlatformException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> imageName = <span class="string">"lib/Resources/message_arrow.png"</span>;</span><br><span class="line">  Future&lt;<span class="built_in">Null</span>&gt; _changeLeftBarButtonAction() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; map = &#123; <span class="string">"content"</span>: <span class="string">"flutter传给iOS的内容"</span>,<span class="string">"data"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]&#125;;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Map</span> dict = <span class="keyword">await</span> methodChannel.invokeMethod(<span class="string">'changeLeftBarButtonAction'</span>, map);</span><br><span class="line"></span><br><span class="line">      setState(() &#123;</span><br><span class="line">        imageName = dict[<span class="string">"imageName"</span>];</span><br><span class="line">        <span class="built_in">print</span>(imageName);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; on PlatformException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement initState</span></span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _changeLeftBarButtonAction();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//Scaffold是Material中主要的布局组件.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">          leading: <span class="keyword">new</span> FlatButton(</span><br><span class="line"><span class="comment">//              child: Image.asset('lib/Resources/nav_back_white_normal.png'),</span></span><br><span class="line">              child: Image.asset(imageName),</span><br><span class="line">              onPressed: ()&#123;</span><br><span class="line">                  _goBack();</span><br><span class="line">              &#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">//          new IconButton(</span></span><br><span class="line"><span class="comment">//            icon: new Icon(Icons.menu),</span></span><br><span class="line"><span class="comment"><span class="markdown">////          icon: Image.asset('lib/Resources/message_arrow.png'),</span></span></span><br><span class="line"><span class="comment">//            tooltip: 'Navigation menu',</span></span><br><span class="line"><span class="comment">//            onPressed: null,</span></span><br><span class="line"><span class="comment">//          ),</span></span><br><span class="line">          title: <span class="keyword">new</span> Text(<span class="string">'StatefulMainPage'</span>),</span><br><span class="line">          actions: &lt;Widget&gt;[</span><br><span class="line"><span class="comment">//            new IconButton(</span></span><br><span class="line"><span class="comment">//              icon: new Icon(Icons.search),</span></span><br><span class="line"><span class="comment">//              tooltip: 'Search',</span></span><br><span class="line"><span class="comment">//              onPressed: null,</span></span><br><span class="line"><span class="comment">//            ),</span></span><br><span class="line">            <span class="keyword">new</span> FlatButton(</span><br><span class="line">                child: Image.asset(<span class="string">'lib/Resources/nav_right_gray_normal.png'</span>),</span><br><span class="line">                onPressed: <span class="keyword">null</span></span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">//body占屏幕的大部分</span></span><br><span class="line">        body: <span class="keyword">new</span> Center(</span><br><span class="line">          child: Column(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Image.asset(<span class="string">'lib/Resources/message_arrow.png'</span>),</span><br><span class="line">              <span class="keyword">new</span> Text(<span class="string">'Hello, StatefulMainPage!'</span>),</span><br><span class="line">              <span class="keyword">new</span> RaisedButton(</span><br><span class="line">                  child: Text(<span class="string">'showToast'</span>),</span><br><span class="line">                  onPressed: ()&#123;</span><br><span class="line">                    _showToast();</span><br><span class="line">                  &#125;</span><br><span class="line">              ),</span><br><span class="line">              <span class="keyword">new</span> RaisedButton(</span><br><span class="line">                  child: Text(<span class="string">'goBack'</span>),</span><br><span class="line">                  onPressed: ()&#123;</span><br><span class="line">                    _goBack();</span><br><span class="line">                  &#125;</span><br><span class="line">              ),</span><br><span class="line">              <span class="keyword">new</span> RaisedButton(</span><br><span class="line">                  child: Text(<span class="string">'goiosPage'</span>),</span><br><span class="line">                  onPressed: ()&#123;</span><br><span class="line">                    _goiosPage();</span><br><span class="line">                  &#125;</span><br><span class="line">              ),</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">          tooltip: <span class="string">'Add'</span>, <span class="comment">// used by assistive technologies</span></span><br><span class="line">          child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            goNextPageNoneParam(context);</span><br><span class="line">          &#125;,</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> goNextPageNoneParam(context) &#123;</span><br><span class="line">  Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NewRouteNoneParam();</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-4、其中完整的NewRouteNoneParam-dart代码如下："><a href="#3-4、其中完整的NewRouteNoneParam-dart代码如下：" class="headerlink" title="3.4、其中完整的NewRouteNoneParam.dart代码如下："></a>3.4、其中完整的<code>NewRouteNoneParam.dart</code>代码如下：</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewRouteNoneParam</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> methodChannel = <span class="keyword">const</span> MethodChannel(<span class="string">'com.dvlproad.ciyouzen/platform_channel'</span>);</span><br><span class="line">  Future&lt;<span class="built_in">Null</span>&gt; _goBack() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> methodChannel.invokeMethod(<span class="string">'goBack'</span>);</span><br><span class="line">    &#125; on PlatformException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"New route none Param"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">"This is new route"</span>),</span><br><span class="line">            RaisedButton(</span><br><span class="line">              child: Text(<span class="string">'goback'</span>),</span><br><span class="line">              onPressed: _goBack</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-5、其中完整的NewRouteWithParam-dart代码如下："><a href="#3-5、其中完整的NewRouteWithParam-dart代码如下：" class="headerlink" title="3.5、其中完整的NewRouteWithParam.dart代码如下："></a>3.5、其中完整的<code>NewRouteWithParam.dart</code>代码如下：</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewRouteWithParam</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> methodChannel = <span class="keyword">const</span> MethodChannel(<span class="string">'com.dvlproad.ciyouzen/platform_channel'</span>);</span><br><span class="line">  Future&lt;<span class="built_in">Null</span>&gt; _goBack() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> methodChannel.invokeMethod(<span class="string">'goBack'</span>);</span><br><span class="line">    &#125; on PlatformException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"New route with params"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">"This is new route with params"</span>),</span><br><span class="line">            RaisedButton(</span><br><span class="line">              child: Text(<span class="string">'goback'</span>),</span><br><span class="line">              onPressed: _goBack</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第三章：原生项目与Flutter的交互 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：Android项目集成Flutter</title>
      <link href="/Flutter/2%E9%9B%86%E6%88%90/Android%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90Flutter/"/>
      <url>/Flutter/2%E9%9B%86%E6%88%90/Android%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90Flutter/</url>
      
        <content type="html"><![CDATA[<h1 id="第2节：Android项目集成Flutter"><a href="#第2节：Android项目集成Flutter" class="headerlink" title="第2节：Android项目集成Flutter"></a>第2节：Android项目集成Flutter</h1><p>本节学习内容：在已有的Android项目中集成Flutter，以使得您的Android项目中的部分界面/功能可以通过Flutter来实现。</p><p>本节学习用时：<strong>3分钟</strong></p><p>本节学习方式：动手实践</p><hr><p>本节目录：</p><p>一、集成方式介绍</p><p>二、集成方法介绍</p><p>三、集成后调用Flutter界面的代码编写</p><hr><h4 id="一、集成方式介绍"><a href="#一、集成方式介绍" class="headerlink" title="一、集成方式介绍"></a>一、集成方式介绍</h4><p>本节将介绍两种在已有的Android项目中集成Flutter的方法。</p><p>待补充。。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第二章：集成Flutter到原生项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 集成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：集成Flutter到原生项目</title>
      <link href="/Flutter/2%E9%9B%86%E6%88%90/README/"/>
      <url>/Flutter/2%E9%9B%86%E6%88%90/README/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章介绍在已有的原生项目中集成Flutter，以使得您的原生项目中的部分界面/功能可以通过Flutter来实现。</p><p>本章目前主要介绍在iOS项目中集成Flutter、在Android项目中集成Flutter两个部分。</p><hr><p>其他参考资料：</p><ul><li><a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps" target="_blank" rel="noopener">flutter自家的混编wiki:Add Flutter to existing apps</a></li></ul><hr><p><a href="./iOS项目集成Flutter.md">点击此处，进入本章第1节的正式学习 &gt;</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 集成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：iOS项目集成Flutter</title>
      <link href="/Flutter/2%E9%9B%86%E6%88%90/iOS%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90Flutter/"/>
      <url>/Flutter/2%E9%9B%86%E6%88%90/iOS%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90Flutter/</url>
      
        <content type="html"><![CDATA[<h1 id="第1节：iOS项目集成Flutter"><a href="#第1节：iOS项目集成Flutter" class="headerlink" title="第1节：iOS项目集成Flutter"></a>第1节：iOS项目集成Flutter</h1><p>本节学习内容：在已有的iOS项目中集成Flutter，以使得您的iOS项目中的部分界面/功能可以通过Flutter来实现。</p><p>本节学习用时：<strong>30分钟</strong></p><p>本节学习方式：动手实践</p><hr><p>本节目录：</p><p>一、集成方式介绍</p><p>二、集成方法一：手动配置iOS与Flutter的混编环境</p><p>三、集成方法二：Pod集成Flutter方式</p><p>四、集成后调用Flutter界面的代码编写</p><hr><h4 id="一、集成方式介绍"><a href="#一、集成方式介绍" class="headerlink" title="一、集成方式介绍"></a>一、集成方式介绍</h4><p>本节将介绍两种在已有的iOS项目中集成Flutter的方法，分别为①手动配置iOS与Flutter的混编环境、②Pod集成Flutter方式。</p><p>下面表格是两种集成Flutter的方法比较：</p><table><thead><tr><th></th><th>手动集成Flutter</th><th>Pod集成Flutter</th></tr></thead><tbody><tr><td>集成速度</td><td>需要自己建立文件、进行相应配置，并替换</td><td>执行Pod及Run Script即可</td></tr><tr><td>Flutter项目更新时</td><td>每次都需要替换</td><td>不用替换</td></tr><tr><td>Flutter项目与iOS同时路径变更时</td><td>不影响iOS工程</td><td>Flutter工程需要重新编译执行；<br>然后iOS工程需再重新执行Pod</td></tr></tbody></table><h4 id="二、集成方法一：手动配置iOS与Flutter的混编环境"><a href="#二、集成方法一：手动配置iOS与Flutter的混编环境" class="headerlink" title="二、集成方法一：手动配置iOS与Flutter的混编环境"></a>二、集成方法一：手动配置iOS与Flutter的混编环境</h4><h6 id="1-1-集成后的最后项目结构如图："><a href="#1-1-集成后的最后项目结构如图：" class="headerlink" title="1.1 集成后的最后项目结构如图："></a>1.1 集成后的最后项目结构如图：</h6><blockquote><p><img src="/Flutter/2集成/iOS项目集成Flutter/myiosproject%20project%20structure.png" alt="myiosproject project structure"></p></blockquote><h6 id="1-2-集成后的最后文件结构如图："><a href="#1-2-集成后的最后文件结构如图：" class="headerlink" title="1.2 集成后的最后文件结构如图："></a>1.2 集成后的最后文件结构如图：</h6><blockquote><p><img src="/Flutter/2集成/iOS项目集成Flutter/myiosproject%20file%20structure.png" alt="myiosproject file structure"></p></blockquote><h6 id="1-3-详细的集成实现步骤如下："><a href="#1-3-详细的集成实现步骤如下：" class="headerlink" title="1.3 详细的集成实现步骤如下："></a>1.3 详细的集成实现步骤如下：</h6><ul><li><p>①、通过终端命令在指定目录(这里我们选择iOS项目的同级目录)创建myfluttermodule。<code>flutter create -t module myfluttermodule</code></p></li><li><p>②、Xcode：创建iOS项目，设为myiosproject；</p></li><li><p>③、Xcode：创建配置衔接文件</p><ul><li><p>在②中建立的iOS项目中新建<code>Config</code>目录，用于存放/管理接下来Xcode工程需要创建的的配置衔接文件；</p></li><li><p>选择创建<code>Configuration Settings File</code>文件，分别创建名为 <code>Flutter.xcconfig</code>、<code>Debug.xcconfig</code>、<code>Release.xcconfig</code>的三个配置文件；</p><blockquote><p><img src="/Flutter/2集成/iOS项目集成Flutter/New%20Configuration%20Settings%20File.png" alt="New Configuration Settings File"></p></blockquote></li><li><p>完善<code>Flutter.xcconfig</code>、<code>Debug.xcconfig</code>、<code>Release.xcconfig</code>三个配置文件的内容为分别如下：</p><blockquote><p>Flutter.xcconfig 配置文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; //Flutter.xconfig,用于指向外目录flutter module的`Generated.xcconfig`文件路径引用文件</span><br><span class="line">&gt; </span><br><span class="line">&gt; //这里填写前面建立的 myfluttermodule 的Generated.xcconfig的路径</span><br><span class="line">&gt; #include &quot;../../myfluttermodule/.ios/Flutter/Generated.xcconfig&quot;</span><br><span class="line">&gt; ENABLE_BITCODE=NO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Debug.xcconfig 配置文件内容如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; //Debug.xconfig，Xcode的环境配置文件</span><br><span class="line">&gt; </span><br><span class="line">&gt; #include &quot;Flutter.xcconfig&quot;</span><br><span class="line">&gt; //#include &quot;../Pods/Target Support Files/******.debug.xcconfig&quot;//pod路径</span><br><span class="line">&gt; #include &quot;../Pods/Target Support Files/Pods-myiosproject/Pods-myiosproject.debug.xcconfig&quot;//pod路径</span><br><span class="line">&gt; FLUTTER_BUILD_MODE=debug</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Release.xcconfig 配置文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; //Release.xconfig，Xcode的环境配置文件</span><br><span class="line">&gt; </span><br><span class="line">&gt; #include &quot;Flutter.xcconfig&quot;</span><br><span class="line">&gt; //#include &quot;../Pods/Target Support Files/******.release.xcconfig&quot;//pod路径</span><br><span class="line">&gt; #include &quot;../Pods/Target Support Files/Pods-myiosproject/Pods-myiosproject.release.xcconfig&quot;//pod路径</span><br><span class="line">&gt; FLUTTER_BUILD_MODE=release</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>修改Xcode Project的环境配置选择</p><blockquote><p><img src="/Flutter/2集成/iOS项目集成Flutter/myiosproject%20Project%20Info%20Configurations.png" alt="myiosproject Project Info Configurations"></p></blockquote></li></ul></li><li><p>④、Xcode -&gt; Target -&gt; Build Phases -&gt; New Run Script Phase，添加要执行的脚本内容引入<code>xcode-backend.sh</code>，此步很重要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot; build</span><br><span class="line">&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot; embed</span><br></pre></td></tr></table></figure><blockquote><p><img src="/Flutter/2集成/iOS项目集成Flutter/myiosproject%20New%20Script%20xcode-backend.sh.png" alt="myiosproject New Script xcode-backend.sh"></p></blockquote></li></ul><ul><li><p>⑤、添加/替换flutter编译产物，<strong>如果之前已添加，则这里每次有有新的时候，注意要替换掉，否则界面还是旧的。</strong></p><blockquote><p>即复制 myfluttermodule/.ios/Flutter下的<code>App.framework</code>、<code>engine</code>、<code>flutter_assets</code>进行替换。</p><p>然后Xcode重新编译即可。</p><p>注意：<code>flutter_assets</code> 并不能使用<code>Create groups</code> 的方式添加，只能使用<code>Creat folder references</code> 的方式添加进Xcode项目内，否则跳转flutter会页面渲染失败（页面空白）。</p></blockquote></li><li><p>⑥、至此，恭喜你，到这里您可向往常一样直接执行已集成Flutter的Xcode项目了。</p></li></ul><h4 id="三、集成方法二：Pod集成Flutter方式"><a href="#三、集成方法二：Pod集成Flutter方式" class="headerlink" title="三、集成方法二：Pod集成Flutter方式"></a>三、集成方法二：Pod集成Flutter方式</h4><h6 id="2-1-最后的项目结构如图："><a href="#2-1-最后的项目结构如图：" class="headerlink" title="2.1 最后的项目结构如图："></a>2.1 最后的项目结构如图：</h6><blockquote><p><img src="/Flutter/2集成/iOS项目集成Flutter/myiosproject2%20project%20structure.png" alt="myiosproject2 project structure"></p></blockquote><h6 id="2-2-实现步骤如下："><a href="#2-2-实现步骤如下：" class="headerlink" title="2.2 实现步骤如下："></a>2.2 实现步骤如下：</h6><ul><li><p>①、通过终端命令在指定目录(这里我们选择iOS项目的同级目录)创建myfluttermodule。<code>flutter create -t module myfluttermodule</code>。这里因为我们已经在1中实现，所以不再重复创建。</p></li><li><p>②、Xcode：创建myiosproject2；添加如Podfile，及在Podfile中如结构图中所示，补充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter_application_path = &apos;./../myfluttermodule/&apos;</span><br><span class="line">eval(File.read(File.join(flutter_application_path, &apos;.ios&apos;, &apos;Flutter&apos;, &apos;podhelper.rb&apos;)), binding)</span><br></pre></td></tr></table></figure><p>后，执行pod install</p><blockquote><p><img src="/Flutter/2集成/iOS项目集成Flutter/myiosproject2%20pod%20install.png" alt="myiosproject2 pod install"></p></blockquote></li><li><p>③、Xcode -&gt; Target -&gt; Build Phases -&gt; New Run Script Phase，添加要执行的脚本内容引入<code>xcode-backend.sh</code>，此步很重要。同1中一样的做法。</p></li><li><p>④、至此，混编环境配置成功！</p></li></ul><h4 id="四、集成后调用Flutter界面的代码编写"><a href="#四、集成后调用Flutter界面的代码编写" class="headerlink" title="四、集成后调用Flutter界面的代码编写"></a>四、集成后调用Flutter界面的代码编写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line">#import &lt;Flutter/Flutter.h&gt;</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    // Override point for customization after application launch.</span><br><span class="line">    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">//    ViewController *viewController = [[ViewController alloc] init];</span><br><span class="line">//    UIViewController *rootViewController = [[UINavigationController alloc] initWithRootViewController:viewController];</span><br><span class="line">    UIViewController *rootViewController = [[FlutterViewController alloc] initWithProject:nil nibName:nil bundle:nil];</span><br><span class="line">    self.window.rootViewController = rootViewController;</span><br><span class="line">    [self.window makeKeyAndVisible];</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后，正常执行Xcode项目即可。</p><h2 id="三、更多混编"><a href="#三、更多混编" class="headerlink" title="三、更多混编"></a>三、更多混编</h2><p>更多混编知识，请查看<a href="https://flutterchina.club/platform-channels/" target="_blank" rel="noopener">官网：使用平台通道编写平台特定的代码</a></p><blockquote><p><img src="/Flutter/2集成/iOS项目集成Flutter/platform%20channel.png" alt="platform channel"></p></blockquote><h2 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h2>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第二章：集成Flutter到原生项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 集成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言</title>
      <link href="/Flutter/README/"/>
      <url>/Flutter/README/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为更好的学习Flutter，特地将Flutter的学习从零整理及总结成本书，方便大家的快速学习！</p><p>其他权威网站：<a href="https://flutterchina.club/" target="_blank" rel="noopener">Flutter中文网</a>、<a href="https://book.flutterchina.club" target="_blank" rel="noopener">Flutter实战书籍</a></p><h2 id="主流跨平台语言对比"><a href="#主流跨平台语言对比" class="headerlink" title="主流跨平台语言对比"></a>主流跨平台语言对比</h2><p><a href="https://ask.dcloud.net.cn/article/id-36083" target="_blank" rel="noopener"><strong>一个推uniapp的flutter、rn、uni-app比较的好文</strong></a></p><p>主流跨平台语言(Flutter和RN、Weex)之间的对比：</p><p><img src="/Flutter/README/主流跨平台语言对比.jpg" alt="主流跨平台语言对比"></p><ul><li>渲染性能</li></ul><p>和RN和Weex将javascript转化为原生控件渲染不同，Flutter完全挣脱了原生控件的“束缚”，如下图所示，Flutter使用了分层架构，分为Framework和Engine两个部分，其中Framework层提供各种基础组件库，包括各种Widget，动画等，Engine层则完全由C和C++实现，使用Skia进行渲染（对！就是chrome用的那个图形渲染框架），官方宣称可以达到原生app的渲染性能。</p><p><img src="/Flutter/README/Flutter结构.jpg" alt="Flutter结构"></p><ul><li>Google新操作系统Fuchsia(被认为是Android的继任者)也使用Flutter作为其UI框架，今后的发展不可限量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目录</title>
      <link href="/Flutter/SUMMARY/"/>
      <url>/Flutter/SUMMARY/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="README.md">前言</a></li><li><a href="1入门/README.md">第一章：入门</a><ul><li><a href="1入门/Flutter开发环境搭建.md">第1节：Flutter开发环境搭建</a></li><li><a href="1入门/Flutter的Hello World.md">第2节：Flutter的Hello World</a></li><li><a href="1入门/Flutter的最基础知识.md">第3节：Flutter的最基础知识</a></li></ul></li><li><a href="2集成/README.md">第二章：原生项目集成Flutter</a><ul><li><a href="2集成/iOS项目集成Flutter.md">第1节：iOS项目集成Flutter</a></li><li><a href="2集成/Android项目集成Flutter.md">第2节：Android项目集成Flutter</a></li></ul></li><li><a href="3交互/README.md">第三章：原生项目与Flutter交互</a><ul><li><a href="3交互/用于测试交互的Flutter项目.md">第1节：用于测试交互的Flutter项目</a></li><li><a href="3交互/交互时iOS端的代码编写.md">第2节：交互时iOS端的代码编写</a></li><li><a href="3交互/交互时Android端的代码编写.md">第3节：交互时Android端的代码编写</a></li></ul></li><li><a href="4登录页实战/README.md">第四章：Flutter登录页实战</a><ul><li><a href="4登录页实战/登录页在Flutter工程中的代码.md">第1节：登录页在Flutter工程中的代码</a></li><li><a href="4登录页实战/登录页在iOS工程中的代码.md">第2节：登录页在iOS工程中的代码</a></li><li><a href="4登录页实战/登录页在Android工程中的代码.md">第3节：登录页在Android工程中的代码</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：Flutter与Dart的升级</title>
      <link href="/Flutter/1%E5%85%A5%E9%97%A8/Flutter%E4%B8%8EDart%E7%9A%84%E5%8D%87%E7%BA%A7/"/>
      <url>/Flutter/1%E5%85%A5%E9%97%A8/Flutter%E4%B8%8EDart%E7%9A%84%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、查看当前Flutter与Dart版本"><a href="#一、查看当前Flutter与Dart版本" class="headerlink" title="一、查看当前Flutter与Dart版本"></a>一、查看当前Flutter与Dart版本</h2><p>升级dart sdk和升级flutter sdk是不一样的，两者千万不要搞混了。</p><p> 废话不多说，其实我就想说一句，dart sdk不建议升级。</p><p>为什么这么说呢，原因很简单，因为flutter sdk中自带了匹配flutter sdk版本的dart sdk（flutter sdk和dart sdk的版本要匹配，不是任意的dart sdk版本都能匹配任意的flutter sdk版本，这一点官方已经帮我们做了。在你下载的flutter sdk中就自带了匹配版本的dart sdk）。如果强行手动去升级dart sdk会报错，flutter项目都会出问题的。</p><p>flutter与Dart的匹配：<a href="https://flutter.cn/docs/development/tools/sdk/releases?tab=macos" target="_blank" rel="noopener">https://flutter.cn/docs/development/tools/sdk/releases?tab=macos</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qian@qiandeMacBook-Pro ~ % dart --version</span><br><span class="line">Dart SDK version: 2.14.4 (stable) (Wed Oct 13 11:11:32 2021 +0200) on "macos_x64"</span><br><span class="line">qian@qiandeMacBook-Pro ~ % </span><br><span class="line">qian@qiandeMacBook-Pro ~ % flutter --version</span><br><span class="line">Flutter 2.5.3 • channel stable • https://github.com/flutter/flutter.git</span><br><span class="line">Framework • revision 18116933e7 (6 months ago) • 2021-10-15 10:46:35 -0700</span><br><span class="line">Engine • revision d3ea636dc5</span><br><span class="line">Tools • Dart 2.14.4</span><br><span class="line">qian@qiandeMacBook-Pro ~ %</span><br></pre></td></tr></table></figure><h2 id="二、升级到3-0-0"><a href="#二、升级到3-0-0" class="headerlink" title="二、升级到3.0.0"></a>二、升级到3.0.0</h2><p>Flutter 3.0 升级涉及的主要三方库整理如下：</p><table><thead><tr><th>三方库</th><th>功能简述</th><th>当前版本</th><th>最新版本</th><th>官方开始支持 flutter3.0的版本</th><th>备注</th></tr></thead><tbody><tr><td><a href="https://pub.dev/packages/pull_to_refresh" target="_blank" rel="noopener">pull_to_refresh</a></td><td>下拉刷新上拉加载</td><td>2.0.0</td><td>2.0.0</td><td>无</td><td></td></tr><tr><td><a href="https://pub.dev/packages/flutter_easyrefresh" target="_blank" rel="noopener">flutter_easyrefresh</a></td><td>下拉刷新上拉加载</td><td>2.2.1</td><td>2.2.1</td><td>无</td><td></td></tr><tr><td><a href="https://pub.dev/packages/marquee" target="_blank" rel="noopener">marquee</a></td><td>跑马灯</td><td>2.2.0</td><td>2.2.2</td><td>2.2.2(5.19)</td><td></td></tr><tr><td><a href="https://pub.dev/packages/fading_edge_scrollview" target="_blank" rel="noopener">fading_edge_scrollview</a></td><td>构建具有淡入淡出边缘的可滚动视图 marquee中依赖</td><td>2.0.1</td><td>2.0.1</td><td>无</td><td></td></tr><tr><td><a href="https://pub.dev/packages/photo_manager" target="_blank" rel="noopener">photo_manager</a></td><td>相册相关插件</td><td>2.0.8</td><td>2.1.1</td><td>2.1.0+2(5.13)</td><td></td></tr><tr><td><a href="https://pub.dev/packages/wechat_assets_picker" target="_blank" rel="noopener">wechat_assets_picker</a></td><td>相册选择照片</td><td>7.2.0</td><td>7.3.0</td><td>7.3.0(5.13)</td><td></td></tr><tr><td><a href="https://pub.dev/packages/wechat_camera_picker" target="_blank" rel="noopener">wechat_camera_picker</a></td><td>相机拍摄照片</td><td>3.1.0</td><td>3.2.0+1</td><td>3.2.0+1(5.13)</td><td></td></tr><tr><td><a href="https://pub.dev/packages/extended_image" target="_blank" rel="noopener">extended_image</a></td><td>图片浏览</td><td>6.0.3</td><td>6.2.1</td><td>6.2.0(5.12)</td><td></td></tr><tr><td><a href="https://pub.dev/packages/extended_image_library" target="_blank" rel="noopener">extended_image_library</a></td><td>图片浏览</td><td>3.1.4</td><td>3.3.0</td><td>3.3.0(5.12)</td><td></td></tr><tr><td><a href="https://pub.dev/packages/reorderables" target="_blank" rel="noopener">reorderables</a></td><td>拖曳排序</td><td>0.4.4</td><td>0.5.0</td><td>0.5.0(5.12)</td><td></td></tr><tr><td><a href="https://pub.dev/packages/cached_network_image" target="_blank" rel="noopener">cached_network_image</a></td><td>图片缓存底层库</td><td>3.2.0</td><td>3.2.1</td><td>3.2.1(5.16)</td><td></td></tr><tr><td><a href="https://pub.dev/packages/flutter_easyloading" target="_blank" rel="noopener">flutter_easyloading</a></td><td>loading</td><td>3.0.1</td><td>3.0.5</td><td>3.0.5(5.23)</td><td></td></tr><tr><td><a href="https://pub.dev/packages/tim_ui_kit_lbs_plugin" target="_blank" rel="noopener">tim_ui_kit_lbs_plugin</a></td><td>地图位置插件</td><td>1.1.2</td><td>1.1.2</td><td>无</td><td></td></tr><tr><td><a href="https://pub.dev/packages/bruno" target="_blank" rel="noopener">bruno</a></td><td>贝壳UI库</td><td>2.0.0</td><td>2.2.0</td><td>无</td><td></td></tr><tr><td><a href="https://pub.dev/packages/scroll_to_index" target="_blank" rel="noopener">scroll_to_index</a></td><td>固定/可变行高的滚动</td><td>2.1.1</td><td>3.0.1</td><td>3.0.0</td><td></td></tr><tr><td><a href="https://pub.dev/packages/scrollable_positioned_list" target="_blank" rel="noopener">scrollable_positioned_list</a></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>scroll_to_index](<a href="https://pub.dev/packages/" target="_blank" rel="noopener">https://pub.dev/packages/</a>)</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>scroll_to_index](<a href="https://pub.dev/packages/" target="_blank" rel="noopener">https://pub.dev/packages/</a>)</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>上述控件计划处理方案：</p><p>1、已支持的，直接升级到，并升级其依赖到的相关库</p><p>2、不支持且需要的，进行手动支持，如<code>tim_ui_kit_lbs_plugin</code>等</p><p>3、不支持但冗余的，合并减少，如<code>pull_to_refresh</code>和<code>flutter_easyrefresh</code></p><p>4、不支持但冗余且被其他app使用率不高的，从项目中逐步移除，如<code>bruno</code></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第一章：Flutter入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：Flutter开发环境搭建与运行</title>
      <link href="/Flutter/1%E5%85%A5%E9%97%A8/Flutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/"/>
      <url>/Flutter/1%E5%85%A5%E9%97%A8/Flutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>本节学习内容：Flutter的环境搭建及创建运行您的第一个Flutter项目。</p><p>本节学习用时：<strong>30分钟</strong></p><p>本节学习方式：动手实践</p><hr><p>本节目录：</p><p>一、检测您是否具备了Flutter的开发环境</p><p>二、创建并运行第一个Flutter项目</p><p>附</p><hr><h2 id="一、检测您是否具备了Flutter的开发环境"><a href="#一、检测您是否具备了Flutter的开发环境" class="headerlink" title="一、检测您是否具备了Flutter的开发环境"></a>一、检测您是否具备了Flutter的开发环境</h2><p>因为您可能之前已经有配置过Flutter的开发环境了，所以为了避免重复安装，我们通过在终端运行<code>flutter doctor</code>命令，来进行检测，查看是否缺少。</p><p>新电脑未安装，请点击查看<a href="https://flutterchina.club/setup-macos/" target="_blank" rel="noopener">在macOS上搭建Flutter开发环境</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在终端打开该文件</span></span><br><span class="line">open ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 终端编辑该文件(没有则会新建)</span></span><br><span class="line">vim .bash_profile # 不存在.bash_profile，可以该终端输入来创建该文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在打开的文件中，插入如下内容</span></span><br><span class="line">export PATH=`pwd`/flutter/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入 :wq 来保存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在终端执行如下命令，保证设置的环境变量，本次就能够使用</span></span><br><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure><h3 id="1、环境已完善时"><a href="#1、环境已完善时" class="headerlink" title="1、环境已完善时"></a>1、环境已完善时</h3><p>如果您的环境之前已经配置过且已完全配置好的话，您的命令执行结果可能会如图所示：</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter doctor 检测出无问题.png" alt="flutter doctor 检测出无问题"></p><h3 id="2、环境未完善时"><a href="#2、环境未完善时" class="headerlink" title="2、环境未完善时"></a>2、环境未完善时</h3><ul><li>如果有提示错误的(<strong>如果你是第一次，那肯定有很多问题</strong>)，请参照本节最后的<code>【附1】、flutter doctor问题解决</code>中的内容进行解决。</li></ul><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/分割图1.jpg" alt="分割图1"></p><h2 id="二、创建第一个Flutter项目"><a href="#二、创建第一个Flutter项目" class="headerlink" title="二、创建第一个Flutter项目"></a>二、创建第一个Flutter项目</h2><h3 id="1、最简单的创建Flutter项目的方法"><a href="#1、最简单的创建Flutter项目的方法" class="headerlink" title="1、最简单的创建Flutter项目的方法"></a>1、最简单的创建Flutter项目的方法</h3><p>在终端执行<code>flutter create originflutterproject</code>即可在指定目录建立Flutter项目。</p><blockquote><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter%20create%20originflutterproject.png" alt="flutter create originflutterproject"></p></blockquote><h2 id="三、运行Flutter项目"><a href="#三、运行Flutter项目" class="headerlink" title="三、运行Flutter项目"></a>三、运行Flutter项目</h2><h3 id="1、运行方法"><a href="#1、运行方法" class="headerlink" title="1、运行方法"></a>1、运行方法</h3><h4 id="1-1、查找本地及指定运行设备"><a href="#1-1、查找本地及指定运行设备" class="headerlink" title="1.1、查找本地及指定运行设备"></a>1.1、查找本地及指定运行设备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter devices</span><br></pre></td></tr></table></figure><h4 id="1-2、常见的在终端运行方法"><a href="#1-2、常见的在终端运行方法" class="headerlink" title="1.2、常见的在终端运行方法"></a>1.2、常见的在终端运行方法</h4><p>在指定设备上运行Flutter项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d xxxxxxxx</span><br></pre></td></tr></table></figure><blockquote><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter%20run%20-d%20deviceid.png" alt="flutter run -d deviceid"></p></blockquote><h4 id="1-3、在WebStorm中运行"><a href="#1-3、在WebStorm中运行" class="headerlink" title="1.3、在WebStorm中运行"></a>1.3、在WebStorm中运行</h4><p>本质还在<code>flutter run -d xxxxxxxx</code></p><p>如果，你想在WebStorm中运行的话，操作如下：</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/webstorm flutter run -d deviceid 2.png" alt="webstorm flutter run -d deviceid"></p><p>上述 <code>External Tool</code>的添加过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/webstorm flutter run -d deviceid 3.png" alt="webstorm flutter run -d deviceid"></p><p>运行效果如下：</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/Users/lichaoqian/Project/CQBook/dvlproadHexo/source/_posts/Flutter/1入门/Flutter开发环境搭建与运行/webstorm flutter run -d deviceid 4.png" alt="webstorm flutter run -d deviceid"></p><p>热更新问题：</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/webstorm flutter run -d deviceid hot 2.png" alt="image-20200817102953555"></p><p>直接在终端下，输入对应的如<code>r</code>就行。</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/webstorm flutter run -d deviceid hot 3.png" alt="image-20200817103401865"></p><h4 id="1-4、在VS-Code中运行"><a href="#1-4、在VS-Code中运行" class="headerlink" title="1.4、在VS Code中运行"></a>1.4、在VS Code中运行</h4><p>选择设备有如下两个地方。当然你也可以直接在终端上执行。</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/image-20211209225632484.png" alt="image-20211209225632484"></p><h3 id="2、运行项目的常见问题"><a href="#2、运行项目的常见问题" class="headerlink" title="2、运行项目的常见问题"></a>2、运行项目的常见问题</h3><h4 id="2-1-问题一、缺少第三方库"><a href="#2-1-问题一、缺少第三方库" class="headerlink" title="2.1 问题一、缺少第三方库"></a>2.1 问题一、缺少第三方库</h4><p>如果缺少依赖的第三方库，在pubspec.yaml 文件中找到 dependencies 在里面填写 第三方库。</p><p>并请在终端执行<code>flutter packages get</code>，以拉取声明的第三方库到本地工程即可。</p><p><strong>flutter第三方库官网：<a href="https://pub.dartlang.org/" target="_blank" rel="noopener">https://pub.dartlang.org/</a></strong></p><p>如要了解更多请查看：<a href="https://flutterchina.club/get-started/test-drive/#terminal" target="_blank" rel="noopener">官网Flutter起步: 体验</a></p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/分割图1.jpg" alt="分割图1"></p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="【附1】、flutter-doctor问题解决"><a href="#【附1】、flutter-doctor问题解决" class="headerlink" title="【附1】、flutter doctor问题解决"></a>【附1】、flutter doctor问题解决</h3><p>flutter doctor该命令的作用：查看是否需要安装其它依赖项来完成安装。</p><p>下面涵盖的错误介绍及解决有：</p><ul><li>1.1、<em>-bash: flutter: command not found</em></li><li>1.2、缺少依赖项</li><li>其他问题，请查看<code>【附2】、flutter 安装过程中的其他问题解决</code></li></ul><h4 id="1-1、flutter-doctor执行问题-bash-flutter-command-not-found"><a href="#1-1、flutter-doctor执行问题-bash-flutter-command-not-found" class="headerlink" title="1.1、flutter doctor执行问题-bash: flutter: command not found"></a>1.1、flutter doctor执行问题<code>-bash: flutter: command not found</code></h4><p>原因：Flutter相关命令无效(此时<code>flutter -h</code>肯定也是一样的问题)</p><p>附：完好的flutter -h结果应为如图所示：</p><blockquote><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/%20flutter%20-h%20%E6%A3%80%E6%B5%8Bflutter.png" alt=" flutter -h 检测flutter"></p></blockquote><p>解决：下载Flutter SDK，并配置Flutter环境变量到PATH中即可。</p><p>步骤：</p><ul><li><p>①下载Flutter SDK。</p><p><a href="https://flutter.io/docs/get-started/install/macos" target="_blank" rel="noopener">Flutter SDK官网地址</a>。（如果您觉得速度慢，这里提供一个已经下载好的地址：<a href="https://pan.baidu.com/s/1yB5WRTvIRA2eISpUHtGP3w" target="_blank" rel="noopener">Flutter SDK 1.0.0 网盘下载地址</a>  密码:nm09）</p></li><li><p>②配置Flutter环境变量方法：即在<em>~/.bash_profile</em>文件里添加需要配置的内容即可。</p><p>下面是我的~/.bash_profile文件内容：</p></li></ul><blockquote><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/%E6%88%91%E7%9A%84~:.bash_profile.png" alt="我的~/.bash_profile"></p></blockquote><p>但在这里目前我们只需要上图中我圈出来的那行<code>export PATH=/Applications/flutter/bin:$PATH  #配置Flutter环境变量</code>即可。这里我们先满足目前认知Flutter所需的即可，没必要把如下其他行是暂时不需要的所有的都加上去，当然你加上去可以以后更省事。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Flutter</span></span><br><span class="line"><span class="built_in">export</span> PATH=/Applications/flutter/bin:<span class="variable">$PATH</span>  <span class="comment">#配置Flutter环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置pub源，才能让你在国内愉快的使用别人写的库</span></span><br><span class="line"><span class="built_in">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line"><span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># ANDROID</span></span><br><span class="line"><span class="built_in">export</span> ANDROID_HOME=/Users/lichaoqian/Library/Android/sdk <span class="comment">#android sdk目录，替换为你自己的即可</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/tools</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/platform-tools</span><br></pre></td></tr></table></figure><h4 id="1-2、flutter-doctor执行结果问题：缺少依赖项"><a href="#1-2、flutter-doctor执行结果问题：缺少依赖项" class="headerlink" title="1.2、flutter doctor执行结果问题：缺少依赖项"></a>1.2、flutter doctor执行结果问题：缺少依赖项</h4><p>如果您不缺依赖项，那您命令的执行结果会为</p><p>如果flutter doctor 检测出问题，此时的命令执行结果一般如下：</p><blockquote><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter%20doctor%20%E6%A3%80%E6%B5%8B%E5%87%BA%E9%97%AE%E9%A2%98.png" alt="flutter doctor 检测出问题"></p></blockquote><p>原因：缺少依赖项</p><p>解决：遇到什么错误，根据提示操作即可。</p><h5 id="1-2-1、iOS-toolchain"><a href="#1-2-1、iOS-toolchain" class="headerlink" title="1.2.1、iOS toolchain"></a>1.2.1、iOS toolchain</h5><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/Flutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220321005147057.png" alt="image-20220321005147057"></p><p>①、解决<code>iOS toolchain - develop for iOS devices （Xcode 10.1）</code>，根据提示终端执行命令后iOS toolchain即变为正常如下</p><blockquote><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/iOS%20toolchain%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%8E.png" alt="iOS toolchain问题解决后"></p></blockquote><h5 id="1-2-2、Android-toolchain"><a href="#1-2-2、Android-toolchain" class="headerlink" title="1.2.2、Android toolchain"></a>1.2.2、Android toolchain</h5><p>②、解决<code>Android toolchain  - develop for iOS devices</code></p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/Flutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220321005213102.png" alt="image-20220321005213102"></p><p>在遇到这个问题，首先要确保自己的Android studio的下图中的几个项勾选上：</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/Flutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220321010157585.png" alt="image-20220321010157585"></p><p>安装 Android SDK Command-line Tools(latest)</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/Flutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220321010247340.png" alt="image-20220321010247340"></p><p>根据提示<a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">下载Android SDK</a>，并放置ANDROD_HOME指定的目录下后，问题解决，结果如下：</p><blockquote><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/Android%20SDK%E5%AE%89%E8%A3%85%E5%90%8E.png" alt="Android SDK安装后"></p></blockquote><p>其他参考：<a href="https://flutterchina.club/setup-macos/" target="_blank" rel="noopener">入门: 在macOS上搭建Flutter开发环境</a></p><p>修改环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ANDROID</span></span><br><span class="line"><span class="built_in">export</span> ANDROID_HOME=/Users/qian/Library/Android/sdk <span class="comment">#android sdk目录，替换为你自己的即可</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/tools</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/platform-tools</span><br></pre></td></tr></table></figure><p>非M1芯片的Mac：</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/Flutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220321011753288.png" alt="image-20220321011753288" style="zoom:25%;"></p><h5 id="1-2-3、Android-Studio"><a href="#1-2-3、Android-Studio" class="headerlink" title="1.2.3、Android Studio"></a>1.2.3、Android Studio</h5><p>③、解决<code>Android Studio</code>，</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/Flutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/image-20220321005253299.png" alt="image-20220321005253299"></p><p>为Android Studio安装Flutter Plugins后</p><blockquote><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/Android%20Studio%E5%AE%89%E8%A3%85Flutter%20Plugins%E5%90%8E.png" alt="Android Studio安装Flutter Plugins后"></p></blockquote><p>安装过程中，如遇Plugins搜索不到时候，如</p><blockquote><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/Android%20Plugins%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%88%B0%E7%9A%84%E7%A4%BA%E4%BE%8B%E6%88%AA%E5%9B%BE.png" alt="Android Plugins搜索不到的示例截图"></p></blockquote><p>请确保如下图中的路径<code>Perferences -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Updates -&gt; Use secure connection</code>中的勾是取消的，如果不是请取消掉，并重启Android Studio后，重新搜索即可。</p><blockquote><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/Android%20Plugins%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%88%B0%E7%9A%84%E5%A4%84%E7%90%861.png" alt="Android Plugins搜索不到的处理1"></p></blockquote><p>或者可以直接从<code>http://plugins.jetbrains.com/</code>上下载插件后，通过选择插件安装方式为Install plugin from disk来进行安装，如下图：</p><blockquote><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%E9%80%89%E6%8B%A9%E4%B8%BAInstall%20plugin%20from%20disk.png" alt="插件安装方式选择为Install plugin from disk"></p></blockquote><p>附：这是<a href="https://pan.baidu.com/s/1yyUxP2lRb7hamJN-MHA1zw" target="_blank" rel="noopener">已经下载好后存在网盘上的Flutter插件</a></p><h5 id="1-2-4、解决Intelij-IDEA，为Intelij-IDEA安装Flutter-Plugins后"><a href="#1-2-4、解决Intelij-IDEA，为Intelij-IDEA安装Flutter-Plugins后" class="headerlink" title="1.2.4、解决Intelij IDEA，为Intelij IDEA安装Flutter Plugins后"></a>1.2.4、解决<code>Intelij IDEA</code>，为Intelij IDEA安装Flutter Plugins后</h5><p>④为Intelij IDEA安装Flutter Plugins后的结果，即为不缺依赖的情况了。</p><p>其他资料：官网中的<a href="https://flutterchina.club/setup-macos/#使用镜像" target="_blank" rel="noopener">入门: 在macOS上搭建Flutter开发环境</a></p><p>如果还没解决安装问题，请查看<code>【附2】、flutter 安装过程中的其他问题解决</code></p><h2 id="四、升级-Flutter"><a href="#四、升级-Flutter" class="headerlink" title="四、升级 Flutter"></a>四、升级 Flutter</h2><p><a href="https://flutterchina.club/upgrading/" target="_blank" rel="noopener">官网升级 Flutter的标准步骤</a></p><h5 id="1-2-5、解决Flutter"><a href="#1-2-5、解决Flutter" class="headerlink" title="1.2.5、解决Flutter"></a>1.2.5、解决<code>Flutter</code></h5><p>有时候，你还会有这种错误，原因为你的flutter sdk太旧了。</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter doctor 检测出问题2.png" alt="flutter doctor 检测出问题2"></p><p>到<a href="https://flutter.dev/docs/development/tools/sdk/releases?tab=macos" target="_blank" rel="noopener">官网</a>下载最新sdk，并替换掉你之前的flutter sdk。（附：你之前的Flutter的sdk的路径，请通过你写在<code>open ~/.bash_profile</code>中的PATH找到。</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter doctor 检测出问题3.png" alt="image-20200717193444530"></p><h3 id="【附2】、flutter-安装过程中的其他问题解决"><a href="#【附2】、flutter-安装过程中的其他问题解决" class="headerlink" title="【附2】、flutter 安装过程中的其他问题解决"></a>【附2】、flutter 安装过程中的其他问题解决</h3><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter%20doctor%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%981.png" alt="flutter doctor其他问题1"></p><p>原因：您的Flutter SDK 要求你Android Studio中的Flutter plugin版本至少到16.0.0。但你当前的Android Studio版本却只允许你最高只能装到Flutter plugin version 12.1。</p><p>解决：升级你的Android Studio后，重新安装其Flutter plugin。</p><p>【附3】、flutter 运行的过程中的其他问题解决</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter运行问题1.png" alt="image-20200718010926592"></p><p>可以看出是路径出错了。</p><p>根据路径出错这个方向，进行工程配置错误的查看，发现出错的位置在如下图位置。</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter运行问题2.png" alt="image-20200718011513227"></p><p>假设我们的工程目录结构如下，</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter运行问题3.png" alt="image-20200718012410466"></p><p>则cj_nativeflutter_fluttermodule的路径表示为<code>${SRCROOT}/../cj_nativeflutter_fluttermodule</code></p><p>修改完后，重新编译即可解决问题。</p><h4 id="Command-PhaseScriptExecution-failed-with-a-nonzero-exit-code"><a href="#Command-PhaseScriptExecution-failed-with-a-nonzero-exit-code" class="headerlink" title="Command PhaseScriptExecution failed with a nonzero exit code"></a>Command PhaseScriptExecution failed with a nonzero exit code</h4><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter运行问题41.png" alt="image-20200718014117212"></p><p>在<code>pubspec.yaml</code>文件所在的目录下执行flutter packages get</p><blockquote><p><code>flutter packages get</code>获取<code>pubspec.yaml</code>文件中列出的所有依赖包</p></blockquote><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter运行问题42.png" alt="image-20200718014656554"></p><p>接着再执行flutter packages upgrade，会发现刚才的Compiler message错误少了很多</p><blockquote><p><code>flutter packages upgrade</code> 获取<code>pubspec.yaml</code>文件中列出的所有依赖包的最新版本</p></blockquote><p>更新库之后还有错误。</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter运行问题43.png" alt="image-20200718015310060"></p><p>进入工程查看，确实各个地方都提示着我们工程代码有问题。那么我们所需要做的就是修复这个问题。</p><p><img src="/Flutter/1入门/Flutter开发环境搭建与运行/flutter运行问题44.png" alt="image-20200718015625741"></p><p>我们对这些编译不通过的代码进行修复或者临时注释掉，即可通过。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第一章：Flutter入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3节：Flutter的最基础知识</title>
      <link href="/Flutter/1%E5%85%A5%E9%97%A8/Flutter%E7%9A%84%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863-%E5%B7%A5%E7%A8%8B/"/>
      <url>/Flutter/1%E5%85%A5%E9%97%A8/Flutter%E7%9A%84%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863-%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="第3节：Flutter的最基础知识"><a href="#第3节：Flutter的最基础知识" class="headerlink" title="第3节：Flutter的最基础知识"></a>第3节：Flutter的最基础知识</h1><p>本节学习内容：通过最基础的Flutter控件等实现一个app ，让您对Flutter构建的app有一个初步的认识！</p><p>本节学习用时：<strong>30分钟</strong></p><p>本节学习方式：<strong>推荐直接看懂代码即可</strong></p><hr><p>本节目录：</p><p>一、本节内容介绍</p><p>二、本节代码解释</p><hr><h2 id="一、本节内容介绍"><a href="#一、本节内容介绍" class="headerlink" title="一、本节内容介绍"></a>一、本节内容介绍</h2><p>本节通过实现以下界面/功能效果，为您介绍一些最基础的Flutter知识点。</p><h4 id="1、主要介绍的知识点有："><a href="#1、主要介绍的知识点有：" class="headerlink" title="1、主要介绍的知识点有："></a>1、主要介绍的知识点有：</h4><ul><li>MaterialApp的应用</li><li>Scaffold的应用</li><li>文本的应用：Text</li><li>按钮的应用：FloatingActionButton</li><li>页面的跳转</li></ul><h4 id="2、要实现的效果如下图所示："><a href="#2、要实现的效果如下图所示：" class="headerlink" title="2、要实现的效果如下图所示："></a>2、要实现的效果如下图所示：</h4><blockquote><p><img src="/Flutter/1入门/Flutter的最基础知识3-工程/Flutter的最基础知识/materialappproject.png" alt="materialappproject效果图"></p></blockquote><h4 id="3、实现本节效果的代码"><a href="#3、实现本节效果的代码" class="headerlink" title="3、实现本节效果的代码"></a>3、实现本节效果的代码</h4><p>本节所有代码文件为：<code>main.dart</code>、<code>NewRoute.dart</code>。</p><blockquote><p>您可自己通过<code>flutter create materialappproject</code>创建materialappproject项目后，将其lib文件夹下的代码文件替换为如下即可。</p></blockquote><h6 id="3-1、其中完整的main-dart代码如下："><a href="#3-1、其中完整的main-dart代码如下：" class="headerlink" title="3.1、其中完整的main.dart代码如下："></a>3.1、其中完整的<code>main.dart</code>代码如下：</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'NewRoute.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法①</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; runApp写法① &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="comment">// void main() &#123;</span></span><br><span class="line"><span class="comment">//   runApp(new MaterialApp(</span></span><br><span class="line"><span class="comment">//     title: '1.MaterialApp in main',</span></span><br><span class="line"><span class="comment">//     home: new HelloWorldPage(),</span></span><br><span class="line"><span class="comment">//   ));</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; runApp写法① &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法②</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; runApp写法② &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'2.MaterialApp in MyApp'</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 页面跳转的方式②：注册路由表</span></span><br><span class="line">      <span class="comment">// 详情查看[官网路由管理](https://book.flutterchina.club/chapter2/flutter_router.html)</span></span><br><span class="line">      <span class="comment">// 缺点：路由传递的参数无法动态修改(如果路由有参数)</span></span><br><span class="line">      routes: &#123;</span><br><span class="line">        <span class="string">"new_page"</span>: (context) =&gt; NewRoute(),</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      home: HelloWorldPage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; runApp写法② &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//Scaffold是Material中主要的布局组件.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">          leading: <span class="keyword">new</span> IconButton(</span><br><span class="line">            icon: <span class="keyword">new</span> Icon(Icons.menu),</span><br><span class="line">            tooltip: <span class="string">'Navigation menu'</span>,</span><br><span class="line">            onPressed: <span class="keyword">null</span>,</span><br><span class="line">          ),</span><br><span class="line">          title: <span class="keyword">new</span> Text(<span class="string">'MaterialApp Example title'</span>),</span><br><span class="line">          actions: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">new</span> IconButton(</span><br><span class="line">              icon: <span class="keyword">new</span> Icon(Icons.search),</span><br><span class="line">              tooltip: <span class="string">'Search'</span>,</span><br><span class="line">              onPressed: <span class="keyword">null</span>,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">//body占屏幕的大部分</span></span><br><span class="line">        body: <span class="keyword">new</span> Center(</span><br><span class="line">          child: <span class="keyword">new</span> Text(<span class="string">'Hello, world2!'</span>),</span><br><span class="line">        ),</span><br><span class="line">        floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">          tooltip: <span class="string">'Add'</span>, <span class="comment">// used by assistive technologies</span></span><br><span class="line">          child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">          <span class="comment">// 1、无方法</span></span><br><span class="line">          <span class="comment">// 写法①</span></span><br><span class="line">          <span class="comment">// onPressed: null,</span></span><br><span class="line">          <span class="comment">// 写法②</span></span><br><span class="line">          <span class="comment">// onPressed: () &#123;&#125;</span></span><br><span class="line">          <span class="comment">// 写法③</span></span><br><span class="line">          <span class="comment">// onPressed: () =&gt; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 2、有方法，但该方法无参数</span></span><br><span class="line">          <span class="comment">// 写法①</span></span><br><span class="line">          <span class="comment">// onPressed: printLog,</span></span><br><span class="line">          <span class="comment">// 写法②</span></span><br><span class="line">          <span class="comment">// onPressed: () &#123;</span></span><br><span class="line">          <span class="comment">//   printLog();</span></span><br><span class="line">          <span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 3、有方法，且该方法有参数</span></span><br><span class="line">          <span class="comment">// onPressed:() &#123;</span></span><br><span class="line">          <span class="comment">//   printText("Hello world");</span></span><br><span class="line">          <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 4.页面跳转方式</span></span><br><span class="line">          <span class="comment">// 写法①</span></span><br><span class="line">          <span class="comment">// onPressed: () &#123;</span></span><br><span class="line">          <span class="comment">//   goNextPage(context);</span></span><br><span class="line">          <span class="comment">// &#125;,</span></span><br><span class="line">          <span class="comment">// 写法②</span></span><br><span class="line">          <span class="comment">// onPressed: () &#123;</span></span><br><span class="line">          <span class="comment">//   Navigator.pushNamed(context, "new_page");</span></span><br><span class="line">          <span class="comment">// &#125;,</span></span><br><span class="line">          <span class="comment">// 写法③</span></span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> NewRoute();</span><br><span class="line">            &#125;));</span><br><span class="line">          &#125;,</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> printLog() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"This is printLog Method"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> printText($text) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"The text is "</span> + $text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> goNextPage(context) &#123;</span><br><span class="line">  <span class="comment">// 导航到新路由</span></span><br><span class="line">  Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NewRoute();</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-2、其中完整的NewRoute-dart代码如下："><a href="#3-2、其中完整的NewRoute-dart代码如下：" class="headerlink" title="3.2、其中完整的NewRoute.dart代码如下："></a>3.2、其中完整的<code>NewRoute.dart</code>代码如下：</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"New route"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(<span class="string">"This is new route"</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、本节代码解释"><a href="#二、本节代码解释" class="headerlink" title="二、本节代码解释"></a>二、本节代码解释</h2><h4 id="1、MaterialApp的使用方式介绍"><a href="#1、MaterialApp的使用方式介绍" class="headerlink" title="1、MaterialApp的使用方式介绍"></a>1、MaterialApp的使用方式介绍</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法①</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(<span class="keyword">new</span> MaterialApp(</span><br><span class="line">    title: <span class="string">'1.MaterialApp in main'</span>,</span><br><span class="line">    home: <span class="keyword">new</span> HelloWorldPage(),</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------- 我是分割线，下面介绍的是另一种写法 ------------------- //</span></span><br><span class="line"><span class="comment">// 写法②</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'2.MaterialApp in MyApp'</span>,</span><br><span class="line">      home: HelloWorldPage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、Scaffold的使用方式介绍"><a href="#2、Scaffold的使用方式介绍" class="headerlink" title="2、Scaffold的使用方式介绍"></a>2、Scaffold的使用方式介绍</h4><p>以创建一个新页面<code>NewRoute.dart</code>为例，该文件代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"New route"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(<span class="string">"This is new route"</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、文本Text以及按钮Button的使用介绍"><a href="#3、文本Text以及按钮Button的使用介绍" class="headerlink" title="3、文本Text以及按钮Button的使用介绍"></a>3、文本Text以及按钮Button的使用介绍</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//Scaffold是Material中主要的布局组件.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        leading: <span class="keyword">new</span> IconButton(</span><br><span class="line">          icon: <span class="keyword">new</span> Icon(Icons.menu),</span><br><span class="line">          tooltip: <span class="string">'Navigation menu'</span>,</span><br><span class="line">          onPressed: <span class="keyword">null</span>,</span><br><span class="line">        ),</span><br><span class="line">        title: <span class="keyword">new</span> Text(<span class="string">'MaterialApp Example title'</span>),</span><br><span class="line">        actions: &lt;Widget&gt;[</span><br><span class="line">          <span class="keyword">new</span> IconButton(</span><br><span class="line">            icon: <span class="keyword">new</span> Icon(Icons.search),</span><br><span class="line">            tooltip: <span class="string">'Search'</span>,</span><br><span class="line">            onPressed: <span class="keyword">null</span>,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">//body占屏幕的大部分</span></span><br><span class="line">      body: <span class="keyword">new</span> Center(</span><br><span class="line">        child: <span class="keyword">new</span> Text(<span class="string">'Hello, world2!'</span>),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">        tooltip: <span class="string">'Add'</span>, <span class="comment">// used by assistive technologies</span></span><br><span class="line">        child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">        onPressed: <span class="keyword">null</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、按钮Button"><a href="#三、按钮Button" class="headerlink" title="三、按钮Button"></a>三、按钮Button</h2><p>按钮的点击：略，请看前文</p><h2 id="四、新页面的创建"><a href="#四、新页面的创建" class="headerlink" title="四、新页面的创建"></a>四、新页面的创建</h2><p>以创建一个新页面<code>NewRoute.dart</code>为例，该文件代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"New route"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(<span class="string">"This is new route"</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、页面的跳转-amp-路由的管理"><a href="#五、页面的跳转-amp-路由的管理" class="headerlink" title="五、页面的跳转 &amp; 路由的管理"></a>五、页面的跳转 &amp; 路由的管理</h2><p>页面的跳转，略。请看前文</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第一章：Flutter入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：入门</title>
      <link href="/Flutter/1%E5%85%A5%E9%97%A8/README/"/>
      <url>/Flutter/1%E5%85%A5%E9%97%A8/README/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章介绍Flutter入门必须掌握的知识点。</p><p><a href="./Flutter开发环境搭建.md">点击此处，进入本章第1节的正式学习 &gt;</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3节：Flutter的最基础知识</title>
      <link href="/Flutter/1%E5%85%A5%E9%97%A8/Flutter%E7%9A%84%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/Flutter/1%E5%85%A5%E9%97%A8/Flutter%E7%9A%84%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="第3节：Flutter的最基础知识"><a href="#第3节：Flutter的最基础知识" class="headerlink" title="第3节：Flutter的最基础知识"></a>第3节：Flutter的最基础知识</h1><h2 id="一、最基础知识"><a href="#一、最基础知识" class="headerlink" title="一、最基础知识"></a>一、最基础知识</h2><h3 id="1、颜色"><a href="#1、颜色" class="headerlink" title="1、颜色"></a>1、颜色</h3><ul><li><a href="https://ninghao.net/blog/6414" target="_blank" rel="noopener">Flutter 移动应用开发 #4：颜色</a></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Colors.transparent,  <span class="comment">//透明色</span></span><br><span class="line">Colors.black.withOpacity(<span class="number">0.4</span>)</span><br></pre></td></tr></table></figure><h3 id="2、图片"><a href="#2、图片" class="headerlink" title="2、图片"></a>2、图片</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Image.asset(<span class="string">'images/goods_image.png'</span>, width: <span class="number">30.0</span>, height: <span class="number">30.0</span>,),</span><br></pre></td></tr></table></figure><h2 id="三、按钮Button"><a href="#三、按钮Button" class="headerlink" title="三、按钮Button"></a>三、按钮Button</h2><h4 id="1、按钮形式"><a href="#1、按钮形式" class="headerlink" title="1、按钮形式"></a>1、按钮形式</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">         tooltip: <span class="string">'Add'</span>, <span class="comment">// used by assistive technologies</span></span><br><span class="line">         child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">         <span class="comment">// 点击进行页面跳转</span></span><br><span class="line">         onPressed:() &#123;</span><br><span class="line">           goNextPage(context);</span><br><span class="line">         &#125;</span><br><span class="line">         ),</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><h4 id="2、按钮的事件写法"><a href="#2、按钮的事件写法" class="headerlink" title="2、按钮的事件写法"></a>2、按钮的事件写法</h4><h6 id="2-1、无方法"><a href="#2-1、无方法" class="headerlink" title="2.1、无方法"></a>2.1、无方法</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法①</span></span><br><span class="line">onPressed: <span class="keyword">null</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法②：推荐</span></span><br><span class="line">onPressed: () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法③：不推荐</span></span><br><span class="line">onPressed: () =&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 缺点：只能直接retrun返回值，不能写多行</span></span><br></pre></td></tr></table></figure><h6 id="2-2、有方法，但该方法无参数"><a href="#2-2、有方法，但该方法无参数" class="headerlink" title="2.2、有方法，但该方法无参数"></a>2.2、有方法，但该方法无参数</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设方法为：</span></span><br><span class="line"><span class="keyword">void</span> printLog() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"This is printLog Method"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 则按钮点击事件有两种写法：</span></span><br><span class="line"><span class="comment">// 写法①：常见的写法</span></span><br><span class="line">onPressed: () &#123;</span><br><span class="line">    printLog();</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 写法②：简写</span></span><br><span class="line">onPressed: printLog,</span><br></pre></td></tr></table></figure><h6 id="2-3、有方法，且该方法有参数"><a href="#2-3、有方法，且该方法有参数" class="headerlink" title="2.3、有方法，且该方法有参数"></a>2.3、有方法，且该方法有参数</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设方法为：</span></span><br><span class="line"><span class="keyword">void</span> printText($text) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"The text is "</span> + $text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//则按钮点击事件为：</span></span><br><span class="line">onPressed:() &#123;</span><br><span class="line">printText(<span class="string">"Hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、页面的跳转-amp-路由的管理"><a href="#五、页面的跳转-amp-路由的管理" class="headerlink" title="五、页面的跳转 &amp; 路由的管理"></a>五、页面的跳转 &amp; 路由的管理</h2><h4 id="5-1-直接跳转"><a href="#5-1-直接跳转" class="headerlink" title="5.1 直接跳转"></a>5.1 直接跳转</h4><p>以跳转到上述建立的<code>NewRoute.dart</code>为例，则跳转方法：</p><p>方式①：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'NewRoute.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮处的写法</span></span><br><span class="line">onPressed: () &#123;</span><br><span class="line">    Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NewRoute();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>方式②：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'NewRoute.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义导航到新路由的方法</span></span><br><span class="line"><span class="keyword">void</span> goNextPage(context) &#123;</span><br><span class="line">  Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NewRoute();</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 则按钮处的写法，自然如下：</span></span><br><span class="line">onPressed:() &#123;</span><br><span class="line">    goNextPage(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-使用路由管理"><a href="#5-2-使用路由管理" class="headerlink" title="5.2 使用路由管理"></a>5.2 使用路由管理</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'NewRoute.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在MaterialApp中注册路由表</span></span><br><span class="line">routes: &#123;</span><br><span class="line">    <span class="string">"new_page"</span>: (context) =&gt; NewRoute(),</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮位置写法</span></span><br><span class="line">onPressed: () &#123;</span><br><span class="line">    Navigator.pushNamed(context, <span class="string">"new_page"</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第一章：Flutter入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：Flutter的Hello World</title>
      <link href="/Flutter/1%E5%85%A5%E9%97%A8/Flutter%E7%9A%84Hello%20World/"/>
      <url>/Flutter/1%E5%85%A5%E9%97%A8/Flutter%E7%9A%84Hello%20World/</url>
      
        <content type="html"><![CDATA[<h1 id="第2节：Flutter的Hello-World"><a href="#第2节：Flutter的Hello-World" class="headerlink" title="第2节：Flutter的Hello World"></a>第2节：Flutter的Hello World</h1><p>本节学习内容：分别通过多种方法实现Hello world! ，让您对Flutter有一个初步的认识！</p><p>本节学习用时：<strong>3分钟</strong></p><p>本节学习方式：<strong>推荐直接看懂代码即可</strong></p><hr><p>本节目录：</p><p>一、本节内容介绍</p><p>二、本节代码解释</p><hr><h2 id="一、本节内容介绍"><a href="#一、本节内容介绍" class="headerlink" title="一、本节内容介绍"></a>一、本节内容介绍</h2><h4 id="1、本节代码"><a href="#1、本节代码" class="headerlink" title="1、本节代码"></a>1、本节代码</h4><p>本节所有代码文件为：<code>main.dart</code>。</p><blockquote><p>您可自己通过<code>flutter create helloworldproject</code>创建helloworldproject项目后，将其lib文件夹下的代码文件替换为如下即可。</p></blockquote><h6 id="1-1、其中完整的main-dart代码如下："><a href="#1-1、其中完整的main-dart代码如下：" class="headerlink" title="1.1、其中完整的main.dart代码如下："></a>1.1、其中完整的<code>main.dart</code>代码如下：</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法①</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; start &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="comment">// void main() =&gt; runApp(const Center(</span></span><br><span class="line"><span class="comment">//     child: Text('1.Hello, world! in Main', textDirection: TextDirection.ltr)));</span></span><br><span class="line"><span class="comment">// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  end  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法②</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 方法② &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="comment">// void main() =&gt; runApp(MyApp());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class MyApp extends StatelessWidget &#123;</span></span><br><span class="line"><span class="comment">//   @override</span></span><br><span class="line"><span class="comment">//   Widget build(BuildContext context) &#123;</span></span><br><span class="line"><span class="comment">//     return const Center(</span></span><br><span class="line"><span class="comment">//         child: Text('2.Hello, world! in MyApp return!', textDirection: TextDirection.ltr));</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 方法② &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法③</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 方法③ &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="comment">// void main() =&gt; runApp(MyApp());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class MyApp extends StatelessWidget &#123;</span></span><br><span class="line"><span class="comment">//    helloWorldPage() &#123;</span></span><br><span class="line"><span class="comment">//      return Center(</span></span><br><span class="line"><span class="comment">//        child: Text('3.Hello world! in helloWorldPage',</span></span><br><span class="line"><span class="comment">//            textDirection: TextDirection.ltr),</span></span><br><span class="line"><span class="comment">//      );</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    @override</span></span><br><span class="line"><span class="comment">//    Widget build(BuildContext context) &#123;</span></span><br><span class="line"><span class="comment">//      return helloWorldPage();</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 方法③ &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法④</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 方法④ &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> HelloWorldPage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Text(<span class="string">'4.Hello world! in HelloWorldPage'</span>,</span><br><span class="line">          textDirection: TextDirection.ltr),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 方法④ &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure><h4 id="2、代码说明"><a href="#2、代码说明" class="headerlink" title="2、代码说明"></a>2、代码说明</h4><p>略</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
          <category> 第一章：Flutter入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5节：ReactNative的常用库</title>
      <link href="/ReactNative/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
      <url>/ReactNative/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="一、安装指定版本"><a href="#一、安装指定版本" class="headerlink" title="一、安装指定版本"></a>一、安装指定版本</h3><p><a href="https://www.cnblogs.com/cisum/p/8401255.html" target="_blank" rel="noopener">https://www.cnblogs.com/cisum/p/8401255.html</a></p><p>您可以通过指定<a href="https://yarn.bootcss.com/docs/dependency-versions" target="_blank" rel="noopener">依赖版本</a>或 <a href="https://yarn.bootcss.com/docs/cli/tag" target="_blank" rel="noopener">标签</a>来指定要安装的软件包的<a href="https://yarn.bootcss.com/docs/dependency-versions" target="_blank" rel="noopener">版本</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add [package]@[version]</span><br><span class="line">yarn add [package]@[tag]</span><br></pre></td></tr></table></figure><p>的<code>[version]</code>或<code>[tag]</code>将是什么被添加到您的<code>package.json</code> ，然后解决安装时依赖对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yarn add package-1@1.2.3</span><br><span class="line">yarn add package-2@^1.0.0</span><br><span class="line">yarn add package-3@beta</span><br><span class="line"></span><br><span class="line">yarn add react-navigation</span><br><span class="line"></span><br><span class="line">结果会是：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;package-1&quot;: &quot;1.2.3&quot;,</span><br><span class="line">    &quot;package-2&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">    &quot;package-3&quot;: &quot;beta&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>link失败，怎么办</p><p><img src="/ReactNative/1入门/ReactNative的常用库/react-native link失败怎么办.png" alt="image-20191118221937663"></p><p>诸如此类，其实是 react-native link react-native-gesture-handler 失败。</p><p>重复执行上述命令还是失败。怎么办？</p><p>答：直接手动remove掉RNGestureHandler.xcodeproj，然后再手动添加吧。</p><h2 id="一、常用ReactNative库"><a href="#一、常用ReactNative库" class="headerlink" title="一、常用ReactNative库"></a>一、常用ReactNative库</h2><p>查找地址：<a href="https://www.npmjs.com/package/" target="_blank" rel="noopener">https://www.npmjs.com/package/</a></p><p>其他常用库文章：<a href="https://www.cnblogs.com/yrcn/p/7364384.html" target="_blank" rel="noopener">React Native插件系列之插件汇总</a></p><table><thead><tr><th>类型</th><th>库</th><th>Stat ⭐️</th></tr></thead><tbody><tr><td>导航</td><td><a href="https://www.npmjs.com/package/react-navigation" target="_blank" rel="noopener">react-navigation</a><br>及其<a href="https://reactnavigation.org/docs/zh-Hans/navigation-prop.html" target="_blank" rel="noopener">Navigation prop reference(导航属性)</a></td><td></td></tr><tr><td>日历</td><td><a href="https://www.npmjs.com/package/react-native-calendars" target="_blank" rel="noopener">react-native-calendars</a></td><td></td></tr><tr><td>Tab</td><td><a href="https://github.com/ptomasroos/react-native-tab-navigator" target="_blank" rel="noopener">react-native-tab-navigator</a>⭐️2187</td><td></td></tr><tr><td>日期计算</td><td><a href="https://github.com/moment/moment" target="_blank" rel="noopener">moment(github)</a>⭐️41285<br><a href="http://momentjs.cn" target="_blank" rel="noopener">官网地址</a></td><td></td></tr><tr><td>地图</td><td><a href="https://github.com/qiuxiang/react-native-amap3d" target="_blank" rel="noopener">react-native-amap3d(github)</a>⭐️690</td><td></td></tr><tr><td>图片浏览</td><td><a href="https://github.com/ascoders/react-native-image-viewer" target="_blank" rel="noopener">react-native-image-viewer</a>⭐️1361</td><td></td></tr><tr><td>轮播图</td><td><a href="https://github.com/leecade/react-native-swiper" target="_blank" rel="noopener">react-native-swiper</a>⭐️7776</td><td></td></tr><tr><td>图片选择</td><td><a href="https://github.com/react-native-community/react-native-image-picker" target="_blank" rel="noopener">react-native-image-picker</a>⭐️5311</td><td></td></tr><tr><td>日期选择</td><td><a href="https://github.com/xgfe/react-native-datepicker" target="_blank" rel="noopener">react-native-datepicker</a> ⭐️1585</td><td></td></tr><tr><td>进度显示</td><td><a href="https://github.com/oblador/react-native-progress" target="_blank" rel="noopener">react-native-progress</a>⭐️2358</td><td></td></tr><tr><td>Toast</td><td><a href="https://github.com/magicismight/react-native-root-toast" target="_blank" rel="noopener">react-native-root-toast</a>⭐️1191</td><td></td></tr><tr><td>网页</td><td></td></tr></tbody></table><p>Picker相关</p><p>link方法：</p><ul><li><a href="https://reactnavigation.org/docs/zh-Hans/getting-started.html" target="_blank" rel="noopener">react-navigation的link</a></li><li><a href="https://www.jianshu.com/p/727c9d4c080c" target="_blank" rel="noopener">react-native-image-picker的link</a></li></ul><h2 id="二、导航-react-navigation"><a href="#二、导航-react-navigation" class="headerlink" title="二、导航(react-navigation)"></a>二、导航(react-navigation)</h2><p>官网文章：</p><ul><li><a href="https://www.npmjs.com/package/react-navigation" target="_blank" rel="noopener">react-navigation</a></li><li><a href="https://reactnavigation.org/docs/zh-Hans/navigation-prop.html" target="_blank" rel="noopener">Navigation prop reference(导航属性)</a></li></ul><p>参考文章：</p><ul><li><p><a href="https://www.jianshu.com/p/8f97574307cc" target="_blank" rel="noopener">关于react-navigation 3.x的使用</a></p><blockquote><p>在安装3.x后，需要将最外层的包裹形式修改为<code>createAppContainer</code></p><p>在之前的版本中，使用<code>createStackNavigator</code>后，就会自动实现<code>createAppContainer</code>，但在新版本中，需要手动使用<code>createAppContainer</code>来包裹最外层的路由。</p></blockquote></li></ul><ul><li><a href="https://blog.csdn.net/theVicTory/article/details/80059632" target="_blank" rel="noopener">React Native–使用React Navigation实现界面导航与跳转</a></li></ul><h2 id="三、网页"><a href="#三、网页" class="headerlink" title="三、网页"></a>三、网页</h2><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &#123; WebView &#125; from &apos;react-native&apos;;# 被废弃的</span><br><span class="line">import &#123; WebView &#125; from &quot;react-native-webview&quot;;# 现在使用的(附只支持 platform :ios, &apos;9.0&apos;)</span><br></pre></td></tr></table></figure><p>如果使用react-native中的WebView会提示如下警告：</p><p><img src="/ReactNative/1入门/ReactNative的常用库/react-native WebView.png" alt="react-native-webview"></p><p>意思是webwiew要废了.不用了.</p><p>于是安装他们推荐的,用下面的命令<br>yarn add react-native-webview<br>react-native link react-native-webview</p><h2 id="三、日期选择-react-native-datepicker"><a href="#三、日期选择-react-native-datepicker" class="headerlink" title="三、日期选择(react-native-datepicker)"></a>三、日期选择(react-native-datepicker)</h2><h3 id="1、安装及使用方法"><a href="#1、安装及使用方法" class="headerlink" title="1、安装及使用方法"></a>1、安装及使用方法</h3><p>官网地址：<a href="https://github.com/xgfe/react-native-datepicker" target="_blank" rel="noopener">react-native-datepicker</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-native-datepicker --save</span><br></pre></td></tr></table></figure><h3 id="2、主要参数说明"><a href="#2、主要参数说明" class="headerlink" title="2、主要参数说明"></a>2、主要参数说明</h3><p>date：设置初始显示的日期<br>mode：显示的模式，date,datetime,time<br>format：设置日期格式，默认为’YYYY-MM-DD’<br>confirmBtnText：确定按钮的显示名称<br>cancelBtnText：取消按钮的显示名称<br>minDate：显示的最小日期<br>maxDate：显示的最大日期<br>duration：时间间隔<br>onDateChange：日期变化时触发的事件<br>placeholder：占位符</p><h2 id="四、Antd库"><a href="#四、Antd库" class="headerlink" title="四、Antd库"></a>四、Antd库</h2><h3 id="1、各Antd库区别"><a href="#1、各Antd库区别" class="headerlink" title="1、各Antd库区别"></a>1、各Antd库区别</h3><table><thead><tr><th>类型</th><th>antd</th><th>antd-mobile</th><th>@ant-design/react-native</th></tr></thead><tbody><tr><td>官网地址</td><td><a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">https://ant.design/docs/react/introduce-cn</a></td><td><a href="https://mobile.ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">https://mobile.ant.design/docs/react/introduce-cn</a></td><td><a href="https://rn.mobile.ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">https://rn.mobile.ant.design/docs/react/introduce-cn</a></td></tr><tr><td>安装命令</td><td>npm install antd –save</td><td>npm install antd-mobile –save</td><td>npm install @ant-design/react-native –save</td></tr><tr><td>特性和优势</td><td></td><td>UI 样式高度可配置，拓展性更强，轻松适应各类产品风格<br></td></tr></tbody></table><h3 id="2、RN-ANTD踩坑记"><a href="#2、RN-ANTD踩坑记" class="headerlink" title="2、RN-ANTD踩坑记"></a>2、RN-ANTD踩坑记</h3><ul><li><a href="https://baijiahao.baidu.com/s?id=1625529168398207776&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">「React Native笔记」 踩坑 Unrecognized font family ‘antoutline’</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第一章：ReactNative入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：ReactNative使用技巧</title>
      <link href="/ReactNative/6%E8%BF%9B%E9%98%B6/ReactNative%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/ReactNative/6%E8%BF%9B%E9%98%B6/ReactNative%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative使用技巧"><a href="#ReactNative使用技巧" class="headerlink" title="ReactNative使用技巧"></a>ReactNative使用技巧</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="一、布局"><a href="#一、布局" class="headerlink" title="一、布局"></a>一、布局</h2><p><strong>默认情况下，使用<code>position: &#39;absolute&#39;</code>后，后面的元素会默认覆盖在前面的元素之上。</strong></p><h2 id="二、Text"><a href="#二、Text" class="headerlink" title="二、Text"></a>二、Text</h2><h4 id="1、-style-Android上Text默认的字体颜色，不是black，不是black，不是black"><a href="#1、-style-Android上Text默认的字体颜色，不是black，不是black，不是black" class="headerlink" title="1、[style]Android上Text默认的字体颜色，不是black，不是black，不是black"></a>1、[style]Android上Text默认的字体颜色，不是black，不是black，不是black</h4><p>如果在Android上面，不显示地给Text添加color，那么显示出来的字体颜色就是灰色。跟iOS的表现不一致；<br><strong>解决方案：</strong><br>方案一：给每个Text都设置color</p><blockquote><p><em>不足：</em>每次都设置color。比较繁琐</p></blockquote><p>方案二：写一个自定义组件</p><blockquote><p>比如MyText，这个Text设置颜色，每次使用xxx就默认为你设置的颜色了。<br><em>不足：</em>多出来了一个新的组件，也比较繁琐。<br>多出来了一个新的组件，也比较繁琐。</p></blockquote><p>方案三：设置默认props</p><blockquote><p>在入口文件里面写上默认的style，比如：<br><code>Text.defaultProps.sytle = { &#39;color&#39;: &#39;#212121&#39;}</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第五章：ReactNative详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3节：ReactNative的最基础知识</title>
      <link href="/ReactNative/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/ReactNative/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="1、Import与export"><a href="#1、Import与export" class="headerlink" title="1、Import与export"></a>1、Import与export</h3><p>参考文章：<a href="https://segmentfault.com/a/1190000018064918" target="_blank" rel="noopener">ES6 export 和 export default的区别</a></p><h4 id="1-1、知识储备"><a href="#1-1、知识储备" class="headerlink" title="1.1、知识储备"></a>1.1、知识储备</h4><ul><li><code>export</code> 和 <code>export default</code>的区别</li></ul><table><thead><tr><th>导出方式</th><th>使用方式</th></tr></thead><tbody><tr><td>export</td><td>用户必须需要知道所要加载的变量名，否则无法加载。</td></tr><tr><td>export default</td><td>但是用户肯定不愿意去阅读子组件看看导出名称叫啥，然后回来导入。所以就有了 export default。</td></tr></tbody></table><ul><li>{} 和 没{} 的区别</li></ul><p><strong>当import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块对外接口的名称相同。</strong></p><ul><li><a href="https://segmentfault.com/q/1010000008760434" target="_blank" rel="noopener">如何用 es6 的 export 语法导出多少个类？</a></li></ul><h4 id="1-2、import使用示例"><a href="#1-2、import使用示例" class="headerlink" title="1.2、import使用示例"></a>1.2、import使用示例</h4><ul><li>当使用的是<code>export</code>，而不是<code>export default</code>的时候</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用方式1：常规方法</span><br><span class="line">import &#123; Greeting &#125; from &quot;./src/greeting&quot;;</span><br><span class="line"></span><br><span class="line">//使用方式2：如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名</span><br><span class="line">import &#123; bieming as Greeting &#125; from &quot;./src/greeting&quot;;</span><br></pre></td></tr></table></figure><ul><li>当使用的是<code>export default</code>的时候</li></ul><p>可以用任意名称指向greeting.js输出的方法，这时就不需要知道原模块输出的变量名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用export default的时候可以有如下写法</span><br><span class="line">import AnyName from &quot;./src/greeting&quot;;</span><br></pre></td></tr></table></figure><p>需要注意的是，这时import命令后面，不使用大括号。常见于<code>export default createAppContainer(UIHomeNavigation);</code></p><h3 id="2、颜色与图片资源"><a href="#2、颜色与图片资源" class="headerlink" title="2、颜色与图片资源"></a>2、颜色与图片资源</h3><ul><li><a href="https://reactnative.cn/docs/0.50/colors.html" target="_blank" rel="noopener">React Native中文网：颜色</a></li><li><a href="https://www.jianshu.com/p/a3bce3c7d838" target="_blank" rel="noopener">如何高效管理 React Native 项目中的图片资源</a></li></ul><h3 id="3、View样式属性"><a href="#3、View样式属性" class="headerlink" title="3、View样式属性"></a>3、View样式属性</h3><p>参考文章：</p><ul><li><a href="https://reactnative.cn/docs/view-style-props/" target="_blank" rel="noopener">View样式属性</a></li></ul><h3 id="4、组件的属性添加及隐藏"><a href="#4、组件的属性添加及隐藏" class="headerlink" title="4、组件的属性添加及隐藏"></a>4、组件的属性添加及隐藏</h3><p>需求距离：日期连接符，根据参数来判断是用直线还是波浪线。</p><p>定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class DateConnectView extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            showWave: true</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        let dateConnectView = this.props.showWave ?</span><br><span class="line">            &lt;View</span><br><span class="line">                style=&#123;&#123;width: 20, height: 1, backgroundColor: &quot;black&quot;&#125;&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">            :</span><br><span class="line">            &lt;View</span><br><span class="line">                style=&#123;&#123;width: 20, height: 1, backgroundColor: &quot;black&quot;&#125;&#125;</span><br><span class="line">            /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &#123;dateConnectView&#125;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;DateConnectView showWave=&#123;false&#125; /&gt;</span><br></pre></td></tr></table></figure><h2 id="二、bind"><a href="#二、bind" class="headerlink" title="二、bind"></a>二、bind</h2><blockquote><p>ES5语法React.createClass会自动绑定this,ES6的写法,不再自动绑定this。</p></blockquote><p>参考文章：</p><ul><li><a href="https://www.cnblogs.com/shaoting/p/6108809.html" target="_blank" rel="noopener">React Native 的绑定 this</a></li></ul><ul><li><a href="https://www.jianshu.com/p/ce970791aba4" target="_blank" rel="noopener">React Native绑定this(bind(this))</a></li></ul><p><strong>如果需要传参数，则采用箭头函数的写法。</strong></p><h2 id="三、常见问题"><a href="#三、常见问题" class="headerlink" title="三、常见问题"></a>三、常见问题</h2><h3 id="1、使用Class类出现的问题"><a href="#1、使用Class类出现的问题" class="headerlink" title="1、使用Class类出现的问题"></a>1、使用Class类出现的问题</h3><h4 id="1-1、View-config-not-found-for-name完美解决方法"><a href="#1-1、View-config-not-found-for-name完美解决方法" class="headerlink" title="1.1、View config not found for name完美解决方法"></a>1.1、View config not found for name完美解决方法</h4><p>出现的原因是return的内容内组件的首字母不是大写，比如如果提示View config not found for name  abc，则只需将abc换成Abc即可解决。</p><h4 id="1-2、Only-one-default-export-allowed-per-module"><a href="#1-2、Only-one-default-export-allowed-per-module" class="headerlink" title="1.2、Only one default export allowed per module"></a>1.2、Only one default export allowed per module</h4><p>export default class声明的类只能有一个，并且被引用的类要符合执行顺序</p><p>所以，请检查export default class 是不是太多了。</p><h4 id="1-3、Module-does-not-exist-in-the-module-map"><a href="#1-3、Module-does-not-exist-in-the-module-map" class="headerlink" title="1.3、Module does not exist in the module map"></a>1.3、Module does not exist in the module map</h4><p>Module does not exist in the module map 即<br>在Haste模块映射中或在这些映射中不存在，一般存在于对同一级目录的引用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ButtonFactory from &apos;cjdemobuttonfactory&apos;// 错误</span><br><span class="line">// 改为下面即可</span><br><span class="line">import ButtonFactory from &apos;./cjdemobuttonfactory&apos; // 正确</span><br></pre></td></tr></table></figure><h2 id="2、使用Text问题"><a href="#2、使用Text问题" class="headerlink" title="2、使用Text问题"></a>2、使用Text问题</h2><h4 id="2-1、Text文字的垂直居中"><a href="#2-1、Text文字的垂直居中" class="headerlink" title="2.1、Text文字的垂直居中"></a>2.1、Text文字的垂直居中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text style=&#123;&#123;</span><br><span class="line">    flex: 1,</span><br><span class="line">    height: 44,</span><br><span class="line">    lineHeight:44,//添加这行即可使得Text文字垂直居中显示</span><br><span class="line">    textAlign: &quot;center&quot;,</span><br><span class="line">    backgroundColor: &quot;red&quot;,</span><br><span class="line">    color: &apos;#5C5C5C&apos;,</span><br><span class="line">    fontSize: 15,</span><br><span class="line">&#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">&quot;我是文字&quot;</span><br><span class="line">&lt;/Text&gt;</span><br></pre></td></tr></table></figure><h3 id="3、使用列表-FlatList-SectionList-出现的问题"><a href="#3、使用列表-FlatList-SectionList-出现的问题" class="headerlink" title="3、使用列表 FlatList/SectionList 出现的问题"></a>3、使用列表 <em>FlatList</em>/<em>SectionList</em> 出现的问题</h3><h4 id="3-1、keyExtractor"><a href="#3-1、keyExtractor" class="headerlink" title="3.1、keyExtractor"></a>3.1、keyExtractor</h4><blockquote><p>VirtualizedList: missing keys for items, make sure to specify a key property on each item or provide a custom keyExtractor.</p></blockquote><p>它警告我们每个item 要有不同的key 。默认情况下每行都需要提供一个不重复的key属性。你也可以提供一个keyExtractor函数来生成key。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;FlatList</span><br><span class="line"> keyExtractor=&#123;(item, index) =&gt; index.toString()&#125;//不能缺少</span><br><span class="line">/&gt;  </span><br><span class="line"></span><br><span class="line">// keyExtractor也可以用方法写</span><br><span class="line">keyExtractor = &#123;this._extraUniqueKey&#125;   </span><br><span class="line"></span><br><span class="line">_extraUniqueKey(item ,index)&#123;</span><br><span class="line">      return &quot;index&quot;+index+item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2、virtualizedCell-cellKey"><a href="#3-2、virtualizedCell-cellKey" class="headerlink" title="3.2、virtualizedCell.cellKey"></a>3.2、virtualizedCell.cellKey</h4><blockquote><p>Warning: Failed child context type: Invalid child context virtualizedCell.cellKey of type number supplied to CellRenderer, expected string.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keyExtractor=&#123;(item, index) =&gt; index&#125;//会有警告⚠️</span><br><span class="line">// 修改成如下：</span><br><span class="line">keyExtractor=&#123;(item, index) =&gt; index.toString()&#125;//成功</span><br></pre></td></tr></table></figure><h3 id="4、使用导航问题"><a href="#4、使用导航问题" class="headerlink" title="4、使用导航问题"></a>4、使用导航问题</h3><blockquote><p>TypeError: undefined is not an object (evaluating ‘this.props.navigation.navigate’)</p></blockquote><p>检查下是不是导航栏不是在该类，而是在其他类上。常见于你在子组件中调用了该属性而发生错误。</p><p>举例：<a href="https://stackoverflow.com/questions/48446821/typeerror-undefined-is-not-an-object-evaluating-this-props-navigation-navigate" target="_blank" rel="noopener">https://stackoverflow.com/questions/48446821/typeerror-undefined-is-not-an-object-evaluating-this-props-navigation-navigate</a></p><ul><li>问：怎么判断导航栏是否为空？</li><li>答：</li></ul><h3 id="5、引用资源遇到的问题"><a href="#5、引用资源遇到的问题" class="headerlink" title="5、引用资源遇到的问题"></a>5、引用资源遇到的问题</h3><blockquote><p>Metro Bundler has encountered an internal error, please check your terminal error output for more details</p></blockquote><p>可能原因：路径出错，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">icon:require(&apos;../image/home_n.png&apos;),</span><br><span class="line">//改成正确的路径后，问题解决</span><br><span class="line">icon:require(&apos;./image/home_n.png&apos;),</span><br></pre></td></tr></table></figure><h2 id="四、第三方库"><a href="#四、第三方库" class="headerlink" title="四、第三方库"></a>四、第三方库</h2><h3 id="1、添加库"><a href="#1、添加库" class="headerlink" title="1、添加库"></a>1、添加库</h3><ul><li><p><a href="https://reactnavigation.org/docs/en/getting-started.html" target="_blank" rel="noopener">官网react-navigation的添加方法</a></p></li><li><p>同理你要添加如<code>react-native-device-info</code>库，则在终端cd到package.json后，执行<code>npm install --save react-native-device-info</code>，其就会在package.json中添加。</p></li><li><p>添加</p><p><a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">antd</a></p><p><a href="https://mobile.ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">Ant Design Mobile of React</a></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd xxx</span><br><span class="line">npm install antd --save</span><br><span class="line">npm install antd-mobile --save</span><br><span class="line">npm install @ant-design/react-native --save</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第一章：ReactNative入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4节：ReactNative私有库</title>
      <link href="/ReactNative/6%E8%BF%9B%E9%98%B6/ReactNative%E7%A7%81%E6%9C%89%E5%BA%93/"/>
      <url>/ReactNative/6%E8%BF%9B%E9%98%B6/ReactNative%E7%A7%81%E6%9C%89%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative私有库"><a href="#ReactNative私有库" class="headerlink" title="ReactNative私有库"></a>ReactNative私有库</h1><p>私有库</p><p>路径及执行的写法</p><p><img src="/ReactNative/6进阶/ReactNative私有库/ReactNative私有库1.png" alt="ReactNative私有库1"></p><p>npmjs库的发布详情查看：<a href="../../代码管理/库管理/npmjs/npmjs的发布.md">代码管理/库管理/npmjs/npmjs的发布</a></p><p><img src="/ReactNative/6进阶/ReactNative私有库/ReactNative私有库2.png" alt="image-20200816152306638"></p><p><img src="/ReactNative/6进阶/ReactNative私有库/ReactNative私有库3.png" alt="image-20200816152207129"></p>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第六章：ReactNative进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5节：ReactNative的常用库</title>
      <link href="/React/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
      <url>/React/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="一、安装指定版本"><a href="#一、安装指定版本" class="headerlink" title="一、安装指定版本"></a>一、安装指定版本</h3><p><a href="https://www.cnblogs.com/cisum/p/8401255.html" target="_blank" rel="noopener">https://www.cnblogs.com/cisum/p/8401255.html</a></p><p>您可以通过指定<a href="https://yarn.bootcss.com/docs/dependency-versions" target="_blank" rel="noopener">依赖版本</a>或 <a href="https://yarn.bootcss.com/docs/cli/tag" target="_blank" rel="noopener">标签</a>来指定要安装的软件包的<a href="https://yarn.bootcss.com/docs/dependency-versions" target="_blank" rel="noopener">版本</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add [package]@[version]</span><br><span class="line">yarn add [package]@[tag]</span><br></pre></td></tr></table></figure><p>的<code>[version]</code>或<code>[tag]</code>将是什么被添加到您的<code>package.json</code> ，然后解决安装时依赖对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yarn add package-1@1.2.3</span><br><span class="line">yarn add package-2@^1.0.0</span><br><span class="line">yarn add package-3@beta</span><br><span class="line"></span><br><span class="line">yarn add react-navigation</span><br><span class="line"></span><br><span class="line">结果会是：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;package-1&quot;: &quot;1.2.3&quot;,</span><br><span class="line">    &quot;package-2&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">    &quot;package-3&quot;: &quot;beta&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>link失败，怎么办</p><p><img src="/React/1入门/ReactNative的常用库/react-native link失败怎么办.png" alt="image-20191118221937663"></p><p>诸如此类，其实是 react-native link react-native-gesture-handler 失败。</p><p>重复执行上述命令还是失败。怎么办？</p><p>答：直接手动remove掉RNGestureHandler.xcodeproj，然后再手动添加吧。</p><h2 id="一、常用ReactNative库"><a href="#一、常用ReactNative库" class="headerlink" title="一、常用ReactNative库"></a>一、常用ReactNative库</h2><p>查找地址：<a href="https://www.npmjs.com/package/" target="_blank" rel="noopener">https://www.npmjs.com/package/</a></p><p>其他常用库文章：<a href="https://www.cnblogs.com/yrcn/p/7364384.html" target="_blank" rel="noopener">React Native插件系列之插件汇总</a></p><table><thead><tr><th>类型</th><th>库</th><th>Stat ⭐️</th></tr></thead><tbody><tr><td>导航</td><td><a href="https://www.npmjs.com/package/react-navigation" target="_blank" rel="noopener">react-navigation</a><br>及其<a href="https://reactnavigation.org/docs/zh-Hans/navigation-prop.html" target="_blank" rel="noopener">Navigation prop reference(导航属性)</a></td><td></td></tr><tr><td>日历</td><td><a href="https://www.npmjs.com/package/react-native-calendars" target="_blank" rel="noopener">react-native-calendars</a></td><td></td></tr><tr><td>Tab</td><td><a href="https://github.com/ptomasroos/react-native-tab-navigator" target="_blank" rel="noopener">react-native-tab-navigator</a>⭐️2187</td><td></td></tr><tr><td>日期计算</td><td><a href="https://github.com/moment/moment" target="_blank" rel="noopener">moment(github)</a>⭐️41285<br><a href="http://momentjs.cn" target="_blank" rel="noopener">官网地址</a></td><td></td></tr><tr><td>地图</td><td><a href="https://github.com/qiuxiang/react-native-amap3d" target="_blank" rel="noopener">react-native-amap3d(github)</a>⭐️690</td><td></td></tr><tr><td>图片浏览</td><td><a href="https://github.com/ascoders/react-native-image-viewer" target="_blank" rel="noopener">react-native-image-viewer</a>⭐️1361</td><td></td></tr><tr><td>轮播图</td><td><a href="https://github.com/leecade/react-native-swiper" target="_blank" rel="noopener">react-native-swiper</a>⭐️7776</td><td></td></tr><tr><td>图片选择</td><td><a href="https://github.com/react-native-community/react-native-image-picker" target="_blank" rel="noopener">react-native-image-picker</a>⭐️5311</td><td></td></tr><tr><td>日期选择</td><td><a href="https://github.com/xgfe/react-native-datepicker" target="_blank" rel="noopener">react-native-datepicker</a> ⭐️1585</td><td></td></tr><tr><td>进度显示</td><td><a href="https://github.com/oblador/react-native-progress" target="_blank" rel="noopener">react-native-progress</a>⭐️2358</td><td></td></tr><tr><td>Toast</td><td><a href="https://github.com/magicismight/react-native-root-toast" target="_blank" rel="noopener">react-native-root-toast</a>⭐️1191</td><td></td></tr><tr><td>网页</td><td></td></tr></tbody></table><p>Picker相关</p><p>link方法：</p><ul><li><a href="https://reactnavigation.org/docs/zh-Hans/getting-started.html" target="_blank" rel="noopener">react-navigation的link</a></li><li><a href="https://www.jianshu.com/p/727c9d4c080c" target="_blank" rel="noopener">react-native-image-picker的link</a></li></ul><h2 id="二、导航-react-navigation"><a href="#二、导航-react-navigation" class="headerlink" title="二、导航(react-navigation)"></a>二、导航(react-navigation)</h2><p>官网文章：</p><ul><li><a href="https://www.npmjs.com/package/react-navigation" target="_blank" rel="noopener">react-navigation</a></li><li><a href="https://reactnavigation.org/docs/zh-Hans/navigation-prop.html" target="_blank" rel="noopener">Navigation prop reference(导航属性)</a></li></ul><p>参考文章：</p><ul><li><p><a href="https://www.jianshu.com/p/8f97574307cc" target="_blank" rel="noopener">关于react-navigation 3.x的使用</a></p><blockquote><p>在安装3.x后，需要将最外层的包裹形式修改为<code>createAppContainer</code></p><p>在之前的版本中，使用<code>createStackNavigator</code>后，就会自动实现<code>createAppContainer</code>，但在新版本中，需要手动使用<code>createAppContainer</code>来包裹最外层的路由。</p></blockquote></li></ul><ul><li><a href="https://blog.csdn.net/theVicTory/article/details/80059632" target="_blank" rel="noopener">React Native–使用React Navigation实现界面导航与跳转</a></li></ul><h2 id="三、网页"><a href="#三、网页" class="headerlink" title="三、网页"></a>三、网页</h2><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &#123; WebView &#125; from &apos;react-native&apos;;# 被废弃的</span><br><span class="line">import &#123; WebView &#125; from &quot;react-native-webview&quot;;# 现在使用的(附只支持 platform :ios, &apos;9.0&apos;)</span><br></pre></td></tr></table></figure><p>如果使用react-native中的WebView会提示如下警告：</p><p><img src="/React/1入门/ReactNative的常用库/react-native WebView.png" alt="react-native-webview"></p><p>意思是webwiew要废了.不用了.</p><p>于是安装他们推荐的,用下面的命令<br>yarn add react-native-webview<br>react-native link react-native-webview</p><h2 id="三、日期选择-react-native-datepicker"><a href="#三、日期选择-react-native-datepicker" class="headerlink" title="三、日期选择(react-native-datepicker)"></a>三、日期选择(react-native-datepicker)</h2><h3 id="1、安装及使用方法"><a href="#1、安装及使用方法" class="headerlink" title="1、安装及使用方法"></a>1、安装及使用方法</h3><p>官网地址：<a href="https://github.com/xgfe/react-native-datepicker" target="_blank" rel="noopener">react-native-datepicker</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-native-datepicker --save</span><br></pre></td></tr></table></figure><h3 id="2、主要参数说明"><a href="#2、主要参数说明" class="headerlink" title="2、主要参数说明"></a>2、主要参数说明</h3><p>date：设置初始显示的日期<br>mode：显示的模式，date,datetime,time<br>format：设置日期格式，默认为’YYYY-MM-DD’<br>confirmBtnText：确定按钮的显示名称<br>cancelBtnText：取消按钮的显示名称<br>minDate：显示的最小日期<br>maxDate：显示的最大日期<br>duration：时间间隔<br>onDateChange：日期变化时触发的事件<br>placeholder：占位符</p><h2 id="四、Antd库"><a href="#四、Antd库" class="headerlink" title="四、Antd库"></a>四、Antd库</h2><h3 id="1、各Antd库区别"><a href="#1、各Antd库区别" class="headerlink" title="1、各Antd库区别"></a>1、各Antd库区别</h3><table><thead><tr><th>类型</th><th>antd</th><th>antd-mobile</th><th>@ant-design/react-native</th></tr></thead><tbody><tr><td>官网地址</td><td><a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">https://ant.design/docs/react/introduce-cn</a></td><td><a href="https://mobile.ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">https://mobile.ant.design/docs/react/introduce-cn</a></td><td><a href="https://rn.mobile.ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">https://rn.mobile.ant.design/docs/react/introduce-cn</a></td></tr><tr><td>安装命令</td><td>npm install antd –save</td><td>npm install antd-mobile –save</td><td>npm install @ant-design/react-native –save</td></tr><tr><td>特性和优势</td><td></td><td>UI 样式高度可配置，拓展性更强，轻松适应各类产品风格<br></td></tr></tbody></table><h3 id="2、RN-ANTD踩坑记"><a href="#2、RN-ANTD踩坑记" class="headerlink" title="2、RN-ANTD踩坑记"></a>2、RN-ANTD踩坑记</h3><ul><li><a href="https://baijiahao.baidu.com/s?id=1625529168398207776&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">「React Native笔记」 踩坑 Unrecognized font family ‘antoutline’</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第一章：ReactNative入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3节：ReactNative组件的封装</title>
      <link href="/ReactNative/6%E8%BF%9B%E9%98%B6/ReactNative%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85/"/>
      <url>/ReactNative/6%E8%BF%9B%E9%98%B6/ReactNative%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative组件的封装"><a href="#ReactNative组件的封装" class="headerlink" title="ReactNative组件的封装"></a>ReactNative组件的封装</h1><p>参考文章：</p><ul><li><a href="http://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">es6 Class 的继承</a></li><li><a href="https://www.jianshu.com/p/02ea122171c4" target="_blank" rel="noopener">(重要)react-native之Button组件及自定义</a></li><li><p><a href="https://www.jianshu.com/p/e9a4843fd873" target="_blank" rel="noopener">(重要)React-Native 自定义按钮系列</a></p></li><li><p><a href="https://www.jianshu.com/p/a92e68de0b6a" target="_blank" rel="noopener">React Native (三)： 自定义视图</a></p></li></ul><p>很多用React Native的同学都是前端工程师，在传统的js没有继承的概念。但是在react Native所支持的es6是有继承的，效果也是不错的。</p>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第六章：ReactNative进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3节：ReactNative的最基础知识</title>
      <link href="/React/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/React/1%E5%85%A5%E9%97%A8/ReactNative%E7%9A%84%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="1、Import与export"><a href="#1、Import与export" class="headerlink" title="1、Import与export"></a>1、Import与export</h3><p>参考文章：<a href="https://segmentfault.com/a/1190000018064918" target="_blank" rel="noopener">ES6 export 和 export default的区别</a></p><h4 id="1-1、知识储备"><a href="#1-1、知识储备" class="headerlink" title="1.1、知识储备"></a>1.1、知识储备</h4><ul><li><code>export</code> 和 <code>export default</code>的区别</li></ul><table><thead><tr><th>导出方式</th><th>使用方式</th></tr></thead><tbody><tr><td>export</td><td>用户必须需要知道所要加载的变量名，否则无法加载。</td></tr><tr><td>export default</td><td>但是用户肯定不愿意去阅读子组件看看导出名称叫啥，然后回来导入。所以就有了 export default。</td></tr></tbody></table><ul><li>{} 和 没{} 的区别</li></ul><p><strong>当import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块对外接口的名称相同。</strong></p><ul><li><a href="https://segmentfault.com/q/1010000008760434" target="_blank" rel="noopener">如何用 es6 的 export 语法导出多少个类？</a></li></ul><h4 id="1-2、import使用示例"><a href="#1-2、import使用示例" class="headerlink" title="1.2、import使用示例"></a>1.2、import使用示例</h4><ul><li>当使用的是<code>export</code>，而不是<code>export default</code>的时候</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用方式1：常规方法</span><br><span class="line">import &#123; Greeting &#125; from &quot;./src/greeting&quot;;</span><br><span class="line"></span><br><span class="line">//使用方式2：如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名</span><br><span class="line">import &#123; bieming as Greeting &#125; from &quot;./src/greeting&quot;;</span><br></pre></td></tr></table></figure><ul><li>当使用的是<code>export default</code>的时候</li></ul><p>可以用任意名称指向greeting.js输出的方法，这时就不需要知道原模块输出的变量名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用export default的时候可以有如下写法</span><br><span class="line">import AnyName from &quot;./src/greeting&quot;;</span><br></pre></td></tr></table></figure><p>需要注意的是，这时import命令后面，不使用大括号。常见于<code>export default createAppContainer(UIHomeNavigation);</code></p><h3 id="2、颜色与图片资源"><a href="#2、颜色与图片资源" class="headerlink" title="2、颜色与图片资源"></a>2、颜色与图片资源</h3><ul><li><a href="https://reactnative.cn/docs/0.50/colors.html" target="_blank" rel="noopener">React Native中文网：颜色</a></li><li><a href="https://www.jianshu.com/p/a3bce3c7d838" target="_blank" rel="noopener">如何高效管理 React Native 项目中的图片资源</a></li></ul><h3 id="3、View样式属性"><a href="#3、View样式属性" class="headerlink" title="3、View样式属性"></a>3、View样式属性</h3><p>参考文章：</p><ul><li><a href="https://reactnative.cn/docs/view-style-props/" target="_blank" rel="noopener">View样式属性</a></li></ul><h3 id="4、组件的属性添加及隐藏"><a href="#4、组件的属性添加及隐藏" class="headerlink" title="4、组件的属性添加及隐藏"></a>4、组件的属性添加及隐藏</h3><p>需求距离：日期连接符，根据参数来判断是用直线还是波浪线。</p><p>定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class DateConnectView extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            showWave: true</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        let dateConnectView = this.props.showWave ?</span><br><span class="line">            &lt;View</span><br><span class="line">                style=&#123;&#123;width: 20, height: 1, backgroundColor: &quot;black&quot;&#125;&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">            :</span><br><span class="line">            &lt;View</span><br><span class="line">                style=&#123;&#123;width: 20, height: 1, backgroundColor: &quot;black&quot;&#125;&#125;</span><br><span class="line">            /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &#123;dateConnectView&#125;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;DateConnectView showWave=&#123;false&#125; /&gt;</span><br></pre></td></tr></table></figure><h2 id="二、bind"><a href="#二、bind" class="headerlink" title="二、bind"></a>二、bind</h2><blockquote><p>ES5语法React.createClass会自动绑定this,ES6的写法,不再自动绑定this。</p></blockquote><p>参考文章：</p><ul><li><a href="https://www.cnblogs.com/shaoting/p/6108809.html" target="_blank" rel="noopener">React Native 的绑定 this</a></li></ul><ul><li><a href="https://www.jianshu.com/p/ce970791aba4" target="_blank" rel="noopener">React Native绑定this(bind(this))</a></li></ul><p><strong>如果需要传参数，则采用箭头函数的写法。</strong></p><h2 id="三、常见问题"><a href="#三、常见问题" class="headerlink" title="三、常见问题"></a>三、常见问题</h2><h3 id="1、使用Class类出现的问题"><a href="#1、使用Class类出现的问题" class="headerlink" title="1、使用Class类出现的问题"></a>1、使用Class类出现的问题</h3><h4 id="1-1、View-config-not-found-for-name完美解决方法"><a href="#1-1、View-config-not-found-for-name完美解决方法" class="headerlink" title="1.1、View config not found for name完美解决方法"></a>1.1、View config not found for name完美解决方法</h4><p>出现的原因是return的内容内组件的首字母不是大写，比如如果提示View config not found for name  abc，则只需将abc换成Abc即可解决。</p><h4 id="1-2、Only-one-default-export-allowed-per-module"><a href="#1-2、Only-one-default-export-allowed-per-module" class="headerlink" title="1.2、Only one default export allowed per module"></a>1.2、Only one default export allowed per module</h4><p>export default class声明的类只能有一个，并且被引用的类要符合执行顺序</p><p>所以，请检查export default class 是不是太多了。</p><h4 id="1-3、Module-does-not-exist-in-the-module-map"><a href="#1-3、Module-does-not-exist-in-the-module-map" class="headerlink" title="1.3、Module does not exist in the module map"></a>1.3、Module does not exist in the module map</h4><p>Module does not exist in the module map 即<br>在Haste模块映射中或在这些映射中不存在，一般存在于对同一级目录的引用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ButtonFactory from &apos;cjdemobuttonfactory&apos;// 错误</span><br><span class="line">// 改为下面即可</span><br><span class="line">import ButtonFactory from &apos;./cjdemobuttonfactory&apos; // 正确</span><br></pre></td></tr></table></figure><h2 id="2、使用Text问题"><a href="#2、使用Text问题" class="headerlink" title="2、使用Text问题"></a>2、使用Text问题</h2><h4 id="2-1、Text文字的垂直居中"><a href="#2-1、Text文字的垂直居中" class="headerlink" title="2.1、Text文字的垂直居中"></a>2.1、Text文字的垂直居中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text style=&#123;&#123;</span><br><span class="line">    flex: 1,</span><br><span class="line">    height: 44,</span><br><span class="line">    lineHeight:44,//添加这行即可使得Text文字垂直居中显示</span><br><span class="line">    textAlign: &quot;center&quot;,</span><br><span class="line">    backgroundColor: &quot;red&quot;,</span><br><span class="line">    color: &apos;#5C5C5C&apos;,</span><br><span class="line">    fontSize: 15,</span><br><span class="line">&#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">&quot;我是文字&quot;</span><br><span class="line">&lt;/Text&gt;</span><br></pre></td></tr></table></figure><h3 id="3、使用列表-FlatList-SectionList-出现的问题"><a href="#3、使用列表-FlatList-SectionList-出现的问题" class="headerlink" title="3、使用列表 FlatList/SectionList 出现的问题"></a>3、使用列表 <em>FlatList</em>/<em>SectionList</em> 出现的问题</h3><h4 id="3-1、keyExtractor"><a href="#3-1、keyExtractor" class="headerlink" title="3.1、keyExtractor"></a>3.1、keyExtractor</h4><blockquote><p>VirtualizedList: missing keys for items, make sure to specify a key property on each item or provide a custom keyExtractor.</p></blockquote><p>它警告我们每个item 要有不同的key 。默认情况下每行都需要提供一个不重复的key属性。你也可以提供一个keyExtractor函数来生成key。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;FlatList</span><br><span class="line"> keyExtractor=&#123;(item, index) =&gt; index.toString()&#125;//不能缺少</span><br><span class="line">/&gt;  </span><br><span class="line"></span><br><span class="line">// keyExtractor也可以用方法写</span><br><span class="line">keyExtractor = &#123;this._extraUniqueKey&#125;   </span><br><span class="line"></span><br><span class="line">_extraUniqueKey(item ,index)&#123;</span><br><span class="line">      return &quot;index&quot;+index+item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2、virtualizedCell-cellKey"><a href="#3-2、virtualizedCell-cellKey" class="headerlink" title="3.2、virtualizedCell.cellKey"></a>3.2、virtualizedCell.cellKey</h4><blockquote><p>Warning: Failed child context type: Invalid child context virtualizedCell.cellKey of type number supplied to CellRenderer, expected string.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keyExtractor=&#123;(item, index) =&gt; index&#125;//会有警告⚠️</span><br><span class="line">// 修改成如下：</span><br><span class="line">keyExtractor=&#123;(item, index) =&gt; index.toString()&#125;//成功</span><br></pre></td></tr></table></figure><h3 id="4、使用导航问题"><a href="#4、使用导航问题" class="headerlink" title="4、使用导航问题"></a>4、使用导航问题</h3><blockquote><p>TypeError: undefined is not an object (evaluating ‘this.props.navigation.navigate’)</p></blockquote><p>检查下是不是导航栏不是在该类，而是在其他类上。常见于你在子组件中调用了该属性而发生错误。</p><p>举例：<a href="https://stackoverflow.com/questions/48446821/typeerror-undefined-is-not-an-object-evaluating-this-props-navigation-navigate" target="_blank" rel="noopener">https://stackoverflow.com/questions/48446821/typeerror-undefined-is-not-an-object-evaluating-this-props-navigation-navigate</a></p><ul><li>问：怎么判断导航栏是否为空？</li><li>答：</li></ul><h3 id="5、引用资源遇到的问题"><a href="#5、引用资源遇到的问题" class="headerlink" title="5、引用资源遇到的问题"></a>5、引用资源遇到的问题</h3><blockquote><p>Metro Bundler has encountered an internal error, please check your terminal error output for more details</p></blockquote><p>可能原因：路径出错，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">icon:require(&apos;../image/home_n.png&apos;),</span><br><span class="line">//改成正确的路径后，问题解决</span><br><span class="line">icon:require(&apos;./image/home_n.png&apos;),</span><br></pre></td></tr></table></figure><h2 id="四、第三方库"><a href="#四、第三方库" class="headerlink" title="四、第三方库"></a>四、第三方库</h2><h3 id="1、添加库"><a href="#1、添加库" class="headerlink" title="1、添加库"></a>1、添加库</h3><ul><li><p><a href="https://reactnavigation.org/docs/en/getting-started.html" target="_blank" rel="noopener">官网react-navigation的添加方法</a></p></li><li><p>同理你要添加如<code>react-native-device-info</code>库，则在终端cd到package.json后，执行<code>npm install --save react-native-device-info</code>，其就会在package.json中添加。</p></li><li><p>添加</p><p><a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">antd</a></p><p><a href="https://mobile.ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">Ant Design Mobile of React</a></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd xxx</span><br><span class="line">npm install antd --save</span><br><span class="line">npm install antd-mobile --save</span><br><span class="line">npm install @ant-design/react-native --save</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第一章：ReactNative入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3节：React与ReactNative的区别</title>
      <link href="/React/1%E5%85%A5%E9%97%A8/React%E4%B8%8EReactNative%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/React/1%E5%85%A5%E9%97%A8/React%E4%B8%8EReactNative%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="react-img标签引入图片的几种方式"><a href="#react-img标签引入图片的几种方式" class="headerlink" title="react img标签引入图片的几种方式"></a>react img标签引入图片的几种方式</h3><blockquote><p>1）import 方法：</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> imgURL <span class="keyword">from</span> <span class="string">'./../images/photo.png'</span>;</span><br><span class="line">&lt;img src=&#123;imgURL &#125; /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>（2）require方法 这种方法需要注意的是，require里只能写字符串，不能写变量。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&#123;<span class="built_in">require</span>(<span class="string">'./../images/photo.png'</span>)&#125; /&gt;</span><br></pre></td></tr></table></figure><h3 id="react中使用prop-types检测props数据类型"><a href="#react中使用prop-types检测props数据类型" class="headerlink" title="react中使用prop-types检测props数据类型"></a>react中使用prop-types检测props数据类型</h3><p><a href="https://www.jianshu.com/p/a73fb26c88b5" target="_blank" rel="noopener">react中使用prop-types检测props数据类型</a></p><h3 id="1、react通过state的数据显示style多个样式（三目运算）"><a href="#1、react通过state的数据显示style多个样式（三目运算）" class="headerlink" title="1、react通过state的数据显示style多个样式（三目运算）"></a>1、react通过state的数据显示style多个样式（三目运算）</h3><p><a href="https://blog.csdn.net/chensong8331/article/details/102938954" target="_blank" rel="noopener">react通过state的数据显示style多个样式（三目运算）</a></p><table><thead><tr><th>序号</th><th>区别点</th><th>React</th><th>ReactNative</th></tr></thead><tbody><tr><td></td><td>图片类</td><td>img</td><td>Image</td></tr><tr><td></td><td>图片数据属性</td><td>src</td><td>source</td></tr><tr><td></td><td>多style的设置</td><td>{xx, yy}</td><td>{[xx,yy]}</td></tr><tr><td></td><td>获取屏幕的宽高</td><td><a href="https://blog.csdn.net/robin912/article/details/80274719" target="_blank" rel="noopener">React下获取width和height</a></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第一章：ReactNative入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：ReactNative详解Button</title>
      <link href="/React/5%E8%AF%A6%E8%A7%A3/ReactNative%E8%AF%A6%E8%A7%A3Button/"/>
      <url>/React/5%E8%AF%A6%E8%A7%A3/ReactNative%E8%AF%A6%E8%A7%A3Button/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative详解Button"><a href="#ReactNative详解Button" class="headerlink" title="ReactNative详解Button"></a>ReactNative详解Button</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第五章：ReactNative详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：ReactNative详解布局</title>
      <link href="/React/5%E8%AF%A6%E8%A7%A3/ReactNative%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/"/>
      <url>/React/5%E8%AF%A6%E8%A7%A3/ReactNative%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative详解布局"><a href="#ReactNative详解布局" class="headerlink" title="ReactNative详解布局"></a>ReactNative详解布局</h1><p>参考文章：</p><ul><li><a href="https://reactnative.cn/docs/0.47/layout-props.html" target="_blank" rel="noopener">RN中文网：RN布局样式属性</a></li><li><a href="https://blog.csdn.net/u010689434/article/details/80611570" target="_blank" rel="noopener">React-Native 第一章 布局</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>布局</p><h2 id="一、flex"><a href="#一、flex" class="headerlink" title="一、flex"></a>一、flex</h2><p><code>flex:1</code> ，那么这是什么意思呢？<br>可以理解为<strong>比重</strong></p><p><strong>·</strong> 如果同级组件上只有一个，并且设置了 <code>flex:1</code>，那么这个组件相当于分配了全部空间。<br><strong>·</strong> 如果同级组件上只有两个，并且这两个都设置了 <code>flex:1</code>，那么相当于这两个组件平均分配了全部空间。<br><strong>·</strong> 如果同级组件上只有两个，并且第一个组件设置了 <code>flex:1</code>，第二个组件设置了 <code>flex:2</code>，那么相当于第一个组件占据全部空间的三分之一，第二个组件占据全部空间的三分之二。<br><strong>·</strong> 如果没有设置 <code>flex</code> 属性，那么这个组件按需分配空间。</p><h3 id="1、flex-与-width-height-的优先级"><a href="#1、flex-与-width-height-的优先级" class="headerlink" title="1、flex 与 width/height 的优先级"></a>1、flex 与 width/height 的优先级</h3><p>同时有flex、width、height时候，flex 与 width/height 的优先级</p><p>flex的优先级 &gt; width/height。具体，</p><p>①、当组件是竖向排列时候，flex的优先级 &gt; height，即height的设置会失效；</p><p>②、当组件是横向排列时候，flex的优先级 &gt; width，即width的设置会失效；</p><p>如还有不懂此相关的文章可参考：<a href="https://www.jianshu.com/p/025f4ad7a4a4" target="_blank" rel="noopener">https://www.jianshu.com/p/025f4ad7a4a4</a></p><h2 id="二、flexDirection"><a href="#二、flexDirection" class="headerlink" title="二、flexDirection"></a>二、flexDirection</h2><p><code>flexDirection enum(&#39;row&#39;, &#39;column&#39;,&#39;row-reverse&#39;,&#39;column-reverse&#39;)</code><br><code>flexDirection</code>属性定义了父视图中的子元素沿横轴或侧轴方片的排列方式。</p><table><thead><tr><th>类型</th><th>含义</th><th>图形举例</th></tr></thead><tbody><tr><td>column(默认的排列方式)</td><td>从上向下排列</td><td></td></tr><tr><td>column-reverse</td><td>从下向上排列</td><td></td></tr><tr><td>row</td><td>从左向右依次排列</td><td></td></tr><tr><td>row-reverse</td><td>从右向左依次排列</td></tr></tbody></table><p>图形举例：</p><p><img src="/React/5详解/ReactNative详解布局/fiexDirection_all.png" alt="image-20190522144243353"></p><h2 id="三、flexWrap"><a href="#三、flexWrap" class="headerlink" title="三、flexWrap"></a>三、flexWrap</h2><p><code>flexWrap enum(&#39;wrap&#39;, &#39;nowrap&#39;)</code><br><code>flexWrap</code>属性定义了子元素在父视图内是否允许多行排列，默认为nowrap。</p><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>nowrap<br>(默认)</td><td>flex的元素只排列在一行上，可能导致溢出。</td><td></td></tr><tr><td>wrap</td><td>flex的元素在一行排列不下时，就进行多行排列</td><td></td></tr><tr><td>wrap-reverse</td><td>换行，第一行在下方</td></tr></tbody></table><p>图形举例：</p><p><img src="/React/5详解/ReactNative详解布局/flexWrap_all.png" alt="image-20190522144822763"></p><p>代码举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123; &#123;flexWrap:&apos;wrap&apos;,flexDirection:&apos;row&apos;,backgroundColor:&quot;darkgray&quot;,marginTop:20&#125;&#125;&gt;</span><br><span class="line">···</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure><h2 id="四、justifyContent"><a href="#四、justifyContent" class="headerlink" title="四、justifyContent"></a>四、justifyContent</h2><table><thead><tr><th>类型</th><th>含义</th><th>row举例</th><th>column举例</th></tr></thead><tbody><tr><td>flex-start<br>(default)</td><td><strong>从行首开始排列。</strong>每行第一个弹性元素与行首对齐，同时所有后续的弹性元素与前一个对齐</td><td><img src="/React/5详解/ReactNative详解布局/row_flex-start.png" alt="image-20190522141651963"></td><td><img src="/React/5详解/ReactNative详解布局/column_flex-start.png" alt="image-20190522141910412"></td></tr><tr><td>center</td><td><strong>伸缩元素向每行中点排列。</strong>每行第一个元素到行首的距离将与每行最后一个元素到行尾的距离相同。</td><td><img src="/React/5详解/ReactNative详解布局/row_center.png" alt="image-20190522141712063"></td><td><img src="/React/5详解/ReactNative详解布局/column_center.png" alt="image-20190522141921712"></td></tr><tr><td>flex-end</td><td><strong>从行尾开始排列。</strong>每行最后一个弹性元素与行尾对齐，其他元素将与后一个对齐。</td><td><img src="/React/5详解/ReactNative详解布局/row_flex-end.png" alt="image-20190522141735033"></td><td><img src="/React/5详解/ReactNative详解布局/column_flex-end.png" alt="image-20190522141945434"></td></tr><tr><td>space-between</td><td>在每行上均匀分配弹性元素。相邻元素间距离相同。<strong>每行第一个元素与行首对齐，每行最后一个元素与行尾对齐。</strong></td><td><img src="/React/5详解/ReactNative详解布局/row_space-between.png" alt="image-20190522141408707"></td><td><img src="/React/5详解/ReactNative详解布局/column_space-between.png" alt="image-20190522141846812"></td></tr><tr><td>space-around</td><td>在每行上均匀分配弹性元素。相邻元素间距离相同。<strong>每行第一个元素到行首的距离和每行最后一个元素到行尾的距离将会是相邻元素之间距离的一半。</strong></td><td><img src="/React/5详解/ReactNative详解布局/row_space-around.png" alt="image-20190522141755193"></td><td><img src="/React/5详解/ReactNative详解布局/column_space-around.png" alt="image-20190522142004059"></td></tr></tbody></table><p>其他图：</p><p><img src="/React/5详解/ReactNative详解布局/row_all.png" alt="image-20190522143527522"></p><p>代码使用举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;View        style=&#123; &#123;justifyContent:&apos;center&apos;,flexDirection:&apos;row&apos;,backgroundColor:&quot;darkgray&quot;,marginTop:20&#125;&#125;&gt;</span><br><span class="line">···</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure><h2 id="五、alignItems（此样式设置在父元素上）"><a href="#五、alignItems（此样式设置在父元素上）" class="headerlink" title="五、alignItems（此样式设置在父元素上）"></a>五、alignItems（此样式设置在父元素上）</h2><table><thead><tr><th>类型</th><th>比较</th><th>注意</th></tr></thead><tbody><tr><td>justifyContent</td><td>决定其<strong>子元素</strong>沿着<strong>主轴</strong>的<strong>排列方式</strong></td><td></td></tr><tr><td>alignItems</td><td>决定其<strong>子元素</strong>沿着<strong>次轴</strong>的<strong>排列方式</strong></td></tr></tbody></table><p><code>alignItems</code>决定了<strong>子元素</strong>在次轴方向的排列方式（此样式设置在父元素上）。例如若子元素本来是沿着竖直方向排列的（即主轴竖直，次轴水平），则<code>alignItems</code>决定了它们在水平方向的排列方式。此样式和CSS中的<code>align-items</code>表现一致，默认值为stretch。</p><p><code>alignItems enum(&#39;flex-start&#39;, &#39;flex-end&#39;, &#39;center&#39;, &#39;stretch&#39;)</code><br><code>alignItems</code>属性以与justify-content相同的方式在侧轴方向上将当前行上的弹性元素对齐，默认为stretch。</p><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>stretch<br>(默认)</td><td>弹性元素被<strong>在侧轴方向</strong>被拉伸到与容器相同的高度或宽度。</td><td></td></tr><tr><td>flex-start</td><td>元素<strong>向侧轴起点对齐</strong></td><td></td></tr><tr><td>flex-end</td><td>元素<strong>向侧轴终点对齐</strong></td><td></td></tr><tr><td>center</td><td>元素<strong>在侧轴居中</strong>。如果元素在侧轴上的高度高于其容器，那么在两个方向上溢出距离相同。</td></tr></tbody></table><p>在<code>{justifyContent:&#39;center&#39;,flexDirection:&#39;row&#39;}</code>的情况下：</p><p><img src="/React/5详解/ReactNative详解布局/alignItems_mainRow_all.png" alt="image-20190522151226308"></p><h2 id="六、alignSelf（此样式设置在子元素上）"><a href="#六、alignSelf（此样式设置在子元素上）" class="headerlink" title="六、alignSelf（此样式设置在子元素上）"></a>六、alignSelf（此样式设置在子元素上）</h2><table><thead><tr><th>类型</th><th>比较</th><th>注意</th></tr></thead><tbody><tr><td>alignItems</td><td>决定了<strong>子元素</strong>在次轴方向的排列方式（<strong>此样式设置在父元素上</strong>）</td><td></td></tr><tr><td>alignSelf</td><td>决定了<strong>该元素</strong>在父元素的次轴方向的排列方式（<strong>此样式设置在子元素上</strong>）</td><td>其值会覆盖父元素的<code>alignItems</code>的值</td></tr></tbody></table><h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><h3 id="1、position-定位"><a href="#1、position-定位" class="headerlink" title="1、position(定位)"></a>1、position(定位)</h3><p><strong>React Native 中，position 默认值为 <code>relative</code>，即相对布局。</strong></p><p>position enum(‘absolute’, ‘relative’)属性设置元素的定位方式，为将要定位的元素定义定位规则。</p><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>relative<br>(默认值)</td><td>生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</td><td></td></tr><tr><td>absolute</td><td>生成绝对定位的元素，元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td></tr></tbody></table><p><strong>默认情况下，使用<code>position: &#39;absolute&#39;</code>后，后面的元素会默认覆盖在前面的元素之上。</strong></p><h3 id="2、边缘与宽高-flex、width-height、top-left-bottom-right"><a href="#2、边缘与宽高-flex、width-height、top-left-bottom-right" class="headerlink" title="2、边缘与宽高(flex、width/height、top/left/bottom/right)"></a>2、边缘与宽高(flex、width/height、top/left/bottom/right)</h3><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>top</td><td>元素的上外边距边界与其包含块上边界之间的偏移</td><td></td></tr><tr><td>left</td><td>元素左外边距边界与其包含块左边界之间的偏移</td><td></td></tr><tr><td>bottom</td><td>元素的下外边距边界与其包含块下边界之间的偏移</td><td></td></tr><tr><td>right</td><td>元素右外边距边界与其包含块右边界之间的偏移</td><td></td></tr><tr><td>width</td><td>元素的宽</td><td></td></tr><tr><td>height</td><td>元素的高</td></tr></tbody></table><h4 id="①、相对布局relative下，flex优先级比width-height高"><a href="#①、相对布局relative下，flex优先级比width-height高" class="headerlink" title="①、相对布局relative下，flex优先级比width/height高"></a>①、相对布局relative下，flex优先级比width/height高</h4><table><thead><tr><th>父组件的前提下</th><th>对子组件进行的设置</th><th>造成子组件结果</th></tr></thead><tbody><tr><td>如果父组件设置了 flex 值</td><td>子组件设置了 flex 值的同时，也设置了高度值</td><td>则高度无效</td></tr><tr><td>如果父组件设置了 flex 值</td><td>子组件没有设置 flex 值，只设置了高度值，</td><td>则子组件高度有效</td></tr></tbody></table><p>参考文章：<a href="https://www.jianshu.com/p/5e35610aeacf" target="_blank" rel="noopener">React-Native 中的基本布局技巧</a></p><h4 id="②、绝对布局absolute下，width-height优先级比flex高"><a href="#②、绝对布局absolute下，width-height优先级比flex高" class="headerlink" title="②、绝对布局absolute下，width/height优先级比flex高"></a>②、绝对布局absolute下，width/height优先级比flex高</h4><h3 id="3、margin-外边距"><a href="#3、margin-外边距" class="headerlink" title="3、margin(外边距)"></a>3、margin(外边距)</h3><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>marginTop</td><td>上外边距</td><td></td></tr><tr><td>marginLeft</td><td>左外边距</td><td></td></tr><tr><td>marginBottom</td><td>下外边距</td><td></td></tr><tr><td>marginRight</td><td>右外边距</td><td></td></tr><tr><td>marginHorizontal</td><td>左右外边距</td><td></td></tr><tr><td>marginVertical</td><td>上下外边距</td></tr></tbody></table><h3 id="4、padding-内边距"><a href="#4、padding-内边距" class="headerlink" title="4、padding(内边距)"></a>4、padding(内边距)</h3><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>paddingTop</td><td>上内边距</td><td></td></tr><tr><td>paddingLeft</td><td>左内边距</td><td></td></tr><tr><td>paddingBottom</td><td>下内边距</td><td></td></tr><tr><td>paddingRight</td><td>右内边距</td><td></td></tr><tr><td>paddingHorizontal</td><td>左右内边距</td><td></td></tr><tr><td>paddingVertical</td><td>上下内边距</td></tr></tbody></table><h3 id="5、视图边框"><a href="#5、视图边框" class="headerlink" title="5、视图边框"></a>5、视图边框</h3><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>borderTopWidth</td><td>顶部边框宽度</td><td></td></tr><tr><td>borderLeftWidth</td><td>左边框宽度</td><td></td></tr><tr><td>borderBottomWidth</td><td>底部边框宽度</td><td></td></tr><tr><td>borderRightWidth</td><td>右边框宽度</td><td></td></tr><tr><td>borderColor</td><td>边框颜色</td><td></td></tr><tr><td>border&lt;Bottom\</td><td>Left\</td><td>Right\</td><td>Top&gt;Color</td><td>各个方向边框的颜色</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第五章：ReactNative详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：ReactNative使用技巧</title>
      <link href="/React/6%E8%BF%9B%E9%98%B6/ReactNative%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/React/6%E8%BF%9B%E9%98%B6/ReactNative%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative使用技巧"><a href="#ReactNative使用技巧" class="headerlink" title="ReactNative使用技巧"></a>ReactNative使用技巧</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="一、布局"><a href="#一、布局" class="headerlink" title="一、布局"></a>一、布局</h2><p><strong>默认情况下，使用<code>position: &#39;absolute&#39;</code>后，后面的元素会默认覆盖在前面的元素之上。</strong></p><h2 id="二、Text"><a href="#二、Text" class="headerlink" title="二、Text"></a>二、Text</h2><h4 id="1、-style-Android上Text默认的字体颜色，不是black，不是black，不是black"><a href="#1、-style-Android上Text默认的字体颜色，不是black，不是black，不是black" class="headerlink" title="1、[style]Android上Text默认的字体颜色，不是black，不是black，不是black"></a>1、[style]Android上Text默认的字体颜色，不是black，不是black，不是black</h4><p>如果在Android上面，不显示地给Text添加color，那么显示出来的字体颜色就是灰色。跟iOS的表现不一致；<br><strong>解决方案：</strong><br>方案一：给每个Text都设置color</p><blockquote><p><em>不足：</em>每次都设置color。比较繁琐</p></blockquote><p>方案二：写一个自定义组件</p><blockquote><p>比如MyText，这个Text设置颜色，每次使用xxx就默认为你设置的颜色了。<br><em>不足：</em>多出来了一个新的组件，也比较繁琐。<br>多出来了一个新的组件，也比较繁琐。</p></blockquote><p>方案三：设置默认props</p><blockquote><p>在入口文件里面写上默认的style，比如：<br><code>Text.defaultProps.sytle = { &#39;color&#39;: &#39;#212121&#39;}</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第五章：ReactNative详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：ReactNative详解生命周期</title>
      <link href="/React/5%E8%AF%A6%E8%A7%A3/ReactNative%E8%AF%A6%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/React/5%E8%AF%A6%E8%A7%A3/ReactNative%E8%AF%A6%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><a href="#divtop">跳转指定位置</a></p><h1 id="ReactNative详解生命周期"><a href="#ReactNative详解生命周期" class="headerlink" title="ReactNative详解生命周期"></a>ReactNative详解生命周期</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>1、数据变化怎么通知React(以按钮更新文本为例)</li></ul><p>常用的通知React数据变化的方法是调用<strong>setState(data,callback)</strong>，这个方法会合并data到this.state，并重新渲染组件。渲染完成后，调用可选的callback回调。大部分情况不需要提供callback，因为React会负责吧界面更新到最新状态。</p><p>详情查看：<a href="#Attachment1">附一：StateEasyPage.js 与 StateNormalPage.js</a></p><ul><li>2、怎么给组件添加属性、设置默认值，并对默认值设置类型检查</li></ul><h2 id="一、了解state作用"><a href="#一、了解state作用" class="headerlink" title="一、了解state作用"></a>一、了解state作用</h2><h3 id="1、this-setState-xxx-’’-与-this-state-xxx-’’"><a href="#1、this-setState-xxx-’’-与-this-state-xxx-’’" class="headerlink" title="1、this.setState({xxx:’’}) 与 this.state.xxx=’’"></a>1、this.setState({xxx:’’}) 与 this.state.xxx=’’</h3><table><thead><tr><th>类型</th><th>this.state.xxx=’’</th><th>this.setState({xxx:’’})</th></tr></thead><tbody><tr><td>作用</td><td>this.state通常是用来初始化state的</td><td>this.setstate是用来修改state值的</td></tr><tr><td>注意</td><td>再次调用时候，之前的state会被覆盖掉</td><td>再次调用时候，只会替换掉相应的state值</td></tr><tr><td></td><td></td></tr></tbody></table><p><strong>所以，自定义组件的时候，因为其需要传的参数是会被变化的，所以，我们在自定义组件中，不能使用state来更新，而是自定义组件中使用props，结合外部调用它的来处理。</strong></p><h3 id="2、认识state原理"><a href="#2、认识state原理" class="headerlink" title="2、认识state原理"></a>2、认识state原理</h3><h4 id="2-1、this-setState"><a href="#2-1、this-setState" class="headerlink" title="2.1、this.setState({})"></a>2.1、this.setState({})</h4><p><strong>this.setState({})会触发render方法，重新渲染界面。而this.state.xxx=’’ 不会重新加载UI。</strong></p><p>this.setState({})是异步的</p><h2 id="三、类型判断"><a href="#三、类型判断" class="headerlink" title="三、类型判断"></a>三、类型判断</h2><p>参考文章：</p><ul><li><a href="https://www.jb51.net/article/102972.htm" target="_blank" rel="noopener">js 判断数据类型的几种方法</a></li></ul><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="附一：StateEasyPage-js-与-StateNormalPage-js"><a href="#附一：StateEasyPage-js-与-StateNormalPage-js" class="headerlink" title="附一：StateEasyPage.js 与 StateNormalPage.js"></a>附一：StateEasyPage.js 与 StateNormalPage.js</h3><p><a name="Attachment1"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//StateEasyPage.js</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; View, Button, Text &#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">export default class StateEasyPage extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            showText:&quot;旧标题&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Button</span><br><span class="line">                    title=&#123;&quot;点击切换标题&quot;&#125;</span><br><span class="line">                    onPress=&#123;()=&gt;&#123;</span><br><span class="line">                        this.setState(&#123;</span><br><span class="line">                            showText: &quot;新标题&quot;</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">                &lt;Text&gt;&#123;this.state.showText&#125;&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>丰富一下，使其可以来回切换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//StateNormalPage.js</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; View, Button, Text &#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">export default class StateNormalPage extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            showText:&quot;旧标题&quot;,</span><br><span class="line">            isShowNew: false</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        let currentShowText = this.state.isShowNew ? &quot;新标题&quot; : &quot;旧标题&quot;</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Button</span><br><span class="line">                    title=&#123;&quot;点击切换标题&quot;&#125;</span><br><span class="line">                    onPress=&#123;()=&gt;&#123;</span><br><span class="line">                        let isShowNew = !this.state.isShowNew;</span><br><span class="line">                        this.setState(&#123;</span><br><span class="line">                            isShowNew: isShowNew</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">                &lt;Text&gt;&#123;currentShowText&#125;&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第五章：ReactNative详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3节：ReactNative组件的封装</title>
      <link href="/React/6%E8%BF%9B%E9%98%B6/ReactNative%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85/"/>
      <url>/React/6%E8%BF%9B%E9%98%B6/ReactNative%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative组件的封装"><a href="#ReactNative组件的封装" class="headerlink" title="ReactNative组件的封装"></a>ReactNative组件的封装</h1><p>参考文章：</p><ul><li><a href="http://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">es6 Class 的继承</a></li><li><a href="https://www.jianshu.com/p/02ea122171c4" target="_blank" rel="noopener">(重要)react-native之Button组件及自定义</a></li><li><p><a href="https://www.jianshu.com/p/e9a4843fd873" target="_blank" rel="noopener">(重要)React-Native 自定义按钮系列</a></p></li><li><p><a href="https://www.jianshu.com/p/a92e68de0b6a" target="_blank" rel="noopener">React Native (三)： 自定义视图</a></p></li></ul><p>很多用React Native的同学都是前端工程师，在传统的js没有继承的概念。但是在react Native所支持的es6是有继承的，效果也是不错的。</p>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第六章：ReactNative进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：ReactNative详解Button</title>
      <link href="/ReactNative/5%E8%AF%A6%E8%A7%A3/ReactNative%E8%AF%A6%E8%A7%A3Button/"/>
      <url>/ReactNative/5%E8%AF%A6%E8%A7%A3/ReactNative%E8%AF%A6%E8%A7%A3Button/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative详解Button"><a href="#ReactNative详解Button" class="headerlink" title="ReactNative详解Button"></a>ReactNative详解Button</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第五章：ReactNative详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：ReactNative详解生命周期</title>
      <link href="/ReactNative/5%E8%AF%A6%E8%A7%A3/ReactNative%E8%AF%A6%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/ReactNative/5%E8%AF%A6%E8%A7%A3/ReactNative%E8%AF%A6%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><a href="#divtop">跳转指定位置</a></p><h1 id="ReactNative详解生命周期"><a href="#ReactNative详解生命周期" class="headerlink" title="ReactNative详解生命周期"></a>ReactNative详解生命周期</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>1、数据变化怎么通知React(以按钮更新文本为例)</li></ul><p>常用的通知React数据变化的方法是调用<strong>setState(data,callback)</strong>，这个方法会合并data到this.state，并重新渲染组件。渲染完成后，调用可选的callback回调。大部分情况不需要提供callback，因为React会负责吧界面更新到最新状态。</p><p>详情查看：<a href="#Attachment1">附一：StateEasyPage.js 与 StateNormalPage.js</a></p><ul><li>2、怎么给组件添加属性、设置默认值，并对默认值设置类型检查</li></ul><h2 id="一、了解state作用"><a href="#一、了解state作用" class="headerlink" title="一、了解state作用"></a>一、了解state作用</h2><h3 id="1、this-setState-xxx-’’-与-this-state-xxx-’’"><a href="#1、this-setState-xxx-’’-与-this-state-xxx-’’" class="headerlink" title="1、this.setState({xxx:’’}) 与 this.state.xxx=’’"></a>1、this.setState({xxx:’’}) 与 this.state.xxx=’’</h3><table><thead><tr><th>类型</th><th>this.state.xxx=’’</th><th>this.setState({xxx:’’})</th></tr></thead><tbody><tr><td>作用</td><td>this.state通常是用来初始化state的</td><td>this.setstate是用来修改state值的</td></tr><tr><td>注意</td><td>再次调用时候，之前的state会被覆盖掉</td><td>再次调用时候，只会替换掉相应的state值</td></tr><tr><td></td><td></td></tr></tbody></table><p><strong>所以，自定义组件的时候，因为其需要传的参数是会被变化的，所以，我们在自定义组件中，不能使用state来更新，而是自定义组件中使用props，结合外部调用它的来处理。</strong></p><h3 id="2、认识state原理"><a href="#2、认识state原理" class="headerlink" title="2、认识state原理"></a>2、认识state原理</h3><h4 id="2-1、this-setState"><a href="#2-1、this-setState" class="headerlink" title="2.1、this.setState({})"></a>2.1、this.setState({})</h4><p><strong>this.setState({})会触发render方法，重新渲染界面。而this.state.xxx=’’ 不会重新加载UI。</strong></p><p>this.setState({})是异步的</p><h2 id="三、类型判断"><a href="#三、类型判断" class="headerlink" title="三、类型判断"></a>三、类型判断</h2><p>参考文章：</p><ul><li><a href="https://www.jb51.net/article/102972.htm" target="_blank" rel="noopener">js 判断数据类型的几种方法</a></li></ul><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="附一：StateEasyPage-js-与-StateNormalPage-js"><a href="#附一：StateEasyPage-js-与-StateNormalPage-js" class="headerlink" title="附一：StateEasyPage.js 与 StateNormalPage.js"></a>附一：StateEasyPage.js 与 StateNormalPage.js</h3><p><a name="Attachment1"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//StateEasyPage.js</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; View, Button, Text &#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">export default class StateEasyPage extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            showText:&quot;旧标题&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Button</span><br><span class="line">                    title=&#123;&quot;点击切换标题&quot;&#125;</span><br><span class="line">                    onPress=&#123;()=&gt;&#123;</span><br><span class="line">                        this.setState(&#123;</span><br><span class="line">                            showText: &quot;新标题&quot;</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">                &lt;Text&gt;&#123;this.state.showText&#125;&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>丰富一下，使其可以来回切换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//StateNormalPage.js</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; View, Button, Text &#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">export default class StateNormalPage extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            showText:&quot;旧标题&quot;,</span><br><span class="line">            isShowNew: false</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        let currentShowText = this.state.isShowNew ? &quot;新标题&quot; : &quot;旧标题&quot;</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Button</span><br><span class="line">                    title=&#123;&quot;点击切换标题&quot;&#125;</span><br><span class="line">                    onPress=&#123;()=&gt;&#123;</span><br><span class="line">                        let isShowNew = !this.state.isShowNew;</span><br><span class="line">                        this.setState(&#123;</span><br><span class="line">                            isShowNew: isShowNew</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">                &lt;Text&gt;&#123;currentShowText&#125;&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第五章：ReactNative详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：ReactNative详解布局</title>
      <link href="/ReactNative/5%E8%AF%A6%E8%A7%A3/ReactNative%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/"/>
      <url>/ReactNative/5%E8%AF%A6%E8%A7%A3/ReactNative%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative详解布局"><a href="#ReactNative详解布局" class="headerlink" title="ReactNative详解布局"></a>ReactNative详解布局</h1><p>参考文章：</p><ul><li><a href="https://reactnative.cn/docs/0.47/layout-props.html" target="_blank" rel="noopener">RN中文网：RN布局样式属性</a></li><li><a href="https://blog.csdn.net/u010689434/article/details/80611570" target="_blank" rel="noopener">React-Native 第一章 布局</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>布局</p><h2 id="一、flex"><a href="#一、flex" class="headerlink" title="一、flex"></a>一、flex</h2><p><code>flex:1</code> ，那么这是什么意思呢？<br>可以理解为<strong>比重</strong></p><p><strong>·</strong> 如果同级组件上只有一个，并且设置了 <code>flex:1</code>，那么这个组件相当于分配了全部空间。<br><strong>·</strong> 如果同级组件上只有两个，并且这两个都设置了 <code>flex:1</code>，那么相当于这两个组件平均分配了全部空间。<br><strong>·</strong> 如果同级组件上只有两个，并且第一个组件设置了 <code>flex:1</code>，第二个组件设置了 <code>flex:2</code>，那么相当于第一个组件占据全部空间的三分之一，第二个组件占据全部空间的三分之二。<br><strong>·</strong> 如果没有设置 <code>flex</code> 属性，那么这个组件按需分配空间。</p><h3 id="1、flex-与-width-height-的优先级"><a href="#1、flex-与-width-height-的优先级" class="headerlink" title="1、flex 与 width/height 的优先级"></a>1、flex 与 width/height 的优先级</h3><p>同时有flex、width、height时候，flex 与 width/height 的优先级</p><p>flex的优先级 &gt; width/height。具体，</p><p>①、当组件是竖向排列时候，flex的优先级 &gt; height，即height的设置会失效；</p><p>②、当组件是横向排列时候，flex的优先级 &gt; width，即width的设置会失效；</p><p>如还有不懂此相关的文章可参考：<a href="https://www.jianshu.com/p/025f4ad7a4a4" target="_blank" rel="noopener">https://www.jianshu.com/p/025f4ad7a4a4</a></p><h2 id="二、flexDirection"><a href="#二、flexDirection" class="headerlink" title="二、flexDirection"></a>二、flexDirection</h2><p><code>flexDirection enum(&#39;row&#39;, &#39;column&#39;,&#39;row-reverse&#39;,&#39;column-reverse&#39;)</code><br><code>flexDirection</code>属性定义了父视图中的子元素沿横轴或侧轴方片的排列方式。</p><table><thead><tr><th>类型</th><th>含义</th><th>图形举例</th></tr></thead><tbody><tr><td>column(默认的排列方式)</td><td>从上向下排列</td><td></td></tr><tr><td>column-reverse</td><td>从下向上排列</td><td></td></tr><tr><td>row</td><td>从左向右依次排列</td><td></td></tr><tr><td>row-reverse</td><td>从右向左依次排列</td></tr></tbody></table><p>图形举例：</p><p><img src="/ReactNative/5详解/ReactNative详解布局/fiexDirection_all.png" alt="image-20190522144243353"></p><h2 id="三、flexWrap"><a href="#三、flexWrap" class="headerlink" title="三、flexWrap"></a>三、flexWrap</h2><p><code>flexWrap enum(&#39;wrap&#39;, &#39;nowrap&#39;)</code><br><code>flexWrap</code>属性定义了子元素在父视图内是否允许多行排列，默认为nowrap。</p><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>nowrap<br>(默认)</td><td>flex的元素只排列在一行上，可能导致溢出。</td><td></td></tr><tr><td>wrap</td><td>flex的元素在一行排列不下时，就进行多行排列</td><td></td></tr><tr><td>wrap-reverse</td><td>换行，第一行在下方</td></tr></tbody></table><p>图形举例：</p><p><img src="/ReactNative/5详解/ReactNative详解布局/flexWrap_all.png" alt="image-20190522144822763"></p><p>代码举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123; &#123;flexWrap:&apos;wrap&apos;,flexDirection:&apos;row&apos;,backgroundColor:&quot;darkgray&quot;,marginTop:20&#125;&#125;&gt;</span><br><span class="line">···</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure><h2 id="四、justifyContent"><a href="#四、justifyContent" class="headerlink" title="四、justifyContent"></a>四、justifyContent</h2><table><thead><tr><th>类型</th><th>含义</th><th>row举例</th><th>column举例</th></tr></thead><tbody><tr><td>flex-start<br>(default)</td><td><strong>从行首开始排列。</strong>每行第一个弹性元素与行首对齐，同时所有后续的弹性元素与前一个对齐</td><td><img src="/ReactNative/5详解/ReactNative详解布局/row_flex-start.png" alt="image-20190522141651963"></td><td><img src="/ReactNative/5详解/ReactNative详解布局/column_flex-start.png" alt="image-20190522141910412"></td></tr><tr><td>center</td><td><strong>伸缩元素向每行中点排列。</strong>每行第一个元素到行首的距离将与每行最后一个元素到行尾的距离相同。</td><td><img src="/ReactNative/5详解/ReactNative详解布局/row_center.png" alt="image-20190522141712063"></td><td><img src="/ReactNative/5详解/ReactNative详解布局/column_center.png" alt="image-20190522141921712"></td></tr><tr><td>flex-end</td><td><strong>从行尾开始排列。</strong>每行最后一个弹性元素与行尾对齐，其他元素将与后一个对齐。</td><td><img src="/ReactNative/5详解/ReactNative详解布局/row_flex-end.png" alt="image-20190522141735033"></td><td><img src="/ReactNative/5详解/ReactNative详解布局/column_flex-end.png" alt="image-20190522141945434"></td></tr><tr><td>space-between</td><td>在每行上均匀分配弹性元素。相邻元素间距离相同。<strong>每行第一个元素与行首对齐，每行最后一个元素与行尾对齐。</strong></td><td><img src="/ReactNative/5详解/ReactNative详解布局/row_space-between.png" alt="image-20190522141408707"></td><td><img src="/ReactNative/5详解/ReactNative详解布局/column_space-between.png" alt="image-20190522141846812"></td></tr><tr><td>space-around</td><td>在每行上均匀分配弹性元素。相邻元素间距离相同。<strong>每行第一个元素到行首的距离和每行最后一个元素到行尾的距离将会是相邻元素之间距离的一半。</strong></td><td><img src="/ReactNative/5详解/ReactNative详解布局/row_space-around.png" alt="image-20190522141755193"></td><td><img src="/ReactNative/5详解/ReactNative详解布局/column_space-around.png" alt="image-20190522142004059"></td></tr></tbody></table><p>其他图：</p><p><img src="/ReactNative/5详解/ReactNative详解布局/row_all.png" alt="image-20190522143527522"></p><p>代码使用举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;View        style=&#123; &#123;justifyContent:&apos;center&apos;,flexDirection:&apos;row&apos;,backgroundColor:&quot;darkgray&quot;,marginTop:20&#125;&#125;&gt;</span><br><span class="line">···</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure><h2 id="五、alignItems（此样式设置在父元素上）"><a href="#五、alignItems（此样式设置在父元素上）" class="headerlink" title="五、alignItems（此样式设置在父元素上）"></a>五、alignItems（此样式设置在父元素上）</h2><table><thead><tr><th>类型</th><th>比较</th><th>注意</th></tr></thead><tbody><tr><td>justifyContent</td><td>决定其<strong>子元素</strong>沿着<strong>主轴</strong>的<strong>排列方式</strong></td><td></td></tr><tr><td>alignItems</td><td>决定其<strong>子元素</strong>沿着<strong>次轴</strong>的<strong>排列方式</strong></td></tr></tbody></table><p><code>alignItems</code>决定了<strong>子元素</strong>在次轴方向的排列方式（此样式设置在父元素上）。例如若子元素本来是沿着竖直方向排列的（即主轴竖直，次轴水平），则<code>alignItems</code>决定了它们在水平方向的排列方式。此样式和CSS中的<code>align-items</code>表现一致，默认值为stretch。</p><p><code>alignItems enum(&#39;flex-start&#39;, &#39;flex-end&#39;, &#39;center&#39;, &#39;stretch&#39;)</code><br><code>alignItems</code>属性以与justify-content相同的方式在侧轴方向上将当前行上的弹性元素对齐，默认为stretch。</p><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>stretch<br>(默认)</td><td>弹性元素被<strong>在侧轴方向</strong>被拉伸到与容器相同的高度或宽度。</td><td></td></tr><tr><td>flex-start</td><td>元素<strong>向侧轴起点对齐</strong></td><td></td></tr><tr><td>flex-end</td><td>元素<strong>向侧轴终点对齐</strong></td><td></td></tr><tr><td>center</td><td>元素<strong>在侧轴居中</strong>。如果元素在侧轴上的高度高于其容器，那么在两个方向上溢出距离相同。</td></tr></tbody></table><p>在<code>{justifyContent:&#39;center&#39;,flexDirection:&#39;row&#39;}</code>的情况下：</p><p><img src="/ReactNative/5详解/ReactNative详解布局/alignItems_mainRow_all.png" alt="image-20190522151226308"></p><h2 id="六、alignSelf（此样式设置在子元素上）"><a href="#六、alignSelf（此样式设置在子元素上）" class="headerlink" title="六、alignSelf（此样式设置在子元素上）"></a>六、alignSelf（此样式设置在子元素上）</h2><table><thead><tr><th>类型</th><th>比较</th><th>注意</th></tr></thead><tbody><tr><td>alignItems</td><td>决定了<strong>子元素</strong>在次轴方向的排列方式（<strong>此样式设置在父元素上</strong>）</td><td></td></tr><tr><td>alignSelf</td><td>决定了<strong>该元素</strong>在父元素的次轴方向的排列方式（<strong>此样式设置在子元素上</strong>）</td><td>其值会覆盖父元素的<code>alignItems</code>的值</td></tr></tbody></table><h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><h3 id="1、position-定位"><a href="#1、position-定位" class="headerlink" title="1、position(定位)"></a>1、position(定位)</h3><p><strong>React Native 中，position 默认值为 <code>relative</code>，即相对布局。</strong></p><p>position enum(‘absolute’, ‘relative’)属性设置元素的定位方式，为将要定位的元素定义定位规则。</p><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>relative<br>(默认值)</td><td>生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</td><td></td></tr><tr><td>absolute</td><td>生成绝对定位的元素，元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td></tr></tbody></table><p><strong>默认情况下，使用<code>position: &#39;absolute&#39;</code>后，后面的元素会默认覆盖在前面的元素之上。</strong></p><h3 id="2、边缘与宽高-flex、width-height、top-left-bottom-right"><a href="#2、边缘与宽高-flex、width-height、top-left-bottom-right" class="headerlink" title="2、边缘与宽高(flex、width/height、top/left/bottom/right)"></a>2、边缘与宽高(flex、width/height、top/left/bottom/right)</h3><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>top</td><td>元素的上外边距边界与其包含块上边界之间的偏移</td><td></td></tr><tr><td>left</td><td>元素左外边距边界与其包含块左边界之间的偏移</td><td></td></tr><tr><td>bottom</td><td>元素的下外边距边界与其包含块下边界之间的偏移</td><td></td></tr><tr><td>right</td><td>元素右外边距边界与其包含块右边界之间的偏移</td><td></td></tr><tr><td>width</td><td>元素的宽</td><td></td></tr><tr><td>height</td><td>元素的高</td></tr></tbody></table><h4 id="①、相对布局relative下，flex优先级比width-height高"><a href="#①、相对布局relative下，flex优先级比width-height高" class="headerlink" title="①、相对布局relative下，flex优先级比width/height高"></a>①、相对布局relative下，flex优先级比width/height高</h4><table><thead><tr><th>父组件的前提下</th><th>对子组件进行的设置</th><th>造成子组件结果</th></tr></thead><tbody><tr><td>如果父组件设置了 flex 值</td><td>子组件设置了 flex 值的同时，也设置了高度值</td><td>则高度无效</td></tr><tr><td>如果父组件设置了 flex 值</td><td>子组件没有设置 flex 值，只设置了高度值，</td><td>则子组件高度有效</td></tr></tbody></table><p>参考文章：<a href="https://www.jianshu.com/p/5e35610aeacf" target="_blank" rel="noopener">React-Native 中的基本布局技巧</a></p><h4 id="②、绝对布局absolute下，width-height优先级比flex高"><a href="#②、绝对布局absolute下，width-height优先级比flex高" class="headerlink" title="②、绝对布局absolute下，width/height优先级比flex高"></a>②、绝对布局absolute下，width/height优先级比flex高</h4><h3 id="3、margin-外边距"><a href="#3、margin-外边距" class="headerlink" title="3、margin(外边距)"></a>3、margin(外边距)</h3><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>marginTop</td><td>上外边距</td><td></td></tr><tr><td>marginLeft</td><td>左外边距</td><td></td></tr><tr><td>marginBottom</td><td>下外边距</td><td></td></tr><tr><td>marginRight</td><td>右外边距</td><td></td></tr><tr><td>marginHorizontal</td><td>左右外边距</td><td></td></tr><tr><td>marginVertical</td><td>上下外边距</td></tr></tbody></table><h3 id="4、padding-内边距"><a href="#4、padding-内边距" class="headerlink" title="4、padding(内边距)"></a>4、padding(内边距)</h3><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>paddingTop</td><td>上内边距</td><td></td></tr><tr><td>paddingLeft</td><td>左内边距</td><td></td></tr><tr><td>paddingBottom</td><td>下内边距</td><td></td></tr><tr><td>paddingRight</td><td>右内边距</td><td></td></tr><tr><td>paddingHorizontal</td><td>左右内边距</td><td></td></tr><tr><td>paddingVertical</td><td>上下内边距</td></tr></tbody></table><h3 id="5、视图边框"><a href="#5、视图边框" class="headerlink" title="5、视图边框"></a>5、视图边框</h3><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>borderTopWidth</td><td>顶部边框宽度</td><td></td></tr><tr><td>borderLeftWidth</td><td>左边框宽度</td><td></td></tr><tr><td>borderBottomWidth</td><td>底部边框宽度</td><td></td></tr><tr><td>borderRightWidth</td><td>右边框宽度</td><td></td></tr><tr><td>borderColor</td><td>边框颜色</td><td></td></tr><tr><td>border&lt;Bottom\</td><td>Left\</td><td>Right\</td><td>Top&gt;Color</td><td>各个方向边框的颜色</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第五章：ReactNative详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：ReactNative的继承重写等</title>
      <link href="/ReactNative/6%E8%BF%9B%E9%98%B6/ReactNative%E7%9A%84%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99%E7%AD%89/"/>
      <url>/ReactNative/6%E8%BF%9B%E9%98%B6/ReactNative%E7%9A%84%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative的继承重写等"><a href="#ReactNative的继承重写等" class="headerlink" title="ReactNative的继承重写等"></a>ReactNative的继承重写等</h1><p>参考文章：</p><ul><li><a href="http://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">es6 Class 的继承</a></li></ul><h5 id="1、问：怎么将页面的导航栏设置navigationOptions封装起来，使得子类可以只设置一个navigationOptions中的title值。"><a href="#1、问：怎么将页面的导航栏设置navigationOptions封装起来，使得子类可以只设置一个navigationOptions中的title值。" class="headerlink" title="1、问：怎么将页面的导航栏设置navigationOptions封装起来，使得子类可以只设置一个navigationOptions中的title值。"></a>1、问：怎么将页面的导航栏设置navigationOptions封装起来，使得子类可以只设置一个navigationOptions中的title值。</h5><ul><li><a href="https://blog.csdn.net/kdc18333608478/article/details/52040914" target="_blank" rel="noopener">子类能否重写父类的静态方法(答：不能)</a></li><li><a href="https://blog.csdn.net/lgb1997/article/details/96883870" target="_blank" rel="noopener">在 static方法内部调用外部非静态方法</a></li></ul><h5 id="2、问：怎么在当前页面改变导航栏标题"><a href="#2、问：怎么在当前页面改变导航栏标题" class="headerlink" title="2、问：怎么在当前页面改变导航栏标题"></a>2、问：怎么在当前页面改变导航栏标题</h5><h5 id="3、怎么根据前一个页面的值动态更改导航栏标题"><a href="#3、怎么根据前一个页面的值动态更改导航栏标题" class="headerlink" title="3、怎么根据前一个页面的值动态更改导航栏标题"></a>3、怎么根据前一个页面的值动态更改导航栏标题</h5><p>参考：</p><ul><li><a href="https://blog.csdn.net/ahou2468/article/details/92421745#2.1动态修改标题" target="_blank" rel="noopener">React Native之react-navigation动态修改标题、页面导航等</a></li><li><a href="https://blog.csdn.net/qq_33876553/article/details/79917912" target="_blank" rel="noopener">React Navigation参数传递动态修改navigationOptions-&gt;title</a></li></ul><p>很多用React Native的同学都是前端工程师，在传统的js没有继承的概念。但是在react Native所支持的es6是有继承的，效果也是不错的。</p>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第六章：ReactNative进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：ReactNative的继承重写等</title>
      <link href="/React/6%E8%BF%9B%E9%98%B6/ReactNative%E7%9A%84%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99%E7%AD%89/"/>
      <url>/React/6%E8%BF%9B%E9%98%B6/ReactNative%E7%9A%84%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ReactNative的继承重写等"><a href="#ReactNative的继承重写等" class="headerlink" title="ReactNative的继承重写等"></a>ReactNative的继承重写等</h1><p>参考文章：</p><ul><li><a href="http://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">es6 Class 的继承</a></li></ul><h5 id="1、问：怎么将页面的导航栏设置navigationOptions封装起来，使得子类可以只设置一个navigationOptions中的title值。"><a href="#1、问：怎么将页面的导航栏设置navigationOptions封装起来，使得子类可以只设置一个navigationOptions中的title值。" class="headerlink" title="1、问：怎么将页面的导航栏设置navigationOptions封装起来，使得子类可以只设置一个navigationOptions中的title值。"></a>1、问：怎么将页面的导航栏设置navigationOptions封装起来，使得子类可以只设置一个navigationOptions中的title值。</h5><ul><li><a href="https://blog.csdn.net/kdc18333608478/article/details/52040914" target="_blank" rel="noopener">子类能否重写父类的静态方法(答：不能)</a></li><li><a href="https://blog.csdn.net/lgb1997/article/details/96883870" target="_blank" rel="noopener">在 static方法内部调用外部非静态方法</a></li></ul><h5 id="2、问：怎么在当前页面改变导航栏标题"><a href="#2、问：怎么在当前页面改变导航栏标题" class="headerlink" title="2、问：怎么在当前页面改变导航栏标题"></a>2、问：怎么在当前页面改变导航栏标题</h5><h5 id="3、怎么根据前一个页面的值动态更改导航栏标题"><a href="#3、怎么根据前一个页面的值动态更改导航栏标题" class="headerlink" title="3、怎么根据前一个页面的值动态更改导航栏标题"></a>3、怎么根据前一个页面的值动态更改导航栏标题</h5><p>参考：</p><ul><li><a href="https://blog.csdn.net/ahou2468/article/details/92421745#2.1动态修改标题" target="_blank" rel="noopener">React Native之react-navigation动态修改标题、页面导航等</a></li><li><a href="https://blog.csdn.net/qq_33876553/article/details/79917912" target="_blank" rel="noopener">React Navigation参数传递动态修改navigationOptions-&gt;title</a></li></ul><p>很多用React Native的同学都是前端工程师，在传统的js没有继承的概念。但是在react Native所支持的es6是有继承的，效果也是不错的。</p>]]></content>
      
      
      <categories>
          
          <category> ReactNative </category>
          
          <category> 第六章：ReactNative进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2节：Hexo的进阶</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Hexo/2Hexo%E7%9A%84%E8%BF%9B%E9%98%B6/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Hexo/2Hexo%E7%9A%84%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、资源文件的显示"><a href="#一、资源文件的显示" class="headerlink" title="一、资源文件的显示"></a>一、资源文件的显示</h2><p>创建md的同名文件夹后，资源文件的路径不能写为<code>./xxx/1.jpg</code>(虽然markdown有效)，只能为<code>xxx/1.jpg</code>。</p><p>其他参考：<a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">hexo官网：资源文件夹</a></p><h2 id="二、hexo链接的持久化"><a href="#二、hexo链接的持久化" class="headerlink" title="二、hexo链接的持久化"></a>二、hexo链接的持久化</h2><p>参考文档：</p><p>永久链接（Permalinks）的官网文档：<a href="https://hexo.io/zh-cn/docs/permalinks.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/permalinks.html</a></p><p>hexo链接持久化终极解决之道：<a href="https://blog.csdn.net/yanzi1225627/article/details/77761488?utm_source=blogxgwz4" target="_blank" rel="noopener">https://blog.csdn.net/yanzi1225627/article/details/77761488?utm_source=blogxgwz4</a></p><h3 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h3><p>大家知道hexo默认的链接是<a href="http://xxx.yy.com/2018/12/14/hello-world" target="_blank" rel="noopener">http://xxx.yy.com/2018/12/14/hello-world</a> 这种类型的，这源于站点目录下的配置<strong>_config.yml</strong>里的配置:permalink: :year/:month/:day/:title/，所以，我们当我们在浏览器中浏览的时候，其地址实际上为如上所述。因而我们在处理链接跳转的时候，就也得跟着加上这部分前缀了。</p><h3 id="2、链接优化"><a href="#2、链接优化" class="headerlink" title="2、链接优化"></a>2、链接优化</h3><p>由于上诉中的日期前缀部分通常容易变化，所以为了我们的链接持久化，我们需要将其去掉，即我们在<strong>_config.yml</strong>中做如下修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> permalink: :year/:month/:day/:title/</span></span><br><span class="line">permalink: :title/</span><br></pre></td></tr></table></figure><p>此时网页链接写法</p><p>设文件《1Hexo的使用.md》和《2Hexo的进阶.md》处于同级目录下，则</p><p>当你在《1Hexo的使用.md》的时候想要链接进《2Hexo的进阶.md》的时候，</p><p>平时在markdown中的写法：<code>./2Hexo的进阶.md</code></p><p>现在在Hexo网页中的写法1：<code>../2Hexo的进阶</code> </p><p>*<em>现在在Hexo网页中的写法2：<code>/文档管理/Hexo/2Hexo的进阶</code>（因为根目录为/）</em></p><p>附：如果你想保持.md后缀，可将上诉改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> permalink: :year/:month/:day/:title/</span></span><br><span class="line">permalink: :title/.md</span><br></pre></td></tr></table></figure><h2 id="三、修改博客文章顺序-解决置顶问题"><a href="#三、修改博客文章顺序-解决置顶问题" class="headerlink" title="三、修改博客文章顺序/解决置顶问题"></a>三、修改博客文章顺序/解决置顶问题</h2><p>Hexo默认只提供了按发布日期的排序。</p><p>原理：<strong>在Hexo生成首页HTML时，将top值高的文章排在前面，达到置顶功能</strong>。</p><p>怎么置顶：每篇文章增加一个属性top，普通文章设置值为1，置顶文章设置为1以上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo增加置顶属性</span><br><span class="line">date: 2018-09-14 14:57:57</span><br><span class="line">top: 1</span><br><span class="line">tags:</span><br><span class="line">  - 博客</span><br><span class="line">  - Hexo</span><br><span class="line">  - 置顶</span><br></pre></td></tr></table></figure><p>生成首页的是扩展插件node_modules/hexo-generator-index中。所以修改Hexo文件夹下的<code>node_modules/hexo-generator-index/lib/generator.js</code>，在生成文章之前进行文章top值排序。</p><p>最终的代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">'use strict';</span><br><span class="line"></span><br><span class="line">var pagination = require('hexo-pagination');</span><br><span class="line"></span><br><span class="line">module.exports = function(locals) &#123;</span><br><span class="line">  var config = this.config;</span><br><span class="line">  var posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line"></span><br><span class="line">  // &gt;&gt;&gt;&gt;&gt;&gt;&gt; 添加以下内容，实现置顶功能 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">  posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">    if(a.top &amp;&amp; b.top) &#123;</span><br><span class="line">        if(a.top == b.top) return b.date - a.date;</span><br><span class="line">        else return b.top - a.top;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(a.top &amp;&amp; !b.top) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else return b.date - a.date;</span><br><span class="line">  &#125;);</span><br><span class="line">  // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 添加以上内容，实现置顶功能 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">  </span><br><span class="line">  var paginationDir = config.pagination_dir || 'page';</span><br><span class="line">  var path = config.index_generator.path || '';</span><br><span class="line"></span><br><span class="line">  return pagination(path, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: ['index', 'archive'],</span><br><span class="line">    format: paginationDir + '/%d/',</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><p>其他参考文章：<a href="https://www.jianshu.com/p/28fcf40f2ea7" target="_blank" rel="noopener">hexo+github博客搭建，hexo目录，hexo设置详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 文档管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：使用Hexo创建博客</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Hexo/1Hexo%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Hexo/1Hexo%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官网 https://hexo.io/zh-cn/docs/index.html</a></p></li><li><p><a href="https://www.cnblogs.com/MuYunyun/p/5927491.html" target="_blank" rel="noopener">基于hexo+github搭建一个独立博客</a></p></li></ul><h2 id="前言：新电脑上的使用"><a href="#前言：新电脑上的使用" class="headerlink" title="前言：新电脑上的使用"></a>前言：新电脑上的使用</h2><p>1、终端执行 <code>hexo -v</code>，检查是否安装过hexo，且安装成功</p><p>如果已安装 hexo，则终端执行 <code>hexo -v</code>能够显示结果</p><blockquote><p><img src="/实用工具/Hexo/1Hexo的使用/1Hexo%E7%9A%84%E4%BD%BF%E7%94%A8/image-20230208191318675.png" alt="image-20230208191318675" style="zoom:33%;"></p></blockquote><p>2、node建议安装 v12.19.0版本，否则会出现如下常见错误1</p><p>2、查看项目目录下是否已存在由在该目录下执行<code>npm install</code>命令后生成的 node_modules 文件夹</p><p>如果不存在，则无法执行，请通过以下命令在该项目目录下生成 node_modules 文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 到项目目录</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>若已存在，则通过以下命令，即可生成本地网络路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 到项目目录</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h3 id="常见错误1、hexo部署到github时，提示typeError-ERR-INVALID-ARG-TYPE-The-“mode“-argument-must-be-integer-Receive"><a href="#常见错误1、hexo部署到github时，提示typeError-ERR-INVALID-ARG-TYPE-The-“mode“-argument-must-be-integer-Receive" class="headerlink" title="常见错误1、hexo部署到github时，提示typeError [ERR_INVALID_ARG_TYPE] The “mode“ argument must be integer. Receive"></a>常见错误1、hexo部署到github时，提示typeError [ERR_INVALID_ARG_TYPE] The “mode“ argument must be integer. Receive</h3><p>原因：<a href="https://so.csdn.net/so/search?q=node&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">node</a>版本过高导致的。</p><p>解决方法：使用 12.19.0 版本的时候，可以部署成功。版本的安装命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n v12.19.0</span><br></pre></td></tr></table></figure><p>PS：<a href="../../node/node.md">node指定版本的安装、切换、删除</a> 请进入本博客中的 node 查看</p><p>参考文章：<a href="https://www.cnblogs.com/bingshanyishu/p/15956569.html" target="_blank" rel="noopener">hexo部署到github时，提示typeError ERR_INVALID_ARG_TYPE The “mode“ argument must be integer. Receive</a></p><h2 id="一、主要命令"><a href="#一、主要命令" class="headerlink" title="一、主要命令"></a>一、主要命令</h2><table><thead><tr><th>操作</th><th>命令/配置</th><th>备注</th></tr></thead><tbody><tr><td>初始化</td><td><code>hexo init</code></td><td></td></tr><tr><td>清除缓存文件和已生成的静态文件</td><td><code>hexo clean</code></td><td></td></tr><tr><td>生成缓存(db.json)和静态文件(public)</td><td><code>hexo generate</code>或 <code>hexo g</code></td><td></td></tr><tr><td>本地预览查看</td><td><code>hexo s</code></td><td>开启hexo服务器，用于本地查看</td></tr><tr><td>发布到远程Step1<br><em>配置发布地址</em></td><td>在_config.yml中完善，详情看下</td><td></td></tr><tr><td>发布到远程Step2<br><em>重新部署到服务器</em></td><td><code>hexo deploy</code> 或<code>hexo d</code></td><td>附：<code>hexo d</code>到Github上的也只是html文档，不是<code>.md</code>格式的文档。</td></tr></tbody></table><p>上述配置发布地址(在_config.yml中完善)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: https://github.com/dvlproad/dvlproad.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><h2 id="二、常用的创建"><a href="#二、常用的创建" class="headerlink" title="二、常用的创建"></a>二、常用的创建</h2><table><thead><tr><th>操作</th><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>创建md博文</td><td><code>hexo n &quot;xxxx&quot;</code></td><td></td></tr><tr><td>创建分类</td><td><code>hexo new page categories</code></td><td></td></tr><tr><td>创建关于</td><td><code>hexo new page about</code></td></tr></tbody></table><h2 id="三、常用的主题"><a href="#三、常用的主题" class="headerlink" title="三、常用的主题"></a>三、常用的主题</h2><p>Hexo主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p><p>目前尝试过的主题有：<a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/README.md" target="_blank" rel="noopener">BlueLake</a>、</p><p><a href="../2Hexo进阶">点击此处，进入下一节的正式学习 &gt;</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 文档管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo前言</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Hexo/README/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Hexo/README/</url>
      
        <content type="html"><![CDATA[<p>本章介绍</p><ul><li>①Hexo的使用</li><li>②Hexo的进阶</li></ul><hr><p><a href="../1Hexo的使用">点击此处，进入本章第1节的正式学习 &gt;</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 文档管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：阿里云服务器ECS域名绑定</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="阿里云服务器ECS域名绑定"><a href="#阿里云服务器ECS域名绑定" class="headerlink" title="阿里云服务器ECS域名绑定"></a>阿里云服务器ECS域名绑定</h1><h2 id="一、注册域名"><a href="#一、注册域名" class="headerlink" title="一、注册域名"></a>一、注册域名</h2><p>1、几个阿里云域名注册的网址</p><ul><li><p>域名：<a href="https://wanwang.aliyun.com" target="_blank" rel="noopener">https://wanwang.aliyun.com</a></p></li><li><p>域名特惠专场：<a href="https://www.aliyun.com/activity/daily/yumingtehui" target="_blank" rel="noopener">https://www.aliyun.com/activity/daily/yumingtehui</a></p></li><li>一元域名：<a href="https://wanwang.aliyun.com/domain/1yuan" target="_blank" rel="noopener">https://wanwang.aliyun.com/domain/1yuan</a></li></ul><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS域名绑定/image-20201119104549954.png" alt="image-20201119104549954"></p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS域名绑定/image-20201119104142314.png" alt="image-20201119104142314"></p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS域名绑定/image-20201119104236120.png" alt="image-20201119104236120"></p><h2 id="二、域名解析-绑定"><a href="#二、域名解析-绑定" class="headerlink" title="二、域名解析/绑定"></a>二、域名解析/绑定</h2><p>其他参考：<a href="https://blog.csdn.net/shengqianfeng/article/details/77587293#comments" target="_blank" rel="noopener">阿里云域名和ip绑定步骤</a></p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS域名绑定/image-20201119104809178.png" alt="image-20201119104809178"></p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS域名绑定/image-20201119105543285.png" alt="image-20201119105543285"></p><p>之后，通过在浏览器地址栏输入 goapi.work，其都会自动帮我们加上www前缀。</p><p><strong>同时，即使IP地址的格式中带需要有端口，如：202.106.0.20:8080，也只添加202.106.0.20即可。</strong></p><p>访问的时候，因为我们的ip地址需要带端口，所以访问的时候需要多填个端口。如 <a href="http://www.goapi.work:3000" target="_blank" rel="noopener">http://www.goapi.work:3000</a> 访问</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS域名绑定/image-20201119110133082.png" alt="image-20201119110133082"></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>至此，利用阿里云服务器ECS的使用介绍结束。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 阿里云oss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：GitBook的使用</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/GitBook/1GitBook%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/GitBook/1GitBook%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/lu_embedded/article/details/81100704" target="_blank" rel="noopener">GitBook 从懵逼到入门</a></li></ul><h2 id="一、主要命令"><a href="#一、主要命令" class="headerlink" title="一、主要命令"></a>一、主要命令</h2><table><thead><tr><th>操作</th><th>命令/配置</th><th>备注</th></tr></thead><tbody><tr><td>初始化/生成书籍目录</td><td><code>gitbook init</code></td><td>执行完后，你会看到多了两个文件：README.md 和 SUMMARY.md</td></tr><tr><td>本地预览查看</td><td><code>gitbook serve</code></td><td>开启gitbook服务器，用于本地查看。其包含了也包含在 <code>gitbook build</code>命令</td></tr><tr><td>构建书籍</td><td><code>gitbook build</code></td><td>默认将生成的静态网站输出到 _book 目录</td></tr></tbody></table><p>编辑 SUMMARY.md 文件的示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 目录</span></span><br><span class="line"></span><br><span class="line">* [前言](README.md)</span><br><span class="line">* [第一章](Chapter1/README.md)</span><br><span class="line">  * [第1节：衣](Chapter1/衣.md)</span><br><span class="line">  * [第2节：食](Chapter1/食.md)</span><br><span class="line">  * [第3节：住](Chapter1/住.md)</span><br><span class="line">  * [第4节：行](Chapter1/行.md)</span><br><span class="line">* [第二章](Chapter2/README.md)</span><br><span class="line">* [第三章](Chapter3/README.md)</span><br><span class="line">* [第四章](Chapter4/README.md)</span><br></pre></td></tr></table></figure><h2 id="二、常用的创建"><a href="#二、常用的创建" class="headerlink" title="二、常用的创建"></a>二、常用的创建</h2><table><thead><tr><th>操作</th><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>创建md博文</td><td>新建文件</td><td></td></tr><tr><td>创建分类</td><td>新建文件夹</td><td></td></tr><tr><td>创建关于</td><td>新建文件夹</td></tr></tbody></table><h2 id="三、常用的主题"><a href="#三、常用的主题" class="headerlink" title="三、常用的主题"></a>三、常用的主题</h2><p><img src="/实用工具/GitBook/1GitBook的使用/image-20200927023836954.png" alt="image-20200927023836954"></p><p><img src="/实用工具/GitBook/1GitBook的使用/image-20200927024212824.png" alt="image-20200927024212824"></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> GitBook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 文档管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitBook前言</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/GitBook/README/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/GitBook/README/</url>
      
        <content type="html"><![CDATA[<p>本章介绍</p><ul><li>①GitBook的使用</li><li>②GitBook的进阶</li></ul><hr><p><a href="../1GitBook的使用">点击此处，进入本章第1节的正式学习 &gt;</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 文档管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E9%98%BF%E9%87%8C%E4%BA%91/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E9%98%BF%E9%87%8C%E4%BA%91/%E9%98%BF%E9%87%8C%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><p>个人阿里云域名：<a href="https://devbook.site" target="_blank" rel="noopener">https://devbook.site</a></p><p>查看个人阿里云域名请进入<strong>阿里云域名控制台</strong>查看</p><ul><li><a href="https://dc.console.aliyun.com/" target="_blank" rel="noopener">阿里云域名控制台</a></li><li><a href="https://dc.console.aliyun.com/next/index#/domain/list/all-domain" target="_blank" rel="noopener">阿里云域名控制台-所有域名</a></li></ul><p>更多阿里云相关帮助请查看：<a href="https://help.aliyun.com/knowledge_detail/35815.html?spm=a2c4g.11174283.6.605.65bac8ca7yCwU1" target="_blank" rel="noopener">阿里云域名管理帮助</a></p><h3 id="Gitbook绑定域名"><a href="#Gitbook绑定域名" class="headerlink" title="Gitbook绑定域名"></a>Gitbook绑定域名</h3><p>请登录你个人的<a href="https://app.gitbook.com/" target="_blank" rel="noopener">Gitbook</a>账号，并按照<a href="http://www.chengweiyang.cn/gitbook/gitbook.com/config/domain.html" target="_blank" rel="noopener">官网：Gitbook绑定域名</a>上的操作进行Gitbook的域名绑定。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文档管理</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/README/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/README/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要用新的文档创作平台"><a href="#为什么要用新的文档创作平台" class="headerlink" title="为什么要用新的文档创作平台"></a>为什么要用新的文档创作平台</h2><p>​    通常，我们最开始学习和使用的办公软件就是 Word、Excel 和 PowerPoint。这里不是说它们已经过时了，不是说 GitBook 能够替代它们。相反，Microsoft 的办公软件很优秀并且经受了时间的考验，但是正因为它功能丰富，导致稍显臃肿（二八定律：80%的时间里我们只会只用20%的功能）。</p><p>​    所以，如果你和我一样，不满足于传统的写作方式，正在寻找一种令人愉悦的写作方式，那么可以尝试以下几种文档创作方式！</p><h2 id="一、gitbook与hexo的比较"><a href="#一、gitbook与hexo的比较" class="headerlink" title="一、gitbook与hexo的比较"></a>一、gitbook与hexo的比较</h2><table><thead><tr><th></th><th>gitbook</th><th>hexo+GithubPage</th></tr></thead><tbody><tr><td>网址</td><td><a href="https://www.gitbook.com/?t=2" target="_blank" rel="noopener">gitbook官网</a></td><td><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官网</a></td></tr><tr><td>常用于</td><td>书籍文档类</td><td>博客文档类</td></tr><tr><td>参考案例</td><td><a href="https://mta.qq.com/docs/" target="_blank" rel="noopener">腾讯移动分析</a></td><td><a href="https://tech.meituan.com" target="_blank" rel="noopener">美团技术团队博客</a> 只是猜测</td></tr><tr><td>个人实践</td><td><a href="https://devbook.site" target="_blank" rel="noopener">https://devbook.site</a></td><td><a href="https://dvlproad.github.io">https://dvlproad.github.io</a></td></tr><tr><td>定制型</td><td>相对固定</td><td>根据设置的不同<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题</a>，显示不同排版效果</td></tr><tr><td>优点</td><td>以书籍形态，层次顺序明确；<br>非常适合知识架构的分类整理及递进。</td><td>虽不是书籍类，但也有层次；<br>定制型更强。</td></tr><tr><td>缺点</td><td>官网非翻墙使用不了<br>所以需要申请域名来映射使用</td><td></td></tr><tr><td>访问限制</td><td>暂未了解，目前都是无差别访问</td><td>暂未了解，目前都是无差别访问</td></tr><tr><td>文档存放</td><td>GitHub</td><td>GitHub、Gitlab、SVN等都可以</td></tr><tr><td>文档编写</td><td>Markdown本地编写</td><td>Markdown本地编写</td></tr><tr><td>本地预览</td><td>执行<code>gitbook seve</code>即可预览</td><td>执行<code>hexo seve</code>即可预览</td></tr><tr><td>远程生效</td><td>更新GitHub就可以</td><td>执行<code>hexo d</code>进行发布即可</td></tr></tbody></table><h2 id="附：几个类似GitBook的在线文档创作平台"><a href="#附：几个类似GitBook的在线文档创作平台" class="headerlink" title="附：几个类似GitBook的在线文档创作平台"></a>附：几个类似GitBook的在线文档创作平台</h2><p>参考：<a href="https://weibo.com/ttarticle/p/show?id=2309404295034223596106&amp;sudaref=www.baidu.com&amp;display=0&amp;retcode=6102" target="_blank" rel="noopener">几个类似GitBook的在线文档创作平台</a></p><table><thead><tr><th>在线文档创作平台</th><th>为免费用户提供</th><th>官网地址</th><th>文档示例</th></tr></thead><tbody><tr><td><strong>GitBook</strong>(首推)<br><img src="https://r.sinaimg.cn/large/article/d9a1e0d1189c72b8a25f288be301aea2" alt="img"></td><td>① 一个公共空间<br>②一个私有空间（支持两个用户的团队）<br>③ 支持自定义域名</td><td><a href="https://www.gitbook.com/" target="_blank" rel="noopener">https://www.gitbook.com/</a></td><td><a href="https://amazing-apps.gitbooks.io/windows-apps-that-amaze-us/zh-CN/" target="_blank" rel="noopener">https://amazing-apps.gitbooks.io/windows-apps-that-amaze-us/zh-CN/</a></td></tr><tr><td><strong>看云</strong>(国内最靠谱的选择)<br><img src="https://r.sinaimg.cn/large/article/152fb6eeafff0fbc98b6ffe47f578559" alt="img"></td><td>①不限量公开文档<br>②0个私有文档<br>③完整文档功能</td><td><a href="https://www.kancloud.cn/" target="_blank" rel="noopener">https://www.kancloud.cn/</a></td><td><a href="https://www.kancloud.cn/manual/thinkphp/1678" target="_blank" rel="noopener">https://www.kancloud.cn/manual/thinkphp/1678</a></td></tr><tr><td><strong>北半球</strong><br><img src="https://r.sinaimg.cn/large/article/fd629460e5819a3d460d9c0ff03b4167" alt="img"></td><td>感觉规模并不大，所幸这是一个开源项目，你可以自行搭建属于自己的北半球</td><td><a href="https://www.beibq.cn/" target="_blank" rel="noopener">https://www.beibq.cn/</a></td><td><a href="https://www.beibq.cn/book/beibq_guide" target="_blank" rel="noopener">https://www.beibq.cn/book/beibq_guide</a></td></tr></tbody></table><p>总结：</p><p>如果希望托管在平台，请根据项目数量选择使用GitBook或者看云；</p><p>如果自建，则只有GitBook和北半球提供了源代码，供用户自行搭建。</p><hr><p><a href="/文档管理/Hexo/1Hexo的使用">点击此处，进入本章第1节的正式学习 &gt;</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 文档管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Charles</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Charles/Charles/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Charles/Charles/</url>
      
        <content type="html"><![CDATA[<h2 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h2><ul><li><a href="https://www.jianshu.com/p/4635aa405568" target="_blank" rel="noopener">解决Charles https抓包显示<unknown></unknown></a></li></ul><ul><li><a href="http://www.shanhuxueyuan.com/news/detail/21.html" target="_blank" rel="noopener"><strong>利用Charles进行浏览器、APP数据抓包</strong></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qrencode</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/qrencode/qrencode/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/qrencode/qrencode/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="qrencode"><a href="#qrencode" class="headerlink" title="qrencode"></a>qrencode</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>libqrencode是一个C语言编写的用来生成二维条形码的库，生成的二维条形码可以通过手机的CCD摄像机轻易的扫描出来。</p><h2 id="一、qrencode的安装"><a href="#一、qrencode的安装" class="headerlink" title="一、qrencode的安装"></a>一、qrencode的安装</h2><p>qrencode编译需要libpng库，而libpng库依赖zlib库，所以得依次安装zlib、libpng、qrencdoe。</p><p>1、从<a href="http://zlib.net/下载zlib库" target="_blank" rel="noopener">http://zlib.net/下载zlib库</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入文件夹</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>2、从<a href="http://www.libpng.org/pub/png/libpng.html下载libpng" target="_blank" rel="noopener">http://www.libpng.org/pub/png/libpng.html下载libpng</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入文件夹</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>3、从<a href="http://fukuchi.org/works/qrencode/" target="_blank" rel="noopener">http://fukuchi.org/works/qrencode/</a> 下载qrencode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入文件夹</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="/实用工具/qrencode/qrencode/zlib.png" alt="zlib下载"></p><p><img src="/实用工具/qrencode/qrencode/zlib2安装.png" alt="zlib安装"></p><h2 id="二、使用qrencode命令生成二维码"><a href="#二、使用qrencode命令生成二维码" class="headerlink" title="二、使用qrencode命令生成二维码"></a>二、使用qrencode命令生成二维码</h2><p>使用举例，在当前目录下，生成一张内容为<a href="https://baidu.com，命名为baiduhome_qrcode.jpg的二维码图片。" target="_blank" rel="noopener">https://baidu.com，命名为baiduhome_qrcode.jpg的二维码图片。</a></p><p>则在终端执行的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qrencode -o ./baiduhome_qrcode.jpg &quot;https://baidu.com&quot;</span><br></pre></td></tr></table></figure><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>至此，在终端使用qrencode命令生成二维码的介绍结束。感谢阅读。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：yapi在云服务器ECS上的使用-阿里云</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8-%E9%98%BF%E9%87%8C%E4%BA%91/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/yapi/yapi%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8-%E9%98%BF%E9%87%8C%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="yapi在云服务器ECS上的使用-阿里云"><a href="#yapi在云服务器ECS上的使用-阿里云" class="headerlink" title="yapi在云服务器ECS上的使用-阿里云"></a>yapi在云服务器ECS上的使用-阿里云</h1><h2 id="一、阿里云使用之yapi的安装与启动"><a href="#一、阿里云使用之yapi的安装与启动" class="headerlink" title="一、阿里云使用之yapi的安装与启动"></a>一、阿里云使用之yapi的安装与启动</h2><h3 id="1、阿里云使用之yapi的安装"><a href="#1、阿里云使用之yapi的安装" class="headerlink" title="1、阿里云使用之yapi的安装"></a>1、阿里云使用之yapi的安装</h3><p>阿里云使用之yapi的安装，由于我们使用的云服务器ECS是CentOS系统，所以详细的安装方法，请进入<a href="./yapi的安装.md">前文中的yapi的安装文档</a></p><h3 id="2、阿里云使用之yapi的启动"><a href="#2、阿里云使用之yapi的启动" class="headerlink" title="2、阿里云使用之yapi的启动"></a>2、阿里云使用之yapi的启动</h3><p>因为yapi是使用9090端口，所以，我们需要先进入安全组，添加9090端口配置</p><p><img src="/实用工具/yapi/yapi在云服务器ECS上的使用-阿里云/ecs_use_1safe_1.png" alt="ecs_use_1safe_1" style="zoom: 67%;"></p><p>添加9090端口</p><p><img src="/实用工具/yapi/yapi在云服务器ECS上的使用-阿里云/ecs_use_1safe_2.png" alt="ecs_use_1safe_2"></p><p>添加后，我们执行<code>yapi server</code>，就可以通过 ip:9090 来访问ypai了（注意要先开启yapi server不然也是无法进入的）。访问效果如图：</p><p><img src="/实用工具/yapi/yapi在云服务器ECS上的使用-阿里云/image-yapi-deploy.png" alt="yapi平台部署" style="zoom:50%;"></p><p><img src="/实用工具/yapi/yapi在云服务器ECS上的使用-阿里云/image-20201118135248693.png" alt="image-20201118135248693"></p><blockquote><p>初始化管理员账号成功,账号名：”<a href="mailto:admin@admin.com" target="_blank" rel="noopener">admin@admin.com</a>“，密码：”ymfe.org”</p></blockquote><p><img src="/实用工具/yapi/yapi在云服务器ECS上的使用-阿里云/image-20201118135556799.png" alt="image-20201118135556799"></p><p><img src="/实用工具/yapi/yapi在云服务器ECS上的使用-阿里云/image-yapi-home.png" alt="启动后的yapi首页" style="zoom:50%;"></p><h2 id="二、保持yapi的一直运行-如何让node-app的程序一直运行？"><a href="#二、保持yapi的一直运行-如何让node-app的程序一直运行？" class="headerlink" title="二、保持yapi的一直运行/如何让node app的程序一直运行？"></a>二、保持yapi的一直运行/如何让node app的程序一直运行？</h2><h3 id="1、发现问题：yapi在启动后如果关闭窗口链接，服务也会关闭。"><a href="#1、发现问题：yapi在启动后如果关闭窗口链接，服务也会关闭。" class="headerlink" title="1、发现问题：yapi在启动后如果关闭窗口链接，服务也会关闭。"></a>1、发现问题：yapi在启动后如果关闭窗口链接，服务也会关闭。</h3><p>我们在浏览器中关闭之前成功远程连接，并操作yapi的阿里云网页。刷新界面，发现访问不了了。</p><p><img src="/实用工具/yapi/yapi在云服务器ECS上的使用-阿里云/image-20201118214600778.png" alt="image-20201118214600778" style="zoom: 33%;"></p><h3 id="2、解决问题："><a href="#2、解决问题：" class="headerlink" title="2、解决问题："></a>2、解决问题：</h3><p>既然关掉终端，程序也关闭了，那如何让node app的程序一直运行？</p><h4 id="2-1、使用forever方式"><a href="#2-1、使用forever方式" class="headerlink" title="2.1、使用forever方式"></a>2.1、使用forever方式</h4><p>1.判断是否安装了forever</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 终端执行</span></span><br><span class="line">forever</span><br></pre></td></tr></table></figure><p>2.如果未安装forever，则执行如下命令安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g forever</span><br></pre></td></tr></table></figure><p><img src="/实用工具/yapi/yapi在云服务器ECS上的使用-阿里云/image-20201118214438568.png" alt="image-20201118214438568"></p><p>3.使用forever开启nodejs程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forever start xxx.js</span><br><span class="line">forever start vendors/server/app.js</span><br></pre></td></tr></table></figure><p><img src="/实用工具/yapi/yapi在云服务器ECS上的使用-阿里云/image-20201118215600200.png" alt="image-20201118215600200"></p><p>如果你需要用npm start来运行你的程序，则用命令<br>forever start -c “npm start” 路径</p><p>4.如果不需要一直运行nodejs程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forever stop xxx.js</span><br></pre></td></tr></table></figure><p><img src="/实用工具/yapi/yapi在云服务器ECS上的使用-阿里云/image-20201120104129192.png" alt="image-20201120104129192"></p><p>forever 使用方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 作为前台任务启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> forever server.js</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 作为服务进程启动 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> forever start app.js</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止服务进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> forever stop Id</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> forever restart Id</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 监视当前目录的文件变动，一有变动就重启</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> forever -w server.js</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -m 参数指定最多重启次数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> forever -m 5 server.js </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> forever list</span></span><br></pre></td></tr></table></figure><h4 id="2-2、使用crontab方式"><a href="#2-2、使用crontab方式" class="headerlink" title="2.2、使用crontab方式"></a>2.2、使用crontab方式</h4><p>目前自己未实践过。</p><h2 id="三、云服务器重启的时候的yapi各项服务处理"><a href="#三、云服务器重启的时候的yapi各项服务处理" class="headerlink" title="三、云服务器重启的时候的yapi各项服务处理"></a>三、云服务器重启的时候的yapi各项服务处理</h2><p>mongoDB 和 yapi 都会断掉，需要重新启动。请按顺序启动。</p><p>1、重启 MongoDB，并后台运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd CQApp-api-mongodb/</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">mongod --dbpath ./data --logpath ./log/mongo.log --fork</span><br></pre></td></tr></table></figure><p><img src="/实用工具/yapi/yapi在云服务器ECS上的使用-阿里云/image-20201120103328979.png" alt="image-20201120103328979"></p><p>2、重启yapi，并始终后台运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原本是 node vendors/server/app.js</span></span><br><span class="line">forever start vendors/server/app.js</span><br></pre></td></tr></table></figure><p>初始化管理员账号成功,账号名：”<a href="mailto:admin@admin.com" target="_blank" rel="noopener">admin@admin.com</a>“，密码：”ymfe.org”</p><h2 id="四、提交云服务器代码"><a href="#四、提交云服务器代码" class="headerlink" title="四、提交云服务器代码"></a>四、提交云服务器代码</h2><p>想看本网站中的<a href="../../代码管理/Git代码同步">Git代码同步</a></p><p>大概步骤，摘要如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd CQApp-api-mongodb/</span><br><span class="line">git pull origin master</span><br><span class="line">git add .</span><br><span class="line">git commit -m "add api cardlist"</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h1 id="node-33-DEP0066-DeprecationWarning-OutgoingMessage-prototype-headers-is-deprecated"><a href="#node-33-DEP0066-DeprecationWarning-OutgoingMessage-prototype-headers-is-deprecated" class="headerlink" title="(node:33) [DEP0066] DeprecationWarning: OutgoingMessage.prototype._headers is deprecated"></a>(node:33) [DEP0066] DeprecationWarning: OutgoingMessage.prototype._headers is deprecated</h1><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>至此，利用yapi在云服务器ECS上的使用-阿里云介绍结束。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：阿里云oss上传</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E9%98%BF%E9%87%8C%E4%BA%91oss/%E9%98%BF%E9%87%8C%E4%BA%91oss1%E4%B8%8A%E4%BC%A0/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E9%98%BF%E9%87%8C%E4%BA%91oss/%E9%98%BF%E9%87%8C%E4%BA%91oss1%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="阿里云oss上传"><a href="#阿里云oss上传" class="headerlink" title="阿里云oss上传"></a>阿里云oss上传</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要使用阿里云进行OSS的任意服务，如上传，您都必须先开通阿里云OSS服务。</p><p>详细的<em>阿里云对象存储OSS的帮助文档</em>请通过阿里云帮助主页<a href="https://help.aliyun.com/，进入[对象存储OSS帮助页](https://help.aliyun.com/product/31815.html?spm=a2c4g.11186623.6.540.4ef91c62fkTyj7)进行查看。从[开始使用阿里云OSS](https://help.aliyun.com/document_detail/31883.html?spm=a2c4g.11186623.6.608.3f6440afB2c3Po)开始阅读。" target="_blank" rel="noopener">https://help.aliyun.com/，进入[对象存储OSS帮助页](https://help.aliyun.com/product/31815.html?spm=a2c4g.11186623.6.540.4ef91c62fkTyj7)进行查看。从[开始使用阿里云OSS](https://help.aliyun.com/document_detail/31883.html?spm=a2c4g.11186623.6.608.3f6440afB2c3Po)开始阅读。</a></p><p>整体的操作步骤大概如目录描述如下：</p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil0.png" alt="image-20200917172847512" style="zoom:33%;"></p><h2 id="一、阿里云OSS服务的开通"><a href="#一、阿里云OSS服务的开通" class="headerlink" title="一、阿里云OSS服务的开通"></a>一、阿里云OSS服务的开通</h2><p>详细的创建过程请看帮助文档<a href="https://help.aliyun.com/document_detail/31884.html?spm=a2c4g.11186623.2.17.27271c62WFMFhx#task-njz-hf4-tdb" target="_blank" rel="noopener">开通OSS服务</a></p><p>大概的意思为：</p><ol><li><p>登录<a href="https://www.aliyun.com/" target="_blank" rel="noopener">阿里云官网</a>。</p></li><li><p>将鼠标移至<strong>产品</strong>，单击<strong>对象存储 OSS</strong>，打开 <strong>OSS 产品详情</strong>页面。</p></li><li><p>在 <a href="https://www.aliyun.com/product/oss" target="_blank" rel="noopener">OSS 产品详情页</a>，单击<strong>立即开通</strong>。</p></li><li><p>开通服务后，在 <strong>OSS 产品详情</strong>页单击<strong>管理控制台</strong>直接进入 OSS 管理控制台界面。</p><p>您也可以单击位于官网首页右上方菜单栏的<strong>控制台</strong>，进入阿里云管理控制台首页，然后单击左侧的<strong>对象存储 OSS</strong> 菜单进入 OSS 管理控制台界面。</p></li></ol><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil1.png" alt="ossutil" style="zoom:25%;"></p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil2.png" alt="image-20200917172348782" style="zoom:33%;">  <img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil3.png" alt="image-20200917172605845" style="zoom:33%;"></p><h2 id="二、使用OSS管理控制台创建用于文件存储的存储空间"><a href="#二、使用OSS管理控制台创建用于文件存储的存储空间" class="headerlink" title="二、使用OSS管理控制台创建用于文件存储的存储空间"></a>二、使用OSS管理控制台创建用于文件存储的存储空间</h2><p>详细的创建过程请看帮助文档<a href="https://help.aliyun.com/document_detail/31885.html?spm=a2c4g.11174283.6.610.63b87da2FJnjgA" target="_blank" rel="noopener">使用OSS管理控制台创建存储空间的帮助文档</a></p><p>大概的意思为：</p><ol><li><p>登录<a href="https://oss.console.aliyun.com/" target="_blank" rel="noopener">OSS管理控制台</a>。</p></li><li><p>单击<strong>Bucket列表</strong>，之后单击<strong>创建Bucket</strong>。</p><p>您也可以单击<strong>概览</strong>，之后单击右侧的<strong>创建Bucket</strong>。</p></li><li><p>在<strong>创建Bucket</strong>页面配置Bucket参数。</p></li></ol><p>Bucket 名称：设为例如<code>autopackage</code>即可。</p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil21.png" alt="image-20200918103630889" style="zoom:33%;"></p><p>创建后，可进入”查看Bucket列表“对指定的Bucket进行想要的操作。</p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil22.png" alt="image-20200918104910122" style="zoom:33%;"></p><h2 id="三、进入存储空间进行文件上传（方式1：通过OSS管理控制台上传）"><a href="#三、进入存储空间进行文件上传（方式1：通过OSS管理控制台上传）" class="headerlink" title="三、进入存储空间进行文件上传（方式1：通过OSS管理控制台上传）"></a>三、进入存储空间进行文件上传（方式1：通过OSS管理控制台上传）</h2><p>如我们进入我们刚才创建的’autopackage’这个bucket。然后为其进行文件上传操作。</p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil23.png" alt="image-20200918104801357" style="zoom:50%;"></p><p>文件管理的界面如下：</p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil24.png" alt="image-20200918105842709"></p><p>我们拖动一张图片，进行上传尝试如下：</p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil25.png" alt="image-20200918110106103"></p><h2 id="四、进入存储空间进行文件上传（方式1：通过终端命令上传）"><a href="#四、进入存储空间进行文件上传（方式1：通过终端命令上传）" class="headerlink" title="四、进入存储空间进行文件上传（方式1：通过终端命令上传）"></a>四、进入存储空间进行文件上传（方式1：通过终端命令上传）</h2><h3 id="1、安装命令行工具ossutil"><a href="#1、安装命令行工具ossutil" class="headerlink" title="1、安装命令行工具ossutil"></a>1、安装命令行工具ossutil</h3><p>详细请查看<a href="https://help.aliyun.com/document_detail/120075.html?spm=a2c4g.11186623.6.830.3ed41c7anJQ3cJ" target="_blank" rel="noopener">OSS命令行工具的下载和安装的帮助文档</a></p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil41.png" alt="image-20200918112644521"></p><h3 id="2、配置-ossutilmac64-config"><a href="#2、配置-ossutilmac64-config" class="headerlink" title="2、配置 ossutilmac64 config"></a>2、配置 ossutilmac64 config</h3><p>执行 <code>./ossutilmac64 config</code>的时候，需要我们输入配置信息，要输入的配置信息，如下：</p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil42_config.png" alt="image-20200918113809174"></p><p>①请输入配置的文件名，直接回车，以使用默认的<code>.ossutilconfig</code>名</p><p>②请输入语言(CH/EN)，直接回车，以使用默认的<code>CH</code></p><p>③请输入endpoint，填写我们创建的bucket上的oss，注意不要写成http开头的</p><p>④请输入accessKeyID，这一步，我们需要回到<a href="https://oss.console.aliyun.com/overview" target="_blank" rel="noopener">阿里云OSS首页</a>，通过常用入口，找到<code>Access Key</code>的入口。</p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil43_accessKey.png" alt="image-20200918113458670"></p><p>进入<code>Access Key</code>的创建和管理，进入后并创建AccessKey后的页面显示为：</p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil44_accessKey.png" alt="image-20200918114734684"></p><p>则我们将创建好的信息，在执行<code>./ossutilmac64 config</code>的终端补充上去。其就会为我们生成组中的.ossutilconfig文件。</p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil45_config.png" alt="image-20200918115525237"></p><h3 id="3、通过终端命令，上传文件"><a href="#3、通过终端命令，上传文件" class="headerlink" title="3、通过终端命令，上传文件"></a>3、通过终端命令，上传文件</h3><p>配置后，我们通过通断命令，上传文件，终端命令及上传结果显示如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ossutilmac64 cp 1.jpg oss://autopackage/test1.jpg</span><br></pre></td></tr></table></figure><p><img src="/实用工具/阿里云oss/阿里云oss1上传/ossutil46_cp.png" alt="image-20200918120044242"></p><h2 id="五、检查上传文件的访问权限"><a href="#五、检查上传文件的访问权限" class="headerlink" title="五、检查上传文件的访问权限"></a>五、检查上传文件的访问权限</h2><h3 id="1、不检查访问权限，则可能出现的问题"><a href="#1、不检查访问权限，则可能出现的问题" class="headerlink" title="1、不检查访问权限，则可能出现的问题"></a>1、不检查访问权限，则可能出现的问题</h3><p>上传完文件后，我们经常需要允许可以访问。所以，这里我们要检查访问权限。</p><p>如果不检查，可能会遇到当你在通过相机扫描二维码的时候，出现无法访问的提示。</p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/image-20200918155227902.png" alt="image-20200918155227902" style="zoom:33%;"></p><h3 id="2、检查访问权限的方法"><a href="#2、检查访问权限的方法" class="headerlink" title="2、检查访问权限的方法"></a>2、检查访问权限的方法</h3><p>例如在如上，我们已经通过OSS管理控制台上传了一张1.jpg的图片。现在进行访问测试。</p><p>我们将该图片的地址：<a href="https://autopackage.oss-cn-hangzhou.aliyuncs.com/1.jpg" target="_blank" rel="noopener">https://autopackage.oss-cn-hangzhou.aliyuncs.com/1.jpg</a> 输入到浏览器中，</p><p>结果如下：</p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/image-20200918154655554.png" alt="image-20200918154655554"></p><p>其提示我们为权限问题，则我们进入autopackage这个bucket，将原本的读写权限从”私有“改成”公共读“。</p><p><img src="/实用工具/阿里云oss/阿里云oss1上传/image-20200918154826176.png" alt="image-20200918154826176"></p><p>然后，重新刷新刚才的图片地址即可。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>至此，利用阿里云OSS上传文件的操作介绍结束。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 阿里云oss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：腾讯云cos上传</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E8%85%BE%E8%AE%AF%E4%BA%91/%E8%85%BE%E8%AE%AF%E4%BA%91cos1%E4%B8%8A%E4%BC%A0/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E8%85%BE%E8%AE%AF%E4%BA%91/%E8%85%BE%E8%AE%AF%E4%BA%91cos1%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="腾讯云cos上传"><a href="#腾讯云cos上传" class="headerlink" title="腾讯云cos上传"></a>腾讯云cos上传</h1><p>官方文档：<a href="https://cloud.tencent.com/document/product/436/10976" target="_blank" rel="noopener">腾讯云-COSCMD 工具</a></p><h2 id="一、主要步骤："><a href="#一、主要步骤：" class="headerlink" title="一、主要步骤："></a>一、主要步骤：</h2><p>使用 pip install coscmd</p><p>需要：①使用python3安装pip、②使用pip install coscmd、③使用coscmd上传文件</p><p>其他：brew</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><h3 id="1、python3"><a href="#1、python3" class="headerlink" title="1、python3"></a>1、python3</h3><p>找不到python3的bin地址可使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which python3</span><br></pre></td></tr></table></figure><h3 id="2、pip"><a href="#2、pip" class="headerlink" title="2、pip"></a>2、pip</h3><p>在 Mac 上为 Python 3 使用 PIP 安装脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</span><br><span class="line"></span><br><span class="line">python3 get-pip.py</span><br></pre></td></tr></table></figure><p>以上脚本来源于：<a href="https://www.yundongfang.com/Yun164937.html" target="_blank" rel="noopener">如何在 Mac 上安装 PIP</a></p><p><img src="/实用工具/腾讯云/腾讯云cos1上传/image-20220726013611412.png" alt="image-20220726013611412"></p><p>安装失败，原因未设置到环境变量中，通过如下命令即可设置新增环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">which pip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 非M1芯片的MacOS使用如下：</span></span><br><span class="line">echo 'export PATH=~/Library/Python/3.8/bin:$PATH' &gt;&gt;~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 非M1芯片的MacOS使用如下：</span></span><br><span class="line">echo 'export PATH=~/Library/Python/3.8/bin:$PATH' &gt;&gt;~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line">which pip</span><br></pre></td></tr></table></figure><p>错误修改参考于文章：<a href="https://zhuanlan.zhihu.com/p/115676400" target="_blank" rel="noopener">Pip安装警告:Consider adding this directory to PATH..</a></p><h3 id="3、COSCMD-工具安装"><a href="#3、COSCMD-工具安装" class="headerlink" title="3、COSCMD 工具安装"></a>3、COSCMD 工具安装</h3><p>官方文档：<a href="https://cloud.tencent.com/document/product/436/10976" target="_blank" rel="noopener">腾讯云-COSCMD 工具</a></p><p>我们使用通过 pip 安装方式安装 COSCMD。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pip install coscmd</span><br><span class="line"></span><br><span class="line">coscmd -v</span><br><span class="line">which coscmd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 非M1芯片的MacOS使用如下：</span></span><br><span class="line">echo 'export PATH=~/Library/Python/3.8/bin:$PATH' &gt;&gt;~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 非M1芯片的MacOS使用如下：</span></span><br><span class="line">echo 'export PATH=~/Library/Python/3.8/bin:$PATH' &gt;&gt;~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line">which pip</span><br></pre></td></tr></table></figure><p><img src="/实用工具/腾讯云/腾讯云cos1上传/image-20220726150612750.png" alt="image-20220726150612750"></p><h3 id="4、COSCMD-工具使用"><a href="#4、COSCMD-工具使用" class="headerlink" title="4、COSCMD 工具使用"></a>4、COSCMD 工具使用</h3><p>COSCMD 工具在运行前会首先从配置文件中读取运行时所需的必要信息，COSCMD 会默认从 <code>~/.cos.conf</code> 中读取配置项。</p><p>所以，在~目录下，新建<code>.cos.conf</code>文件，并配置上类似如下的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">secret_id = AKIDA6wUmImTMzvXZNbGLCgtusZ2E8mG****</span><br><span class="line">secret_key = TghWBCyf5LIyTcXCoBdw1oRpytWk****</span><br><span class="line">bucket = configure-bucket-1250000000</span><br><span class="line">region = ap-chengdu</span><br><span class="line">max_thread = 5</span><br><span class="line">part_size = 1</span><br><span class="line">retry = 5</span><br><span class="line">timeout = 60</span><br><span class="line">schema = https</span><br><span class="line">verify = md5</span><br><span class="line">anonymous = False</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 非M1芯片的MacOS使用如下：</span></span><br><span class="line">echo 'export PATH=/Applications/Xcode.app/Contents/SharedFrameworks/ContentDeliveryServices.framework/itms/bin:$PATH' &gt;&gt;~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 非M1芯片的MacOS使用如下：</span></span><br><span class="line">echo 'export PATH=/Applications/Xcode.app/Contents/SharedFrameworks/ContentDeliveryServices.framework/itms/bin:$PATH' &gt;&gt;~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><h2 id="腾讯云-对象存储-Python-SDK"><a href="#腾讯云-对象存储-Python-SDK" class="headerlink" title="腾讯云-对象存储-Python SDK"></a><a href="https://cloud.tencent.com/document/product/436/12269" target="_blank" rel="noopener">腾讯云-对象存储-Python SDK</a></h2><p>之后即可正常安装<a href="https://cloud.tencent.com/document/product/436/12269" target="_blank" rel="noopener">腾讯云-对象存储-Python SDK</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U cos-python-sdk-v5</span><br></pre></td></tr></table></figure><p><img src="/实用工具/腾讯云/腾讯云cos1上传/image-20220726014253864.png" alt="image-20220726014253864"></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>至此，利用腾讯云Cos上传文件的操作介绍结束。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 阿里云oss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：阿里云服务器ECS</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="阿里云服务器ECS的使用"><a href="#阿里云服务器ECS的使用" class="headerlink" title="阿里云服务器ECS的使用"></a>阿里云服务器ECS的使用</h1><h2 id="一、目前部署在ECS上的项目有"><a href="#一、目前部署在ECS上的项目有" class="headerlink" title="一、目前部署在ECS上的项目有"></a>一、目前部署在ECS上的项目有</h2><ul><li><a href="../../实用工具/yapi/yapi在云服务器ECS上的使用-阿里云">yapi在云服务器ECS上的使用-阿里云</a></li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>至此，利用阿里云服务器ECS的使用介绍结束。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 阿里云oss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：阿里云服务器ECS</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E7%9A%84%E8%B4%AD%E4%B9%B0%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E7%9A%84%E8%B4%AD%E4%B9%B0%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="阿里云服务器ECS"><a href="#阿里云服务器ECS" class="headerlink" title="阿里云服务器ECS"></a>阿里云服务器ECS</h1><h2 id="一、购买服务器ECS"><a href="#一、购买服务器ECS" class="headerlink" title="一、购买服务器ECS"></a>一、购买服务器ECS</h2><p>1、进入 <a href="https://free.aliyun.com" target="_blank" rel="noopener">阿里云开发者试用中心https://free.aliyun.com</a></p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/ecs_buy_free.png" alt="ecs_buy_free" style="zoom: 67%;"></p><p>2、选择服务器</p><p>操作系统选择常见的系统，如CentOS 8.2的（之前用CentOS 8.4的，结果安装mongodb的时候只找到8.2的版本）</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/ecs_buy_2.png" alt="ecs_buy_2"></p><p>3、下单</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/ecs_buy_3.png" alt="ecs_buy_3"></p><p>4、购买支付</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/ecs_buy_4.png" alt="ecs_buy_4"></p><p>至此，购买成功。</p><h2 id="二、主页"><a href="#二、主页" class="headerlink" title="二、主页"></a>二、主页</h2><p>我的云服务器ECS资源</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/ecs_main1.png" alt="ecs_main1"></p><h2 id="三、远程桌面连接"><a href="#三、远程桌面连接" class="headerlink" title="三、远程桌面连接"></a>三、远程桌面连接</h2><p>远程连接方式有以下几种方式</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/image-20210804140640136.png" alt="image-20210804140640136" style="zoom:33%;"></p><p>如何正确的远程连接方式 请直接调到第四步。</p><h3 id="1、错误1：通过公网IP或者EIP访问实例增加Workbench的服务器白名单"><a href="#1、错误1：通过公网IP或者EIP访问实例增加Workbench的服务器白名单" class="headerlink" title="1、错误1：通过公网IP或者EIP访问实例增加Workbench的服务器白名单:"></a>1、错误1：通过公网IP或者EIP访问实例增加Workbench的服务器白名单:</h3><h4 id="1-1、发现错误"><a href="#1-1、发现错误" class="headerlink" title="1.1、发现错误"></a>1.1、发现错误</h4><p>Windows用户需要隶属于Remote Desktop Users组才能使用RDP远程登录</p><p>通过公网IP或者EIP访问实例增加Workbench的服务器白名单:<br>47.96.60.0/24<br>118.31.243.0/24</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/image-20201117155701566.png" alt="image-20201117155701566"></p><h4 id="1-2、解决错误"><a href="#1-2、解决错误" class="headerlink" title="1.2、解决错误"></a>1.2、解决错误</h4><p>解决办法：</p><p>鼠标放在在阿里云右上角 账号头像 上 ，然后找到 “<strong>安全管控”</strong> 。</p><p>然后在左侧上找到“<strong><em>\</em>IP白名单**</strong>”</p><p>如下图所示添加上面的两个iP进白名单即可。</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/image-20201117155550649.png" alt="image-20201117155550649"></p><p>添加白名单</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/image-20201117160123181.png" alt="image-20201117160123181"></p><p>两个都添加后，</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/image-20201117160242381.png" alt="image-20201117160242381"></p><p>如果还不能连接，请检查安全组端口</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/image-20201117102103027.png" alt="image-20201117102103027"></p><h3 id="2、实际上正确的远程连接需要安装远程桌面服务"><a href="#2、实际上正确的远程连接需要安装远程桌面服务" class="headerlink" title="2、实际上正确的远程连接需要安装远程桌面服务"></a>2、实际上正确的远程连接需要安装远程桌面服务</h3><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/image-20201117165745806.png" alt="image-20201117165745806"></p><h2 id="四、正确的远程连接方式"><a href="#四、正确的远程连接方式" class="headerlink" title="四、正确的远程连接方式"></a>四、正确的远程连接方式</h2><h3 id="远程连接的几种方式"><a href="#远程连接的几种方式" class="headerlink" title="远程连接的几种方式"></a>远程连接的几种方式</h3><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/ecs_connect_vnc1.png" alt="ecs_connect_vnc1"></p><h3 id="1、Workbench方式连接"><a href="#1、Workbench方式连接" class="headerlink" title="1、Workbench方式连接"></a>1、Workbench方式连接</h3><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/image-20210804144528676.png" alt="image-20210804144528676"></p><h3 id="2、VNC方式连接"><a href="#2、VNC方式连接" class="headerlink" title="2、VNC方式连接"></a>2、VNC方式连接</h3><h4 id="2-1、VNC方式连接-默认进入的是终端界面"><a href="#2-1、VNC方式连接-默认进入的是终端界面" class="headerlink" title="2.1、VNC方式连接(默认进入的是终端界面)"></a>2.1、VNC方式连接(默认进入的是终端界面)</h4><p>选择VNC，输入远程连接的密码（这里不是不是root对应的密码），如Login1</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/ecs_connect_vnc2.png" alt="ecs_connect_vnc2"></p><p>之后进入终端界面，输入登录账号密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号：root</span><br><span class="line">密码：实例的登录密码（和ssh登录是一样的）</span><br></pre></td></tr></table></figure><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/ecs_connect_vnc3.png" alt="ecs_connect_vnc3"></p><p>登录成功后，就可以输入其他终端命令来操作了。</p><h4 id="2-2、将VNC的进入界面改成桌面形式-CentOS8如何安装图形界面"><a href="#2-2、将VNC的进入界面改成桌面形式-CentOS8如何安装图形界面" class="headerlink" title="2.2、将VNC的进入界面改成桌面形式/CentOS8如何安装图形界面"></a>2.2、将VNC的进入界面改成桌面形式/CentOS8如何安装图形界面</h4><p>官网帮助文档：<a href="https://help.aliyun.com/knowledge_detail/151830.html?spm=5176.13910061.sslink.1.7a2d5d584Ps39h" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/151830.html?spm=5176.13910061.sslink.1.7a2d5d584Ps39h</a></p><p>安装命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall &quot;Server with GUI&quot; -y</span><br><span class="line">systemctl set-default graphical</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>之后仍然选择VNC方式连接，连接后会发现进入的界面变成了以下样式</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/image-20201117171441762.png" alt="image-20201117171441762" style="zoom: 50%;"></p><p>之后和之前一样输入登录账号密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号：root</span><br><span class="line">密码：实例的登录密码（和ssh登录是一样的） // 如常用的8位密码</span><br></pre></td></tr></table></figure><p>即可进入。</p><p>进入之后的页面如下：</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/image-20211221102404260.png" alt="image-20211221102404260"></p><p>其他参考内容：</p><blockquote><p>在Centos 6.x中，我们常使用rdesktop软件，去连接windows的远程桌面</p><p>但是在Centos 7.x中，默认的yum仓库中没有集成rdesktop软件包了</p><p>如果要在Centos 7.x中连接windows的远程桌面，可以有如下几种方法</p><p><strong>1、通过其他yum仓库，或者其他方式安装rdesktop软件包，然后通过rdesktop -u username -p password IP 进行连接</strong></p><p><strong>2、安装GNOME桌面后，然后使用其自带的Remote Desktop Viewer通过RDP协议（也可以通过vinagre命令启动窗口）进行连接</strong></p><p><strong>3、安装freerdp软件包，然后使用xfreerdp x.x.x.x 进行连接</strong></p><p>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</p><p>今天主要记录一下，如何通过freerdp软件包，去连接windows的远程桌面</p><p>1、直接使用yum命令即可完成安装，在[updates]仓库中就集成了freerdp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [root@qq5201351 ~]# yum install freerdp -y           #也可以写freerdp软件包中的二进制文件xfreerdp</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>2、安装后，使用xfreerdp x.x.x.x 即可进行连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [root@qq5201351 ~]# xfreerdp 1.2.3.4                 #如果不是默认的tcp的3389端口，可以直接在ip后面加:port</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>注：软件包的名字为freerdp，但是其二进制的命令文件为xfreerdp</strong></p></blockquote><h2 id="五、云服务器内部"><a href="#五、云服务器内部" class="headerlink" title="五、云服务器内部"></a>五、云服务器内部</h2><p>登录到阿里云服务器ECS后</p><p>1、查看默认进入到的文件路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>2、查看该文件所在的父文件的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接/image-20210803114919466-7962568.png" alt="image-20210803114919466"></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>至此，利用阿里云服务器ECS购买及远程连接操作介绍结束。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 阿里云oss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1节：阿里云服务器ECS</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="阿里云服务器ECS的使用"><a href="#阿里云服务器ECS的使用" class="headerlink" title="阿里云服务器ECS的使用"></a>阿里云服务器ECS的使用</h1><h2 id="一、如何将云服务器ECS中的数据备份到本地"><a href="#一、如何将云服务器ECS中的数据备份到本地" class="headerlink" title="一、如何将云服务器ECS中的数据备份到本地"></a>一、如何将云服务器ECS中的数据备份到本地</h2><p>官网文档：<a href="https://help.aliyun.com/knowledge_detail/159174.html?spm=5176.13910061.sslink.7.43a04c92N9Smor" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/159174.html?spm=5176.13910061.sslink.7.43a04c92N9Smor</a></p><p><a href="https://help.aliyun.com/knowledge_detail/159174.html?spm=5176.13910061.sslink.10.2c963ebfnNsH2V" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/159174.html?spm=5176.13910061.sslink.10.2c963ebfnNsH2V</a></p><h2 id="二、手动搭建FTP站点（CentOS-7）"><a href="#二、手动搭建FTP站点（CentOS-7）" class="headerlink" title="二、手动搭建FTP站点（CentOS 7）"></a>二、手动搭建FTP站点（CentOS 7）</h2><p><a href="https://help.aliyun.com/document_detail/92048.html?spm=a2c4g.11186623.2.11.36ac4c078t7O3M" target="_blank" rel="noopener">阿里云官网帮助文档：手动搭建FTP站点（CentOS 7）</a></p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的数据备份/image-20201120115313756.png" alt="image-20201120115313756"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">adduser lichaoqian</span><br><span class="line">passwd lichaoqian</span><br><span class="line"></span><br><span class="line">mkdir /root/ProjectTest</span><br><span class="line">chown -R lichaoqian:lichaoqian /root/ProjectTest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ftp://121.196.63.236:3000</span><br></pre></td></tr></table></figure><h3 id="1、步骤一：安装vsftpd"><a href="#1、步骤一：安装vsftpd" class="headerlink" title="1、步骤一：安装vsftpd"></a>1、步骤一：安装vsftpd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y vsftpd</span><br><span class="line">systemctl enable vsftpd.service</span><br><span class="line">systemctl start vsftpd.service</span><br><span class="line">netstat -antup | grep ftp</span><br></pre></td></tr></table></figure><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的数据备份/image-20201120105446990.png" alt="image-20201120105446990"></p><p>vim /etc/vsftpd/vsftpd.conf</p><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的数据备份/image-20201120112330288.png" alt="image-20201120112330288"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#除下面提及的参数外，其他参数保持默认值即可。</span><br><span class="line"></span><br><span class="line">#修改下列参数的值</span><br><span class="line">#禁止匿名登录FTP服务器</span><br><span class="line">anonymous_enable=NO</span><br><span class="line">#允许本地用户登录FTP服务器</span><br><span class="line">local_enable=YES</span><br><span class="line">#监听IPv4 sockets</span><br><span class="line">listen=YES</span><br><span class="line">#在行首添加#注释掉以下参数，关闭监听IPv6 sockets</span><br><span class="line">#listen_ipv6=YES</span><br><span class="line"></span><br><span class="line">#添加下列参数</span><br><span class="line">#设置本地用户登录后所在目录</span><br><span class="line">local_root=/root/Project</span><br><span class="line">#全部用户被限制在主目录</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">#启用例外用户名单</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line">#指定例外用户列表文件，列表中用户不被锁定在主目录</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="line">#开启被动模式</span><br><span class="line">pasv_enable=YES</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line">#本教程中为Linux实例公网IP</span><br><span class="line">#pasv_address=&lt;FTP服务器公网IP地址&gt;</span><br><span class="line">pasv_address=121.196.63.236</span><br><span class="line">#设置被动模式下，建立数据传输可使用的端口范围的最小值</span><br><span class="line">#pasv_min_port=&lt;port number&gt;</span><br><span class="line">pasv_min_port=50000</span><br><span class="line">#设置被动模式下，建立数据传输可使用的端口范围的最大值</span><br><span class="line">#pasv_max_port=&lt;port number&gt;</span><br><span class="line">pasv_max_port=50010</span><br></pre></td></tr></table></figure><p><img src="/实用工具/阿里云服务器ECS/阿里云服务器ECS的数据备份/image-20201120113245620.png" alt="image-20201120113245620"></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>至此，利用阿里云服务器ECS的使用介绍结束。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 阿里云oss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第0节：iOS 安装包-完整自动化流程</title>
      <link href="/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/iOS%20%E5%AE%89%E8%A3%85%E5%8C%850-%E5%AE%8C%E6%95%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/"/>
      <url>/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/iOS%20%E5%AE%89%E8%A3%85%E5%8C%850-%E5%AE%8C%E6%95%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="iOS-安装包-完整自动化流程"><a href="#iOS-安装包-完整自动化流程" class="headerlink" title="iOS 安装包-完整自动化流程"></a>iOS 安装包-完整自动化流程</h1><h2 id="一、安装包-编译-amp-打包"><a href="#一、安装包-编译-amp-打包" class="headerlink" title="一、安装包-编译&amp;打包"></a>一、安装包-编译&amp;打包</h2><p>详情查看：</p><p><a href="./iOS 安装包1-编译&amp;打包.md">iOS 安装包1-编译&amp;打包</a></p><h2 id="二、安装包-上传"><a href="#二、安装包-上传" class="headerlink" title="二、安装包-上传"></a>二、安装包-上传</h2><p>详情查看：</p><p><a href="./iOS 安装包2-上传.md">iOS 安装包2-上传</a></p><h2 id="三、安装包-二维码扫码安装"><a href="#三、安装包-二维码扫码安装" class="headerlink" title="三、安装包-二维码扫码安装"></a>三、安装包-二维码扫码安装</h2><p>详情查看：</p><p><a href="./iOS 安装包1-编译&amp;打包.md">iOS 安装包1-编译&amp;打包</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节：iOS 安装包-编译&amp;打包</title>
      <link href="/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/Flutter%20iOS%20%E5%AE%89%E8%A3%85%E5%8C%851-%E7%BC%96%E8%AF%91&amp;%E6%89%93%E5%8C%85/"/>
      <url>/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/Flutter%20iOS%20%E5%AE%89%E8%A3%85%E5%8C%851-%E7%BC%96%E8%AF%91&amp;%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="iOS-安装包-编译-amp-打包"><a href="#iOS-安装包-编译-amp-打包" class="headerlink" title="iOS 安装包-编译&amp;打包"></a>iOS 安装包-编译&amp;打包</h1>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节：iOS 安装包-上传</title>
      <link href="/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/iOS%20%E5%AE%89%E8%A3%85%E5%8C%852-%E4%B8%8A%E4%BC%A0/"/>
      <url>/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/iOS%20%E5%AE%89%E8%A3%85%E5%8C%852-%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="iOS-安装包2-上传"><a href="#iOS-安装包2-上传" class="headerlink" title="iOS 安装包2-上传"></a>iOS 安装包2-上传</h1><p><img src="/iOS/自动化/iOS 安装包2-上传/image-20210123122550446.png" alt="image-20210123122550446"></p><p><img src="/iOS/自动化/iOS 安装包2-上传/image-20210123122846919.png" alt="image-20210123122846919"></p><h2 id="一、ApplicationLoader-gt-Transporter"><a href="#一、ApplicationLoader-gt-Transporter" class="headerlink" title="一、ApplicationLoader -&gt; Transporter"></a>一、ApplicationLoader -&gt; Transporter</h2><h3 id="1、ApplicationLoader-新版本的xcode11后不再提供"><a href="#1、ApplicationLoader-新版本的xcode11后不再提供" class="headerlink" title="1、ApplicationLoader(新版本的xcode11后不再提供)"></a>1、ApplicationLoader(新版本的xcode11后不再提供)</h3><p>以前：使用Application loader上传安装包。</p><p>现在：升级xcode11后，你会发现找不到Application loader这个工具了。(附：实际上Application loader只是对altool的封装。）<br> 去查看xcdoe11的<strong><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Fxcode_release_notes%2Fxcode_11_release_notes%3Flanguage%3Dobjc" target="_blank" rel="noopener">更新说明</a></strong>，有这样一段话</p><blockquote><p>Xcode supports uploading apps from the Organizer window or from the command line with xcodebuild or xcrun altool. Application Loader is no longer included with Xcode. (29008875)</p></blockquote><h3 id="2、Transporter"><a href="#2、Transporter" class="headerlink" title="2、Transporter"></a>2、Transporter</h3><p>ApplicationLoader不能使用了，那我们使用什么。苹果在2019年10月份上线了<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fapps.apple.com%2Fcn%2Fapp%2Ftransporter%2Fid1450874784%3Fmt%3D12" target="_blank" rel="noopener">Transporter</a>。</p><p>在 App Store Connect 中创建 App 记录后，您便可以通过 Xcode、macOS 版 Transporter 或 altool 上传构建版本。其界面如下：</p><p><img src="/iOS/自动化/iOS 安装包2-上传/Transporter.png" alt="image-20200921095227639" style="zoom:33%;"></p><p>如果您使用 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Fappstoreconnectapi" target="_blank" rel="noopener">App Store Connect API</a>，则建议您通过命令行工具 Transporter 和 JSON 网络令牌（JWT）验证来上传二进制文件。用于 API 的 JWT 也可以用于上传二进制文件。</p><h2 id="二、xcrun-altool"><a href="#二、xcrun-altool" class="headerlink" title="二、xcrun altool"></a>二、xcrun altool</h2><p>Xcode11前：旧版本的altool只支持ipa、pkg的上传。</p><p>xcode11后，新版本的altool在旧版本的基础上，额外支持了各种文件压缩包的上传，应该就是mac、ipad、iphone应用和其他相关打包产物的集合包。</p><p>altool 位于：<code>/Applications/Xcode.app/Contents/Developer/usr/bin/altool</code>。</p><p><img src="/iOS/自动化/iOS 安装包2-上传/altool1位置.png" alt="altool位置"></p><h3 id="1、查看xcrun-altool的用法"><a href="#1、查看xcrun-altool的用法" class="headerlink" title="1、查看xcrun altool的用法"></a>1、查看xcrun altool的用法</h3><p>终端执行<code>xcrun altool</code>命令，可见其命令用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:~ $ xcrun altool</span><br><span class="line">Copyright (c) 2009-2019, Apple Inc. Version 4.00.1181</span><br><span class="line"></span><br><span class="line">Usage: altool --validate-app -f &lt;file&gt; -t &lt;platform&gt; -u &lt;username&gt; &#123;[-p &lt;password&gt;] | --apiKey &lt;api_key&gt; --apiIssuer &lt;issuer_id&gt;&#125;</span><br><span class="line">       altool --upload-app -f &lt;file&gt; -t &lt;platform&gt; -u &lt;username&gt; &#123;[-p &lt;password&gt;] | --apiKey &lt;api_key&gt; --apiIssuer &lt;issuer_id&gt;&#125;</span><br><span class="line">       altool --notarize-app -f &lt;file&gt; --primary-bundle-id &lt;bundle_id&gt; -u &lt;username&gt; &#123;[-p &lt;password&gt;] | --apiKey &lt;api_key&gt; --apiIssuer &lt;issuer_id&gt;&#125; [--asc-provider &lt;provider_shortname&gt;]</span><br><span class="line">       altool --notarization-info &lt;uuid&gt; -u &lt;username&gt; &#123;[-p &lt;password&gt;] | --apiKey &lt;api_key&gt; --apiIssuer &lt;issuer_id&gt;&#125;</span><br><span class="line">       altool --notarization-history &lt;page&gt; -u &lt;username&gt; &#123;[-p &lt;password&gt;] | --apiKey &lt;api_key&gt; --apiIssuer &lt;issuer_id&gt;&#125; [--asc-provider &lt;provider_shortname&gt;]</span><br><span class="line">       altool --list-apps -u &lt;username&gt; &#123;[-p &lt;password&gt;] | --apiKey &lt;api_key&gt; --apiIssuer &lt;issuer_id&gt;&#125;</span><br><span class="line">       altool --store-password-in-keychain-item &lt;name_for_keychain_item&gt; -u &lt;username&gt; -p &lt;password&gt;</span><br><span class="line"></span><br><span class="line">Authentication: Most commands require authorization.</span><br><span class="line">                There are two methods available: user name with password, and apiKey with apiIssuer.</span><br><span class="line"></span><br><span class="line">                -u, --username &lt;username&gt; Username. Required to connect for validation, upload, and notarization.</span><br><span class="line">                -p, --password &lt;password&gt; Password. Required if username specified and apiKey/apiIssuer are not.</span><br><span class="line">                                          If this argument is not supplied on the command line, it will be read from stdin.</span><br><span class="line">                                          Alternatively to entering &lt;password&gt; in plaintext, it may also be specified using a '@keychain:'</span><br><span class="line">                                          or '@env:' prefix followed by a keychain password item name or environment variable name.</span><br><span class="line">                                          Example: '-p @keychain:&lt;name&gt;' uses the password stored in the keychain password item named &lt;name&gt;.</span><br><span class="line">                                                                         You can create and update keychain items with the</span><br><span class="line">                                                                         --store-password-in-keychain-item command.</span><br><span class="line">                                          Example: '-p @env:&lt;variable&gt;'  uses the value in the environment variable named &lt;variable&gt;</span><br><span class="line"></span><br><span class="line">                --apiKey &lt;api_key&gt;        apiKey. Required for JWT authentication while using validation, upload, and notarization.</span><br><span class="line">                                          This option will search the following directories in sequence for a private key file</span><br><span class="line">                                          with the name of 'AuthKey_&lt;api_key&gt;.p8':  './private_keys', '~/private_keys', '~/.private_keys',</span><br><span class="line">                                          and '~/.appstoreconnect/private_keys'.</span><br><span class="line">                --apiIssuer &lt;issuer_id&gt;   Issuer ID. Required if --apiKey is specified.</span><br><span class="line"></span><br><span class="line"> -f, --file &lt;file&gt;                   &lt;file&gt; specifies the path to the file to process.</span><br><span class="line"> -t, --type &#123;osx | ios | appletvos&#125;  Specify the platform of the file.</span><br><span class="line"></span><br><span class="line">     --primary-bundle-id &lt;bundle_id&gt; Used with --notarize-app to uniquely identify a package.</span><br><span class="line"></span><br><span class="line">     --asc-provider &lt;provider_shortname&gt; Required with --notarize-app and --notarization-history when a user account is associated with multiple</span><br><span class="line">                                         providers.</span><br><span class="line"></span><br><span class="line"> -v, --validate-app                  Validates an app archive for the App Store. Authentication and -f are required.</span><br><span class="line">     --upload-app                    Uploads the given app archive to the App Store. Authentication and -f are required.</span><br><span class="line">     --list-apps                     Display all apps associated with your account(s).</span><br><span class="line"></span><br><span class="line">     --notarize-app                  Uploads the given app package, dmg or zip file for notarization. Authentication, -f,</span><br><span class="line">                                     and --primary-bundle-id are required. --asc-provider is required for an account associated with multiple providers.</span><br><span class="line">                                     If successful, the UUID associated with the upload is returned.</span><br><span class="line"></span><br><span class="line">     --notarization-info &lt;uuid&gt;      Returns the status and log file URL of a package previously uploaded for notarization with the specified &lt;uuid&gt;.</span><br><span class="line">                                     Authentication is required. The log file can be retrieved with 'curl &lt;log_file_url&gt;'.</span><br><span class="line"></span><br><span class="line">     --notarization-history &lt;page&gt;   Returns a list of all uploads submitted for notarization. &lt;page&gt; specifies a range of entries where 0</span><br><span class="line">                                     returns the most recent number of entries. A new page value will be returned which can be used as the</span><br><span class="line">                                     &lt;page&gt; value to the next use of --notarization-history and so forth until no more items are returned.</span><br><span class="line">                                     Authentication is required. --asc-provider is required for an account associated with multiple providers.</span><br><span class="line"></span><br><span class="line">     --store-password-in-keychain-item &lt;name_for_keychain_item&gt; -u &lt;username&gt; -p &lt;password&gt;</span><br><span class="line">                                     Stores the password &lt;password&gt; in the keychain item named &lt;name_for_keychain_item&gt; associated with the account &lt;username&gt;.</span><br><span class="line">                                     If an item with that name and account already exists in the keychain, its password will be updated. Otherwise a new item</span><br><span class="line">                                     is created with that name. You can use this keychain item with the -p option to mask your password with other commands.</span><br><span class="line">                                     Example: altool --store-password-in-keychain-item MY_SECRET -u jappleseed@apple.com -p "MyP@ssw0rd!@78"</span><br><span class="line">                                              altool --notarize-app -u jappleseed@apple.com -p @keychain:MY_SECRET [...]</span><br><span class="line"></span><br><span class="line">     --output-format &#123;xml | normal&#125;  Specifies how the output is formatted. 'xml' displays the output in a structured format; 'normal' displays in</span><br><span class="line">                                     an unstructured format (default).</span><br><span class="line"></span><br><span class="line">     --verbose                       Enable logging output.</span><br><span class="line"></span><br><span class="line"> -h, --help                          Display this output.</span><br></pre></td></tr></table></figure><h3 id="2、查看ipa包验证和上传使用的xcrun-altool命令"><a href="#2、查看ipa包验证和上传使用的xcrun-altool命令" class="headerlink" title="2、查看ipa包验证和上传使用的xcrun altool命令"></a>2、查看ipa包验证和上传使用的xcrun altool命令</h3><p>我们主要看两个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: altool --validate-app -f &lt;file&gt; -t &lt;platform&gt; -u &lt;username&gt; &#123;[-p &lt;password&gt;] | --apiKey &lt;api_key&gt; --apiIssuer &lt;issuer_id&gt;&#125;</span><br><span class="line">       altool --upload-app -f &lt;file&gt; -t &lt;platform&gt; -u &lt;username&gt; &#123;[-p &lt;password&gt;] | --apiKey &lt;api_key&gt; --apiIssuer &lt;issuer_id&gt;&#125;</span><br></pre></td></tr></table></figure><h2 id="三、xcrun-altool验证上传-方式1：username-password方式"><a href="#三、xcrun-altool验证上传-方式1：username-password方式" class="headerlink" title="三、xcrun altool验证上传(方式1：username+password方式)"></a>三、xcrun altool验证上传(方式1：username+password方式)</h2><p>将我们查看到的两个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: altool --validate-app -f &lt;file&gt; -t &lt;platform&gt; -u &lt;username&gt; &#123;[-p &lt;password&gt;] | --apiKey &lt;api_key&gt; --apiIssuer &lt;issuer_id&gt;&#125;</span><br><span class="line">       altool --upload-app -f &lt;file&gt; -t &lt;platform&gt; -u &lt;username&gt; &#123;[-p &lt;password&gt;] | --apiKey &lt;api_key&gt; --apiIssuer &lt;issuer_id&gt;&#125;</span><br></pre></td></tr></table></figure><p>使用 username+password 方式 改为最终的形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun altool --validate-app -f ../output/Debug-iphoneos/Runner/Runner.ipa -t ios --verbose -u 账号 -p 密码</span><br><span class="line">xcrun altool --validate-app -f ../output/Debug-iphoneos/Runner/Runner.ipa -t ios --verbose -u 账号 -p 专用密码</span><br></pre></td></tr></table></figure><h3 id="1、问题1Please-sign-in-with-an-app-specific-password"><a href="#1、问题1Please-sign-in-with-an-app-specific-password" class="headerlink" title="1、问题1Please sign in with an app-specific password"></a>1、问题1<code>Please sign in with an app-specific password</code></h3><h4 id="1-1、错误详情及分析"><a href="#1-1、错误详情及分析" class="headerlink" title="1.1、错误详情及分析"></a>1.1、错误详情及分析</h4><p>使用非专用密码时候的错误截图如下： <img src="/iOS/自动化/iOS 安装包2-上传/image-20200918190110153.png?lastModify=1600652256" alt="image-20200918190110153"></p><p>提示信息：Please sign in with an app-specific password. You can create one at <a href="http://appleid.apple.com/" target="_blank" rel="noopener">appleid.apple.com</a> 。这是因为自己账号开启了二重验证，所以这里的密码不能使用原始的明文密码，而应该使用专用密码。</p><h4 id="1-2、创建生成专用密码"><a href="#1-2、创建生成专用密码" class="headerlink" title="1.2、创建生成专用密码"></a>1.2、创建生成专用密码</h4><p>解决办法：在<a href="https://www.apple.com.cn/" target="_blank" rel="noopener">Apple官网https://www.apple.com.cn/</a>登陆你的账号，并进入”管理你的Apple ID“。</p><p><img src="/iOS/自动化/iOS 安装包2-上传/管理你的AppleID.png" alt="image-20200918185022063" style="zoom: 33%;"></p><p>在管理密码的地方有一个App专用密码，点击<code>Generate an App-Specific Password</code>，生成专用密码。</p><p><img src="/iOS/自动化/iOS 安装包2-上传/image-20200918185328249.png?lastModify=1600652256" alt="image-20200918185328249" style="zoom: 33%;"></p><h4 id="1-3、管理生成的专用密码"><a href="#1-3、管理生成的专用密码" class="headerlink" title="1.3、管理生成的专用密码"></a>1.3、管理生成的专用密码</h4><p>点击”查看记录“，可查看管理过往专用密码。</p><p><img src="/iOS/自动化/iOS 安装包2-上传/image-20200918185521612.png?lastModify=1600652256" alt="image-20200918185521612"></p><h3 id="2、问题2Invalid-Provisioning-Profile-The-provisioning-profile-included-in-the-bundle-com-dvlproad-autopackage-Payload-Runner-app-is-invalid"><a href="#2、问题2Invalid-Provisioning-Profile-The-provisioning-profile-included-in-the-bundle-com-dvlproad-autopackage-Payload-Runner-app-is-invalid" class="headerlink" title="2、问题2Invalid Provisioning Profile. The provisioning profile included in the bundle com.dvlproad.autopackage [Payload/Runner.app] is invalid."></a>2、问题2<code>Invalid Provisioning Profile. The provisioning profile included in the bundle com.dvlproad.autopackage [Payload/Runner.app] is invalid.</code></h3><p>使用专用密码，进行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun altool --validate-app -f ../output/Debug-iphoneos/Runner/Runner.ipa -t ios --verbose -u 12345678@qq.com -p lnaa-xxxx-yyyy-zzzz</span><br></pre></td></tr></table></figure><p>出现了新错误，新错误截图如下： <img src="/iOS/自动化/iOS 安装包2-上传/image-20200918190727435.png?lastModify=1600652256" alt="image-20200918190727435"></p><p>原因：</p><p>1、你打出来的包不是生产环境，比如你打的是dev环境</p><p>2、</p><h2 id="四、xcrun-altool验证上传-方式2：apiKey-apiIssuer方式"><a href="#四、xcrun-altool验证上传-方式2：apiKey-apiIssuer方式" class="headerlink" title="四、xcrun altool验证上传(方式2：apiKey+apiIssuer方式)"></a>四、xcrun altool验证上传(方式2：apiKey+apiIssuer方式)</h2><p>xcrun altool有双重认证限制后，不能直接使用账号密码了，只能使用新的-apiKey 、–apiIssuer。</p><p>所以，最终的验证、上传的两个命令形如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xcrun altool --validate-app -f xxx/xxx/xxx.ipa -t ios --apiKey xxxxxxxx --apiIssuer xxxxxx --verbose  --output-format xml</span><br><span class="line"></span><br><span class="line">xcrun altool --upload-app -f xxx/xxx/xxx.ipa -t ios --apiKey xxxxxxxx --apiIssuer xxxxxx --verbose  --output-format xml</span><br></pre></td></tr></table></figure><p>2个命令分别对应 验证IPA 和 上传IPA，都需要使用3个参数<code>ipa路径</code>、<code>apiKey</code>、<code>apiIssuer</code></p><p>①、<code>ipa路径</code>：用<code>xcodebuild</code>打包或用<code>Organizer</code>Export导出的App store包。</p><p>②、<code>apiKey</code>和<code>apiIssuer</code>需要去开发者官网-用户和访问-密钥-去新增。</p><h3 id="1、准备xcrun-altool上传参数中的apiKey和apiIssuer"><a href="#1、准备xcrun-altool上传参数中的apiKey和apiIssuer" class="headerlink" title="1、准备xcrun altool上传参数中的apiKey和apiIssuer"></a>1、准备xcrun altool上传参数中的apiKey和apiIssuer</h3><h4 id="1-1、创建生成apiKey和apiIssuer"><a href="#1-1、创建生成apiKey和apiIssuer" class="headerlink" title="1.1、创建生成apiKey和apiIssuer"></a>1.1、创建生成apiKey和apiIssuer</h4><p><code>apiKey</code>和<code>apiIssuer</code>需要去开发者<a href="https://appstoreconnect.apple.com/access/users" target="_blank" rel="noopener">官网-用户和访问</a>-密钥-去新增。如下图流程</p><p>新增一个密钥，名称和访问者可以自由填写</p><p><img src="https://upload-images.jianshu.io/upload_images/293993-84ec23421430d29b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200" alt="img"></p><p>生成完成后，IssuerID就是apiIssuer，密钥ID就是apiKey，并且还有一个API密钥可以下载。<strong>注意此秘钥文件只能下载一次，请妥善保存</strong></p><p><img src="https:////upload-images.jianshu.io/upload_images/293993-2eb34b53fcd448ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200" alt="img"></p><h4 id="1-2、下载保存apiKey和apiIssuer"><a href="#1-2、下载保存apiKey和apiIssuer" class="headerlink" title="1.2、下载保存apiKey和apiIssuer"></a>1.2、下载保存apiKey和apiIssuer</h4><p>创建生成apiKey和apiIssuer后，按照我们之前在终端执行的<code>xcrun altool</code>命令提示有如下说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--apiKey &lt;api_key&gt;        apiKey. Required for JWT authentication while using validation, upload, and notarization.</span><br><span class="line">                          This option will search the following directories in sequence for a private key file</span><br><span class="line">                          with the name of 'AuthKey_&lt;api_key&gt;.p8':  './private_keys', '~/private_keys', '~/.private_keys',</span><br><span class="line">                          and '~/.appstoreconnect/private_keys'.</span><br><span class="line">--apiIssuer &lt;issuer_id&gt;   Issuer ID. Required if --apiKey is specified.</span><br></pre></td></tr></table></figure><p>即：我们需要把刚才下载好的密钥文件放到这里面的其中一个文件夹里，它会按顺序去查找。</p><p>这里我们就选择<code>~/private_keys</code>这个位置吧，即在自己用户目录下<code>/Users/xxx/private_keys</code>新建了个private_keys文件夹，并把密钥文件放进去的。</p><h3 id="2、使用xcrun-altool验证上传"><a href="#2、使用xcrun-altool验证上传" class="headerlink" title="2、使用xcrun altool验证上传"></a>2、使用xcrun altool验证上传</h3><p>在确定完ipa包验证和上传使用的xcrun altool命令和上传参数中的apiKey和apiIssuer后，我们就可以开始使用xcrun altool验证上传了。</p><h4 id="2-1、xcrun-altool验证"><a href="#2-1、xcrun-altool验证" class="headerlink" title="2.1、xcrun altool验证"></a>2.1、xcrun altool验证</h4><p>验证结果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2019-11-13 11:36:56.773 altool[3970:100440] Deallocating <span class="tag">&lt;<span class="name">ITunesSoftwareServiceWorkSeriesFactory:</span> <span class="attr">0x7fa5d6d06610</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>os-version<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>10.14.6<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>success-message<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>No errors validating archive at '/Users/xxx/Desktop/altools.ipa'<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>tool-path<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Applications/Xcode.app/Contents/SharedFrameworks/ContentDeliveryServices.framework/Versions/A/Frameworks/AppStoreService.framework<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>tool-version<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>4.00.1181<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br><span class="line">2019-11-13 11:36:</span><br></pre></td></tr></table></figure><p>等到提示<code>No errors validating archive at xxx</code>时就代表验证成功了，可以上传了。</p><h4 id="4-2、xcrun-altool上传"><a href="#4-2、xcrun-altool上传" class="headerlink" title="4.2、xcrun altool上传"></a>4.2、xcrun altool上传</h4><p>上传结果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2019-11-13 11:49:55.382 altool[4093:102055] [2019-11-13 11:49:55 CST] <span class="tag">&lt;<span class="name">main</span>&gt;</span> DBG-X: Returning 0</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>os-version<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>10.14.6<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>success-message<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>No errors uploading '/Users/xxx/Desktop/altools.ipa'<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>tool-path<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Applications/Xcode.app/Contents/SharedFrameworks/ContentDeliveryServices.framework/Versions/A/Frameworks/AppStoreService.framework<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>tool-version<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>4.00.1181<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等到提示<code>No errors uploading</code>时就代表上传成功了。</p><h2 id="五、上传结果的查看"><a href="#五、上传结果的查看" class="headerlink" title="五、上传结果的查看"></a>五、上传结果的查看</h2><p>可以去开发者中心-活动里面查看一下是否有构建版本<br><img src="https://upload-images.jianshu.io/upload_images/293993-a23bf6bf0729862d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节：iOS 安装包-编译&amp;打包</title>
      <link href="/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/iOS%20%E5%AE%89%E8%A3%85%E5%8C%851-%E7%BC%96%E8%AF%91&amp;%E6%89%93%E5%8C%85/"/>
      <url>/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/iOS%20%E5%AE%89%E8%A3%85%E5%8C%851-%E7%BC%96%E8%AF%91&amp;%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="iOS-安装包-编译-amp-打包"><a href="#iOS-安装包-编译-amp-打包" class="headerlink" title="iOS 安装包-编译&amp;打包"></a>iOS 安装包-编译&amp;打包</h1><p><img src="/iOS/自动化/iOS 安装包1-编译&打包/iOS 安装包1-编译&amp;打包/error1_nosigningcer.png" alt="error1_nosigningcer"></p><p>原因：本地钥匙串中缺少iOS发布证书，即缺少<code>Apple Distribution: xxx Co.,Ltd. (yyy)</code>。</p><p><img src="/iOS/自动化/iOS 安装包1-编译&打包/iOS 安装包1-编译&amp;打包/error1_nosigningcer_solve.png" alt="error1_nosigningcer_solve"></p><p>小技巧，为了减少命令编译的错误次数，我们可以使用XCode的界面操作先自己编译导出一次。</p><p>如下，在导出的时候遇到如下错误。</p><p><img src="/iOS/自动化/iOS 安装包1-编译&打包/iOS 安装包1-编译&amp;打包/error3_noprofiles.png" alt="error3_noprofiles"></p><h2 id="自动打包时候，自动更新添加进去的设备-Library-MobileDevice-Provisioning-Profiles"><a href="#自动打包时候，自动更新添加进去的设备-Library-MobileDevice-Provisioning-Profiles" class="headerlink" title="自动打包时候，自动更新添加进去的设备~/Library/MobileDevice/Provisioning Profiles"></a>自动打包时候，自动更新添加进去的设备~/Library/MobileDevice/Provisioning Profiles</h2><p>进入<code>~/Library/MobileDevice/Provisioning Profiles</code>查看证书文件，</p><p>参考文章：<a href="https://blog.csdn.net/jackyzheng/article/details/79219187" target="_blank" rel="noopener">自动打包时候，自动更新添加进去的设备</a></p><p>Provisioning profile实际上包含了Device ID，因此更新Provisioning profile就可以更新Device ID。根据xcode编译提示在archive阶段加入了-allowProvisioningUpdates这个参数的，应该会自动更新。</p><p>实时新增用户反馈<font color="\" warning\""="">132例</font>，请相关同事注意。</p><p>​            类型:<font color="\" comment\""="">用户反馈</font></p><p>​            普通用户反馈:<font color="\" comment\""="">117例</font></p><p>​            VIP用户反馈:<font color="\" comment\""="">15例</font></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化</title>
      <link href="/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/iOS%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
      <url>/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/iOS%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS-单元测试及自动化测试-只看这篇就够了"><a href="#iOS-单元测试及自动化测试-只看这篇就够了" class="headerlink" title="iOS 单元测试及自动化测试(只看这篇就够了)"></a>iOS 单元测试及自动化测试(只看这篇就够了)</h1><p><a href="https://www.jianshu.com/p/5b38dd41a20a" target="_blank" rel="noopener">https://www.jianshu.com/p/5b38dd41a20a</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化</title>
      <link href="/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/iOS%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/iOS/%E8%87%AA%E5%8A%A8%E5%8C%96/iOS%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS-单元测试及自动化测试-只看这篇就够了"><a href="#iOS-单元测试及自动化测试-只看这篇就够了" class="headerlink" title="iOS 单元测试及自动化测试(只看这篇就够了)"></a>iOS 单元测试及自动化测试(只看这篇就够了)</h1><p><a href="https://www.jianshu.com/p/5b38dd41a20a" target="_blank" rel="noopener">https://www.jianshu.com/p/5b38dd41a20a</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本检查</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="版本检查"><a href="#版本检查" class="headerlink" title="版本检查"></a>版本检查</h1><h2 id="一、思维脑图"><a href="#一、思维脑图" class="headerlink" title="一、思维脑图"></a>一、思维脑图</h2><p>思维脑图：请点击查看<a href="./版本检查.xmind">版本检查.xmind</a></p><h2 id="二、版本修改"><a href="#二、版本修改" class="headerlink" title="二、版本修改"></a>二、版本修改</h2><h3 id="1、iOS版本设置"><a href="#1、iOS版本设置" class="headerlink" title="1、iOS版本设置"></a>1、iOS版本设置</h3><p>略</p><h3 id="2、Android版本修改"><a href="#2、Android版本修改" class="headerlink" title="2、Android版本修改"></a>2、Android版本修改</h3><p>进入<code>bulid.gradle</code>文件，修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutterVersionName  =<span class="string">"1."</span>+<span class="keyword">new</span> Date().format(<span class="string">"MM.dd"</span>, TimeZone.getTimeZone(<span class="string">"GMT+8:00"</span>))</span><br><span class="line"></span><br><span class="line">flutterVersionCode = <span class="keyword">new</span> Date().format(<span class="string">"MMddHHmm"</span>, TimeZone.getTimeZone(<span class="string">"GMT+8:00"</span>)) <span class="comment">// 需要versionCode每次都要比上次大，与版本无关</span></span><br></pre></td></tr></table></figure><h3 id="3、Jenkins中的版本设置"><a href="#3、Jenkins中的版本设置" class="headerlink" title="3、Jenkins中的版本设置"></a>3、Jenkins中的版本设置</h3><p>进入Jenkins指定iOS项目的配置，修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VERSION="1."$(date "+%m.%d") # 1.02.21</span><br><span class="line">BUILD=$(date "+%H%M") # 1506</span><br><span class="line">echo "------VERSION:$&#123;VERSION&#125;"</span><br><span class="line">echo "------BUILD:$&#123;BUILD&#125;"</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络框架</title>
      <link href="/Architecture%E6%9E%B6%E6%9E%84/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
      <url>/Architecture%E6%9E%B6%E6%9E%84/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h1><p>思维脑图：请点击查看<a href="./网络框架.xmind">网络框架.xmind</a></p><p>网络模拟文档请查看：<a href="./网络ApiMock">网络ApiMock</a></p>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac中个各种文件夹</title>
      <link href="/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/Mac%E4%B8%AD%E4%B8%AA%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
      <url>/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/Mac%E4%B8%AD%E4%B8%AA%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="Mac中个各种文件夹"><a href="#Mac中个各种文件夹" class="headerlink" title="Mac中个各种文件夹"></a>Mac中个各种文件夹</h2><h3 id="1、Mac系统自带的桌面壁纸在哪个文件夹"><a href="#1、Mac系统自带的桌面壁纸在哪个文件夹" class="headerlink" title="1、Mac系统自带的桌面壁纸在哪个文件夹"></a>1、Mac系统自带的桌面壁纸在哪个文件夹</h3><p><img src="/电脑使用/Mac中个各种文件夹/image-20210123223301377.png" alt="image-20210123223301377"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>终端常用命令</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Terminal/1%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Terminal/1%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="一、brew-安装"><a href="#一、brew-安装" class="headerlink" title="一、brew 安装"></a>一、brew 安装</h2><p>Mac系统是使用brew命令install，而brew的安装需要通过ruby安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装ruby</span></span><br><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure><p>其他：</p><p>brew update -》更新homebrew到最新版本</p><p>brew doctor -》检查homebrew状态</p><h1 id="二、brew-使用"><a href="#二、brew-使用" class="headerlink" title="二、brew 使用"></a>二、brew 使用</h1><p>建议安装前，先执行遍<code>brew update</code></p><h3 id="1、使用-brew-安装-卸载-node、npm"><a href="#1、使用-brew-安装-卸载-node、npm" class="headerlink" title="1、使用 brew 安装/卸载 node、npm"></a>1、使用 brew 安装/卸载 node、npm</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line">brew uninstall node</span><br></pre></td></tr></table></figure><p>使用 <code>brew install node</code> 安装即可。(如果已存在，则使用<code>brew upgrade node</code>)</p><p>安装完成npm就ok啦～</p><p>可以使用 <code>npm -v</code> 看下效果</p><h3 id="2、使用brew安装nvm"><a href="#2、使用brew安装nvm" class="headerlink" title="2、使用brew安装nvm"></a>2、使用brew安装nvm</h3><p>brew update<br>brew install nvm</p><p>npm install npm@latest -g</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="1、版本相关命令"><a href="#1、版本相关命令" class="headerlink" title="1、版本相关命令"></a>1、版本相关命令</h3><table><thead><tr><th>命令描述</th><th>命令举例</th><th>备注</th></tr></thead><tbody><tr><td>查看node版本</td><td>node –v</td><td></td></tr><tr><td>查看版本详情</td><td>npm version</td><td></td></tr><tr><td>查看npm最新版本号</td><td>npm view npm version</td><td></td></tr><tr><td>查看npm所有的版本号</td><td>npm view npm versions</td></tr></tbody></table><h3 id="2、升级相关命令"><a href="#2、升级相关命令" class="headerlink" title="2、升级相关命令"></a>2、升级相关命令</h3><table><thead><tr><th>命令描述</th><th>命令举例</th><th></th></tr></thead><tbody><tr><td>安装最新稳定版</td><td>nvm install stable</td><td></td></tr><tr><td>升级到最新版</td><td>npm install npm@latest -g</td><td></td></tr><tr><td>升级到指定版本</td><td>npm install npm@xx -g</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第1节：Jenkins的安装与启动</title>
      <link href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
      <url>/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Jenkins/Jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="第1节：Jenkins的安装与启动"><a href="#第1节：Jenkins的安装与启动" class="headerlink" title="第1节：Jenkins的安装与启动"></a>第1节：Jenkins的安装与启动</h1><p>自己的文章：</p><p>①、<a href="https://www.jianshu.com/p/126c9e6b63ef" target="_blank" rel="noopener">Jenkins(一)初步认识</a></p><h2 id="一、Jenkins的安装"><a href="#一、Jenkins的安装" class="headerlink" title="一、Jenkins的安装"></a>一、Jenkins的安装</h2><p>①、直接下载<a href="https://jenkins.io/index.html" target="_blank" rel="noopener">Jenkins</a>安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install jenkins-lts</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Stable：稳定版本。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> LTS（Long Term Support）：长期演进版</span></span><br></pre></td></tr></table></figure><p>②、安装成功后，其会自动打开<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a></p><p>此时如果我们发现打开错误。原因是我们缺少Jenkins的运行环境，所以我们需要安装java的jdk。如果要验证是否是这个原因的话，我们可以<code>通过命令行查看当前的java版本</code><br><img src="/实用工具/Jenkins/Jenkins的安装与启动/Java.png" alt="Java"><br>果然发现没有安装，则我们通过下载jdk来进行安装。<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">java的jdk下载地址</a><br><img src="/实用工具/Jenkins/Jenkins的安装与启动/jenkins_jdk1.png" alt="jenkins_jdk1"><br><img src="/实用工具/Jenkins/Jenkins的安装与启动/jenkins_jdk2.png" alt="jenkins_jdk2"><br>安装完后，我们再运行一下验证命令，发现可以运行了，即我们安装好了。<br><img src="/实用工具/Jenkins/Jenkins的安装与启动/Java.png" alt="Java"></p><p>③、java环境安装成功之后，接下来我们就可以正常访问Jenkins了。Jenkins的访问地址为<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a>。打开的页面显示如下：<br><img src="/实用工具/Jenkins/Jenkins的安装与启动/jenkins_3.png" alt="jenkins_3"></p><p>④、提示我们需要输入其指定文件夹下的密码来访问。则我们访问其指定文件，发现没法访问该文件内容<br><img src="/实用工具/Jenkins/Jenkins的安装与启动/jenkins_4.png" alt="jenkins_4"><br><img src="/实用工具/Jenkins/Jenkins的安装与启动/jenkins_noPermission1.png" alt="jenkins_noPermission1"></p><p>所以这里我们通过修改权限，让读取该文件内容，如下：<br><img src="/实用工具/Jenkins/Jenkins的安装与启动/jenkins_noPermission2.png" alt="jenkins_noPermission2"><br>⑤、将读取后的密码输入到登录网页上，即可登录，登录后的结果为：<br><img src="/实用工具/Jenkins/Jenkins的安装与启动/jenkins_start1.png" alt="jenkins_start1"></p><p>⑥、因为此时为首次登陆，所以其会提示我们安装Jenkins建议的插件。则我们按照步骤进行Jenkins默认插件的安装。安装过程如下所示：<br><img src="/实用工具/Jenkins/Jenkins的安装与启动/jenkins_start2.jpg" alt="jenkins_start2"><br><img src="/实用工具/Jenkins/Jenkins的安装与启动/jenkins_start3.jpg" alt="jenkins_start3"></p><p>⑦、一路安装过来，输入用户名，密码。<br>之后继续登录<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>可以看到最终的显示结果为：<br><img src="/实用工具/Jenkins/Jenkins的安装与启动/jenkins_use1.png" alt="jenkins_use1"><br>此时则我们的Jenkins的初始安装完毕(之后我们可能还需要安装一些自己需要的插件)。</p><h2 id="二、Jenkins的启动"><a href="#二、Jenkins的启动" class="headerlink" title="二、Jenkins的启动"></a>二、Jenkins的启动</h2><p>没有权限问题的Jenkins正确的启动方式如下(按下面方式打开，才不会出现权限问题)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -jar /Applications/Jenkins/jenkins.war --httpPort=8080</span></span><br></pre></td></tr></table></figure><p>当你执行完这两行命令的时候，你可以在浏览器上输入<code>http://localhost:8080</code>来访问Jenkins了。(如果你只执行了第一行，没执行第二行，会出现无法访问)</p><h2 id="三、Jenkins的升级"><a href="#三、Jenkins的升级" class="headerlink" title="三、Jenkins的升级"></a>三、Jenkins的升级</h2><h3 id="1、如何查看jenkins-的版本号"><a href="#1、如何查看jenkins-的版本号" class="headerlink" title="1、如何查看jenkins 的版本号"></a>1、如何查看jenkins 的版本号</h3><p>jenkins页面的右下角就是jenkins版本号信息</p><p><img src="/实用工具/Jenkins/Jenkins的安装与启动/image-20200927143448781.png" alt="image-20200927143448781"></p><p><img src="/实用工具/Jenkins/Jenkins的安装与启动/image-20200927143111985.png" alt="image-20200927143111985"></p><p><img src="/实用工具/Jenkins/Jenkins的安装与启动/image-20200927233412864.png" alt="image-20200927233412864"></p><p><img src="/实用工具/Jenkins/Jenkins的安装与启动/image-20200927234036120.png" alt="image-20200927234036120"></p><p>要执行下载好的版本</p><p><img src="/实用工具/Jenkins/Jenkins的安装与启动/image-20200928001116531.png" alt="image-20200928001116531"></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CocoaPods库部署</title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/CocoaPods/CocoaPods%E5%BA%93%E9%83%A8%E7%BD%B2/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/%E5%BA%93%E7%AE%A1%E7%90%86/CocoaPods/CocoaPods%E5%BA%93%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="搜索库pod-search"><a href="#搜索库pod-search" class="headerlink" title="搜索库pod search"></a>搜索库<code>pod search</code></h3><p>如果你在终端执行<code>pod search xxx</code>，未得到上面的结果，是因为cocoaPods的本地search_index.json文件有问题，<br>方法①：请前往<code>~/Library/Caches/CocoaPods/search_index.json</code>将该文件删除，<br>方法②：或者直接在终端输入：<code>rm ~/Library/Caches/CocoaPods/search_index.json</code>，<br>删除后，再重新执行命令即可。</p><h2 id="一、远程库"><a href="#一、远程库" class="headerlink" title="一、远程库"></a>一、远程库</h2><h3 id="1、添加库的版本"><a href="#1、添加库的版本" class="headerlink" title="1、添加库的版本"></a>1、添加库的版本</h3><h4 id="1-1、添加公有库的版本"><a href="#1-1、添加公有库的版本" class="headerlink" title="1.1、添加公有库的版本"></a>1.1、添加公有库的版本</h4><h4 id="1-2、添加私有库的版本"><a href="#1-2、添加私有库的版本" class="headerlink" title="1.2、添加私有库的版本"></a>1.2、添加私有库的版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash">验证方法1：</span></span><br><span class="line"> pod lib lint CQBaseUIKit.podspec --sources='https://github.com/CocoaPods/Specs.git,https://gitee.com/dvlproad/dvlproadSpecs' --allow-warnings --use-libraries --verbose</span><br><span class="line"><span class="meta">#</span><span class="bash">验证方法2：</span></span><br><span class="line">pod lib lint CQBaseUIKit.podspec --sources=master,dvlproad --allow-warnings --use-libraries --verbose</span><br><span class="line"><span class="meta">#</span><span class="bash">提交方法： </span></span><br><span class="line">pod repo push dvlproad CQBaseUIKit.podspec --sources=master,dvlproad --allow-warnings --use-libraries --verbose</span><br></pre></td></tr></table></figure><p>不需要过多验证的话，简洁版：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo push dvlproad CQThemeUIKit.podspec --allow-warnings</span><br></pre></td></tr></table></figure><h3 id="2、删除库的某个版本"><a href="#2、删除库的某个版本" class="headerlink" title="2、删除库的某个版本"></a>2、删除库的某个版本</h3><h4 id="2-1、删除公有库的某个版本"><a href="#2-1、删除公有库的某个版本" class="headerlink" title="2.1、删除公有库的某个版本"></a>2.1、删除公有库的某个版本</h4><h4 id="2-2、删除私有库的某个版本"><a href="#2-2、删除私有库的某个版本" class="headerlink" title="2.2、删除私有库的某个版本"></a>2.2、删除私有库的某个版本</h4><p>CocoaPods创建公有Pod库后删除特定版本来纠正意外推送</p><p>可以删除一个POD的特定版本来纠正意外推送。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk delete PODNAME VERSION</span><br></pre></td></tr></table></figure><h3 id="3、放弃整个库"><a href="#3、放弃整个库" class="headerlink" title="3、放弃整个库"></a>3、放弃整个库</h3><p>你也可以放弃整个POD和所有版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk deprecate PODNAME</span><br></pre></td></tr></table></figure><p>确认时，请回复一个”y”(小写字母 y)</p><h2 id="二、本地库"><a href="#二、本地库" class="headerlink" title="二、本地库"></a>二、本地库</h2><h3 id="1、库的本地位置"><a href="#1、库的本地位置" class="headerlink" title="1、库的本地位置"></a>1、库的本地位置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 库目录</span></span><br><span class="line">~/.cocoapods/repos/dvlproad</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocoaPods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%20Feature/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%20Feature/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-feature"><a href="#Git-feature" class="headerlink" title="Git feature"></a>Git feature</h2><h2 id="使用Git-Flow工作流："><a href="#使用Git-Flow工作流：" class="headerlink" title="使用Git Flow工作流："></a>使用Git Flow工作流：</h2><p><img src="/代码管理/Git Feature/image-20220301145230642.png" alt="image-20220301145230642" style="zoom:33%;"></p><p><img src="/代码管理/Git Feature/image-20220301145504810.png" alt="image-20220301145504810" style="zoom:33%;"></p><p>输入对应的生产环境分支名和开发分支名，如果输入的分支不存在，则会弹出如下提示：</p><p><img src="/代码管理/Git Feature/image-20220301152403882.png" alt="image-20220301152403882" style="zoom:50%;"></p><p>git 项目默认自动创建 master 主分支；<br>点击仓库–&gt; git flow 或 hg fow –&gt;初始化仓库，初始化仓库并创建develop开发分支；</p><p><img src="/代码管理/Git Feature/git_feature_init1.png" alt="在这里插入图片描述"></p><p>创建 feature 功能分支：</p><p>双击 Sourcetree 左侧的 develop 开发分支，切换到 develop 开发分支；<br>点击仓库–&gt; git flow 或 hg fow –&gt;建立新的功能，输入功能名称，点击确定即可；</p><ol><li><p><img src="/代码管理/Git Feature/git_feature_create1.png" alt="在这里插入图片描述"></p><p><img src="/代码管理/Git Feature/git_feature_create2.png" alt="在这里插入图片描述" style="zoom:25%;"></p><p><img src="/代码管理/Git Feature/git_feature_create3.png" alt="在这里插入图片描述"></p></li></ol><h6 id="完成-feature-功能分支："><a href="#完成-feature-功能分支：" class="headerlink" title="完成 feature 功能分支："></a>完成 feature 功能分支：</h6><p>当 feature 功能分支开发完成后，即可将 feature 中的代码合并到 develop 分支中。</p><p>提交 feature 功能分支的代码到远程；<br>在 feature 分支上，点击仓库–&gt; git flow 或 hg fow –&gt;完成功能；</p><p><img src="/代码管理/Git Feature/git_feature_finish1.png" alt="在这里插入图片描述"></p><p>feature 功能分支中的代码合并到了develop 开发分支，feature 分支被删除；</p><p>创建 release 发布分支：</p><p>双击 Sourcetree 左侧的 develop 开发分支，切换到 develop 开发分支；<br>点击仓库–&gt; git flow 或 hg fow –&gt;建立新的发布版本，输入发布版本号，点击确定即可；<br>完成 release 发布分支：</p><p>在 release 分支上，点击仓库–&gt; git flow 或 hg fow –&gt;完成发布版本，发布完成后 release 分支的代码同时合并到了 master 分支和 develop 分支。</p><p>创建 hotfix 补丁分支：</p><p>在 master 分支上，点击仓库–&gt; git flow 或 hg fow –&gt;建立新的修复补丁。</p><p>完成 hotfix 补丁分支：</p><p>在 hotfix 分支上，点击仓库–&gt; git flow 或 hg fow –&gt;完成修复补丁，合并完成后 hotfix 的代码同时合并到了 master 分支和 develop 分支。</p>]]></content>
      
      
      <categories>
          
          <category> 代码管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Log</title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%20Log/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%20Log/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-log"><a href="#Git-log" class="headerlink" title="Git log"></a>Git log</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log --merges --after="2022-10-13" --oneline --decorate</span><br><span class="line">git log --after="2022-10-13" --oneline --decorate</span><br><span class="line"></span><br><span class="line">git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative --all --after '10-13-2022' --merges</span><br></pre></td></tr></table></figure><p>查看历史版本记录–指定显示条数</p><p>同时，与git log相同的是，git reflog也提供了控制显示条数的选项：</p><p>命令：git reflog -n </p><h2 id="1、获取本分支合入指定分支的commitId"><a href="#1、获取本分支合入指定分支的commitId" class="headerlink" title="1、获取本分支合入指定分支的commitId"></a>1、获取本分支合入指定分支的commitId</h2><p>有些时候需要解析分支，tag，或者其他对于提交的间接引用。对于这种情况，你可以使用<code>git rev-parse</code>命令。下面的命令返回指向<code>development</code>分支的提交哈希串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-parse development</span><br></pre></td></tr></table></figure><p>这对于编写只接受提交ID作为参数的自定义脚本非常有用。你可以使用<code>git rev-parse</code>命令来标准化脚本的输入，进而进入对于提交的统一处理。这就避免了脚本用户需要手动解析提交的引用。</p><h2 id="二、获取commitId的信息"><a href="#二、获取commitId的信息" class="headerlink" title="二、获取commitId的信息"></a>二、获取commitId的信息</h2><h3 id="1、获取commitId的提交信息"><a href="#1、获取commitId的提交信息" class="headerlink" title="1、获取commitId的提交信息"></a>1、获取commitId的提交信息</h3><p>想要将此哈希串作为参数传递给其他Git命令，只需要提供足够长度的字符串就可以了。比如说，你可以通过下面的命令来传入上面的哈希串，以便使用<code>git show</code>命令查看那次提交的具体内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git show 0c708f</span><br><span class="line"></span><br><span class="line">git show -s --oneline 3d21461a7ef205ed0cee0baf45e95e782f4e84af</span><br></pre></td></tr></table></figure><h3 id="2、获取commitId的根源远程分支"><a href="#2、获取commitId的根源远程分支" class="headerlink" title="2、获取commitId的根源远程分支"></a>2、获取commitId的根源远程分支</h3><h4 id="①、获取有哪些远程分支里已经合入了commitId"><a href="#①、获取有哪些远程分支里已经合入了commitId" class="headerlink" title="①、获取有哪些远程分支里已经合入了commitId"></a>①、获取有哪些远程分支里已经合入了commitId</h4><ul><li><a href="https://www.jianshu.com/p/6ad6981f8ec5" target="_blank" rel="noopener">git获取某次commit是在哪个分支提交的</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --contains eb0633b76925041f84b592a2e261e0b8537953f7 -r # -r标识远程分支</span><br></pre></td></tr></table></figure><h4 id="②、第一个合入commitId的远程分支，即为commitId的根源分支"><a href="#②、第一个合入commitId的远程分支，即为commitId的根源分支" class="headerlink" title="②、第一个合入commitId的远程分支，即为commitId的根源分支"></a>②、第一个合入commitId的远程分支，即为commitId的根源分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">branchResultForFisrtCommit=$(git branch --contains "$&#123;firstCommitId&#125;" -r)</span><br><span class="line">echo "$&#123;branchResultForFisrtCommit&#125;"</span><br><span class="line"></span><br><span class="line">branchArrayForFisrtCommit=($&#123;branchResultForFisrtCommit&#125;)</span><br><span class="line">branchCountForFisrtCommit=$&#123;#branchArrayForFisrtCommit[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="string">"branchCountForFisrtCommit=<span class="variable">$branchCountForFisrtCommit</span>"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">for</span> ((i=0;i&lt;branchCountForFisrtCommit;i+=1))</span></span><br><span class="line"><span class="meta">#</span><span class="bash">&#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    branchName=<span class="variable">$&#123;branchArrayForFisrtCommit[i]&#125;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="built_in">echo</span> <span class="string">"branchName=<span class="variable">$&#123;branchName&#125;</span>"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">&#125;</span></span><br><span class="line"></span><br><span class="line">echo "\n------下面开始获取firstCommitId:$&#123;firstCommitId&#125;的提交所属的根源远程功能分支名------"</span><br><span class="line">sourceBranchForFisrtCommit=$&#123;branchArrayForFisrtCommit[$&#123;branchCountForFisrtCommit&#125;-1]&#125;</span><br><span class="line">echo "sourceBranchForFisrtCommit=$&#123;sourceBranchForFisrtCommit&#125;"</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Rebase</title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%20Rebase/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%20Rebase/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h2><h3 id="【Git系列】git-rebase详解"><a href="#【Git系列】git-rebase详解" class="headerlink" title="【Git系列】git rebase详解"></a>【Git系列】git rebase详解</h3><p><a href="https://www.jianshu.com/p/4a8f4af4e803" target="_blank" rel="noopener">【Git】rebase 用法小结</a><br><a href="https://www.cnblogs.com/pinefantasy/articles/6287147.html" target="_blank" rel="noopener">【Git系列】git rebase详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Search</title>
      <link href="/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%20Search/"/>
      <url>/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/Git%20Search/</url>
      
        <content type="html"><![CDATA[<h2 id="Git查看分支从哪个分支创建的"><a href="#Git查看分支从哪个分支创建的" class="headerlink" title="Git查看分支从哪个分支创建的"></a>Git查看分支从哪个分支创建的</h2><p>查看分支创建时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog show --date=iso &lt;branch name&gt;</span><br></pre></td></tr></table></figure><p>举例如图：</p><p><img src="/代码管理/Git Search/Git/查看Git分支从哪创建.png" alt="查看Git分支从哪创建"></p><p>最老的那条记录即可以看出是从哪创建出来的。</p><p>但有时候记录太多，滑动太长，可以直接使用如下命令，直接查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog dev_environment | grep "Created from"</span><br></pre></td></tr></table></figure><p>如果是feature分支 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog show --date=iso feature/设备小程序</span><br></pre></td></tr></table></figure><p><img src="/代码管理/Git Search/Git Feature/image-20220301145230642.png" alt="image-20220301145230642"></p>]]></content>
      
      
      <categories>
          
          <category> 代码管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我的</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>这是我的关于页，这个我在后续再补充！感谢您的点击查阅</p>]]></content>
      
    </entry>
    
    
  
</search>
