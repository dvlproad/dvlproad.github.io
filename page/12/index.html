<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>dvlproadの博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学而时习之不亦说乎(dvlproad)">
<meta name="keywords" content="blog,IT,iOS,Flutter">
<meta property="og:type" content="website">
<meta property="og:title" content="dvlproadの博客">
<meta property="og:url" content="https://dvlproad.github.io/page/12/index.html">
<meta property="og:site_name" content="dvlproadの博客">
<meta property="og:description" content="学而时习之不亦说乎(dvlproad)">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dvlproadの博客">
<meta name="twitter:description" content="学而时习之不亦说乎(dvlproad)">
  
    <link rel="alternate" href="/atom.xml" title="dvlproadの博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">dvlproadの博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">整理及总结平时过程中的知识点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://dvlproad.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS/3必备知识架构/2内存/2内存-②循环引用Timer" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/" class="article-date">
  <time datetime="2022-03-16T05:35:04.597Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-内存-②循环引用Timer"><a href="#必备知识架构-内存-②循环引用Timer" class="headerlink" title="必备知识架构-内存-②循环引用Timer"></a>必备知识架构-内存-②循环引用Timer</h1><p>–</p>
<h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p>
<p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p>
<p></p><p id="目录"></p><p></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#NSTimer">九、NSTimer</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、NSTimer和NSRunLoop的关系？</span><br><span class="line">2、NSTimer使用细节</span><br><span class="line">3、NSTimer的创建</span><br><span class="line">4、NSTimer的循环引用</span><br><span class="line">5、NSTimer使用的优化</span><br><span class="line">&gt;</span><br><span class="line">6、NSTimer的销毁问题</span><br><span class="line">(1)、子线程中NSTimer的创建和销毁问题</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p>
</li>
<li><p><a href="#END">END</a></p>
</li>
</ul>
<p></p><p id="NSTimer"></p><p></p>
<h2 id="九、NSTimer"><a href="#九、NSTimer" class="headerlink" title="九、NSTimer"></a>九、NSTimer</h2><blockquote>
<p>&lt; <a href="#目录">返回目录</a></p>
</blockquote>
<h3 id="1、NSTimer的创建"><a href="#1、NSTimer的创建" class="headerlink" title="1、NSTimer的创建"></a>1、NSTimer的创建</h3><p>NSTimer的创建通常有两种方式，尽管都是类方法，一种是timerWithXXX，另一种scheduedTimerWithXXX。</p>
<p>二者最大的区别就是后者除了创建一个定时器外会自动以NSDefaultRunLoopModeMode添加到当前线程RunLoop中，不添加到RunLoop中的NSTimer是无法正常工作的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController1 ()</span><br><span class="line">@property (nonatomic, weak) NSTimer *timer1;</span><br><span class="line">@property (nonatomic, weak) NSTimer *timer2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation ViewController1</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.timer1 = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timeInterval1:) userInfo:nil repeats:YES];</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    错误做法：</span><br><span class="line">    self.timer2 = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timeInterval2:) userInfo:nil repeats:YES];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:self.timer2 forMode:NSDefaultRunLoopMode];</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    //正确做法：</span><br><span class="line">    //特别注意：timer2创建时并没直接赋值给timer2。</span><br><span class="line">    //原因是timer2是weak属性，如果直接赋值给timer2会被立即释放。</span><br><span class="line">    //因为timerWithXXX方法创建的NSTimer默认并没有加入RunLoop，只有后面加入RunLoop以后才可以将引用指向timer2。从而导致执行到addTimer:forMode的时候，访问了野指针而发生EXC_BAD_ACCESS，崩溃。</span><br><span class="line">    NSTimer *tempTimer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timeInterval2:) userInfo:nil repeats:YES];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:tempTimer forMode:NSDefaultRunLoopMode];</span><br><span class="line">    self.timer2 = tempTimer;</span><br><span class="line">    。。。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)timeInterval1:(id)object &#123;</span><br><span class="line">    NSLog(@&quot;111&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timeInterval2:(id)object &#123;</span><br><span class="line">    NSLog(@&quot;222&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="2、NSTimer的修饰符"><a href="#2、NSTimer的修饰符" class="headerlink" title="2、NSTimer的修饰符"></a>2、NSTimer的修饰符</h3><p><strong>runloop强制持有timer(runloop-&gt;timer),timer会强制持有其target，未处理的情况下一般都是self(timer-&gt;self)，导致self无法释放。</strong><br>虽然设置timer为weak属性时候，self未强制持有timer,没构成循环应用，但还是导致了self无法释放的问题，dealloc无法执行。</p>
<h3 id="2、NSTimer的循环引用"><a href="#2、NSTimer的循环引用" class="headerlink" title="2、NSTimer的循环引用"></a>2、NSTimer的循环引用</h3><p>关于循环引用，我们先看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController1 ()</span><br><span class="line">@property (nonatomic, strong) NSTimer *timer;//注意这里的属性不是为weak,从而很容易引起循环引用</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation ViewController1</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    // 代码标记1 (产生timer与self之前的强引用，如下图中的L3强引用线)</span><br><span class="line">    NSTimer *timer = [[NSTimer alloc] initWithFireDate:[NSDate date] interval:1 target:self selector:@selector(timerFire) userInfo:nil repeats:YES];</span><br><span class="line">    // 代码标记2 (产生RunLoop与timer之间的强引用，如下图中的L4强引用线)</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">    // 代码标记3 (产生self与timer之间的强引用，，如下图中的L2强引用线)</span><br><span class="line">    self.timer = timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timerFire &#123;</span><br><span class="line">    NSLog(@&quot;timer fire&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>假设代码中的视图控制器由UINavigationController管理，由于self.timer是strong类型，则强引用可以表示如下：</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/2内存-②循环引用/NSTimer循环引用例子1.png" alt="NSTimer循环引用例子1"></p>
</blockquote>
<p>由于，很容易看出来，由于timer本身在创建时候已经与self发生了强引用（<strong>不管target使用<code>weak</code>还是<code>strong</code>修饰，timer都会对target强引用。</strong>）。而赋值时候又由于timer是被设为strong的，而导致self与timer之间也发生了强引用，最终这两个强引用，就形成了循环引用。</p>
<p>所以，</p>
<p>①、首先，我们先解决循环引用，为了解决timer的循环应用问题，我们上面的timer属性应该使用weak。设置成weak后，L2就消失了。</p>
<p>②、但是<strong>即使使用了弱引用，上面的代码中ViewController1在pop退出的时候也无法正常释放，原因是在创建NSTimer时指定了target为self，这样一来造成了timer对ViewController1有一个强引用</strong>。从而导致，timer没释放的时候，viewController也是不会被释放的。<strong>为了让timer能够释放，我们就需要调用NSTimer的invalidate方法</strong>（注意：无论是重复执行的定时器还是一次性的定时器只要调用invalidate方法则会变得无效，只是一次性的定时器执行完操作后会自动调用invalidate方法）。所以，假设在viewController pop回去前，我们通过一个按钮来让timer调用invalidate方法，那么viewController在pop回去时候，就能够被释放了。</p>
<p>问题是我们一般不会有这个按钮操作，那么这时候让timer调用invalidate方法的操作，应该写在哪里呢。这时候，你可能会想到那就写在viewDidDisappear中呗。但是一旦在viewWillDisappear中写<code>[timer invalidate]; timer = nil;</code>那么你也得把timer的创建放在viewWillAppear中。因为我们可能执行的是push跳到下一页,再返回来的操作。然而显然将timer的创建放在viewWillAppear中这样的方式，显然会是导致当timer可能需要频繁添加。所以，我们放弃此方法，还是把timer的创建放在viewDidLoad中，然后考虑其他方法。</p>
<p>所以，我们最后<strong>为了让ViewController1在pop退出的时候不会因为timer的强引用，而导致无法正常释放。我们选择转移timer中的target</strong>。这样就能确保，viewController在pop退出的时候能够正常释放，从而调用viewController的dealloc方法。</p>
<blockquote>
<p>附：转移timer中的target的方法通常有两种：</p>
</blockquote>
<p>一种是将target分离出来独立成一个对象（在这个对象中创建NSTimer并将对象本身作为NSTimer的target），控制器通过这个对象间接使用NSTimer；</p>
<blockquote>
</blockquote>
<p>另一种方式的思路仍然是转移target，只是可以直接增加NSTimer扩展（分类），让NSTimer自身做为target，同时可以将操作selector封装到block中。</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/2内存-②循环引用/NSTimer转移target方法二.jpg" alt="NSTimer转移target方法二"><br>图中参考<a href="https://github.com/mBrissman/NSTimer-Block" target="_blank" rel="noopener">NSTimer+Block</a></p>
</blockquote>
<p>后者相对优雅，也是目前使用较多的方案。显然Apple也认识到了这个问题，如果你可以确保代码只在iOS 10下运行就可以使用iOS 10新增的系统级block方案（上面的代码中已经贴出这种方法）。</p>
<p>③、如果不做②中的转移timer的target的话，那么viewController就会无法释放，造成内存泄露。<br>但是，我们发现<strong>通过转移timer的target后，虽然解决了UIViewController1因为被timer强引用而导致的在pop回来的时候无法释放的问题。</strong>我们的计时器，却在UIViewController1 pop退出被释放后，两个定时器仍然在运行，也就是它还没被释放。所以，我们还需要解决timer的释放。那怎么让timer释放呢？答：<strong>如果要让timer释放掉的话，需要调用NSTimer的invalidate方法</strong>（注意：无论是重复执行的定时器还是一次性的定时器只要调用invalidate方法则会变得无效，只是一次性的定时器执行完操作后会自动调用invalidate方法）。<br><strong>invalidate方法有2个功能：一是将timer从runloop中移除，那么图中的L4就消失，二是timer本身也会释放它持有资源，比如它的target、userinfo、block等，因为这里的target是self，所以强引用L3也就消失。</strong><br>所以，最终当viewController在pop退出的时候，其正常释放并调用了dealloc放。我们只需要在dealloc方法中，添加上timer调用invalidate的方法，即可以解决viewController被释放了，但timer没被释放的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    NSLog(@&quot;ViewController1 dealloc...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，一个完整的timer过程，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure>
<h3 id="3、NSTimer和NSRunLoop的关系？"><a href="#3、NSTimer和NSRunLoop的关系？" class="headerlink" title="3、NSTimer和NSRunLoop的关系？"></a>3、NSTimer和NSRunLoop的关系？</h3><p>只要出现NSTimer必须要有NSRunLoop，NSTimer必须依赖NSRunLoop才能执行 。NSTimer其实也是一种资源，如果看过多线程编程指引文档的话，我们会发现所有的source如果要起作用，就得加到runloop中去。同理timer这种资源要想起作用，那肯定也需要加到runloop中才会生效喽。如果一个runloop里面不包含任何资源的话，运行该runloop时会立马退出。</p>
<p>NSRunLoop与timer有关方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addTimer:(NSTimer *)timer forMode:(NSString *)mode; //在run loop上注册timer</span><br></pre></td></tr></table></figure>
<p>注意事项:</p>
<blockquote>
<p>我们通常在主线程中使用NSTimer，有个实际遇到的问题需要注意。当滑动界面时，系统为了更好地处理UI事件和滚动显示，主线程runloop会暂时停止处理一些其它事件，这时主线程中运行的NSTimer就会被暂停。解决办法就是改变NSTimer运行的mode（mode可以看成事件类型），不使用缺省的NSDefaultRunLoopMode，而是改用NSRunLoopCommonModes，这样主线程就会继续处理NSTimer事件了。具体代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timer:) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<h3 id="4、NSTimer使用细节："><a href="#4、NSTimer使用细节：" class="headerlink" title="4、NSTimer使用细节："></a>4、NSTimer使用细节：</h3><p>NSTimer上的定时任务是在创建NSTimer的线程上执行的。NSTimer的销毁和创建必须在同一个线程上操作<br>NSTimer要被添加到当前线程的 Runloop 里面且 Runloop 被启动，定时任务（selector或者invocation）才会触发。</p>
<p>以下内容摘自：<a href="https://www.cnblogs.com/mddblog/p/6517377.html" target="_blank" rel="noopener">NSTimer定时器进阶——详细介绍，循环引用分析与解决</a></p>
<ol>
<li>它需要被添加到runloop，否则不会运行，当然添加的runloop不存在也不会运行；</li>
<li>还要指定添加到的runloop的哪个模式，而且还可以指定添加到runloop的多个模式，模式不对也是不会运行的</li>
<li><strong>runloop会对timer有强引用，timer会对目标对象进行强引用(是否隐约的感觉到坑了。。。)</strong></li>
<li>timer的执行时间并不准确，系统繁忙的话，还会被跳过去。(具体的两种不准时，请查看原文)</li>
<li>invalidate调用后，timer停止运行后，就一定能从runloop中消除吗，资源？？？？invalidate方法的调用必须在timer添加到的runloop所在的线程，如果不在的话：由于调用invalidate 方法后，timer本身会释放掉它自己持有的资源比如target、userinfo、block，图中的L3会消失。但是runloop不会释放timer，即图中的L4不会消失，假设，self被pop了–&gt;L1无效–&gt;self引用计数为0,self释放–&gt;L2也消失。此时就剩runloop、timer、L4，timer也就永远不会释放了，造成内存泄露。</li>
</ol>
<p>NSTimer的强引用问题举例:</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/2内存-②循环引用/NSTimer的强引用问题举例.png" alt="NSTimer的强引用问题举例"></p>
</blockquote>
<h4 id="5、NSTimer使用的优化"><a href="#5、NSTimer使用的优化" class="headerlink" title="5、NSTimer使用的优化"></a>5、NSTimer使用的优化</h4><p>问：为什么要在非主线程创建NSTimer？</p>
<ul>
<li>将 timer 添加到主线程的Runloop里面本身会增加线程负荷；</li>
<li>如果主线程因为某些原因阻塞卡顿了，timer 定时任务触发的时间精度肯定也会受到影响；</li>
<li>有些定时任务不是UI相关的，本来就没必要在主线程执行，给主线程增加不必要的负担。当然也可以在定时任务执行时，手动将任务指派到非主线程上，但这也是有额外开销的。</li>
</ul>
<h4 id="6、NSTimer的销毁问题"><a href="#6、NSTimer的销毁问题" class="headerlink" title="6、NSTimer的销毁问题"></a>6、NSTimer的销毁问题</h4><p>前面我们已经简单讲过要让NSTimer销毁释放的时候，只能通过调用其invalidate来达到销毁目的。关于invalidate的第一个作用以及它在哪个线程调用的问题，我的理解如下：</p>
<p>invalidate方法的第一个作用将timer从runloop中移除。这里的runLoop指的应该是当前的runLoop，而不是timer被添加到的runLoop，这个纯属个人理解，未验证，因为如果是其添加的runLoop的话，那子线程timer的销毁，就不会有人说还要和timer所在的线程一致了。所以，这里的个人理解有如下：</p>
<p><em>为了销毁timer和去除runloop与timer之间的强引用</em>，我们调用了timer的invalidate方法。</p>
<blockquote>
<p>1、对于invalidate方法的调用是写在必须在timer所添加到的runloop所在的线程（如主线程）的时候，invalidate方法会将timer从runloop中移除，并且释放它持有资源。即上面的L4和L3都消失。</p>
<p>2、对于invalidate方法的调用不是写在必须在timer所添加到的runloop所在的线程的时候（如子线程中添加timer，在主线程中调用该timer的invalidate），虽然timer本身会释放掉它自己持有的资源比如target、userinfo、block，图中的L3会消失。但是runloop不会释放timer，即图中的L4不会消失，假设，self被pop了–&gt;L1无效–&gt;self引用计数为0,self释放–&gt;L2也消失。此时就剩runloop、timer、L4，timer也就永远不会释放了，造成内存泄露。</p>
<p>如果invalidate方法的调用的位置不更改的话，这时候要让L4消失的方法，</p>
<p>方法①手动销毁runloop。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    //[[NSRunLoop currentRunLoop] run]; //将原本的方法注释掉</span><br><span class="line">    NSDate *date = [NSDate dateWithTimeIntervalSinceNow:5.f];</span><br><span class="line">    [[NSRunLoop currentRunLoop] runUntilDate:date]; //让runloop在5s后销毁</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这种方式，只适用于销毁时间确定的情况。那如果销毁时间不确定怎么办？</p>
<p>方法②：因为<strong>当某个线程销毁时，其runloop也随之销毁</strong>，所以方法二即为通过销毁timer所在的线程，来达到销毁runloop的目的。如果是在主线程，线程一直存在，我们没法让主线程销毁。</p>
</blockquote>
<p>所以，下面我们讨论的是<em>在子线程中添加timer的时候，<strong>如果</strong>该timer的invalidate方法的调用位置不是写在对应子线程，而是写在主线程的时候，我们该怎么通过销毁子线程，来销毁runLoop。从而接触该runloop对timerd的强引用？</em></p>
<h5 id="6-1子线程中NSTimer的创建和销毁问题"><a href="#6-1子线程中NSTimer的创建和销毁问题" class="headerlink" title="6.1子线程中NSTimer的创建和销毁问题"></a>6.1子线程中NSTimer的创建和销毁问题</h5><p>我们按上诉2中②的讨论描述的：子线程中添加timer的时候，如果该timer的invalidate方法的调用位置不是写在对应子线程，而是写在主线程的时候，写出的对应代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) NSTimer *threadTimer; //子线程timer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    // 开辟子线程</span><br><span class="line">    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)newThread &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSThread *currentThread = [NSThread currentThread];</span><br><span class="line">        [currentThread setName:@&quot;这是子线程&quot;];</span><br><span class="line">        </span><br><span class="line">        self.threadTimer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(threadTimerAction) userInfo:nil repeats:YES];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)threadTimerAction &#123;</span><br><span class="line">    static NSInteger counter = 0;</span><br><span class="line">    </span><br><span class="line">    NSString *isMainThreadDescription = [NSThread isMainThread] ? @&quot;YES&quot; : @&quot;NO&quot;;</span><br><span class="line">    NSLog(@&quot;当前方法执行的线程：%@, 它是否是主线程:%@, counter = %@&quot;, [NSThread currentThread], isMainThreadDescription, @(counter++));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，我们该怎么通过销毁子线程，来销毁runLoop。从而接触该runloop对timerd的强引用？即怎么销毁线程？</p>
<p>乍看当在子线程开启runloop后，timer会一直在子线程中运行，所以子线程不会销毁，runloop也就无法停止，runloop也就没法销毁，runloop与timer之间的强引用则还是被保留着，这似乎又是个死循环。但实际上，<em>由于上述代码runloop的mode item只有Timer，所以只要销毁timer，runloop就会退出。</em>所以，上述的代码是没问题的，不存在内存泄露问题。</p>
<p>附：NSTimer上的定时任务是在创建NSTimer的线程上执行的。</p>
<p>–</p>
<p>附：以上NSTimer的内容，有空的话还可参考<a href="https://www.imooc.com/article/22331" target="_blank" rel="noopener">NSTimer,NSRunLoop,autoreleasepool,多线程的爱恨情仇</a>，它那边讲的，和这边自己理解的基本是一样的。只是对于有些点的介绍详细不一定一样而已。</p>
<p>其他有空可看<a href="http://www.cocoachina.com/ios/20150710/12444.html" target="_blank" rel="noopener">iOS 中的 NSTimer</a></p>
<p></p><p id="常见笔试/面试题"></p><p></p>
<h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/" data-id="cm121y2zu017cqar48lpyqis9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/2内存/2内存-②Block" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-②Block/" class="article-date">
  <time datetime="2022-03-16T05:35:04.594Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-内存-②Block"><a href="#必备知识架构-内存-②Block" class="headerlink" title="必备知识架构-内存-②Block"></a>必备知识架构-内存-②Block</h1><p>[toc]</p>
<h2 id="iOS-Block本质"><a href="#iOS-Block本质" class="headerlink" title="iOS-Block本质"></a>iOS-Block本质</h2><p><a href="https://www.jianshu.com/p/4e79e9a0dd82" target="_blank" rel="noopener">iOS-Block本质</a></p>
<p>block本质上也是一个OC对象，它内部也有个isa指针，最终继承NSObject。</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSGlobalBlock &lt;--__NSGlobalBlock &lt;--NSBlock &lt;-- NSObject</span><br></pre></td></tr></table></figure>
<h4 id="Q：block有哪几种类型-及-各类型的block在内存中如何分配的？"><a href="#Q：block有哪几种类型-及-各类型的block在内存中如何分配的？" class="headerlink" title="Q：block有哪几种类型 及 各类型的block在内存中如何分配的？"></a>Q：block有哪几种类型 及 各类型的block在内存中如何分配的？</h4><p>block的类型，取决于isa指针，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型。</p>
<p><strong>堆</strong>：动态分配内存，需要程序员自己申请，程序员自己管理</p>
<p><strong>栈</strong>：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况</p>
<ul>
<li><p><strong>NSGlobalBlock </strong> 在数据区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void (^block1)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;block1&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>NSMallocBlock </strong> 在堆区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age1 = 1;</span><br><span class="line">void (^block2)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;block2:%d&quot;, age1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>NSStackBlock </strong> 在栈区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age2 = 2;</span><br><span class="line">NSLog(@&quot;%@&quot;, [^&#123;</span><br><span class="line">        NSLog(@&quot;block3:%d&quot;, age2);</span><br><span class="line">    &#125; class]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>附：打印block类型<code>NSLog(@&quot;%@&quot;, [block1 class]);</code></p>
<h2 id="问：以下各情况，Person的对象什么时候才销毁？或Person对象在block上是如何操作的？"><a href="#问：以下各情况，Person的对象什么时候才销毁？或Person对象在block上是如何操作的？" class="headerlink" title="问：以下各情况，Person的对象什么时候才销毁？或Person对象在block上是如何操作的？"></a>问：以下各情况，Person的对象什么时候才销毁？或Person对象在block上是如何操作的？</h2><p>有Person类如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;Person dealloc&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>了解解题的基础知识：</p>
<h4 id="1、当对象类型的auto变量被block内部访问时，是强引用还是弱引用？-延伸：引用过后，block内部无法修改auto变量值，除非使用-block"><a href="#1、当对象类型的auto变量被block内部访问时，是强引用还是弱引用？-延伸：引用过后，block内部无法修改auto变量值，除非使用-block" class="headerlink" title="1、当对象类型的auto变量被block内部访问时，是强引用还是弱引用？(延伸：引用过后，block内部无法修改auto变量值，除非使用__block)"></a>1、当对象类型的auto变量被block内部访问时，是强引用还是弱引用？(延伸：引用过后，block内部无法修改auto变量值，除非使用__block)</h4><ul>
<li>如果block在<code>栈</code>空间，不管外部变量是强引用还是弱引用，block都会弱引用访问对象</li>
<li>如果block在<code>堆</code>空间，如果外部强引用，block内部也是强引用；如果外部弱引用，block内部也是弱引用</li>
</ul>
<p>2、GCD API的方法参数block，在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上。</p>
<h4 id="附：在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上的几种情况？"><a href="#附：在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上的几种情况？" class="headerlink" title="附：在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上的几种情况？"></a>附：在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上的几种情况？</h4><ul>
<li><p>1.block作为函数返回值时</p>
</li>
<li><p>2.将block赋值给__strong指针时</p>
</li>
<li><p>3.block作为Cocoa API中方法名含有usingBlock的方法参数时</p>
</li>
<li><p>4.block作为GCD API的方法参数时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1、问：-下列代码中的Person的对象什么时候才销毁？"><a href="#1、问：-下列代码中的Person的对象什么时候才销毁？" class="headerlink" title="1、问： 下列代码中的Person的对象什么时候才销毁？"></a>1、问： 下列代码中的Person的对象什么时候才销毁？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = 10;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;age:%d&quot;, person.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：方法代码执行完就person就销毁了</p>
<h3 id="2、问：以下gcd的block中引用-Person的对象什么时候才销毁？"><a href="#2、问：以下gcd的block中引用-Person的对象什么时候才销毁？" class="headerlink" title="2、问：以下gcd的block中引用 Person的对象什么时候才销毁？"></a>2、问：以下gcd的block中引用 Person的对象什么时候才销毁？</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">// 不使用__weak修饰</span></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age:%d"</span>, person.age);	<span class="comment">// 堆block会对Person强引用，故而也就只有block销毁时候Person才会被释放。这里是2秒后销毁。</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"touchesBegan"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：</p>
<p>1、gcd的block默认会做copy操作，即dispatch_after的block是堆block。</p>
<p>2、我们知道<code>如果block在堆空间，如果外部强引用，block内部也是强引用；如果外部弱引用，block内部也是弱引用</code>。</p>
<p>所以这里外部的Person没有声明为__weak，所以堆block会对Person强引用，故而也就只有block销毁时候Person才会被释放。这里是2秒后销毁。(如果没有gcd)</p>
<h3 id="3、续问：如果上述Person被添加上-weak修饰，那Person什么时候释放？会造成什么问题？"><a href="#3、续问：如果上述Person被添加上-weak修饰，那Person什么时候释放？会造成什么问题？" class="headerlink" title="3、续问：如果上述Person被添加上__weak修饰，那Person什么时候释放？会造成什么问题？"></a>3、续问：如果上述Person被添加上__weak修饰，那Person什么时候释放？会造成什么问题？</h3><p>续答：此时上述的代码会变为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = 10;</span><br><span class="line">    </span><br><span class="line">  	// 不使用__weak修饰</span><br><span class="line">    __weak Person *weakPerson = person;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;person:%p&quot;, weakPerson);	// 当Person被添加上__weak修饰后，堆block会对Person弱引用。而在touchesBegan函数结束后，由于Person就会被释放，所以2秒后gcd无法捕捉到Person的后果。所以此处person 是 nil，打印的%p地址，是0x0。</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;touchesBegan&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，还是我们知道<code>如果block在堆空间，如果外部强引用，block内部也是强引用；如果外部弱引用，block内部也是弱引用</code>。所以当Person被添加上__weak修饰后，堆block会对Person弱引用。而在touchesBegan函数结束后，由于Person就会被释放，所以2秒后gcd无法捕捉到Person的后果。即上述的输出结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person 是 nil，打印的%p地址，是0x0。</span><br></pre></td></tr></table></figure>
<h3 id="4、上述代码使用-weak后，变量被释放了，那怎么防止block持有的对象提前释放"><a href="#4、上述代码使用-weak后，变量被释放了，那怎么防止block持有的对象提前释放" class="headerlink" title="4、上述代码使用__weak后，变量被释放了，那怎么防止block持有的对象提前释放"></a>4、上述代码使用__weak后，变量被释放了，那怎么防止block持有的对象提前释放</h3><h4 id="Q：block的属性修饰词为什么是copy？"><a href="#Q：block的属性修饰词为什么是copy？" class="headerlink" title="Q：block的属性修饰词为什么是copy？"></a>Q：block的属性修饰词为什么是copy？</h4><p>block一旦没有进行copy操作，就不会在堆上<br>block在堆上，程序员就可以对block做内存管理等操作，可以控制block的生命周期</p>
<h4 id="Q：当block被copy到堆时，对-block修饰的变量做了什么？"><a href="#Q：当block被copy到堆时，对-block修饰的变量做了什么？" class="headerlink" title="Q：当block被copy到堆时，对__block修饰的变量做了什么？"></a>Q：当block被copy到堆时，对__block修饰的变量做了什么？</h4><ul>
<li>会调用block内部的copy函数</li>
<li>copy函数内部会调用_Block_object_assign函数</li>
<li>_Block_object_assign函数会对__block变量形成强引用（retain）</li>
<li>对于__block 修饰的变量 assign函数对其强引用；对于外部对象 assign函数根据外部如何引用而引用</li>
</ul>
<h4 id="Q：当block从堆中移除时，对-block修饰的变量做了什么？"><a href="#Q：当block从堆中移除时，对-block修饰的变量做了什么？" class="headerlink" title="Q：当block从堆中移除时，对__block修饰的变量做了什么？"></a>Q：当block从堆中移除时，对__block修饰的变量做了什么？</h4><ul>
<li>会调用block内部的dispose函数</li>
<li>dispose函数内部会调用_Block_object_dispose函数</li>
<li>_Block_object_dispose函数会自动释放引用的__block变量（release）</li>
</ul>
<h2 id="二、-block修饰符"><a href="#二、-block修饰符" class="headerlink" title="二、__block修饰符"></a>二、__block修饰符</h2><h4 id="Q：-block-int-age-10，系统做了哪些？"><a href="#Q：-block-int-age-10，系统做了哪些？" class="headerlink" title="Q：__block int age = 10，系统做了哪些？"></a>Q：<code>__block</code> int age = 10，系统做了哪些？</h4><h4 id="Q：-block-修饰符作用？"><a href="#Q：-block-修饰符作用？" class="headerlink" title="Q：__block 修饰符作用？"></a>Q：__block 修饰符作用？</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-②Block/" data-id="cm121y2yv0178qar4t17wm8nh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/2内存/2内存-①修饰词" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-①修饰词/" class="article-date">
  <time datetime="2022-03-16T05:35:04.583Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-①语言Swift"><a href="#必备知识架构-①语言Swift" class="headerlink" title="必备知识架构-①语言Swift"></a>必备知识架构-①语言Swift</h1><p>[Toc]</p>
<h2 id="一、Copy"><a href="#一、Copy" class="headerlink" title="一、Copy"></a>一、Copy</h2><ol>
<li><p>如何让自己的类用<code>copy</code>修饰符</p>
<blockquote>
<p>若想令自己所写的对象具有拷贝功能，则需实现<code>NSCopying</code>协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现<code>NSCopying</code>与<code>NSMutableCopying</code>协议。<br>具体步骤：<br>1.需声明该类遵从<code>NSCopying</code>协议<br>2.实现<code>NSCopying</code>协议的方法，具体区别<a href="https://www.jianshu.com/p/f84803356cbb" target="_blank" rel="noopener">戳这里</a></p>
</blockquote>
</li>
</ol>
<ul>
<li><code>NSCopying</code>协议方法为：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">  MyObject *<span class="keyword">copy</span> = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone: zone] init];</span><br><span class="line">  <span class="keyword">copy</span>.username = <span class="keyword">self</span>.username;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">copy</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1、浅拷贝和深拷贝的区别"><a href="#1、浅拷贝和深拷贝的区别" class="headerlink" title="1、浅拷贝和深拷贝的区别"></a>1、浅拷贝和深拷贝的区别</h3><blockquote>
<p><strong>浅层复制：只复制指向对象的指针，而不复制引用对象本身。</strong><br><strong>深层复制：复制引用对象本身。</strong></p>
<p>意思就是说我有个A对象，复制一份后得到A_copy对象后,</p>
<p>对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。<br>而对于深复制就好理解了,内存中存在了两份独立对象本身。</p>
<p>通俗的话将就是：<br>浅复制好比你和你的影子，你完蛋，你的影子也完蛋;<br>深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。</p>
</blockquote>
<h3 id="2、-iOS-Copy-与-MutableCopy"><a href="#2、-iOS-Copy-与-MutableCopy" class="headerlink" title="2、 iOS - Copy 与 MutableCopy"></a>2、 iOS - Copy 与 MutableCopy</h3><p><a href="http://www.jianshu.com/p/63239d4d65e0" target="_blank" rel="noopener">iOS - Copy 与 MutableCopy</a><br>①copy：因为<strong>copy默认返回的是不可变的</strong>，所以当我们对一个不可变的字符串进行copy的时候，我们只是拷贝了它的指针（浅拷贝）。当我们对一个可变的字符串进行拷贝的时候，因为类型转变了，我们需对其进行深拷贝。<br>②<strong>mutableCopy：默认返回的是一个可变的对象</strong>，适用于可变的对象，例如NSMutableString，NSMutableArray，NSMutableDictionary、etc。  无论对于可变的字符串还是不可变的字符串进行mutableCopy，系统都默认进行深拷贝。</p>
<p><a href="https://www.jianshu.com/p/700f58eb0b86" target="_blank" rel="noopener">其他参考</a></p>
<h4 id="1-、copy到底是深拷贝还是浅拷贝？"><a href="#1-、copy到底是深拷贝还是浅拷贝？" class="headerlink" title="(1)、copy到底是深拷贝还是浅拷贝？"></a>(1)、copy到底是深拷贝还是浅拷贝？</h4><p>当我们对一个不可变对象（NSString类型）使用copy关键字的时候，系统是不会产生一个新对象，因为原来的对象是不能修改的，拷贝出来的对象也是不能修改的，那么既然两个都不可以修改，所以这两个对象永远也不会影响到另一个对象（符合我们说的“修改新（旧）对象，不影响旧（新）对象”原则），系统为了节省内存，所以就不会产生一个新的对象了。那么问题来了，<strong>copy到底是深拷贝还是浅拷贝？答：是否是深浅拷贝，是否创建新的对象，是由程序运行的环境所造成的，并不是一概而论。</strong></p>
<h4 id="2-、这个写法会出什么问题-property-nonatomic-copy-NSMutableArray-mutableArray"><a href="#2-、这个写法会出什么问题-property-nonatomic-copy-NSMutableArray-mutableArray" class="headerlink" title="(2)、这个写法会出什么问题@property (nonatomic, copy) NSMutableArray *mutableArray;"></a>(2)、这个写法会出什么问题<code>@property (nonatomic, copy) NSMutableArray *mutableArray;</code></h4><blockquote>
<p>添加，删除，修改数组内元素的时候，程序会因为找不到对应的方法而崩溃。原因：</p>
<p>self.mutableArray = xxx；在copy的修饰下执行的是 self.mutableArray = [xxx copy]；进行了浅拷贝，得到的是一个xxx的副本，且该副本是一个不可变的数组。导致在运行的时候，其实你的mutableArray已经是NSArray类了。从而在添加，删除，修改数组内元素的时候，程序会因为找不到对应的方法而崩溃。</p>
</blockquote>
<h3 id="3、为什么NSArray用copy修饰、NSMutableArray用strong修饰"><a href="#3、为什么NSArray用copy修饰、NSMutableArray用strong修饰" class="headerlink" title="3、为什么NSArray用copy修饰、NSMutableArray用strong修饰"></a>3、为什么NSArray用copy修饰、NSMutableArray用strong修饰</h3><blockquote>
<p>把NSMutableArray用copy修饰有时就会crash，因为copy后的数组变成了不可变数组NSArray.当你对不可变数组NSArray进行增删改操作的时候就会crash，<br>举例如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①NSMutableArray用copy属性造成的crash：</span><br><span class="line">@property (nonatomic, copy) NSMutableArray *mutableArray1; // 会崩溃</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *mutableArray2; // 正确</span><br><span class="line"></span><br><span class="line">NSMutableArray *array = [NSMutableArray arrayWithArray:@[[Model1 new], [Model1 new]]];</span><br><span class="line">self.mutableArray1 = array; // copy： mutableArray1是array的副本，且通过打印验证是浅拷贝。且此时aArray的值mArray的一个副本，该副本是通过[mArray copy]进行的浅拷贝得到的一个不可变新对象，即类型在执行时候变为了 NSArray了。所以，如果对归属为NSArray了的aArray执行NSMutableArray才有的如removeAllObjects的方法时，就会崩溃。</span><br><span class="line">self.mutableArray2 = array; // strong:mutableArray1是array自身</span><br></pre></td></tr></table></figure>
<p><strong>当修饰可变类型的属性时，如NSMutableArray、NSMutableDictionary、NSMutableString，用strong。</strong></p>
<p><strong>当修饰不可变类型的属性时，如NSArray、NSDictionary、NSString，用copy。</strong></p>
<h3 id="4、模型数组深拷贝"><a href="#4、模型数组深拷贝" class="headerlink" title="4、模型数组深拷贝"></a>4、模型数组深拷贝</h3><p>通常需要实现对模型的拷贝都需要先实现<code>NSCopying、 NSMutableCopying</code>协议。注意：如果是数组使用拷贝操作是不会对数组内实现copy协议的对象进行深拷贝的。</p>
<p>参考文章：<a href="https://www.jianshu.com/p/a75fc0677036" target="_blank" rel="noopener">iOS 模型数组深拷贝</a></p>
<p>1、最笨的方法就是通过遍历逐个拷贝元素</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (Person *person <span class="keyword">in</span> dataSourceAry) &#123;</span><br><span class="line">    [array addObject:[person <span class="keyword">copy</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、也有人使用归档解档实现数组内部元素拷贝</p>
<p>3、这么好用的一个方法现在才发现（推荐）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithArray:(<span class="built_in">NSArray</span>&lt;ObjectType&gt; *)array copyItems:(<span class="built_in">BOOL</span>)flag</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> &lt;Person *&gt;*deepCopyAry = [[<span class="built_in">NSArray</span> alloc]initWithArray:dataSourceAry copyItems:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"&lt;dataSourceAry: %@&gt;"</span>, dataSourceAry);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"&lt;deepCopyAry: %@&gt;"</span>, deepCopyAry);</span><br><span class="line">    </span><br><span class="line">[deepCopyAry enumerateObjectsUsingBlock:^(Person *obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    obj.name = <span class="string">@"弗兰克"</span>;</span><br><span class="line">    obj.dog.name = <span class="string">@"弗兰克的dog"</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="4、分析NSString、NSMutableString等类的copy、mutableCopy"><a href="#4、分析NSString、NSMutableString等类的copy、mutableCopy" class="headerlink" title="4、分析NSString、NSMutableString等类的copy、mutableCopy"></a>4、分析NSString、NSMutableString等类的copy、mutableCopy</h3><blockquote>
<p>在语言文章中，我们已经说明对于语句<code>NSString *obj = [[NSData alloc] init];</code> obj在编译时是NSString的类型；运行时是NSData类型的对象。</p>
<p>由此得出的结论是，不要被编译时的类型蒙蔽，还要看实际运行时的类型。</p>
</blockquote>
<h6 id="1-、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？"><a href="#1-、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？" class="headerlink" title="(1)、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？"></a>(1)、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？</h6><blockquote>
<p>你可以片面理解为</p>
<p><code>copy</code>是[NSString alloc]，所以生成的都是不可变的；<br><code>mutableCopy</code>是[NSMutableString alloc]，所以生成的都是可变的；</p>
</blockquote>
<p>所以以下代码的结果，即为代码中的注释一样</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;NSString *str1 = @&quot;test001&quot;;</span><br><span class="line">&gt;	    </span><br><span class="line">&gt;NSMutableString *str2 = [str1 copy];</span><br><span class="line">&gt;//编译时，str2是NSMutableString类型。因为是把str2声明为可变字符串，所以str2即为声明的可变字符串</span><br><span class="line">&gt;//运行时，str2是NSString类型。因为是copy，所以不管str1是可变不可变，str2都是不可变字符串</span><br><span class="line">&gt;</span><br><span class="line">&gt;NSMutableString *str3 = [str1 mutableCopy];</span><br><span class="line">&gt;//编译时，str3是NSMutableString类型。因为是把str3声明为可变字符串，所以str3即为声明的可变字符串</span><br><span class="line">&gt;//运行时，str3是NSMutableString类型。因为是mutableCopy，所以不管str1是可变不可变，str3都是可变字符串</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="2-、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？"><a href="#2-、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？" class="headerlink" title="(2)、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？"></a>(2)、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</h6><blockquote>
<p><code>copy</code>：对[string copy]是浅拷贝，即不会开辟新地址，而对[mutableString copy]是深拷贝，会开辟新地址。</p>
<p><code>mutableCopy</code>：不管是对[string mutableCopy]，还是对[mutableString mutableCopy]，都是深拷贝，都会开辟新地址。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)testCopy &#123;</span><br><span class="line">    NSString *testStr = [NSString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">    id copyedStr = [testStr copy];</span><br><span class="line">    id mutableCopyStr = [testStr mutableCopy];</span><br><span class="line">    NSLog(@&quot;===    对NSString变量进行copy、mutableCopy得到的地址和类型分别是    ===&quot;);</span><br><span class="line">    NSLog(@&quot;testStr        = %p, class: %@&quot;, testStr, NSStringFromClass([testStr class]));</span><br><span class="line">    NSLog(@&quot;copyedStr      = %p, class: %@&quot;, copyedStr, NSStringFromClass([copyedStr class]));</span><br><span class="line">    NSLog(@&quot;mutableCopyStr = %p, class: %@&quot;, mutableCopyStr, NSStringFromClass([mutableCopyStr class]));</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">    id copyedMutableStr = [testMutableStr copy];</span><br><span class="line">    id mutableCopyMutableStr = [testMutableStr mutableCopy];</span><br><span class="line">    NSLog(@&quot;=== 对NSMutableString变量进行copy、mutableCopy得到的地址和类型分别是 ===&quot;);</span><br><span class="line">    NSLog(@&quot;testMutableStr        = %p, class: %@&quot;, testMutableStr, NSStringFromClass([testMutableStr class]));</span><br><span class="line">    NSLog(@&quot;copyedMutableStr      = %p, class: %@&quot;, copyedMutableStr, NSStringFromClass([copyedMutableStr class]));</span><br><span class="line">    NSLog(@&quot;mutableCopyMutableStr = %p, class: %@&quot;, mutableCopyMutableStr, NSStringFromClass([mutableCopyMutableStr class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-①修饰词/2内存-①基础/copy&amp;mutableCopy.jpg" alt="对NSString、NSMutableString变量进行copy、mutableCopy得到的地址和类型分别是"></p>
<p><strong>结论：分别对NSString、NSMutableString进行copy、mutableCopy操作，只有NSString copy是浅拷贝</strong>。</p>
</blockquote>
<h6 id="3-、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？-附：NSString用copy修饰是为什么"><a href="#3-、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？-附：NSString用copy修饰是为什么" class="headerlink" title="(3)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？(附：NSString用copy修饰是为什么)"></a>(3)、将NSString、NSMutableString变量赋值给<em>用copy、strong修饰</em>的<code>NSString</code>属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？(附：NSString用copy修饰是为什么)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *copyedStr;</span><br><span class="line">@property (nonatomic, strong) NSString *strongStr;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *copyedMutableStr;</span><br><span class="line">@property (nonatomic, strong) NSString *strongMutableStr;</span><br><span class="line"></span><br><span class="line">///将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候</span><br><span class="line">- (void)testCopy &#123;</span><br><span class="line">    NSString *testStr = [NSString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">    self.copyedStr = testStr;</span><br><span class="line">    self.strongStr = testStr;</span><br><span class="line">    NSLog(@&quot;===    将NSString变量赋值给用copy、strong修饰的NSString属性的时候    ===&quot;);</span><br><span class="line">    NSLog(@&quot;testStr   = %p&quot;, testStr);</span><br><span class="line">    NSLog(@&quot;copyedStr = %p&quot;, self.copyedStr);</span><br><span class="line">    NSLog(@&quot;strongStr = %p&quot;, self.strongStr);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">    self.copyedMutableStr = testMutableStr;</span><br><span class="line">    self.strongMutableStr = testMutableStr;</span><br><span class="line">    NSLog(@&quot;=== 将NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候 ===&quot;);</span><br><span class="line">    NSLog(@&quot;testMutableStr   = %p&quot;, testMutableStr);</span><br><span class="line">    NSLog(@&quot;copyedMutableStr = %p&quot;, self.copyedMutableStr);</span><br><span class="line">    NSLog(@&quot;strongMutableStr = %p&quot;, self.strongMutableStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-①修饰词/2内存-①基础/copy1.jpg" alt="将NSString、NSMutableString赋值给用copy、strong修饰的NSString变量"></p>
</blockquote>
<p>可以看出，</p>
<p>①将NSString变量赋值给用copy、strong修饰的NSString属性的时候，不管是strong还是copy属性的对象，其指向的地址都是同一个，即为string指向的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *copyedStr;</span><br><span class="line">@property (nonatomic, strong) NSString *strongStr;</span><br><span class="line"></span><br><span class="line">NSString *testStr = [NSString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">self.copyedStr = testStr;</span><br><span class="line">self.strongStr = testStr;</span><br></pre></td></tr></table></figure>
<p>②将NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，</p>
<p>此时copy属性字符串<code>copyedMutableStr</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *copyedMutableStr;</span><br><span class="line"></span><br><span class="line">NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">self.copyedMutableStr = testMutableStr;</span><br></pre></td></tr></table></figure>
<p>深拷贝了testMutableStr字符串，并让copyedMutableStr对象指向这个字符串(即copyedMutableStr和testMutableStr只是对象值一样，但不是同一个了)。所以此时，我们如果去修改testMutableStr字符串的话，可以看到，我们用<code>@property (nonatomic, copy) NSString *copyedMutableStr;</code>修饰的<code>copyedMutableStr</code>能够不会因为其赋值源<code>testMutableStr</code>的改变而改变，也就保证了安全性。</p>
<p>而strong属性字符串<code>strongMutableStr</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *strongMutableStr;</span><br><span class="line"></span><br><span class="line">NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">self.strongMutableStr = testMutableStr;</span><br></pre></td></tr></table></figure>
<p>因为strongMutableStr与testMutableStr是指向同一对象，所以strongMutableStr的值也会跟随着改变；</p>
<p>综上：所以，<strong>在声明NSString属性时，到底是选择strong还是copy，可以根据实际情况来定。不过，一般我们将对象声明为NSString时，都不希望它改变(包括不希望赋值后，其他原来的值的改变会改变到它)，所以大多数情况下，我们建议用copy，以免因可变字符串的修改导致的一些非预期问题。</strong>使用copy来修饰无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本,这样更安全。</p>
<h6 id="4-、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSMutableString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？"><a href="#4-、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSMutableString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？" class="headerlink" title="(4)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSMutableString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？"></a>(4)、将NSString、NSMutableString变量赋值给用copy、strong修饰的<code>NSMutableString</code>属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSMutableString *copyedStr;</span><br><span class="line">@property (nonatomic, strong) NSMutableString *strongStr;</span><br><span class="line"></span><br><span class="line">NSString *testStr = [NSString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">self.copyedStr = testStr;</span><br><span class="line">self.strongStr = testStr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSMutableString *copyedMutableStr;</span><br><span class="line"></span><br><span class="line">NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">self.copyedMutableStr = testMutableStr;</span><br></pre></td></tr></table></figure>
<p><strong>2.自定义类如何让它具有copy功能?</strong><br>遵守NScoping协议，实现copywithzone方法即可.</p>
<h6 id="5-、自己代码实现copy修饰符，应该怎么写？？？？"><a href="#5-、自己代码实现copy修饰符，应该怎么写？？？？" class="headerlink" title="(5)、自己代码实现copy修饰符，应该怎么写？？？？"></a>(5)、自己代码实现copy修饰符，应该怎么写？？？？</h6><h4 id="4、NSCoding和NSCopy"><a href="#4、NSCoding和NSCopy" class="headerlink" title="4、NSCoding和NSCopy"></a>4、NSCoding和NSCopy</h4><p><a href="http://my.oschina.net/megan/blog/181463?p=1" target="_blank" rel="noopener">NSCoding和NSCopy</a></p>
<h6 id="1-、NSCoding的作用"><a href="#1-、NSCoding的作用" class="headerlink" title="(1)、NSCoding的作用"></a>(1)、NSCoding的作用</h6><p><a href="http://blog.csdn.net/qq5306546/article/details/9240283" target="_blank" rel="noopener">iOS通过NSCoding保存实体对象</a></p>
<p>很多时候我们都需要将对象序列化，比如将一个对象存入到NSUserDefault 里面去的时候，由于NSUserDefault支持存入的类型有限制，所以很多时候我们需要将NSObject类型的对象转换成NSData再存入进去。</p>
<h6 id="2-、NSCopy"><a href="#2-、NSCopy" class="headerlink" title="(2)、NSCopy"></a>(2)、NSCopy</h6><p>当你要进行对象拷贝的时候需要遵循NSCopy协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    id copy = [[[self class] alloc] init];</span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        [copy setId:[self.id copyWithZone:zone]];</span><br><span class="line">        [copy setNickName:[self.nickName copyWithZone:zone]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、-synthesize和-dynamic区别"><a href="#5、-synthesize和-dynamic区别" class="headerlink" title="5、@synthesize和@dynamic区别"></a>5、@synthesize和@dynamic区别</h4><p><a href="http://www.cnblogs.com/xiaodao/archive/2012/10/09/2716244.html" target="_blank" rel="noopener">@synthesize和@dynamic区别</a></p>
<p>在声明property属性后，有2种实现选择</p>
<ul>
<li>@synthesize</li>
</ul>
<p>编译器期间，让编译器自动生成getter/setter方法。当有自定义的存或取方法时，自定义会屏蔽自动生成该方法</p>
<ul>
<li>@dynamic</li>
</ul>
<p>告诉编译器，不自动生成getter/setter方法，避免编译期间产生警告，然后由自己实现存取方法，或存取方法在运行时动态创建绑定：主要使用在CoreData的实现NSManagedObject子类时使用，由Core Data框架在程序运行的时动态生成子类属性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-①修饰词/" data-id="cm121y2yd0176qar477cxdahp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/2内存/2内存-①基础" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-①基础/" class="article-date">
  <time datetime="2022-03-16T05:35:04.583Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-内存"><a href="#必备知识架构-内存" class="headerlink" title="必备知识架构-内存"></a>必备知识架构-内存</h1><p>[toc]</p>
<h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p>
<p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p>
<p></p><p id="目录"></p><p></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#指针">一、指针</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、几个本质</span><br><span class="line">&gt;</span><br><span class="line">2、空指针和未初始化的指针</span><br><span class="line">(1)、空指针和未初始化的指针的区别：</span><br><span class="line">(2)、为什么指针变量定义时一定要初始化？ </span><br><span class="line">&gt;</span><br><span class="line">3、野指针与悬空指针</span><br><span class="line">(1)、指针与内存的常见使用顺序</span><br><span class="line">(2)、内存泄漏的概念</span><br><span class="line">(3)、野指针概念</span><br><span class="line">(4)、在iOS中野指针的后果</span><br><span class="line">(5)、分析野指针的产生原因及解决办法</span><br><span class="line">&gt;</span><br><span class="line">4、iOS NSerror 用双重指针理解</span><br><span class="line">&gt;</span><br><span class="line">5、指针和引用的区别</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><a href="#内存">二、内存</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、堆和栈的区别?</span><br><span class="line">&gt;</span><br><span class="line">2、浅拷贝和深拷贝的区别</span><br><span class="line">&gt;</span><br><span class="line">3、分析NSString、NSMutableString等类的copy、mutableCopy</span><br><span class="line">(1)、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？</span><br><span class="line">(2)、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</span><br><span class="line">(3)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</span><br><span class="line">(4)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSMutableString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</span><br><span class="line">(5)、自己代码实现copy修饰符，应该怎么写？？？？</span><br><span class="line">&gt;</span><br><span class="line">4、NSCoding和NSCopy</span><br><span class="line">(1)、NSCoding的作用</span><br><span class="line">(2)、NSCopy</span><br><span class="line">&gt;</span><br><span class="line">5、@synthesize和@dynamic区别</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><a href="#内存">八、谈谈内存管理、内存泄露、循环引用</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、内存管理</span><br><span class="line">(1)、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？</span><br><span class="line">(2)、那怎么知道对象已经没有被引用了呢？</span><br><span class="line">(3)、autorelease、autoreleasepool(自动释放池)</span><br><span class="line">(4)、autoreleasepool(自动释放池)　</span><br><span class="line">(5)、autoreleasepool里面对象的内存什么时候释放? </span><br><span class="line">(6)、runloop、autorelease pool以及线程之间的关系</span><br><span class="line">(7)、自动释放池怎样创建</span><br><span class="line">(8)、自动释放池使用注意</span><br><span class="line">(9)、自动释放池的应用/什么时候要用@autoreleasepool</span><br><span class="line">&gt;</span><br><span class="line">2、如何监测内存泄漏</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><a href="#常见笔试/面试题">常见笔试/面试题</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自动释放池底层怎么实现?</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><a href="#END">END</a></li>
</ul>
<p>常用数据类型占用内存大小</p>
<ul>
<li><a href="https://www.cnblogs.com/guozht/p/7929033.html" target="_blank" rel="noopener">常用数据类型占用内存大小</a></li>
</ul>
<blockquote>
<p><strong>64位编译器</strong></p>
<p>char ：1个字节<br>char*(即指针变量): 8个字节<br>short int : 2个字节<br>int： 4个字节<br>unsigned int : 4个字节<br>float: 4个字节<br>double:  8个字节<br><strong>long:  8个字节</strong><br>long long: 8个字节<br>unsigned long: 8个字节</p>
</blockquote>
<p></p><p id="指针"></p><p></p>
<h2 id="一、指针"><a href="#一、指针" class="headerlink" title="一、指针"></a>一、指针</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<h4 id="1、几个本质"><a href="#1、几个本质" class="headerlink" title="1、几个本质"></a>1、几个本质</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">数据类型：</span><br><span class="line">数据类型的本质是固定大小内存的别名。</span><br><span class="line">对变量声明数据类型，是为了告诉编译器分配几个字节的内存。</span><br><span class="line"></span><br><span class="line">变量：</span><br><span class="line">变量的本质是一段内存空间的别名。</span><br><span class="line">也就是给一段内存空间取一个新的名字，就是变量。</span><br><span class="line"></span><br><span class="line">指针：</span><br><span class="line">指针也是一种数据类型，它的值是某一个内存空间的地址。</span><br><span class="line">指针的步长根据它指向的内存空间的数据类型而定。</span><br><span class="line"></span><br><span class="line">数组中[]的本质：假如有数组array，则array[i]等价于*(array+i)，是因为[]对于程序员来讲是友好的，但是编译器最终还是要将它理解为指针，也就是数组作为函数参数时的退化。array[i] ==&gt; array[0+i] ==&gt;*(array+i)</span><br></pre></td></tr></table></figure>
<h4 id="2、空指针和未初始化的指针-野指针"><a href="#2、空指针和未初始化的指针-野指针" class="headerlink" title="2、空指针和未初始化的指针/野指针"></a>2、空指针和未初始化的指针/野指针</h4><h6 id="1-、空指针和未初始化的指针的区别："><a href="#1-、空指针和未初始化的指针的区别：" class="headerlink" title="(1)、空指针和未初始化的指针的区别："></a>(1)、空指针和未初始化的指针的区别：</h6><blockquote>
<p><strong>①空指针可以确保不指向任何对象或函数</strong>;<br>而<strong>②未初始化指针则可能指向任何地方，即它所指向的地址就是随机的，也就说此时它是个野指针。（附：如果一个指针的指向对象后来被删除，却未置为空指针nil，则它也是野指针）</strong><br>所以空指针在概念上不同于未初始化的指针。<br>对于malloc在其内存分配的时候，如果内存分配成功，返回的一定不是空指针；但是如果malloc内存分配失败,返回的空指针。而不是一个未初始化的指针。</p>
</blockquote>
<p>以下是华为笔试题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下面有关空指针和未初始化指针，说法错误的是？</span><br><span class="line">A.对0x0这个地址取值是非法的</span><br><span class="line">B.空指针可以确保不指向任何对象或函数; 而未初始化指针则可能指向任何地方。</span><br><span class="line">C.空指针与任何对象或函数的指针值都不相等</span><br><span class="line">D.malloc在其内存分配失败时返回的是一个未初始化的指针</span><br></pre></td></tr></table></figure>
<p>错误答案是D，因malloc内存分配失败，返回的是空指针。详细请查看原文地址<br><a href="https://www.nowcoder.com/questionTerminal/9a24bf403b1c4103a23562d52a2091ea" target="_blank" rel="noopener">华为笔试：下面有关空指针和未初始化指针，说法错误的是？</a></p>
<h6 id="2-、为什么指针变量定义时一定要初始化？"><a href="#2-、为什么指针变量定义时一定要初始化？" class="headerlink" title="(2)、为什么指针变量定义时一定要初始化？"></a>(2)、为什么指针变量定义时一定要初始化？</h6><blockquote>
<p>答:因为你首先要理解一点.内存空间不是你分配了才可以使用，只是你分配了之后使用才安全。</p>
<p>为什么要进行对他初始化呢，因为如果你没对它初始化，那么这个指针所指向的地址就是随机的，即此时它是个野指针。这时候如果你引用这个指针并对它做了修改这个指针所指向的内容的操作的话，如果刚好这个指针所指向的内容恰好是另外一个程序的数据的话，那么你原本随意的一个修改，就造成了对另一个程序的数据的修改了，也就会导致另外一个程序可能不能正常运行了。所以使用前一定要进行初始化。</p>
</blockquote>
<h4 id="3、野指针与悬空指针"><a href="#3、野指针与悬空指针" class="headerlink" title="3、野指针与悬空指针"></a>3、野指针与悬空指针</h4><p>在C/C++等语言中，</p>
<p>悬空指针（Dangling Pointer）指的是：<strong>一个指针的指向对象已被删除</strong>，那么就成了悬空指针。</p>
<p><strong>野指针是那些未初始化的指针</strong>。</p>
<p>有时也把野指针和悬空指针通称悬空指针。<br>而好像在iOS中是通称为野指针。</p>
<p>以下内容摘自：<a href="https://baike.baidu.com/item/迷途指针/6959997?fr=aladdin" target="_blank" rel="noopener">百度百科：迷途指针</a></p>
<blockquote>
<p>在计算机编程领域中，迷途指针，或称悬空指针、野指针，指的是不指向任何合法的对象的指针。</p>
<p>当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址，此情况下该指针便称迷途指针。</p>
<p>若操作系统将这部分已经释放的内存重新分配给另外一个进程，而原来的程序重新引用现在的迷途指针，则将产生无法预料的后果。因为此时迷途指针所指向的内存现在包含的已经完全是不同的数据。通常来说，若原来的程序继续往迷途指针所指向的内存地址写入数据，这些和原来程序不相关的数据将被损坏，进而导致不可预料的程序错误。</p>
<p>这种类型的程序错误，不容易找到问题的原因，通常会导致存储器区块错误（Linux系统中）和一般保护错误（Windows系统中）。如果操作系统的内存分配器将已经被覆盖的数据区域再分配，就可能会影响系统的稳定性。</p>
<p>某些编程语言允许未初始化的指针的存在，而这类指针即为野指针。野指针所导致的错误和迷途指针非常相似，但野指针的问题更容易被发现。</p>
</blockquote>
<h6 id="1-、指针与内存的常见使用顺序"><a href="#1-、指针与内存的常见使用顺序" class="headerlink" title="(1)、指针与内存的常见使用顺序"></a>(1)、指针与内存的常见使用顺序</h6><p>在堆中申请了一块内存，并用一个指针指向它。<br>一般我们都会在不用的时候先释放该指针指向的内存，再将该指针置为空指针。<br>即一般正确的写法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针变量和指针所指向的内存变量是两个不同的概念</span></span><br><span class="line"><span class="comment">//使用动态内存分为三步</span></span><br><span class="line"><span class="comment">//1.定义时，将指针为定义NULL</span></span><br><span class="line"><span class="comment">//2.释放内存时，把指针变量重新赋值或者NULL</span></span><br><span class="line"><span class="comment">//3.释放内存后，把指针变量赋值为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);<span class="comment">//释放P所指向的内存空间,但指针变量p仍然留在栈中,成为了野指针</span></span><br><span class="line">        p = <span class="literal">NULL</span>;<span class="comment">//释放野指针（这是关键，记得释放指针所指向的内存空间后，要释放野指针）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是<br>①、如果我们在未来始终没有去手动释放掉我们开辟的内存的话，会导致内存泄漏；<br>②、如果释放掉了该内存，却忘了同时释放只想该内存的指针，会导致产生悬空指针或者说是迷途指针，或者有人也称是野指针。<br>③、如果记得释放指针，却忘了释放指针只想的内存(即记得②忘了①)，那么由于指针已经消失，而指针指向的东西还在，那么久永远无法控制这块内存，而导致一定内存泄漏了。</p>
<h6 id="2-、内存泄漏的概念"><a href="#2-、内存泄漏的概念" class="headerlink" title="(2)、内存泄漏的概念"></a>(2)、内存泄漏的概念</h6><p><strong>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</strong></p>
<h6 id="3-、野指针概念"><a href="#3-、野指针概念" class="headerlink" title="(3)、野指针概念"></a>(3)、野指针概念</h6><blockquote>
<p>C语言: 当我们声明1个指针变量,没有为这个指针变量赋初始值.这个指针变量的值是1个垃圾指针 指向1块随机的内存空间。</p>
<p>OC语言: 指针指向的对象已经被回收掉了.这个指针就叫做野指针.</p>
<p><strong>野指针：指向内存被释放的内存或者没有访问权限的内存的指针</strong>。</p>
</blockquote>
<p>更详细的概念可查看：<a href="https://baike.baidu.com/item/野指针/9654046?fr=aladdin" target="_blank" rel="noopener">百度百科——野指针</a></p>
<h6 id="4-、在iOS中野指针的后果"><a href="#4-、在iOS中野指针的后果" class="headerlink" title="(4)、在iOS中野指针的后果"></a>(4)、在iOS中野指针的后果</h6><p>野指针的后果：崩溃EXC_BAD_ADDRESS</p>
<h6 id="5-、分析野指针的产生原因及解决办法"><a href="#5-、分析野指针的产生原因及解决办法" class="headerlink" title="(5)、分析野指针的产生原因及解决办法"></a>(5)、分析野指针的产生原因及解决办法</h6><blockquote>
<p>知识点：任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</p>
</blockquote>
<p>“野指针”的成因主要有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）指针变量没有被初始化。(即随机只想的这个指针很有可能只想一块没人用的内存，)</span><br><span class="line"><span class="keyword">char</span> *p; <span class="comment">//此时p为野指针</span></span><br><span class="line"><span class="comment">//正确的为在声明之后加上 p=new char[10];我们常直接写为一行，即char *p=new char[10];</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）指针p被<span class="built_in">free</span>或者<span class="keyword">delete</span>之后，没有置为<span class="literal">NULL</span>，让人误以为p是个合法的指针.</span><br><span class="line"><span class="keyword">char</span> *p=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];  <span class="comment">//指向堆中分配的内存首地址，p存储在栈区</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; p;</span><br><span class="line"><span class="keyword">delete</span> []p; <span class="comment">//p重新变为野指针</span></span><br><span class="line"><span class="comment">//正确的应该在指针p被free或者delete之后,加上p = Null;</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）指针操作超越了变量的作用范围。</span><br><span class="line"><span class="keyword">char</span> *p=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; <span class="comment">//指向堆中分配的内存首地址</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; p;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(p+<span class="number">10</span>); <span class="comment">//可能输出未知数据</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/tgycoder/p/5661431.html" target="_blank" rel="noopener">iOS 关于僵尸对象和僵尸指针的那些事儿</a></p>
<h4 id="4、iOS-NSerror-用双重指针理解"><a href="#4、iOS-NSerror-用双重指针理解" class="headerlink" title="4、iOS NSerror 用双重指针理解"></a>4、iOS NSerror 用双重指针理解</h4><p>常见代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *error = nil;</span><br><span class="line">[[NSFileManager defaultManager] removeItemAtPath:absoluteFilePath error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">	NSLog(@&quot;删除单个文件的时候出现错误：%@&quot;,error.localizedDescription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，如果我们不是传指针的指针&amp;error,而是传error，那么if(error)中的error就肯定是nil了。那就没用了。</p>
<p>所以这里传error的指针的原因可简单概括为：<br>因为我们要得到一个新的error值。所以如果有方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSError *)getNewErrorForremoveItemAtPathremoveItemAtPath:(NSString *)path  error:(NSError **)error &#123;</span><br><span class="line">	NSError *newError = [NSError errorWithDomain:...];</span><br><span class="line">	</span><br><span class="line">	return newError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这边，我们的error,就可以直接传error本身，甚至不传都是可以的。</p>
<p>但是实际是这些方法本身的返回值，已经被定义为判断能否进行某种操作，而不是操作是否成功给占用了，如这边已经被判断能否进行删除文件给占用了，所以如果我们还想知道这个删除文件操作结果的error，那就把error的指针的指针传进去，最后其出来的就是我们想要的。<br>所以，猜测其内部结构应该是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)removeItemAtPath:(NSString *)path error:(NSError **)error &#123;</span><br><span class="line">	BOOL canRemove = ...;</span><br><span class="line">	if (!canRemove) &#123;</span><br><span class="line">		* error = [NSError errorWithDomain:...];</span><br><span class="line">		return NO;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		//* error = * error; //即不变</span><br><span class="line">		return YES;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下解释原因摘自：<a href="https://zhidao.baidu.com/question/484954523.html" target="_blank" rel="noopener">ios中处理错误为什么传递的是&amp;error，而不是error？</a></p>
<blockquote>
<p>因为 需要将error 传入后修改其值，然后再返回来，返回来后还要保证己经修改过了。</p>
<p>&amp;error传入是传的地址引用，传入后处理函数直接访问变量的地址，可以修改其值再返回同一个地址， 调用函数就可以知道值是否有修改，即是否有错。</p>
<p>而error传入是传的值引用，值引用传入到程序栈中后其实是把原来的值复制了一份传过去，处理函数可以修改，但无法将改后的值传出函数体。</p>
</blockquote>
<h4 id="5、指针和引用的区别"><a href="#5、指针和引用的区别" class="headerlink" title="5、指针和引用的区别"></a>5、指针和引用的区别</h4><p>(1)定义和性质的区别<br>①指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；<br>②而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。<br>简单点说：一个是存地址，一个是变量别名<br>（2）指针和引用作为函数参数进行传递时的区别<br>①用指针传递参数，可以实现对实参进行改变的目的，是因为传递过来的是实参的地址<br>②引用作为函数参数进行传递时，实质上传递的是实参本身，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。</p>
<p></p><p id="内存"></p><p></p>
<h2 id="二、内存"><a href="#二、内存" class="headerlink" title="二、内存"></a>二、内存</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<h4 id="1、堆和栈的区别"><a href="#1、堆和栈的区别" class="headerlink" title="1、堆和栈的区别?"></a>1、堆和栈的区别?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一、堆栈空间分配区别：</span><br><span class="line">1、栈（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；</span><br><span class="line">2、堆（操作系统）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</span><br><span class="line"></span><br><span class="line">二、堆栈缓存方式区别：</span><br><span class="line">1、栈使用的是一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放；</span><br><span class="line">2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</span><br></pre></td></tr></table></figure>
<h2 id="八、谈谈内存管理、内存泄露、循环引用"><a href="#八、谈谈内存管理、内存泄露、循环引用" class="headerlink" title="八、谈谈内存管理、内存泄露、循环引用"></a>八、谈谈内存管理、内存泄露、循环引用</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>ARC已经出来很久了，自动释放内存的确很方便，但是并非绝对安全绝对不会产生内存泄露。</p>
<h3 id="1、内存管理"><a href="#1、内存管理" class="headerlink" title="1、内存管理"></a>1、内存管理</h3><h5 id="1-、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？"><a href="#1-、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？" class="headerlink" title="(1)、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？"></a>(1)、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？</h5><p>答案是：当对象没有被任何变量引用（也可以说是没有指针指向该对象）的时候，就会被释放。</p>
<h5 id="2-、那怎么知道对象已经没有被引用了呢？"><a href="#2-、那怎么知道对象已经没有被引用了呢？" class="headerlink" title="(2)、那怎么知道对象已经没有被引用了呢？"></a>(2)、那怎么知道对象已经没有被引用了呢？</h5><p>ObjC采用引用计数（reference counting）的技术来进行管理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）每个对象都有一个关联的整数，称为引用计数器；</span><br><span class="line">2）当代码需要使用该对象时，则将对象的引用计数加1；</span><br><span class="line">3）当代码结束使用该对象时，则将对象的引用计数减1；</span><br><span class="line">4）当引用计数的值变为0时，表示对象没有被任何代码使用，此时对象将被释放。</span><br></pre></td></tr></table></figure>
<p>与之对应的消息发送方法如下：</p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th>OC中对应的方法</th>
<th>引用计数的变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>当对象被创建时</td>
<td>alloc/new/copy/mutableCopy等</td>
<td>+1</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain</td>
<td>+1</td>
</tr>
<tr>
<td>释放对象</td>
<td>release</td>
<td>-1</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc</td>
<td>-</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）当对象被创建（通过alloc、new或copy/mutableCopy等方法）时，其引用计数初始值为1；</span><br><span class="line">2）给对象发送retain消息，其引用计数加1；</span><br><span class="line">3）给对象发送release消息，其引用计数减1；</span><br><span class="line">4）当对象引用计数归0时，ObjC給对象发送dealloc消息销毁对象</span><br><span class="line">当创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1；</span><br><span class="line">在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1；</span><br><span class="line">需要释放一个对象时，就将该对象的引用计数减1；</span><br><span class="line">直至对象的引用计数为0，对象的内存会被立刻释放。</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];	<span class="comment">// 执行后，引用计数 = 1 </span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n 引用计数 = %lu \n 对象内存 = %p \n object指针内存地址 = %x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[object retainCount], object, &amp;object);</span><br><span class="line">    <span class="keyword">self</span>.property = object;											<span class="comment">// 执行后，引用计数 = 2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n 引用计数 = %lu \n 对象内存 = %p \n object指针内存地址 = %x \n property指针内存地址 = %x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[object retainCount], object, &amp;object, &amp;_property);</span><br><span class="line">    [object release];														<span class="comment">// 执行后，引用计数 = 1 </span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n 引用计数 = %lu \n 对象内存 = %p \n object指针内存地址 = %x \n property指针内存地址 = %x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[object retainCount], object, &amp;object, &amp;_property);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要释放强引用指向的对象时，需要保证所有指向对象强引用置为 nil。<code>__strong</code> 修饰符是 id 类型和对象类型默认的所有权修饰符。</p>
<p><code>__weak</code> 表示弱引用，对应定义 <code>property</code> 时用到的 weak。弱引用不会影响对象的释放，而当对象被释放时，所有指向它的弱引用都会自定被置为 nil，这样可以防止野指针。</p>
<h3 id="2、如何监测内存泄漏"><a href="#2、如何监测内存泄漏" class="headerlink" title="2、如何监测内存泄漏"></a>2、如何监测内存泄漏</h3><p>如果内存管理不当，势必会造成内存泄露。那我们如何快速的来找出内存泄露呢？以前我们可能会使用Instruments来监测，但是我们会发现使用Instruments特别繁琐，而且不一定能定位到内存泄露。</p>
<p>所以这里伟大的Facebook工程师们开源了一些自动化工具来解决监测内存泄露问题：FBRetainCycleDetector、FBAllocationTracker、FBMemoryProfiler。详情查看<a href="http://www.cocoachina.com/ios/20160419/15954.html" target="_blank" rel="noopener">在iOS上自动检测内存泄露</a></p>
<h6 id="你在开发大型项目时-如何进行内存泄露检测的"><a href="#你在开发大型项目时-如何进行内存泄露检测的" class="headerlink" title="你在开发大型项目时,如何进行内存泄露检测的?"></a>你在开发大型项目时,如何进行内存泄露检测的?</h6><blockquote>
<p>instruments下有个leaks工具，启动此工具后，运行项目，工具里可以显示内存泄露的情况，双击可找到源码位置，可以帮助进行内存泄露的处理。</p>
</blockquote>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-①基础/" data-id="cm121y2zc017aqar4g1yvxucz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/2内存/2内存-①AutoRelease" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-①AutoRelease/" class="article-date">
  <time datetime="2022-03-16T05:35:04.573Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-内存"><a href="#必备知识架构-内存" class="headerlink" title="必备知识架构-内存"></a>必备知识架构-内存</h1><p>[toc]</p>
<p>必看文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/1b66c4d47cd7" target="_blank" rel="noopener">AutoreleasePool的原理和实现</a></li>
</ul>
<p>什么是内存管理？是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。</p>
<p><strong>内存管理管理的是堆上的内存，栈上的内存并不需要我们管理。</strong></p>
<h2 id="说说内存管理"><a href="#说说内存管理" class="headerlink" title="说说内存管理"></a>说说内存管理</h2><p>我们知道，当不再使用一个对象时应该将其释放，但是在某些情况下，我们很难理清一个对象什么时候不再使用(比如self.name不止在一个方法里会被调用到的时候)，这可怎么办？ObjC提供autorelease方法来解决这个问题。</p>
<p>说到内存管理，我们就不得不提引用计数。当对象的引用计数为0，对象的内存就会被释放。</p>
<blockquote>
<p>引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。</p>
</blockquote>
<p>当我们在创建一个对象的实例并在堆上申请内存时，或者在其他对象中需要持有这个对象时，该对象的引用计数就会加1；<br>当代码结束使用该对象/释放对象时，则将对象的引用计数减1；而想要释放一个对象的内存，我们将该对象的引用计数减到0，即进行release到0。<br>在ARC的情况下，为了方便管理内存，它会有一个autorelease的东西，它省去了我们还要自己去执行release方法的操作。同时与autorelease相关的还有一个叫AutoreleasePool自动释放池。</p>
<p>通过autorelease，当给一个对象发送autorelease消息（类方法创建的对象系统会自动添加autorelease）时，对象在接收到autorelease消息后，它会被添加到了当前的自动释放池autoreleasepool中。在未来某个时间，当自动释放池被销毁时，会给池里所有的对象发送release消息将其释放(释放≠销毁)。如果自动释放池向对象发送release消息后对象的引用计数变为了0，则改对象就会被销毁，内存就会被回收。在释放前这个时间段内，对象还是可以使用的（<strong>注意1：autorelease不会改变对象的引用计数，release才改变引用计数</strong>）（<strong>注意2：自动释放池实质上只是在释放的时候给池中所有对象对象发送release消息，不保证对象一定会销毁，如果自动释放池向对象发送release消息后对象的引用计数仍大于1，对象就无法销毁。</strong>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id array = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">此源代码等同于以下源码。</span><br><span class="line">id array = [[[NSMutableArray alloc] initWithCapacity:1] autorelease];</span><br></pre></td></tr></table></figure>
<p>所以AutoreleasePool的释放有如下两种情况。</p>
<ul>
<li><p>一是Autorelease对象是在当前的<strong>runloop</strong>迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop。（<strong>一定要回答到runloop</strong>）。那runloop什么时候结束呢？</p>
<blockquote>
<p>一个<code>RunLoop</code>包含若干个<code>Mode</code>，每个<code>Mode</code>包含若干个<code>Source</code>/<code>Timer</code>/<code>Observer</code>/<code>Port</code>。当启动一个<code>RunLoop</code>时会先指定一个<code>Mode</code>，检查指定<code>Mode</code>是否存在以及<code>Mode</code>中是否含有<code>Source</code>和<code>Timer</code>，如果<code>Mode</code>不存在或者<code>Mode</code>中无<code>Source</code>和<code>Timer</code>，认为该<code>Mode</code>是一个空的<code>Mode</code>，<code>RunLoop</code>就直接退出。</p>
</blockquote>
</li>
<li><p>二是手动调用AutoreleasePool的释放方法（drain方法）来销毁AutoreleasePool</p>
</li>
</ul>
<h2 id="AutoreleasePool（自动释放池）"><a href="#AutoreleasePool（自动释放池）" class="headerlink" title="AutoreleasePool（自动释放池）"></a>AutoreleasePool（自动释放池）</h2><h3 id="1、AutoreleasePool（自动释放池）介绍"><a href="#1、AutoreleasePool（自动释放池）介绍" class="headerlink" title="1、AutoreleasePool（自动释放池）介绍"></a>1、AutoreleasePool（自动释放池）介绍</h3><p><strong>AutoreleasePool（自动释放池）是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。</strong>即当我们创建了一个对象，并把他加入到了自动释放池中时，他不会立即被释放，会等到一次<code>runloop</code>结束或者作用域超出<code>autoreleasepool{}</code>之后再被释放。在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。</p>
<p>我们把<code>main.m</code>文件通过Xcode自带的xcrun命令，来编译成<a href="./2内存-①AutoRelease/main.cpp">main.cpp</a>文件</p>
<p>命令行如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator clang -rewrite-objc ./main.m</span><br></pre></td></tr></table></figure>
<p>可以在编译出来的cpp文件中，看到如下自动释放池的结构体如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; 	<span class="comment">// 构造函数</span></span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;			<span class="comment">// 析构函数</span></span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>objc4</code>是我们通常说的Runtime源码，我们遇到的<code>libobjc.A.dylib</code>就是用它编译出来的。</p>
<p>源码查看，进入<a href="http://opensource.apple.com/source/" target="_blank" rel="noopener">http://opensource.apple.com/source/</a>搜索objc4，</p>
<p><img src="/iOS/3必备知识架构/2内存/2内存-①AutoRelease/image-20211103173107899-5931876.png" alt="image-20211103173107899"></p>
<h1 id="NSThread、NSRunLoop-和-NSAutoreleasePool三者之间的关系"><a href="#NSThread、NSRunLoop-和-NSAutoreleasePool三者之间的关系" class="headerlink" title="NSThread、NSRunLoop 和 NSAutoreleasePool三者之间的关系"></a>NSThread、NSRunLoop 和 NSAutoreleasePool三者之间的关系</h1><ul>
<li>NSThread 和 NSRunLoop是<code>一一对应</code>的关系</li>
<li>在NSRunLoop对象的每个<code>运行循环（event loop）</code>开始前，系统会自动创建一个autoreleasepool，并在<code>运行循环（event loop）</code>结束时<code>drain</code>掉这个pool，同时释放所有autorelease对象</li>
<li><code>autoreleasepool</code>只会对应<code>一个</code>线程，每个<code>线程</code>可能会对应<code>多个</code>autoreleasepool，比如autoreleasepool<code>嵌套</code>的情况</li>
</ul>
<ul>
<li>autorelease<code>本质</code>上就是<code>延迟</code>调用release方法</li>
<li>MRC环境，通过调用<code>[obj autorelease]</code>来<code>延迟</code>内存的释放</li>
<li>ARC环境，甚至可以<code>完全不知道</code>autorelease也能管理好内存</li>
</ul>
<p>看到这里有人可能会问，那到底延迟到什么时候执行呢？看完本文后，各位心中自然会有答案。</p>
<h5 id="3-、autorelease、autoreleasepool-自动释放池"><a href="#3-、autorelease、autoreleasepool-自动释放池" class="headerlink" title="(3)、autorelease、autoreleasepool(自动释放池)"></a>(3)、autorelease、autoreleasepool(自动释放池)</h5><h5 id="4-、autoreleasepool-自动释放池"><a href="#4-、autoreleasepool-自动释放池" class="headerlink" title="(4)、autoreleasepool(自动释放池)　　"></a>(4)、autoreleasepool(自动释放池)　　</h5><p>　　这里说到的自动释放池，顾名思义，就是一个池，这个池可以容纳对象，而且可以自动释放，这就大大增加了我们处理对象的灵活性。
　　</p>
<h5 id="5-、autoreleasepool里面对象的内存什么时候释放"><a href="#5-、autoreleasepool里面对象的内存什么时候释放" class="headerlink" title="(5)、autoreleasepool里面对象的内存什么时候释放?"></a>(5)、autoreleasepool里面对象的内存什么时候释放?</h5><p>　　在runloop sleep的时候当前autoreleasePool drain（objc_autoreleasePoolPop） 掉，向里面的对象都发送release消息，建立一个新的autoreleasePool(objc_autoreleasePoolPush)。或者简单的说就是当@autoreleasepool结束时，里面的内存就会回收;</p>
<p>ARC时代，系统自动管理自己的autoreleasepool，runloop就是iOS中的消息循环机制，当一个runloop结束时系统才会一次性清理掉被autorelease处理过的对象，其实本质上说是在本次runloop迭代结束时清理掉被本次迭代期间被放到autorelease pool中的对象的。至于何时runloop结束并没有固定的duration。 </p>
<h5 id="6-、runloop、autorelease-pool以及线程之间的关系"><a href="#6-、runloop、autorelease-pool以及线程之间的关系" class="headerlink" title="(6)、runloop、autorelease pool以及线程之间的关系"></a>(6)、runloop、autorelease pool以及线程之间的关系</h5><p>每个线程(包含主线程)都有一个Runloop。对于每一个Runloop，系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个像callstack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</p>
<p>#####　(7)、自动释放池怎样创建</p>
<p>ObjC提供两种方法创建自动释放池：</p>
<p>方法一：使用NSAutoreleasePool来创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool * pool = [[NSAutoreleasePool alloc]init];</span><br><span class="line">//这里写代码</span><br><span class="line">[pool release];</span><br></pre></td></tr></table></figure>
<p>方法二：使用@autoreleasepool创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">//这里写代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动释放池创建后，就会成为活动的池子，释放池子后，池子将释放其所包含的所有对象。</p>
<p>以上两种方法推荐第一种，因为将内存交给ObjC管理更高效。</p>
<h5 id="8-、自动释放池使用注意"><a href="#8-、自动释放池使用注意" class="headerlink" title="(8)、自动释放池使用注意"></a>(8)、自动释放池使用注意</h5><blockquote>
<p>1）自动释放池实质上只是在释放的时候给池中所有对象对象发送release消息，不保证对象一定会销毁，如果自动释放池向对象发送release消息后对象的引用计数仍大于1，对象就无法销毁。</p>
<p>2）自动释放池中的对象会集中同一时间释放，如果操作需要生成的对象较多占用内存空间大，可以使用多个释放池来进行优化。比如在一个循环中需要创建大量的临时变量，可以创建内部的池子来降低内存占用峰值。</p>
<p>3）autorelease不会改变对象的引用计数</p>
</blockquote>
<h5 id="9-、自动释放池的应用-什么时候要用-autoreleasepool"><a href="#9-、自动释放池的应用-什么时候要用-autoreleasepool" class="headerlink" title="(9)、自动释放池的应用/什么时候要用@autoreleasepool"></a>(9)、自动释放池的应用/什么时候要用@autoreleasepool</h5><p>有些情况下，我们还是需要手动创建自动释放池，那么，什么时候呢？</p>
<p>苹果文档中的翻译如下：</p>
<ol>
<li>如果你正在编写不基于UI 框架的程序，比如命令行工具。</li>
<li>如果你编写的循环创建了很多临时对象。那么你可以在循环中使用自动释放池block，在下次迭代前处理这些对象。在循环中使用自动释放池block，有助于减少应用程序的内存占用。</li>
<li>你生成了一个辅助线程。 一旦线程开始执行你必须自己创建自动释放池。否则，应用将泄漏对象。</li>
</ol>
<p>按我的理解，最重要的使用场景，应该是有大量中间临时变量产生时，避免内存使用峰值过高，及时释放内存的场景。 </p>
<p>如在一个循环事件中，如果循环次数较大或者事件处理占用内存较大，就会导致内存占用不断增长，可能会导致不希望看到的后果。</p>
<p>举个例子，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSArray *urls = &lt;# An array of file URLs #&gt;;</span><br><span class="line">for (NSURL *url in urls) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSError *error;</span><br><span class="line">        NSString *fileContents = [NSString stringWithContentsOfURL:url</span><br><span class="line">                                         encoding:NSUTF8StringEncoding</span><br><span class="line">                                         error:&amp;error];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//或</span><br><span class="line">     for (int i = 0; i &lt; 100000; i ++) &#123;</span><br><span class="line">         @autoreleasepool &#123;</span><br><span class="line">             NSString * log  = [NSString stringWithFormat:@&quot;%d&quot;, i];</span><br><span class="line">             NSLog(@&quot;%@&quot;, log);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>如果这个for循环里不使用@autoreleasepool，虽然每个循环中生成的字符串对象都会放在自动释放池子中(假设是1号自动释放池)，但是这个1号自动释放池是需要等到循环事件结束时释放的。这时候由于循环太大，势必会造成在循环期间内存不增长。所以，这里我们需要使用@autoreleasepool，额外创建一个2号自动释放池，来使得在每个@autoreleasepool结束时，里面的临时变量都会回收，内存使用更加合理。</p>
<p>例子2：假如有2000张图片，每张1M左右，现在需要获取所有图片的尺寸，你会怎么做？<br>　　如果这样做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 2000; i ++) &#123;</span><br><span class="line"> CGSize size = [UIImage imageNamed:[NSString stringWithFormat:@&quot;%d.jpg&quot;,i]].size;</span><br><span class="line"> //add size to array</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>　　用imageNamed方法加载图片占用Cache的内存，autoReleasePool也不能释放，对此问题需要另外的解决方法，当然保险的当然是双管齐下了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   for (int i = 0; i &lt; 2000; i ++) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">       CGSize size = [UIImage imageWithContentsOfFile:filePath].size;</span><br><span class="line">       //add siez to array</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p>
<h6 id="自动释放池底层怎么实现"><a href="#自动释放池底层怎么实现" class="headerlink" title="自动释放池底层怎么实现?"></a>自动释放池底层怎么实现?</h6><blockquote>
<p>答:自动释放池以栈的形式实现:当你创建一个新的自动释放池时,它将被添加到栈顶.当一个对象收到发送autorelease消息时,他被添加到当前线程的处于栈顶的自动释放池中,当自动释放池被回收时,他们从栈中被删除,并且会给池子里面所有的对象都会做一次release操作</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-①AutoRelease/" data-id="cm121y2xe0171qar4rd16oeck" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/1语言/1语言Common" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/1语言/1语言Common/" class="article-date">
  <time datetime="2022-03-16T05:35:04.572Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-①语言"><a href="#必备知识架构-①语言" class="headerlink" title="必备知识架构-①语言"></a>必备知识架构-①语言</h1><p>[Toc]</p>
<p>–</p>
<h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p>
<p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p>
<p></p><p id="Objective-C与C++"></p><p></p>
<h2 id="面向对象-OOP"><a href="#面向对象-OOP" class="headerlink" title="面向对象(OOP)"></a>面向对象(OOP)</h2><p>面向对象的三个特性：封装、继承和多态。</p>
<blockquote>
<p>所谓封装，也就是把客观事物封装成抽象的类；</p>
<p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。(或者说是不同对象以自己的方式响应相同的消息的能力叫做多态。)</p>
</blockquote>
<p>继承的问题：如果架构工程师写父类，业务工程师实现子类。那么业务工程师很可能不清楚：哪些方法需要被覆盖重载，哪些不需要。如果子类没有覆重方法，而父类提供的只是空方法，就很容易出问题。如果子类在覆重的时候引入了其他不相关逻辑，那么子类对象就显得不够单纯，角色复杂了。</p>
<blockquote>
<p>多态面临的四个问题：</p>
<ul>
<li><p>父类有部分public的方法是不需要，也不允许子类覆重。</p>
<p>答：公司内部可以规定:<code>不允许覆盖重载父类中的方法</code>、<code>子类需要实现接口协议中的方法</code>。</p>
</li>
<li><p>父类有一些特别的方法是必须要子类去覆重的，在父类的方法其实是个空方法。</p>
</li>
<li><p>父类有一些方法即便被覆重，父类原方法还是要执行的。</p>
</li>
<li><p>父类有一些方法是可选覆重的，一旦覆重，则以子类为准。</p>
</li>
</ul>
</blockquote>
<p></p><p id="常见笔试/面试题"></p><p></p>
<h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p>
<h4 id="2、const-与define使用的区别"><a href="#2、const-与define使用的区别" class="headerlink" title="2、const 与define使用的区别"></a>2、const 与define使用的区别</h4><ul>
<li>define修饰的变量不指定类型,const的指定类型</li>
<li>defien修饰的变量每次引用都开辟一次内存,而const只有一份内存</li>
<li>如果修饰的是代码片段适合用define,如果修饰的是变量适合用const</li>
</ul>
<h4 id="6、nil-Nil-NULL-与-NSNull-的区别"><a href="#6、nil-Nil-NULL-与-NSNull-的区别" class="headerlink" title="6、nil, Nil,NULL 与 NSNull 的区别"></a>6、nil, Nil,NULL 与 NSNull 的区别</h4><ul>
<li>nil 指向一个<strong>对象的指针</strong>为空,在objc.h 的定义如下: <code>NSString *name = nil;</code></li>
<li>Nil 指向一个<strong>类的指针</strong>为空,定义如下: <code>Class aClass = Nil;</code></li>
<li>NULL 指向<strong>C类型的指针</strong>为空, 例如: <code>int*pInt = NULL;</code></li>
<li>NSNull 在Objective-C中是一个类,使用为生成一个空对象<code>[NSNull null];</code>，多用于集合(NSArray,NSDictionary)中值为空的对象</li>
</ul>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/1语言/1语言Common/" data-id="cm121y2v9016pqar4y854wu6b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/1语言/1语言Swift" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/1语言/1语言Swift/" class="article-date">
  <time datetime="2022-03-16T05:35:04.572Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-①语言Swift"><a href="#必备知识架构-①语言Swift" class="headerlink" title="必备知识架构-①语言Swift"></a>必备知识架构-①语言Swift</h1><p>[Toc]</p>
<h2 id="一、iOS开发中使用OC和swift的对比"><a href="#一、iOS开发中使用OC和swift的对比" class="headerlink" title="一、iOS开发中使用OC和swift的对比"></a>一、iOS开发中使用OC和swift的对比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.import的类</span><br><span class="line">OC：某个只要要使用某个类就要将该类import。</span><br><span class="line">swift：如果是用户自己创建类，其他类无需import可以直接使用。pod的一些三方类和系统的一些类，在使用的时候需要import</span><br></pre></td></tr></table></figure>
<p>Guard语句的语法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> expression <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//语句</span></span><br><span class="line">    <span class="comment">//必须包含一个控制语句：return，break，continue或throw。</span></span><br><span class="line">&#125;</span><br><span class="line">这里，expression是一个布尔表达式（返回<span class="literal">true</span>或者<span class="literal">false</span>）。</span><br><span class="line">如果对表达式求值<span class="literal">false</span>，<span class="keyword">guard</span>则执行代码块内的语句。</span><br><span class="line">如果对表达式求值<span class="literal">true</span>，<span class="keyword">guard</span>则从执行中跳过代码块内的语句</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="literal">false</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Condition not met"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Condition met"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、【iOS】Swift和OC协议的区别？为何Swift是面向协议的？"><a href="#二、【iOS】Swift和OC协议的区别？为何Swift是面向协议的？" class="headerlink" title="二、【iOS】Swift和OC协议的区别？为何Swift是面向协议的？"></a>二、【iOS】Swift和OC协议的区别？为何Swift是面向协议的？</h2><p><a href="https://blog.csdn.net/hanrovey/article/details/106636624" target="_blank" rel="noopener">【iOS】Swift和OC协议的区别？为何Swift是面向协议的？</a></p>
<p>相比于OC，Swift 可以做到协议方法的具体实现，而 OC 则不行。</p>
<blockquote>
<p>OC中协议<code>（Protocol）</code>类似一个类的接口，只声明，不实现。<br>只能定义公用的一套接口，但不能提供具体的实现方法。也就是说，它只告诉你要做什么，但具体怎么做不关心。具体的实现要在遵守这个协议的类中实现。</p>
</blockquote>
<h3 id="OC的Protocol与继承的区别"><a href="#OC的Protocol与继承的区别" class="headerlink" title="OC的Protocol与继承的区别"></a>OC的Protocol与继承的区别</h3><p>继承连同方法的实现也继承了，而protocol只有声明没有实现；<br>protocol能够作用到不同类型的类上。</p>
<h3 id="OC的Protocol与Category的区别"><a href="#OC的Protocol与Category的区别" class="headerlink" title="OC的Protocol与Category的区别"></a>OC的Protocol与Category的区别</h3><p><code>Category</code>可以给一个类扩充方法，既有申明也有实现；而<code>Protocol</code>只有声明，没有实现。<br> 同：<code>Category</code>和<code>Protocol</code>都可以声明方法，不能声明属性。</p>
<h2 id="Swift-面试题解"><a href="#Swift-面试题解" class="headerlink" title="Swift 面试题解"></a>Swift 面试题解</h2><h3 id="的作用"><a href="#的作用" class="headerlink" title="?? 的作用"></a>?? 的作用</h3><p>可选值的默认值, 当可选值为nil 的时候, 会返回后面的值. 如<br><code>let someValue = optional1 ?? 0</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/1语言/1语言Swift/" data-id="cm121y2w9016vqar4bdahw3sp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/1语言/Runtime" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/1语言/Runtime/" class="article-date">
  <time datetime="2022-03-16T05:35:04.572Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Runtime-Interview"><a href="#Runtime-Interview" class="headerlink" title="Runtime_Interview"></a>Runtime_Interview</h1><p>Runtime</p>
<p>前言：</p>
<p>  Objective C的runtime技术功能非常强大，能够在运行时获取并修改类的各种信息，包括获取方法列表、属性列表、变量列表，修改方法、属性，增加方法，属性等等，本文对相关的几个要点做了一个小结。</p>
<p>目录：</p>
<p>（1）使用class_replaceMethod/class_addMethod函数在运行时对函数进行动态替换或增加新函数</p>
<p>（2）重载forwardingTargetForSelector，将无法处理的selector转发给其他对象</p>
<p>（3）重载resolveInstanceMethod，从而在无法处理某个selector时，动态添加一个selector</p>
<p>（4）使用class_copyPropertyList及property_getName获取类的属性列表及每个属性的名称</p>
<p>  (5) 使用class_copyMethodList获取类的所有方法列表</p>
<h4 id="一些参考"><a href="#一些参考" class="headerlink" title="一些参考"></a>一些参考</h4><p><a href="http://www.cnblogs.com/yswdarren/p/3619303.html" target="_blank" rel="noopener">Objective C运行时（runtime）技术总结</a></p>
<p>需求1、当项目中，需要继承某一个父类，但是父类中并没有提供我们需要的调用方法，一般情况下，这种时候，我们可能会再派生一个类，或者会直接为这个类写一个分类（category），在这个分类中，我们可以新增或者替换某个方法（注意：不推荐在分类中重写方法，而且也无法通过 super 来获取所谓父类的方法）。大致在这两种情况下，我们可以通过 class_addMethod 来实现我们想要的效果。</p>
<p>先从一个场景问题带出吧，比如一个应用都是继承于UIViewController，刚开始时候不要求要转屏，到后面才决定加上旋转屏适配，这个时候如果我们去创建一个父类，并让去修改每个类的继承这个方法显然是效率太低了。而且有时候，我们也不想多创个父类，于是我们就只能决定一次过替换掉这些controller里的viewWillAppear:和 willAnimateRotationToInterfaceOrientation:duration:，换成自己的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class clazz = object_getClass((id)self);</span><br><span class="line">        </span><br><span class="line">        //将系统的resolveInstanceMethod替换成自己的myResolveInstanceMethod，而系统的resolveInstanceMethod方法就是当运行时对象调用了一个找不到的方法的时候系统会去寻找的机制。</span><br><span class="line">        [clazz swizzleMethod:@selector(resolveInstanceMethod:) withMethod:@selector(myResolveInstanceMethod:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  用什么方法替换掉什么方法</span><br><span class="line"> *</span><br><span class="line"> *  @param origSel  原方法选择子</span><br><span class="line"> *  @param aftSel   新方法选择子</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)swizzleMethod:(SEL)origSel withMethod:(SEL)aftSel &#123;</span><br><span class="line">	//通过class_getInstanceMethod()拿到对应的Method</span><br><span class="line">    Method originMethod = class_getInstanceMethod(self, origSel);</span><br><span class="line">    Method newMethod = class_getInstanceMethod(self, aftSel);</span><br><span class="line">    </span><br><span class="line">    if(originMethod &amp;&amp; newMethod)&#123; //必须两个Method都要拿到</span><br><span class="line">    	//class_addMethod将本来不存在于被操作的Class里的newMethod的实现添加在被操作的Class里，并使用origSel作为其选择子</span><br><span class="line">        if(class_addMethod(self, origSel, method_getImplementation(newMethod),method_getTypeEncoding(newMethod))) &#123;</span><br><span class="line">        	//当addMethod成功完成后，利用class_replaceMethod换掉method_getImplaementation(oiginMethod)的选择子，将原方法的实现的SEL换成新方法的SEL:aftSel，ok目的达成了。想一想，现在通过旧方法SEL来调用，就会实现新方法的IMP，通过新方法的SEL来调用，就会实现旧方法的IMP。</span><br><span class="line">            class_replaceMethod(self, aftSel, method_getImplementation(originMethod), method_getTypeEncoding(originMethod));</span><br><span class="line">        &#125;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/1语言/Runtime/" data-id="cm121y2ww016yqar4lb5yb85p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/1语言/1语言-消息转发" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/1语言/1语言-消息转发/" class="article-date">
  <time datetime="2022-03-16T05:35:04.562Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-①语言-消息转发"><a href="#必备知识架构-①语言-消息转发" class="headerlink" title="必备知识架构-①语言-消息转发"></a>必备知识架构-①语言-消息转发</h1><p>《<a href="https://github.com/dvlproad/CJUIKit/tree/master/CJBaseHelper/CJBaseHelper/HookCJHelper" target="_blank" rel="noopener">CJBaseHelper/HookCJHelper</a>》</p>
<blockquote>
<p>pod search CJBaseHelper</p>
<p><img src="/iOS/3必备知识架构/1语言/1语言-消息转发/image-20240822165215629.png" alt="image-20240822165215629"></p>
<blockquote>
<p>库的使用方法，见我简书中的以下文章：</p>
<ul>
<li><p><a href="https://www.jianshu.com/p/5013d7bcddb5" target="_blank" rel="noopener">iOS 获取当前正在显示的视图控制器ViewController(最全)</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/cc715c5b594c" target="_blank" rel="noopener">iOS 拦截篇(一)：拦截H5通过<input>标签选取的图片</a></p>
</li>
</ul>
</blockquote>
</blockquote>
<p>《<a href="https://github.com/dvlproad/CJUIKit/tree/master/CJHook" target="_blank" rel="noopener">CJHook</a>》</p>
<blockquote>
<p>pod search CJHook</p>
<p><img src="/iOS/3必备知识架构/1语言/1语言-消息转发/image-20240822165517533.png" alt="image-20240822165517533"></p>
</blockquote>
<h2 id="在调用原始方法之前插入额外的执行逻辑"><a href="#在调用原始方法之前插入额外的执行逻辑" class="headerlink" title="在调用原始方法之前插入额外的执行逻辑"></a>在调用原始方法之前插入额外的执行逻辑</h2><h3 id="1、使用场景"><a href="#1、使用场景" class="headerlink" title="1、使用场景"></a>1、使用场景</h3><ol>
<li><p><strong>日志记录与监控</strong>： 在方法执行前后添加日志记录，可以帮助开发者监控应用的行为，特别是在调试和性能分析时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)swizzleMethod:(Class)class withSelector:(SEL)selector &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(class, selector);</span><br><span class="line">    IMP originalIMP = method_getImplementation(originalMethod);</span><br><span class="line">    IMP newIMP = imp_implementationWithBlock(^(id self) &#123;</span><br><span class="line">         NSLog(@&quot;Before method execution&quot;);</span><br><span class="line">         ((void(*)(id, SEL))originalIMP)(self, selector);</span><br><span class="line">         NSLog(@&quot;After method execution&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    method_setImplementation(originalMethod, newIMP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2、调用"><a href="#2、调用" class="headerlink" title="2、调用"></a>2、调用</h3><p>以在<strong>进入个人主页前，需要先判断是否登录</strong>为例</p>
<p>常规：使用<strong>Util式、使用宏</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)goMineHomePage &#123;</span><br><span class="line">    // 在调用原始方法之前执行的代码（进入个人主页前，需要先判断是否登录）</span><br><span class="line">    bool canPush = [LoginCheckerUtil checkLogin];</span><br><span class="line">  	if (!canPush) return;</span><br><span class="line">    </span><br><span class="line">    MineHomeViewController *viewController = [[MineHomeViewController alloc] init];</span><br><span class="line">		[self.navigationController pushViewController:viewController animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进(改进后发现，其实可读性不高，所以还不如不这么改）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// LoginCheckUtil.m</span><br><span class="line">#define NeedLoginAnnotation(Class originalSelOwnerClass, SEL originalSelector) \</span><br><span class="line">HookCJHelper_addPreExecutionToClassMethod(originalSelOwnerClass, originalSelector, [LoginCheckUtil class], @selector(loginCheckMethod));</span><br><span class="line">class LoginCheckUtil: NSObject &#123;</span><br><span class="line">	+ (bool)loginCheckMethod &#123;</span><br><span class="line">	  if (UserManager.isLogin) &#123;</span><br><span class="line">      return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    LoginViewController *viewController = [[MineHomeViewController alloc] init];</span><br><span class="line">		[topVC pushViewController:viewController animated:YES];</span><br><span class="line">    return NO;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// HomeViewController.m</span><br><span class="line">+ (void) initialize &#123;</span><br><span class="line">	@NeedLoginAnnotation([self class], @selector(goMineHomePage))	// 在 + (void) initialize 中调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)goMineHomePage &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、内部核心代码"><a href="#3、内部核心代码" class="headerlink" title="3、内部核心代码"></a>3、内部核心代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 在调用原始方法之前插入额外的执行逻辑</span><br><span class="line">bool HookCJHelper_addPreExecutionToClassMethod(Class originalSelOwnerClass, SEL originalSelector, Class preExecSelOwnerClass, SEL preExecutionSelector) &#123;</span><br><span class="line">  	// 原始方法检查</span><br><span class="line">    if (!originalSelOwnerClass || !class_getClassMethod(originalSelOwnerClass, originalSelector)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    Method originalMethod = class_getClassMethod(originalSelOwnerClass, originalSelector);</span><br><span class="line">    IMP originalIMP = method_getImplementation(originalMethod);</span><br><span class="line">    if (!originalIMP) &#123;</span><br><span class="line">    		return false;</span><br><span class="line">   	&#125;</span><br><span class="line">    </span><br><span class="line">  	// 要插入的方法</span><br><span class="line">    if (!preExecSelOwnerClass || !class_getClassMethod(preExecSelOwnerClass, preExecutionSelector)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建新的方法实现</span><br><span class="line">    IMP newIMP = imp_implementationWithBlock(^(Class self) &#123;</span><br><span class="line">      // 调用额外的逻辑（预执行类方法）</span><br><span class="line">      ((void(*)(Class, SEL))objc_msgSend)(preExecSelOwnerClass, preExecutionSelector);</span><br><span class="line">      // 调用原始的类方法</span><br><span class="line">      ((void(*)(Class, SEL))originalIMP)(self, originalSelector);</span><br><span class="line">  	&#125;);</span><br><span class="line"></span><br><span class="line">    // 替换原始方法的实现为新的实现</span><br><span class="line">    method_setImplementation(originalMethod, newIMP);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>什么时候会报<code>unrecognized selector</code>的异常</li>
</ol>
<ul>
<li><p>当调用该对象上某个方法，而该对象上没有实现这个方法的时候。可以通过<code>消息转发</code>进行解决，流程见下图</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1948913-f236e31f679fe683.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/597" alt="img"></p>
<p>image</p>
</li>
<li><p><code>OC</code>在向一个对象发送消息时，<code>runtime</code>库会根据对象的<code>isa</code>指针找到该对象实际所属的类，然后<strong>在该类中的方法列表以及其父类方法列表中寻找方法运行，如果在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常<code>unrecognized selector sent to XXX</code></strong><br><strong>但是在这之前，OC的运行时会给出三次拯救程序崩溃的机会</strong></p>
</li>
<li><p>Method resolution（<strong>消息动态解析</strong>）<br><code>OC</code>运行时会调用<code>+resolveInstanceMethod:</code>或者<code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则，运行时就会移到下一步，消息转发（<code>Message Forwarding</code>）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写 resolveInstanceMethod: 添加对象方法实现</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="comment">// 如果是执行 run 函数，就动态解析，指定新的 IMP</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"run:"</span>)) &#123;</span><br><span class="line">        <span class="comment">// class: 给哪个类添加方法</span></span><br><span class="line">        <span class="comment">// SEL: 添加哪个方法</span></span><br><span class="line">        <span class="comment">// IMP: 方法实现 =&gt; 函数 =&gt; 函数入口 =&gt; 函数名</span></span><br><span class="line">        <span class="comment">// type: 方法类型：void用v来表示，id参数用@来表示，SEL用:来表示</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)runMethod, <span class="string">"v@:@"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新的 run 函数</span></span><br><span class="line"><span class="keyword">void</span> runMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSNumber</span> *meter) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"跑了%@"</span>, meter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Fast forwarding（<strong>消息接受者重定向</strong>）<br>  如果目标对象实现了<code>-forwardingTargetForSelector:</code>，<code>Runtime</code>这时就会调用这个方法，给你把这个消息<strong>转发给其他对象</strong>的机会。只要这个方法返回的不是<code>nil</code>和<code>self</code>，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续<code>Normal Fowarding</code>。 这里叫<code>Fast</code>，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个<code>NSInvocation</code>对象，所以相对更快点</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息接受者重定向</span></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="meta">@selector(run:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[Person alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="comment">// 返回 Person 对象，让 Person 对象接收这个消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Normal forwarding（<strong>消息重定向</strong>）<br>这一步是<code>Runtime</code>最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回<code>nil</code>，<code>Runtime</code>则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，<code>Runtime</code>就会创建一个<code>NSInvocation</code>对象并发送<code>-forwardInvocation:</code>消息给目标对象</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取函数的参数和返回值类型，返回签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(aSelector) isEqualToString:<span class="string">@"run:"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:@"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息重定向</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="comment">// 从 anInvocation 中获取消息</span></span><br><span class="line">    SEL sel = anInvocation.selector;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"run:"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 1\. 指定当前类的一个方法作为IMP</span></span><br><span class="line">        <span class="comment">// anInvocation.selector = @selector(readBook:);</span></span><br><span class="line">        <span class="comment">// [anInvocation invoke];</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2\. 指定其他类来执行这个IMP</span></span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        <span class="comment">// 判断 Person 对象方法是否可以响应 sel</span></span><br><span class="line">        <span class="keyword">if</span>([p respondsToSelector:sel]) &#123;</span><br><span class="line">            <span class="comment">// 若可以响应，则将消息转发给其他对象处理</span></span><br><span class="line">            [anInvocation invokeWithTarget:p];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若仍然无法响应，则报错：找不到响应方法</span></span><br><span class="line">            [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    [<span class="keyword">super</span> doesNotRecognizeSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>既然<code>-forwardingTargetForSelector:</code>和<code>-forwardInvocation:</code>都可以将消息转发给其他对象处理，那么两者的区别在哪？</strong><br>区别就在于<code>-forwardingTargetForSelector:</code>只能将消息转发给一个对象。而<code>-forwardInvocation:</code>可以把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。修改消息的target，selector，参数等。将消息转发给多个对象</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/1语言/1语言-消息转发/" data-id="cm121y2ua016jqar4j2ov8rgp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/1语言/1语言-消息转发NSProxy" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/1语言/1语言-消息转发NSProxy/" class="article-date">
  <time datetime="2022-03-16T05:35:04.562Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-①语言-消息转发2"><a href="#必备知识架构-①语言-消息转发2" class="headerlink" title="必备知识架构-①语言-消息转发2"></a>必备知识架构-①语言-消息转发2</h1><p>[toc]</p>
<h2 id="一、NSProxy"><a href="#一、NSProxy" class="headerlink" title="一、NSProxy"></a>一、NSProxy</h2><p>NSProxy，你可以通过继承它，并重写它的以下两个方法以实现消息转发到另一个实例。说白了，NSProxy专为代理而生（<strong>负责将消息转发到真正的target的代理类</strong>）。从类名来看是代理类，专门负责代理对象转发消息的。相比NSObject类来说NSProxy更轻量级，<strong>通过NSProxy可以帮助Objective-C间接的实现多重继承的功能</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel;</span><br></pre></td></tr></table></figure>
<h3 id="1、通过NSProxy可以帮助Objective-C间接的实现多重继承的功能的例子"><a href="#1、通过NSProxy可以帮助Objective-C间接的实现多重继承的功能的例子" class="headerlink" title="1、通过NSProxy可以帮助Objective-C间接的实现多重继承的功能的例子"></a>1、通过NSProxy可以帮助Objective-C间接的实现多重继承的功能的例子</h3><p>现在比较流行的说法是用它来模拟多重继承，大致过程就是让它Hold住/包含你要实现多继承的类的对象，然后被hold住的对象的行为定义在接口中，并让Proxy去实现这些接口。然后再转发的时候把消息转发到实现了该接口的对象去执行，这样就好像实现了多重继承一样。<strong>注意</strong>：这个真不是多重继承，只是包含，然后把消息路由到指定的对象而已，其实完全可以用NSObject类来实现。</p>
<p>天使=人+鸟</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [Person new];</span><br><span class="line">Bird *bird = [Bird new];</span><br><span class="line"></span><br><span class="line">id angelProxy = [AngelProxy proxyForObject1:person object2:bird];</span><br><span class="line">[proxy speak];	// 人可以说话</span><br><span class="line">[proxy fly];		// 鸟可以飞</span><br></pre></td></tr></table></figure>
<p>另一个例子：<a href="https://www.cnblogs.com/vokie/p/9289958.html" target="_blank" rel="noopener">NSProxy的学习使用</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// AngelProxy.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface AngelProxy : NSProxy</span><br><span class="line"></span><br><span class="line">+ (id)proxyForObject1:(id)obj1 object2:(id)obj2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// AngelProxy.m</span><br><span class="line">#import &quot;AngelProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@interface AngelProxy()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id target1;</span><br><span class="line">@property (nonatomic, weak) id target2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AngelProxy</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithTarget1:(id)obj1 target2:(id)obj2 &#123;</span><br><span class="line">    _target1 = obj1;</span><br><span class="line">    _target2 = obj2;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)proxyForObject1:(id)obj1 object2:(id)obj2 &#123; </span><br><span class="line">    return [[AngelProxy alloc] initWithTarget1:obj1 target2:obj2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重写NSProxy如下两个方法，在处理消息转发时，将消息转发给真正的Target处理</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    id target;</span><br><span class="line">    if ([_target1 methodSignatureForSelector:invocation.selector]) &#123;</span><br><span class="line">        target = _target1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        target = _target2;</span><br><span class="line">    &#125;</span><br><span class="line">    [invocation invokeWithTarget:target];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">    NSMethodSignature *sig;</span><br><span class="line">    </span><br><span class="line">    sig = [_target1 methodSignatureForSelector:selector];</span><br><span class="line">    if (sig) &#123;</span><br><span class="line">        return sig;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sig = [_target2 methodSignatureForSelector:selector];</span><br><span class="line">    return sig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="2、NSProxy-和-NSObject-的比较"><a href="#2、NSProxy-和-NSObject-的比较" class="headerlink" title="2、NSProxy 和 NSObject 的比较"></a>2、NSProxy 和 NSObject 的比较</h3><p>相比NSObject，NSProxy更轻量级，做消息转发效率更高。</p>
<p>NSObject寻找方法顺序：本类-&gt;(父类-)&gt;(动态方法解析)-&gt; 消息转发；<br>NSproxy顺序：本类-&gt;消息转发</p>
<h3 id="3、NSProxy的用途"><a href="#3、NSProxy的用途" class="headerlink" title="3、NSProxy的用途"></a>3、NSProxy的用途</h3><ol>
<li><p>AOP面向切片编程</p>
<p>iOS中面向切片编程一般有两种方式 ，一个是直接基于runtime 的method-Swizzling.还有一种就是基于NSProxy</p>
</li>
<li><p>解决NSTimer, CADisplayLink等强引用target引起的无法释放问题。如NSTimer:利用消息转发来断开NSTimer对象与视图之间的强引用关系。初始化NSTimer时把触发事件的target替换成一个单独的对象，然后这个对象中NSTimer的SEL方法触发时让这个方法在当前的视图self中实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.timer = [NSTimer timerWithTimeInterval:1 target:self.proxy </span><br><span class="line">              								selector:@selector(timerEvent) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br><span class="line">// 这里我们timer的target使用AYProxy对象，它会实现你这个timer想要实现的timerEvent消息转发给self。从而避免了循环引用</span><br></pre></td></tr></table></figure>
<p>协议类代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#import</span><br><span class="line"></span><br><span class="line">@interface AYProxy : NSProxy</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id obj;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;AYProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation AYProxy</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">   NSMethodSignature *sig = nil;</span><br><span class="line">   sig = [self.obj methodSignatureForSelector:aSelector];</span><br><span class="line">   return sig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">   [anInvocation invokeWithTarget:self.obj];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>多重继承</p>
<p>实现类似CAAnimation类族.</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/1语言/1语言-消息转发NSProxy/" data-id="cm121y2ur016mqar41qra3euh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/11/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/13/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/">Architecture</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第一章：架构相关/">第一章：架构相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第七章：技术选型/">第七章：技术选型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第三章：基础规范/">第三章：基础规范</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第九章：监控相关/">第九章：监控相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第二章：框架相关/">第二章：框架相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第八章：页面加载相关/">第八章：页面加载相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第六章：通用业务规范/">第六章：通用业务规范</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第四章：基础框架设计及接口文档/">第四章：基础框架设计及接口文档</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/无瑕疵的混编登录页/">无瑕疵的混编登录页</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第一章：Flutter入门/">第一章：Flutter入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第七章：规范/">第七章：规范</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第三章：原生项目与Flutter的交互/">第三章：原生项目与Flutter的交互</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第九章：框架升级/">第九章：框架升级</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第二章：集成Flutter到原生项目/">第二章：集成Flutter到原生项目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第五章：详解/">第五章：详解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第八章：状态管理/">第八章：状态管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第六章：进阶/">第六章：进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第四章：Flutter登录页实战/">第四章：Flutter登录页实战</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第零章：Flutter源码/">第零章：Flutter源码</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/QA/">QA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/README/">README</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/React/第一章：React入门/">第一章：React入门</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/">ReactNative</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第一章：ReactNative入门/">第一章：ReactNative入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第一章：React入门/">第一章：React入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第五章：ReactNative详解/">第五章：ReactNative详解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第八章：ReactNative实践/">第八章：ReactNative实践</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第六章：ReactNative进阶/">第六章：ReactNative进阶</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/">Script</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Script/JQuery/">JQuery</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Mac快速操作/">Mac快速操作</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Shell/">Shell</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Weex/">Weex</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Weex/第一章：Weex入门/">第一章：Weex入门</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Swift/">Swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/混编/">混编</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/移动分析/">移动分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/自动化/">自动化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/证书发版/">证书发版</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/npmjs/">npmjs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/上架相关/">上架相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/代码管理/">代码管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全与破解/">安全与破解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/">实用工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/ChatGPT/">ChatGPT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/GitBook/">GitBook</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/Jenkins/">Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/XAMPP/">XAMPP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/Zentao/">Zentao</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/其他小工具/">其他小工具</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作常识/">工作常识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术常识/">技术常识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活常识/">生活常识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/管理相关/">管理相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/管理相关/第一章：账号管理/">第一章：账号管理</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程工具/">编程工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/跨平台/">跨平台</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/跨平台/第一章：混编事项说明/">第一章：混编事项说明</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Architecture/">Architecture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChatGPT/">ChatGPT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac快速操作/">Mac快速操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QA/">QA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/README/">README</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReactNative/">ReactNative</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Script/">Script</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/h5与app交互/">h5与app交互</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npmjs/">npmjs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/上架相关/">上架相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/交互/">交互</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/埋点/">埋点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基类/">基类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/实用工具/">实用工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作常识/">工作常识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/打包/">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术常识/">技术常识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/抓包/">抓包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/搜索相关/">搜索相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文档管理/">文档管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/权限相关/">权限相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构模式/">架构模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境搭建/">环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活常识/">生活常识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/瘦身/">瘦身</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/登录页实战/">登录页实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/破解/">破解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动分析/">移动分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/管理相关/">管理相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程工具/">编程工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化/">自动化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/请求/">请求</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨平台/">跨平台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/路由及跳转/">路由及跳转</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阿里云/">阿里云</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阿里云oss/">阿里云oss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集成/">集成</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Architecture/" style="font-size: 20px;">Architecture</a> <a href="/tags/ChatGPT/" style="font-size: 10.83px;">ChatGPT</a> <a href="/tags/CocoaPods/" style="font-size: 10px;">CocoaPods</a> <a href="/tags/Flutter/" style="font-size: 18.33px;">Flutter</a> <a href="/tags/Git/" style="font-size: 13.33px;">Git</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Jenkins/" style="font-size: 14.17px;">Jenkins</a> <a href="/tags/Mac快速操作/" style="font-size: 10px;">Mac快速操作</a> <a href="/tags/Python/" style="font-size: 11.67px;">Python</a> <a href="/tags/QA/" style="font-size: 10px;">QA</a> <a href="/tags/README/" style="font-size: 10px;">README</a> <a href="/tags/React/" style="font-size: 10.83px;">React</a> <a href="/tags/ReactNative/" style="font-size: 15.83px;">ReactNative</a> <a href="/tags/Ruby/" style="font-size: 10px;">Ruby</a> <a href="/tags/Script/" style="font-size: 15px;">Script</a> <a href="/tags/Shell/" style="font-size: 11.67px;">Shell</a> <a href="/tags/Swift/" style="font-size: 12.5px;">Swift</a> <a href="/tags/Weex/" style="font-size: 10px;">Weex</a> <a href="/tags/h5与app交互/" style="font-size: 12.5px;">h5与app交互</a> <a href="/tags/iOS/" style="font-size: 16.67px;">iOS</a> <a href="/tags/npmjs/" style="font-size: 10.83px;">npmjs</a> <a href="/tags/上架相关/" style="font-size: 10px;">上架相关</a> <a href="/tags/交互/" style="font-size: 12.5px;">交互</a> <a href="/tags/埋点/" style="font-size: 10.83px;">埋点</a> <a href="/tags/基类/" style="font-size: 10.83px;">基类</a> <a href="/tags/安全/" style="font-size: 14.17px;">安全</a> <a href="/tags/实用工具/" style="font-size: 17.5px;">实用工具</a> <a href="/tags/工作常识/" style="font-size: 10px;">工作常识</a> <a href="/tags/打包/" style="font-size: 10px;">打包</a> <a href="/tags/技术常识/" style="font-size: 13.33px;">技术常识</a> <a href="/tags/抓包/" style="font-size: 10px;">抓包</a> <a href="/tags/搜索相关/" style="font-size: 10px;">搜索相关</a> <a href="/tags/文档管理/" style="font-size: 14.17px;">文档管理</a> <a href="/tags/权限相关/" style="font-size: 10px;">权限相关</a> <a href="/tags/架构模式/" style="font-size: 11.67px;">架构模式</a> <a href="/tags/环境搭建/" style="font-size: 10.83px;">环境搭建</a> <a href="/tags/生活常识/" style="font-size: 10px;">生活常识</a> <a href="/tags/瘦身/" style="font-size: 11.67px;">瘦身</a> <a href="/tags/登录页实战/" style="font-size: 12.5px;">登录页实战</a> <a href="/tags/破解/" style="font-size: 11.67px;">破解</a> <a href="/tags/移动分析/" style="font-size: 11.67px;">移动分析</a> <a href="/tags/管理相关/" style="font-size: 11.67px;">管理相关</a> <a href="/tags/编程工具/" style="font-size: 12.5px;">编程工具</a> <a href="/tags/自动化/" style="font-size: 11.67px;">自动化</a> <a href="/tags/请求/" style="font-size: 10.83px;">请求</a> <a href="/tags/跨平台/" style="font-size: 19.17px;">跨平台</a> <a href="/tags/路由及跳转/" style="font-size: 11.67px;">路由及跳转</a> <a href="/tags/阿里云/" style="font-size: 10px;">阿里云</a> <a href="/tags/阿里云oss/" style="font-size: 13.33px;">阿里云oss</a> <a href="/tags/集成/" style="font-size: 11.67px;">集成</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/iOS/3必备知识架构/3视图/3视图-①本质RunLoop/">(no title)</a>
          </li>
        
          <li>
            <a href="/iOS/3必备知识架构/2内存/2内存-②循环引用/">(no title)</a>
          </li>
        
          <li>
            <a href="/Architecture架构/架构相关/3组件化/5框架设计模式-⑦组件化/">(no title)</a>
          </li>
        
          <li>
            <a href="/Architecture架构/监控相关/日志系统/">日志系统</a>
          </li>
        
          <li>
            <a href="/电脑使用/旧电脑数据清理/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 dvlproad<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>