<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>dvlproadの博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学而时习之不亦说乎(dvlproad)">
<meta name="keywords" content="blog,IT,iOS,Flutter">
<meta property="og:type" content="website">
<meta property="og:title" content="dvlproadの博客">
<meta property="og:url" content="https://dvlproad.github.io/page/5/index.html">
<meta property="og:site_name" content="dvlproadの博客">
<meta property="og:description" content="学而时习之不亦说乎(dvlproad)">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dvlproadの博客">
<meta name="twitter:description" content="学而时习之不亦说乎(dvlproad)">
  
    <link rel="alternate" href="/atom.xml" title="dvlproadの博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">dvlproadの博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">整理及总结平时过程中的知识点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://dvlproad.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS/3必备知识架构/2内存/2内存-②循环引用" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-②循环引用/" class="article-date">
  <time datetime="2022-03-16T05:35:04.594Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-内存-②循环引用"><a href="#必备知识架构-内存-②循环引用" class="headerlink" title="必备知识架构-内存-②循环引用"></a>必备知识架构-内存-②循环引用</h1><p>[toc]</p>
<h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p>
<p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p>
<p></p><p id="目录"></p><p></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><p><a href="#循环引用原因">一、循环引用原因</a></p>
</li>
<li><p><a href="#NSTimer的循环引用">二、NSTimer的循环引用</a></p>
</li>
<li><p><a href="#委托delegate的循环引用">三、委托delegate的循环引用</a></p>
</li>
<li><p><a href="#block的循环引用">四、block的循环引用</a></p>
</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、Objective-C中block为何得用copy修饰，能否用其他</span><br><span class="line">2、block的循环引用</span><br><span class="line">3、block循环引用的解决</span><br><span class="line">4、判断该block是否会发生循环引用</span><br><span class="line">5、为什么masonry的block里引用self不需要weak？</span><br><span class="line">6、是否所有的Block中，使用self 都会导致循环引用？</span><br><span class="line">7、block修改外部局部变量</span><br><span class="line">(1)、在block中无法直接修改外部变量的原因</span><br><span class="line">(2)、解决如何在 block 中修改外部变量</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p>
</li>
<li><p><a href="#END">END</a></p>
</li>
</ul>
<p></p><p id="循环引用原因"></p><p></p>
<h2 id="一、循环引用原因"><a href="#一、循环引用原因" class="headerlink" title="一、循环引用原因"></a>一、循环引用原因</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>导致iOS对象无法按预期释放的一个无形杀手是——循环引用。循环引用可以简单理解为A引用了B，而B又引用了A，双方都同时保持对方的一个引用，导致任何时候引用计数都不为0，始终无法释放。若当前对象是一个ViewController，则在dismiss或者pop之后其dealloc无法被调用，在频繁的push或者present之后内存暴增，然后APP就duang地挂了。</p>
<p><strong>循环引用会导致内存泄露，因为循环应用会导致，有些对象没办法在已经不会再使用的时候被释放掉</strong></p>
<p>下面列举我们变成中比较容易碰到的三种循环引用的情形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）计时器NSTimer</span><br><span class="line">（2）block</span><br><span class="line">（3）委托delegate</span><br></pre></td></tr></table></figure>
<p></p><p id="NSTimer的循环引用"></p><p></p>
<h2 id="二、NSTimer的循环引用"><a href="#二、NSTimer的循环引用" class="headerlink" title="二、NSTimer的循环引用"></a>二、NSTimer的循环引用</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>NSTimer的循环引用详情，我们放在下面讲解NSTimer(前面已经提过NSTimer 其实就是RunLoop中的CFRunLoopTimerRef，一个基于时间的触发器)的时候介绍。</p>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@interface HWWeakTimerTarget : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id target;			// 注意是 weak</span><br><span class="line">@property (nonatomic, assign) SEL selector; // assign</span><br><span class="line">@property (nonatomic, weak) NSTimer* timer;	// 注意是 weak</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation HWWeakTimerTarget</span><br><span class="line"></span><br><span class="line">- (void) fire:(NSTimer *)timer &#123;</span><br><span class="line">    if(self.target) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">        [self.target performSelector:self.selector withObject:timer.userInfo afterDelay:0.0f];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.timer invalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation HWWeakTimer</span><br><span class="line"></span><br><span class="line">+ (NSTimer *) scheduledTimerWithTimeInterval:(NSTimeInterval)interval</span><br><span class="line">                                      target:(id)aTarget</span><br><span class="line">                                    selector:(SEL)aSelector</span><br><span class="line">                                    userInfo:(id)userInfo</span><br><span class="line">                                     repeats:(BOOL)repeats &#123;</span><br><span class="line">    HWWeakTimerTarget* timerTarget = [[HWWeakTimerTarget alloc] init];</span><br><span class="line">    timerTarget.target = aTarget;</span><br><span class="line">    timerTarget.selector = aSelector;</span><br><span class="line">    timerTarget.timer = [NSTimer scheduledTimerWithTimeInterval:interval</span><br><span class="line">                                                         target:timerTarget</span><br><span class="line">                                                       selector:@selector(fire:)</span><br><span class="line">                                                       userInfo:userInfo</span><br><span class="line">                                                        repeats:repeats];</span><br><span class="line">    return timerTarget.timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p></p><p id="委托delegate的循环引用"></p><p></p>
<h2 id="三、委托delegate的循环引用"><a href="#三、委托delegate的循环引用" class="headerlink" title="三、委托delegate的循环引用"></a>三、委托delegate的循环引用</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>在委托问题上出现循环引用问题已经是老生常谈了，声明delegate时请用weak(ARC)，如果是MRC则用assign。千万别手贱。</p>
<p></p><p id="block的循环引用"></p><p></p>
<h2 id="四、block的循环引用"><a href="#四、block的循环引用" class="headerlink" title="四、block的循环引用"></a>四、block的循环引用</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<h5 id="1、Objective-C中block为何得用copy修饰，能否用其他"><a href="#1、Objective-C中block为何得用copy修饰，能否用其他" class="headerlink" title="1、Objective-C中block为何得用copy修饰，能否用其他"></a>1、Objective-C中block为何得用copy修饰，能否用其他</h5><blockquote>
<p>答：因为<strong>block在创建的时候，它的内存是分配在栈(stack)上，而不是在堆(heap)上。他本身的作于域是属于创建时候的作用域，一旦在创建时候的作用域外面调用block将导致程序崩溃。所以，为了能够在block的声明域外也能够使用block，我们需要将block拷贝到堆上，所以使用copy属性。</strong>对于堆中的block，也就是copy修饰的block。他的生命周期是随着对象的销毁而结束的。只要对象不销毁，我们就可以调用的到在堆中的block。</p>
</blockquote>
<h5 id="2、block的循环引用"><a href="#2、block的循环引用" class="headerlink" title="2、block的循环引用"></a>2、block的循环引用</h5><p><strong>由于block在copy时都会对block内部用到的对象进行强引用(ARC)或者retainCount增1(非ARC)。所以，不管是在ARC还是非ARC环境下对block使用不当都会引起循环引用问题</strong></p>
<p>一般表现为，某个类将block作为自己的属性变量(则该类就对block强引用了)，然后该类在block的方法体里面又使用了该类本身。即当对象（比如self）拥有一个block属性的时候，在block属性中又引用了对象的其他成员变量或者调用了对象的其他方法。形成你中有我，我中有你，谁都无法将谁释放的困局。形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">self.myBlock = ^&#123;</span><br><span class="line">   [self doSomething];</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line">又或者</span><br><span class="line"></span><br><span class="line">ClassA* objA = [[ClassA alloc] init];</span><br><span class="line">objA.myBlock = ^&#123;</span><br><span class="line">   [self doSomething];</span><br><span class="line">&#125;;</span><br><span class="line">self.objA = objA;</span><br></pre></td></tr></table></figure>
<p>block的这种循环引用会被编译器捕捉到并及时提醒。</p>
<p>以上参考自：<a href="http://www.jianshu.com/p/b79bac09177e" target="_blank" rel="noopener">Block的循环引用</a></p>
<h5 id="3、block循环引用的解决"><a href="#3、block循环引用的解决" class="headerlink" title="3、block循环引用的解决"></a>3、block循环引用的解决</h5><h6 id="1-、常规简单解法"><a href="#1-、常规简单解法" class="headerlink" title="(1)、常规简单解法"></a>(1)、常规简单解法</h6><p>解决方法,就一句话的事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof (self) weakSelf = self; </span><br><span class="line">self.myBlock = ^&#123;</span><br><span class="line">    [weakSelf doSomething];</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  附1：如果是non-ARC环境下就将__weak替换为__block即可。non-ARC情况下，__block变量的含义是在Block中引入一个新的结构体成员变量指向这个__block变量，那么__block typeof(self) weakSelf = self;就表示Block别再对self对象retain啦，这就打破了循环引用。</span><br><span class="line">  </span><br><span class="line">  附2：__weak 是 iOS 5.0 推出的，_weak 相当于 weak，不会做强引用，如果对象被释放，执行的地址，会指向 nil</span><br></pre></td></tr></table></figure>
<h6 id="2-、block中使用-weak–strong-dance-技术避免循环引用"><a href="#2-、block中使用-weak–strong-dance-技术避免循环引用" class="headerlink" title="(2)、block中使用 weak–strong dance 技术避免循环引用"></a>(2)、block中使用 weak–strong dance 技术避免循环引用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self)weakSelf = self;</span><br><span class="line">  [header setTapHandle:^&#123;</span><br><span class="line">  		__strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line">  		if (strongSelf) &#123;</span><br><span class="line">     		NSLog(@&quot;strongSelf = %@&quot;, strongSelf);</span><br><span class="line">  		&#125;</span><br><span class="line"> 	[weakSelf headerAction:header];</span><br><span class="line">	&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>精髓2：①在 block 之前定义对 self 的一个弱引用weakSelf，因为是弱引用，所以当 self 被释放时weakSelf会变为nil；② 在 block 中引用该弱应用，考虑到多线程情况，通过使用强引用 strongSelf 来引用该弱引用，这时如果 self 不为 nil 就会 retain self，以防止在后面的使用过程中 self 被释放;③在之后的 block 块中使用该强引用 bself，注意在使用前要对 bSelf 进行了 nil 检测，因为多线程环境下在用弱引用weakSelf对强引用strongSelf赋值时，弱引用weakSelf可能已经为nil了。通过这种手法，block 就不会持有 self 的引用，从而打破了循环引用。</strong></p>
<h4 id="iOS开发中在block中为什么要weak和strong配合使用"><a href="#iOS开发中在block中为什么要weak和strong配合使用" class="headerlink" title="iOS开发中在block中为什么要weak和strong配合使用"></a><a href="https://www.jianshu.com/p/0b87b4e7da2c" target="_blank" rel="noopener">iOS开发中在block中为什么要<strong>weak和</strong>strong配合使用</a></h4><blockquote>
<p>答：<strong>weak是为了解决循环引用。</strong>strong是为了防止block持有的对象提前释放。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">  [self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line"></span><br><span class="line">  __weak typeof(self) weakSelf = self;</span><br><span class="line">  self.block = ^&#123;</span><br><span class="line">      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          NSLog(@&quot;%@&quot;, weakSelf);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  self.block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>点击屏幕，当前控制器消失，同时被销毁掉，5秒后打印的weakSelf就是一个(null)。<br>而我们如果在block内使用__strong后就能保证再打印完strongSelf之后再释放当前控制器。</p>
</blockquote>
<h5 id="4、判断该block是否会发生循环引用"><a href="#4、判断该block是否会发生循环引用" class="headerlink" title="4、判断该block是否会发生循环引用"></a>4、判断该block是否会发生循环引用</h5><p><a href="http://www.cocoachina.com/ios/20170122/18601.html" target="_blank" rel="noopener">判断该block是否会发生循环引用例子</a></p>
<h5 id="5、为什么masonry的block里引用self不需要weak？"><a href="#5、为什么masonry的block里引用self不需要weak？" class="headerlink" title="5、为什么masonry的block里引用self不需要weak？"></a>5、为什么masonry的block里引用self不需要weak？</h5><p>这个就和网络请求里面使用self道理是一样的。因为UIView未强持有block，所以这个block只是个栈block，而且构不成循环引用的条件。栈block有个特性就是它执行完毕之后就出栈，出栈了就会被释放掉。看mas_makexxx的方法实现会发现这个block很快就被调用了，完事儿就出栈销毁，构不成循环引用，所以可以直接放心的使用self。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    self.translatesAutoresizingMaskIntoConstraints = NO;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    return [constraintMaker install];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果要强引用，block应该是masnory的一个属性，即被masnory对象持有。且是copy修饰符</span><br></pre></td></tr></table></figure>
<h4 id="6、是否所有的Block中，使用self-都会导致循环引用？"><a href="#6、是否所有的Block中，使用self-都会导致循环引用？" class="headerlink" title="6、是否所有的Block中，使用self 都会导致循环引用？"></a>6、是否所有的Block中，使用self 都会导致循环引用？</h4><h4 id="7、block修改外部局部变量"><a href="#7、block修改外部局部变量" class="headerlink" title="7、block修改外部局部变量"></a>7、block修改外部局部变量</h4><p>如果是全局变量呢？</p>
<h6 id="1-、在block中无法直接修改外部变量的原因"><a href="#1-、在block中无法直接修改外部变量的原因" class="headerlink" title="(1)、在block中无法直接修改外部变量的原因"></a>(1)、在block中无法直接修改外部变量的原因</h6><p>错误示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//声明一个局部整型变量 </span><br><span class="line">int intValue = 3; //漏掉了__block修饰符</span><br><span class="line"></span><br><span class="line">//声明一个返回值为int,一个int参数的block变量</span><br><span class="line">int (^block)(int) = ^(int m)&#123;</span><br><span class="line">    intValue++;</span><br><span class="line">    return m * intValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//调用block变量,5作为参数之后的结果</span><br><span class="line">NSLog(@&quot;block(5) = %d&quot;,block(5));</span><br></pre></td></tr></table></figure>
<p>在上面的例子中,我们编译程序后发现编译器会有红色错误,错误提示为<br>Variable is not assignable (missing __block type specifier)</p>
<p>为什么会出现不能被赋值的错误提示呢？</p>
<p>block在实现时就会对它引用到的它所在方法中定义的栈变量进行一次只读拷贝，在 block 块内使用该只读拷贝。<br>那为了避免上述错误，就要<strong>精髓1：使用__block修饰符来修饰外部变量,用来通知编译器该外部变量intValue与block中的intValue指的是同一块儿内存地址，而不需要内存拷贝。</strong></p>
<h6 id="2-、解决如何在-block-中修改外部变量"><a href="#2-、解决如何在-block-中修改外部变量" class="headerlink" title="(2)、解决如何在 block 中修改外部变量"></a>(2)、解决如何在 block 中修改外部变量</h6><ul>
<li><p>有必要了解：<a href="http://www.jianshu.com/p/404ff9d3cd42" target="_blank" rel="noopener">iOS中__block 关键字的底层实现原理</a></p>
</li>
<li><p>结论：<code>block可以访问外部变量，但是无法修改外部变量的值，如果要修改外部变量的值，需要对外部变量加上__block作为该变量的修饰</code></p>
<p>来源：<a href="http://bbs.itheima.com/thread-248328-1-1.html" target="_blank" rel="noopener">OC学习笔记之block访问外部变量【重点面试】</a></p>
</li>
</ul>
<ul>
<li>问题： <a href="http://blog.csdn.net/huyisu/article/details/40543291" target="_blank" rel="noopener">如何在 block 中修改外部变量</a></li>
</ul>
<p>有两种办法<br>① 第一种是可以修改 static 全局变量；<br>② 第二种是可以修改用新关键字 __block 修饰的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__block int blockLocal  = 100;</span><br><span class="line">static int staticLocal  = 100;</span><br><span class="line"></span><br><span class="line">void (^aBlock)(void) = ^(void)&#123; </span><br><span class="line">    NSLog(@&quot; &gt;&gt; Sum: %d\n&quot;, global + staticLocal);</span><br><span class="line">    </span><br><span class="line">    global++;</span><br><span class="line">    blockLocal++;</span><br><span class="line">    staticLocal++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">aBlock();</span><br></pre></td></tr></table></figure>
<p><code>附：静态变量 和 全局变量   在加和不加  __block 都会直接引用变量地址。也就意味着静态变量和全局变量的修改可以直接修改，不需要作添加__block的步骤。</code></p>
<h4 id="在ARC下获取对象的引用计数值"><a href="#在ARC下获取对象的引用计数值" class="headerlink" title="在ARC下获取对象的引用计数值"></a>在ARC下获取对象的引用计数值</h4><p>在ARC下获取对象的引用计数值，可以使用CFGetRetainCount。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于Core Foundation对象：</span><br><span class="line">NSLog(@&quot;CFGetRetainCount is %ld&quot;,  CFGetRetainCount(aCFString));</span><br><span class="line"></span><br><span class="line">对于Foundation对象</span><br><span class="line">NSLog(@&quot;CFGetRetainCount is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)aNNstring));</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@ CFGetRetainCount is %ld&quot;, NSStringFromClass([self class]), CFGetRetainCount((__bridge CFTypeRef)self));</span><br></pre></td></tr></table></figure>
<p>以下获取引用计数的方法错了，但是不知道正确的应该怎么用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%@ dealloc&quot;, NSStringFromClass([self class]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@ viewWillDisappear and CFGetRetainCount is %ld&quot;, NSStringFromClass([self class]), CFGetRetainCount((__bridge CFTypeRef)self));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@ viewDidDisappear and CFGetRetainCount is %ld&quot;, NSStringFromClass([self class]), CFGetRetainCount((__bridge CFTypeRef)self));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几篇文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/bcc0bcaadd6c" target="_blank" rel="noopener">iOS杂谈：影响控制器正常释放的常见问题</a></li>
<li><a href="https://www.cnblogs.com/songliquan/p/4970505.html" target="_blank" rel="noopener">iOS中控制器的释放问题</a></li>
<li><a href="https://blog.csdn.net/u014222687/article/details/51767685" target="_blank" rel="noopener">Block与Self的循环引用</a></li>
<li><p><a href="http://www.cocoachina.com/ios/20170122/18601.html" target="_blank" rel="noopener">ARC下用块（block）的循环引用问题样例探究</a></p>
</li>
<li><p><a href="https://blog.csdn.net/y_csdnblog_xx/article/details/51483111" target="_blank" rel="noopener">ReactiveCocoa之RAC内存管理（十二）</a></p>
</li>
<li><a href="https://www.jianshu.com/p/16b78d72dc95" target="_blank" rel="noopener">ReactiveCocoa入门教程——第二部分</a></li>
<li><a href="https://www.jianshu.com/p/16e8e2e5773c" target="_blank" rel="noopener">subscribenext 循环引用</a></li>
</ul>
<p></p><p id="常见笔试/面试题"></p><p></p>
<h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p>
<h6 id="block和weak修饰符的区别是什么？"><a href="#block和weak修饰符的区别是什么？" class="headerlink" title="block和weak修饰符的区别是什么？"></a><strong>block和</strong>weak修饰符的区别是什么？</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，在MRC时代，__block修饰，可以避免循环引用；ARC时代，__block修饰，同样会引起循环引用问题；</span><br><span class="line">2，__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型；</span><br><span class="line">3，__weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；</span><br><span class="line">4，__block对象可以在block中被重新赋值，__weak不可以；</span><br></pre></td></tr></table></figure>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-②循环引用/" data-id="cldyf81ct00uh00r489exrkt8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/2内存/2内存-①基础" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-①基础/" class="article-date">
  <time datetime="2022-03-16T05:35:04.583Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-内存"><a href="#必备知识架构-内存" class="headerlink" title="必备知识架构-内存"></a>必备知识架构-内存</h1><p>[toc]</p>
<h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p>
<p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p>
<p></p><p id="目录"></p><p></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#指针">一、指针</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、几个本质</span><br><span class="line">&gt;</span><br><span class="line">2、空指针和未初始化的指针</span><br><span class="line">(1)、空指针和未初始化的指针的区别：</span><br><span class="line">(2)、为什么指针变量定义时一定要初始化？ </span><br><span class="line">&gt;</span><br><span class="line">3、野指针与悬空指针</span><br><span class="line">(1)、指针与内存的常见使用顺序</span><br><span class="line">(2)、内存泄漏的概念</span><br><span class="line">(3)、野指针概念</span><br><span class="line">(4)、在iOS中野指针的后果</span><br><span class="line">(5)、分析野指针的产生原因及解决办法</span><br><span class="line">&gt;</span><br><span class="line">4、iOS NSerror 用双重指针理解</span><br><span class="line">&gt;</span><br><span class="line">5、指针和引用的区别</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><a href="#内存">二、内存</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、堆和栈的区别?</span><br><span class="line">&gt;</span><br><span class="line">2、浅拷贝和深拷贝的区别</span><br><span class="line">&gt;</span><br><span class="line">3、分析NSString、NSMutableString等类的copy、mutableCopy</span><br><span class="line">(1)、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？</span><br><span class="line">(2)、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</span><br><span class="line">(3)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</span><br><span class="line">(4)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSMutableString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</span><br><span class="line">(5)、自己代码实现copy修饰符，应该怎么写？？？？</span><br><span class="line">&gt;</span><br><span class="line">4、NSCoding和NSCopy</span><br><span class="line">(1)、NSCoding的作用</span><br><span class="line">(2)、NSCopy</span><br><span class="line">&gt;</span><br><span class="line">5、@synthesize和@dynamic区别</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><a href="#内存">八、谈谈内存管理、内存泄露、循环引用</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、内存管理</span><br><span class="line">(1)、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？</span><br><span class="line">(2)、那怎么知道对象已经没有被引用了呢？</span><br><span class="line">(3)、autorelease、autoreleasepool(自动释放池)</span><br><span class="line">(4)、autoreleasepool(自动释放池)　</span><br><span class="line">(5)、autoreleasepool里面对象的内存什么时候释放? </span><br><span class="line">(6)、runloop、autorelease pool以及线程之间的关系</span><br><span class="line">(7)、自动释放池怎样创建</span><br><span class="line">(8)、自动释放池使用注意</span><br><span class="line">(9)、自动释放池的应用/什么时候要用@autoreleasepool</span><br><span class="line">&gt;</span><br><span class="line">2、如何监测内存泄漏</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><a href="#常见笔试/面试题">常见笔试/面试题</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自动释放池底层怎么实现?</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><a href="#END">END</a></li>
</ul>
<p>常用数据类型占用内存大小</p>
<ul>
<li><a href="https://www.cnblogs.com/guozht/p/7929033.html" target="_blank" rel="noopener">常用数据类型占用内存大小</a></li>
</ul>
<blockquote>
<p><strong>64位编译器</strong></p>
<p>char ：1个字节<br>char*(即指针变量): 8个字节<br>short int : 2个字节<br>int： 4个字节<br>unsigned int : 4个字节<br>float: 4个字节<br>double:  8个字节<br><strong>long:  8个字节</strong><br>long long: 8个字节<br>unsigned long: 8个字节</p>
</blockquote>
<p></p><p id="指针"></p><p></p>
<h2 id="一、指针"><a href="#一、指针" class="headerlink" title="一、指针"></a>一、指针</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<h4 id="1、几个本质"><a href="#1、几个本质" class="headerlink" title="1、几个本质"></a>1、几个本质</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">数据类型：</span><br><span class="line">数据类型的本质是固定大小内存的别名。</span><br><span class="line">对变量声明数据类型，是为了告诉编译器分配几个字节的内存。</span><br><span class="line"></span><br><span class="line">变量：</span><br><span class="line">变量的本质是一段内存空间的别名。</span><br><span class="line">也就是给一段内存空间取一个新的名字，就是变量。</span><br><span class="line"></span><br><span class="line">指针：</span><br><span class="line">指针也是一种数据类型，它的值是某一个内存空间的地址。</span><br><span class="line">指针的步长根据它指向的内存空间的数据类型而定。</span><br><span class="line"></span><br><span class="line">数组中[]的本质：假如有数组array，则array[i]等价于*(array+i)，是因为[]对于程序员来讲是友好的，但是编译器最终还是要将它理解为指针，也就是数组作为函数参数时的退化。array[i] ==&gt; array[0+i] ==&gt;*(array+i)</span><br></pre></td></tr></table></figure>
<h4 id="2、空指针和未初始化的指针-野指针"><a href="#2、空指针和未初始化的指针-野指针" class="headerlink" title="2、空指针和未初始化的指针/野指针"></a>2、空指针和未初始化的指针/野指针</h4><h6 id="1-、空指针和未初始化的指针的区别："><a href="#1-、空指针和未初始化的指针的区别：" class="headerlink" title="(1)、空指针和未初始化的指针的区别："></a>(1)、空指针和未初始化的指针的区别：</h6><blockquote>
<p><strong>①空指针可以确保不指向任何对象或函数</strong>;<br>而<strong>②未初始化指针则可能指向任何地方，即它所指向的地址就是随机的，也就说此时它是个野指针。（附：如果一个指针的指向对象后来被删除，却未置为空指针nil，则它也是野指针）</strong><br>所以空指针在概念上不同于未初始化的指针。<br>对于malloc在其内存分配的时候，如果内存分配成功，返回的一定不是空指针；但是如果malloc内存分配失败,返回的空指针。而不是一个未初始化的指针。</p>
</blockquote>
<p>以下是华为笔试题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下面有关空指针和未初始化指针，说法错误的是？</span><br><span class="line">A.对0x0这个地址取值是非法的</span><br><span class="line">B.空指针可以确保不指向任何对象或函数; 而未初始化指针则可能指向任何地方。</span><br><span class="line">C.空指针与任何对象或函数的指针值都不相等</span><br><span class="line">D.malloc在其内存分配失败时返回的是一个未初始化的指针</span><br></pre></td></tr></table></figure>
<p>错误答案是D，因malloc内存分配失败，返回的是空指针。详细请查看原文地址<br><a href="https://www.nowcoder.com/questionTerminal/9a24bf403b1c4103a23562d52a2091ea" target="_blank" rel="noopener">华为笔试：下面有关空指针和未初始化指针，说法错误的是？</a></p>
<h6 id="2-、为什么指针变量定义时一定要初始化？"><a href="#2-、为什么指针变量定义时一定要初始化？" class="headerlink" title="(2)、为什么指针变量定义时一定要初始化？"></a>(2)、为什么指针变量定义时一定要初始化？</h6><blockquote>
<p>答:因为你首先要理解一点.内存空间不是你分配了才可以使用，只是你分配了之后使用才安全。</p>
<p>为什么要进行对他初始化呢，因为如果你没对它初始化，那么这个指针所指向的地址就是随机的，即此时它是个野指针。这时候如果你引用这个指针并对它做了修改这个指针所指向的内容的操作的话，如果刚好这个指针所指向的内容恰好是另外一个程序的数据的话，那么你原本随意的一个修改，就造成了对另一个程序的数据的修改了，也就会导致另外一个程序可能不能正常运行了。所以使用前一定要进行初始化。</p>
</blockquote>
<h4 id="3、野指针与悬空指针"><a href="#3、野指针与悬空指针" class="headerlink" title="3、野指针与悬空指针"></a>3、野指针与悬空指针</h4><p>在C/C++等语言中，</p>
<p>悬空指针（Dangling Pointer）指的是：<strong>一个指针的指向对象已被删除</strong>，那么就成了悬空指针。</p>
<p><strong>野指针是那些未初始化的指针</strong>。</p>
<p>有时也把野指针和悬空指针通称悬空指针。<br>而好像在iOS中是通称为野指针。</p>
<p>以下内容摘自：<a href="https://baike.baidu.com/item/迷途指针/6959997?fr=aladdin" target="_blank" rel="noopener">百度百科：迷途指针</a></p>
<blockquote>
<p>在计算机编程领域中，迷途指针，或称悬空指针、野指针，指的是不指向任何合法的对象的指针。</p>
<p>当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址，此情况下该指针便称迷途指针。</p>
<p>若操作系统将这部分已经释放的内存重新分配给另外一个进程，而原来的程序重新引用现在的迷途指针，则将产生无法预料的后果。因为此时迷途指针所指向的内存现在包含的已经完全是不同的数据。通常来说，若原来的程序继续往迷途指针所指向的内存地址写入数据，这些和原来程序不相关的数据将被损坏，进而导致不可预料的程序错误。</p>
<p>这种类型的程序错误，不容易找到问题的原因，通常会导致存储器区块错误（Linux系统中）和一般保护错误（Windows系统中）。如果操作系统的内存分配器将已经被覆盖的数据区域再分配，就可能会影响系统的稳定性。</p>
<p>某些编程语言允许未初始化的指针的存在，而这类指针即为野指针。野指针所导致的错误和迷途指针非常相似，但野指针的问题更容易被发现。</p>
</blockquote>
<h6 id="1-、指针与内存的常见使用顺序"><a href="#1-、指针与内存的常见使用顺序" class="headerlink" title="(1)、指针与内存的常见使用顺序"></a>(1)、指针与内存的常见使用顺序</h6><p>在堆中申请了一块内存，并用一个指针指向它。<br>一般我们都会在不用的时候先释放该指针指向的内存，再将该指针置为空指针。<br>即一般正确的写法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针变量和指针所指向的内存变量是两个不同的概念</span></span><br><span class="line"><span class="comment">//使用动态内存分为三步</span></span><br><span class="line"><span class="comment">//1.定义时，将指针为定义NULL</span></span><br><span class="line"><span class="comment">//2.释放内存时，把指针变量重新赋值或者NULL</span></span><br><span class="line"><span class="comment">//3.释放内存后，把指针变量赋值为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);<span class="comment">//释放P所指向的内存空间,但指针变量p仍然留在栈中,成为了野指针</span></span><br><span class="line">        p = <span class="literal">NULL</span>;<span class="comment">//释放野指针（这是关键，记得释放指针所指向的内存空间后，要释放野指针）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是<br>①、如果我们在未来始终没有去手动释放掉我们开辟的内存的话，会导致内存泄漏；<br>②、如果释放掉了该内存，却忘了同时释放只想该内存的指针，会导致产生悬空指针或者说是迷途指针，或者有人也称是野指针。<br>③、如果记得释放指针，却忘了释放指针只想的内存(即记得②忘了①)，那么由于指针已经消失，而指针指向的东西还在，那么久永远无法控制这块内存，而导致一定内存泄漏了。</p>
<h6 id="2-、内存泄漏的概念"><a href="#2-、内存泄漏的概念" class="headerlink" title="(2)、内存泄漏的概念"></a>(2)、内存泄漏的概念</h6><p><strong>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</strong></p>
<h6 id="3-、野指针概念"><a href="#3-、野指针概念" class="headerlink" title="(3)、野指针概念"></a>(3)、野指针概念</h6><blockquote>
<p>C语言: 当我们声明1个指针变量,没有为这个指针变量赋初始值.这个指针变量的值是1个垃圾指针 指向1块随机的内存空间。</p>
<p>OC语言: 指针指向的对象已经被回收掉了.这个指针就叫做野指针.</p>
<p><strong>野指针：指向内存被释放的内存或者没有访问权限的内存的指针</strong>。</p>
</blockquote>
<p>更详细的概念可查看：<a href="https://baike.baidu.com/item/野指针/9654046?fr=aladdin" target="_blank" rel="noopener">百度百科——野指针</a></p>
<h6 id="4-、在iOS中野指针的后果"><a href="#4-、在iOS中野指针的后果" class="headerlink" title="(4)、在iOS中野指针的后果"></a>(4)、在iOS中野指针的后果</h6><p>野指针的后果：崩溃EXC_BAD_ADDRESS</p>
<h6 id="5-、分析野指针的产生原因及解决办法"><a href="#5-、分析野指针的产生原因及解决办法" class="headerlink" title="(5)、分析野指针的产生原因及解决办法"></a>(5)、分析野指针的产生原因及解决办法</h6><blockquote>
<p>知识点：任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</p>
</blockquote>
<p>“野指针”的成因主要有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）指针变量没有被初始化。(即随机只想的这个指针很有可能只想一块没人用的内存，)</span><br><span class="line"><span class="keyword">char</span> *p; <span class="comment">//此时p为野指针</span></span><br><span class="line"><span class="comment">//正确的为在声明之后加上 p=new char[10];我们常直接写为一行，即char *p=new char[10];</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）指针p被<span class="built_in">free</span>或者<span class="keyword">delete</span>之后，没有置为<span class="literal">NULL</span>，让人误以为p是个合法的指针.</span><br><span class="line"><span class="keyword">char</span> *p=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];  <span class="comment">//指向堆中分配的内存首地址，p存储在栈区</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; p;</span><br><span class="line"><span class="keyword">delete</span> []p; <span class="comment">//p重新变为野指针</span></span><br><span class="line"><span class="comment">//正确的应该在指针p被free或者delete之后,加上p = Null;</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）指针操作超越了变量的作用范围。</span><br><span class="line"><span class="keyword">char</span> *p=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; <span class="comment">//指向堆中分配的内存首地址</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; p;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(p+<span class="number">10</span>); <span class="comment">//可能输出未知数据</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/tgycoder/p/5661431.html" target="_blank" rel="noopener">iOS 关于僵尸对象和僵尸指针的那些事儿</a></p>
<h4 id="4、iOS-NSerror-用双重指针理解"><a href="#4、iOS-NSerror-用双重指针理解" class="headerlink" title="4、iOS NSerror 用双重指针理解"></a>4、iOS NSerror 用双重指针理解</h4><p>常见代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *error = nil;</span><br><span class="line">[[NSFileManager defaultManager] removeItemAtPath:absoluteFilePath error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">	NSLog(@&quot;删除单个文件的时候出现错误：%@&quot;,error.localizedDescription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，如果我们不是传指针的指针&amp;error,而是传error，那么if(error)中的error就肯定是nil了。那就没用了。</p>
<p>所以这里传error的指针的原因可简单概括为：<br>因为我们要得到一个新的error值。所以如果有方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSError *)getNewErrorForremoveItemAtPathremoveItemAtPath:(NSString *)path  error:(NSError **)error &#123;</span><br><span class="line">	NSError *newError = [NSError errorWithDomain:...];</span><br><span class="line">	</span><br><span class="line">	return newError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这边，我们的error,就可以直接传error本身，甚至不传都是可以的。</p>
<p>但是实际是这些方法本身的返回值，已经被定义为判断能否进行某种操作，而不是操作是否成功给占用了，如这边已经被判断能否进行删除文件给占用了，所以如果我们还想知道这个删除文件操作结果的error，那就把error的指针的指针传进去，最后其出来的就是我们想要的。<br>所以，猜测其内部结构应该是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)removeItemAtPath:(NSString *)path error:(NSError **)error &#123;</span><br><span class="line">	BOOL canRemove = ...;</span><br><span class="line">	if (!canRemove) &#123;</span><br><span class="line">		* error = [NSError errorWithDomain:...];</span><br><span class="line">		return NO;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		//* error = * error; //即不变</span><br><span class="line">		return YES;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下解释原因摘自：<a href="https://zhidao.baidu.com/question/484954523.html" target="_blank" rel="noopener">ios中处理错误为什么传递的是&amp;error，而不是error？</a></p>
<blockquote>
<p>因为 需要将error 传入后修改其值，然后再返回来，返回来后还要保证己经修改过了。</p>
<p>&amp;error传入是传的地址引用，传入后处理函数直接访问变量的地址，可以修改其值再返回同一个地址， 调用函数就可以知道值是否有修改，即是否有错。</p>
<p>而error传入是传的值引用，值引用传入到程序栈中后其实是把原来的值复制了一份传过去，处理函数可以修改，但无法将改后的值传出函数体。</p>
</blockquote>
<h4 id="5、指针和引用的区别"><a href="#5、指针和引用的区别" class="headerlink" title="5、指针和引用的区别"></a>5、指针和引用的区别</h4><p>(1)定义和性质的区别<br>①指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；<br>②而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。<br>简单点说：一个是存地址，一个是变量别名<br>（2）指针和引用作为函数参数进行传递时的区别<br>①用指针传递参数，可以实现对实参进行改变的目的，是因为传递过来的是实参的地址<br>②引用作为函数参数进行传递时，实质上传递的是实参本身，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。</p>
<p></p><p id="内存"></p><p></p>
<h2 id="二、内存"><a href="#二、内存" class="headerlink" title="二、内存"></a>二、内存</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<h4 id="1、堆和栈的区别"><a href="#1、堆和栈的区别" class="headerlink" title="1、堆和栈的区别?"></a>1、堆和栈的区别?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一、堆栈空间分配区别：</span><br><span class="line">1、栈（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；</span><br><span class="line">2、堆（操作系统）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</span><br><span class="line"></span><br><span class="line">二、堆栈缓存方式区别：</span><br><span class="line">1、栈使用的是一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放；</span><br><span class="line">2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</span><br></pre></td></tr></table></figure>
<h2 id="八、谈谈内存管理、内存泄露、循环引用"><a href="#八、谈谈内存管理、内存泄露、循环引用" class="headerlink" title="八、谈谈内存管理、内存泄露、循环引用"></a>八、谈谈内存管理、内存泄露、循环引用</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>ARC已经出来很久了，自动释放内存的确很方便，但是并非绝对安全绝对不会产生内存泄露。</p>
<h3 id="1、内存管理"><a href="#1、内存管理" class="headerlink" title="1、内存管理"></a>1、内存管理</h3><h5 id="1-、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？"><a href="#1-、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？" class="headerlink" title="(1)、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？"></a>(1)、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？</h5><p>答案是：当对象没有被任何变量引用（也可以说是没有指针指向该对象）的时候，就会被释放。</p>
<h5 id="2-、那怎么知道对象已经没有被引用了呢？"><a href="#2-、那怎么知道对象已经没有被引用了呢？" class="headerlink" title="(2)、那怎么知道对象已经没有被引用了呢？"></a>(2)、那怎么知道对象已经没有被引用了呢？</h5><p>ObjC采用引用计数（reference counting）的技术来进行管理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）每个对象都有一个关联的整数，称为引用计数器；</span><br><span class="line">2）当代码需要使用该对象时，则将对象的引用计数加1；</span><br><span class="line">3）当代码结束使用该对象时，则将对象的引用计数减1；</span><br><span class="line">4）当引用计数的值变为0时，表示对象没有被任何代码使用，此时对象将被释放。</span><br></pre></td></tr></table></figure>
<p>与之对应的消息发送方法如下：</p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th>OC中对应的方法</th>
<th>引用计数的变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>当对象被创建时</td>
<td>alloc/new/copy/mutableCopy等</td>
<td>+1</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain</td>
<td>+1</td>
</tr>
<tr>
<td>释放对象</td>
<td>release</td>
<td>-1</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc</td>
<td>-</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）当对象被创建（通过alloc、new或copy/mutableCopy等方法）时，其引用计数初始值为1；</span><br><span class="line">2）给对象发送retain消息，其引用计数加1；</span><br><span class="line">3）给对象发送release消息，其引用计数减1；</span><br><span class="line">4）当对象引用计数归0时，ObjC給对象发送dealloc消息销毁对象</span><br><span class="line">当创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1；</span><br><span class="line">在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1；</span><br><span class="line">需要释放一个对象时，就将该对象的引用计数减1；</span><br><span class="line">直至对象的引用计数为0，对象的内存会被立刻释放。</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];	<span class="comment">// 执行后，引用计数 = 1 </span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n 引用计数 = %lu \n 对象内存 = %p \n object指针内存地址 = %x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[object retainCount], object, &amp;object);</span><br><span class="line">    <span class="keyword">self</span>.property = object;											<span class="comment">// 执行后，引用计数 = 2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n 引用计数 = %lu \n 对象内存 = %p \n object指针内存地址 = %x \n property指针内存地址 = %x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[object retainCount], object, &amp;object, &amp;_property);</span><br><span class="line">    [object release];														<span class="comment">// 执行后，引用计数 = 1 </span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n 引用计数 = %lu \n 对象内存 = %p \n object指针内存地址 = %x \n property指针内存地址 = %x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[object retainCount], object, &amp;object, &amp;_property);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要释放强引用指向的对象时，需要保证所有指向对象强引用置为 nil。<code>__strong</code> 修饰符是 id 类型和对象类型默认的所有权修饰符。</p>
<p><code>__weak</code> 表示弱引用，对应定义 <code>property</code> 时用到的 weak。弱引用不会影响对象的释放，而当对象被释放时，所有指向它的弱引用都会自定被置为 nil，这样可以防止野指针。</p>
<h3 id="2、如何监测内存泄漏"><a href="#2、如何监测内存泄漏" class="headerlink" title="2、如何监测内存泄漏"></a>2、如何监测内存泄漏</h3><p>如果内存管理不当，势必会造成内存泄露。那我们如何快速的来找出内存泄露呢？以前我们可能会使用Instruments来监测，但是我们会发现使用Instruments特别繁琐，而且不一定能定位到内存泄露。</p>
<p>所以这里伟大的Facebook工程师们开源了一些自动化工具来解决监测内存泄露问题：FBRetainCycleDetector、FBAllocationTracker、FBMemoryProfiler。详情查看<a href="http://www.cocoachina.com/ios/20160419/15954.html" target="_blank" rel="noopener">在iOS上自动检测内存泄露</a></p>
<h6 id="你在开发大型项目时-如何进行内存泄露检测的"><a href="#你在开发大型项目时-如何进行内存泄露检测的" class="headerlink" title="你在开发大型项目时,如何进行内存泄露检测的?"></a>你在开发大型项目时,如何进行内存泄露检测的?</h6><blockquote>
<p>instruments下有个leaks工具，启动此工具后，运行项目，工具里可以显示内存泄露的情况，双击可找到源码位置，可以帮助进行内存泄露的处理。</p>
</blockquote>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-①基础/" data-id="cldyf81bl00ue00r430nyml7b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/2内存/2内存-①修饰词" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-①修饰词/" class="article-date">
  <time datetime="2022-03-16T05:35:04.583Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-①语言Swift"><a href="#必备知识架构-①语言Swift" class="headerlink" title="必备知识架构-①语言Swift"></a>必备知识架构-①语言Swift</h1><p>[Toc]</p>
<h2 id="一、Copy"><a href="#一、Copy" class="headerlink" title="一、Copy"></a>一、Copy</h2><ol>
<li><p>如何让自己的类用<code>copy</code>修饰符</p>
<blockquote>
<p>若想令自己所写的对象具有拷贝功能，则需实现<code>NSCopying</code>协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现<code>NSCopying</code>与<code>NSMutableCopying</code>协议。<br>具体步骤：<br>1.需声明该类遵从<code>NSCopying</code>协议<br>2.实现<code>NSCopying</code>协议的方法，具体区别<a href="https://www.jianshu.com/p/f84803356cbb" target="_blank" rel="noopener">戳这里</a></p>
</blockquote>
</li>
</ol>
<ul>
<li><code>NSCopying</code>协议方法为：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">  MyObject *<span class="keyword">copy</span> = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone: zone] init];</span><br><span class="line">  <span class="keyword">copy</span>.username = <span class="keyword">self</span>.username;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">copy</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1、浅拷贝和深拷贝的区别"><a href="#1、浅拷贝和深拷贝的区别" class="headerlink" title="1、浅拷贝和深拷贝的区别"></a>1、浅拷贝和深拷贝的区别</h3><blockquote>
<p><strong>浅层复制：只复制指向对象的指针，而不复制引用对象本身。</strong><br><strong>深层复制：复制引用对象本身。</strong></p>
<p>意思就是说我有个A对象，复制一份后得到A_copy对象后,</p>
<p>对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。<br>而对于深复制就好理解了,内存中存在了两份独立对象本身。</p>
<p>通俗的话将就是：<br>浅复制好比你和你的影子，你完蛋，你的影子也完蛋;<br>深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。</p>
</blockquote>
<h3 id="2、-iOS-Copy-与-MutableCopy"><a href="#2、-iOS-Copy-与-MutableCopy" class="headerlink" title="2、 iOS - Copy 与 MutableCopy"></a>2、 iOS - Copy 与 MutableCopy</h3><p><a href="http://www.jianshu.com/p/63239d4d65e0" target="_blank" rel="noopener">iOS - Copy 与 MutableCopy</a><br>①copy：因为<strong>copy默认返回的是不可变的</strong>，所以当我们对一个不可变的字符串进行copy的时候，我们只是拷贝了它的指针（浅拷贝）。当我们对一个可变的字符串进行拷贝的时候，因为类型转变了，我们需对其进行深拷贝。<br>②<strong>mutableCopy：默认返回的是一个可变的对象</strong>，适用于可变的对象，例如NSMutableString，NSMutableArray，NSMutableDictionary、etc。  无论对于可变的字符串还是不可变的字符串进行mutableCopy，系统都默认进行深拷贝。</p>
<p><a href="https://www.jianshu.com/p/700f58eb0b86" target="_blank" rel="noopener">其他参考</a></p>
<h4 id="1-、copy到底是深拷贝还是浅拷贝？"><a href="#1-、copy到底是深拷贝还是浅拷贝？" class="headerlink" title="(1)、copy到底是深拷贝还是浅拷贝？"></a>(1)、copy到底是深拷贝还是浅拷贝？</h4><p>当我们对一个不可变对象（NSString类型）使用copy关键字的时候，系统是不会产生一个新对象，因为原来的对象是不能修改的，拷贝出来的对象也是不能修改的，那么既然两个都不可以修改，所以这两个对象永远也不会影响到另一个对象（符合我们说的“修改新（旧）对象，不影响旧（新）对象”原则），系统为了节省内存，所以就不会产生一个新的对象了。那么问题来了，<strong>copy到底是深拷贝还是浅拷贝？答：是否是深浅拷贝，是否创建新的对象，是由程序运行的环境所造成的，并不是一概而论。</strong></p>
<h4 id="2-、这个写法会出什么问题-property-nonatomic-copy-NSMutableArray-mutableArray"><a href="#2-、这个写法会出什么问题-property-nonatomic-copy-NSMutableArray-mutableArray" class="headerlink" title="(2)、这个写法会出什么问题@property (nonatomic, copy) NSMutableArray *mutableArray;"></a>(2)、这个写法会出什么问题<code>@property (nonatomic, copy) NSMutableArray *mutableArray;</code></h4><blockquote>
<p>添加，删除，修改数组内元素的时候，程序会因为找不到对应的方法而崩溃。原因：</p>
<p>self.mutableArray = xxx；在copy的修饰下执行的是 self.mutableArray = [xxx copy]；进行了浅拷贝，导致在运行的时候，其实mutableArray是NSArray类。从而在添加，删除，修改数组内元素的时候，程序会因为找不到对应的方法而崩溃。</p>
</blockquote>
<h3 id="3、为什么NSArray用copy修饰、NSMutableArray用strong修饰"><a href="#3、为什么NSArray用copy修饰、NSMutableArray用strong修饰" class="headerlink" title="3、为什么NSArray用copy修饰、NSMutableArray用strong修饰"></a>3、为什么NSArray用copy修饰、NSMutableArray用strong修饰</h3><blockquote>
<p>把NSMutableArray用copy修饰有时就会crash，因为copy后的数组变成了不可变数组NSArray.当你对不可变数组NSArray进行增删改操作的时候就会crash，<br>举例如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①NSMutableArray用copy属性造成的crash：</span><br><span class="line">@property (nonatomic, copy) NSMutableArray *aArray;</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *bArray;</span><br><span class="line"></span><br><span class="line">NSMutableArray *mArray = [NSMutableArray array];</span><br><span class="line">self.aArray = mArray;		// 此时得到的aArray，是通过[mArray copy]进行的深拷贝得到的一个不可变新对象，即类型在执行时候变为了 NSArray了。所以，如果相对归属为NSArray了的aArray执行NSMutableArray才有的如removeAllObjects的方法时，就会崩溃。</span><br><span class="line">self.bArray = mArray;</span><br></pre></td></tr></table></figure>
<p><strong>当修饰可变类型的属性时，如NSMutableArray、NSMutableDictionary、NSMutableString，用strong。</strong></p>
<p><strong>当修饰不可变类型的属性时，如NSArray、NSDictionary、NSString，用copy。</strong></p>
<h3 id="4、模型数组深拷贝"><a href="#4、模型数组深拷贝" class="headerlink" title="4、模型数组深拷贝"></a>4、模型数组深拷贝</h3><p>通常需要实现对模型的拷贝都需要先实现<code>NSCopying、 NSMutableCopying</code>协议。注意：如果是数组使用拷贝操作是不会对数组内实现copy协议的对象进行深拷贝的。</p>
<p>参考文章：<a href="https://www.jianshu.com/p/a75fc0677036" target="_blank" rel="noopener">iOS 模型数组深拷贝</a></p>
<p>1、最笨的方法就是通过遍历逐个拷贝元素</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (Person *person <span class="keyword">in</span> dataSourceAry) &#123;</span><br><span class="line">    [array addObject:[person <span class="keyword">copy</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、也有人使用归档解档实现数组内部元素拷贝</p>
<p>3、这么好用的一个方法现在才发现（推荐）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithArray:(<span class="built_in">NSArray</span>&lt;ObjectType&gt; *)array copyItems:(<span class="built_in">BOOL</span>)flag</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> &lt;Person *&gt;*deepCopyAry = [[<span class="built_in">NSArray</span> alloc]initWithArray:dataSourceAry copyItems:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"&lt;dataSourceAry: %@&gt;"</span>, dataSourceAry);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"&lt;deepCopyAry: %@&gt;"</span>, deepCopyAry);</span><br><span class="line">    </span><br><span class="line">[deepCopyAry enumerateObjectsUsingBlock:^(Person *obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    obj.name = <span class="string">@"弗兰克"</span>;</span><br><span class="line">    obj.dog.name = <span class="string">@"弗兰克的dog"</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="4、分析NSString、NSMutableString等类的copy、mutableCopy"><a href="#4、分析NSString、NSMutableString等类的copy、mutableCopy" class="headerlink" title="4、分析NSString、NSMutableString等类的copy、mutableCopy"></a>4、分析NSString、NSMutableString等类的copy、mutableCopy</h3><blockquote>
<p>在语言文章中，我们已经说明对于语句<code>NSString *obj = [[NSData alloc] init];</code> obj在编译时是NSString的类型；运行时是NSData类型的对象。</p>
<p>由此得出的结论是，不要被编译时的类型蒙蔽，还要看实际运行时的类型。</p>
</blockquote>
<h6 id="1-、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？"><a href="#1-、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？" class="headerlink" title="(1)、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？"></a>(1)、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？</h6><blockquote>
<p>你可以片面理解为</p>
<p><code>copy</code>是[NSString alloc]，所以生成的都是不可变的；<br><code>mutableCopy</code>是[NSMutableString alloc]，所以生成的都是可变的；</p>
</blockquote>
<p>所以以下代码的结果，即为代码中的注释一样</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;NSString *str1 = @&quot;test001&quot;;</span><br><span class="line">&gt;	    </span><br><span class="line">&gt;NSMutableString *str2 = [str1 copy];</span><br><span class="line">&gt;//编译时，str2是NSMutableString类型。因为是把str2声明为可变字符串，所以str2即为声明的可变字符串</span><br><span class="line">&gt;//运行时，str2是NSString类型。因为是copy，所以不管str1是可变不可变，str2都是不可变字符串</span><br><span class="line">&gt;</span><br><span class="line">&gt;NSMutableString *str3 = [str1 mutableCopy];</span><br><span class="line">&gt;//编译时，str3是NSMutableString类型。因为是把str3声明为可变字符串，所以str3即为声明的可变字符串</span><br><span class="line">&gt;//运行时，str3是NSMutableString类型。因为是mutableCopy，所以不管str1是可变不可变，str3都是可变字符串</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="2-、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？"><a href="#2-、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？" class="headerlink" title="(2)、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？"></a>(2)、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</h6><blockquote>
<p><code>copy</code>：对[string copy]是浅拷贝，即不会开辟新地址，而对[mutableString copy]是深拷贝，会开辟新地址。</p>
<p><code>mutableCopy</code>：不管是对[string mutableCopy]，还是对[mutableString mutableCopy]，都是深拷贝，都会开辟新地址。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)testCopy &#123;</span><br><span class="line">    NSString *testStr = [NSString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">    id copyedStr = [testStr copy];</span><br><span class="line">    id mutableCopyStr = [testStr mutableCopy];</span><br><span class="line">    NSLog(@&quot;===    对NSString变量进行copy、mutableCopy得到的地址和类型分别是    ===&quot;);</span><br><span class="line">    NSLog(@&quot;testStr        = %p, class: %@&quot;, testStr, NSStringFromClass([testStr class]));</span><br><span class="line">    NSLog(@&quot;copyedStr      = %p, class: %@&quot;, copyedStr, NSStringFromClass([copyedStr class]));</span><br><span class="line">    NSLog(@&quot;mutableCopyStr = %p, class: %@&quot;, mutableCopyStr, NSStringFromClass([mutableCopyStr class]));</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">    id copyedMutableStr = [testMutableStr copy];</span><br><span class="line">    id mutableCopyMutableStr = [testMutableStr mutableCopy];</span><br><span class="line">    NSLog(@&quot;=== 对NSMutableString变量进行copy、mutableCopy得到的地址和类型分别是 ===&quot;);</span><br><span class="line">    NSLog(@&quot;testMutableStr        = %p, class: %@&quot;, testMutableStr, NSStringFromClass([testMutableStr class]));</span><br><span class="line">    NSLog(@&quot;copyedMutableStr      = %p, class: %@&quot;, copyedMutableStr, NSStringFromClass([copyedMutableStr class]));</span><br><span class="line">    NSLog(@&quot;mutableCopyMutableStr = %p, class: %@&quot;, mutableCopyMutableStr, NSStringFromClass([mutableCopyMutableStr class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-①修饰词/2内存-①基础/copy&amp;mutableCopy.jpg" alt="对NSString、NSMutableString变量进行copy、mutableCopy得到的地址和类型分别是"></p>
<p><strong>结论：分别对NSString、NSMutableString进行copy、mutableCopy操作，只有NSString copy是浅拷贝</strong>。</p>
</blockquote>
<h6 id="3-、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？-附：NSString用copy修饰是为什么"><a href="#3-、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？-附：NSString用copy修饰是为什么" class="headerlink" title="(3)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？(附：NSString用copy修饰是为什么)"></a>(3)、将NSString、NSMutableString变量赋值给<em>用copy、strong修饰</em>的<code>NSString</code>属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？(附：NSString用copy修饰是为什么)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *copyedStr;</span><br><span class="line">@property (nonatomic, strong) NSString *strongStr;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *copyedMutableStr;</span><br><span class="line">@property (nonatomic, strong) NSString *strongMutableStr;</span><br><span class="line"></span><br><span class="line">///将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候</span><br><span class="line">- (void)testCopy &#123;</span><br><span class="line">    NSString *testStr = [NSString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">    self.copyedStr = testStr;</span><br><span class="line">    self.strongStr = testStr;</span><br><span class="line">    NSLog(@&quot;===    将NSString变量赋值给用copy、strong修饰的NSString属性的时候    ===&quot;);</span><br><span class="line">    NSLog(@&quot;testStr   = %p&quot;, testStr);</span><br><span class="line">    NSLog(@&quot;copyedStr = %p&quot;, self.copyedStr);</span><br><span class="line">    NSLog(@&quot;strongStr = %p&quot;, self.strongStr);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">    self.copyedMutableStr = testMutableStr;</span><br><span class="line">    self.strongMutableStr = testMutableStr;</span><br><span class="line">    NSLog(@&quot;=== 将NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候 ===&quot;);</span><br><span class="line">    NSLog(@&quot;testMutableStr   = %p&quot;, testMutableStr);</span><br><span class="line">    NSLog(@&quot;copyedMutableStr = %p&quot;, self.copyedMutableStr);</span><br><span class="line">    NSLog(@&quot;strongMutableStr = %p&quot;, self.strongMutableStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-①修饰词/2内存-①基础/copy1.jpg" alt="将NSString、NSMutableString赋值给用copy、strong修饰的NSString变量"></p>
</blockquote>
<p>可以看出，</p>
<p>①将NSString变量赋值给用copy、strong修饰的NSString属性的时候，不管是strong还是copy属性的对象，其指向的地址都是同一个，即为string指向的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *copyedStr;</span><br><span class="line">@property (nonatomic, strong) NSString *strongStr;</span><br><span class="line"></span><br><span class="line">NSString *testStr = [NSString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">self.copyedStr = testStr;</span><br><span class="line">self.strongStr = testStr;</span><br></pre></td></tr></table></figure>
<p>②将NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，</p>
<p>此时copy属性字符串<code>copyedMutableStr</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *copyedMutableStr;</span><br><span class="line"></span><br><span class="line">NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">self.copyedMutableStr = testMutableStr;</span><br></pre></td></tr></table></figure>
<p>深拷贝了testMutableStr字符串，并让copyedMutableStr对象指向这个字符串(即copyedMutableStr和testMutableStr只是对象值一样，但不是同一个了)。所以此时，我们如果去修改testMutableStr字符串的话，可以看到，我们用<code>@property (nonatomic, copy) NSString *copyedMutableStr;</code>修饰的<code>copyedMutableStr</code>能够不会因为其赋值源<code>testMutableStr</code>的改变而改变，也就保证了安全性。</p>
<p>而strong属性字符串<code>strongMutableStr</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *strongMutableStr;</span><br><span class="line"></span><br><span class="line">NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">self.strongMutableStr = testMutableStr;</span><br></pre></td></tr></table></figure>
<p>因为strongMutableStr与testMutableStr是指向同一对象，所以strongMutableStr的值也会跟随着改变；</p>
<p>综上：所以，<strong>在声明NSString属性时，到底是选择strong还是copy，可以根据实际情况来定。不过，一般我们将对象声明为NSString时，都不希望它改变(包括不希望赋值后，其他原来的值的改变会改变到它)，所以大多数情况下，我们建议用copy，以免因可变字符串的修改导致的一些非预期问题。</strong>使用copy来修饰无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本,这样更安全。</p>
<h6 id="4-、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSMutableString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？"><a href="#4-、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSMutableString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？" class="headerlink" title="(4)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSMutableString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？"></a>(4)、将NSString、NSMutableString变量赋值给用copy、strong修饰的<code>NSMutableString</code>属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSMutableString *copyedStr;</span><br><span class="line">@property (nonatomic, strong) NSMutableString *strongStr;</span><br><span class="line"></span><br><span class="line">NSString *testStr = [NSString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">self.copyedStr = testStr;</span><br><span class="line">self.strongStr = testStr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSMutableString *copyedMutableStr;</span><br><span class="line"></span><br><span class="line">NSMutableString *testMutableStr = [NSMutableString stringWithFormat:@&quot;mutable_456&quot;];</span><br><span class="line">self.copyedMutableStr = testMutableStr;</span><br></pre></td></tr></table></figure>
<p><strong>2.自定义类如何让它具有copy功能?</strong><br>遵守NScoping协议，实现copywithzone方法即可.</p>
<h6 id="5-、自己代码实现copy修饰符，应该怎么写？？？？"><a href="#5-、自己代码实现copy修饰符，应该怎么写？？？？" class="headerlink" title="(5)、自己代码实现copy修饰符，应该怎么写？？？？"></a>(5)、自己代码实现copy修饰符，应该怎么写？？？？</h6><h4 id="4、NSCoding和NSCopy"><a href="#4、NSCoding和NSCopy" class="headerlink" title="4、NSCoding和NSCopy"></a>4、NSCoding和NSCopy</h4><p><a href="http://my.oschina.net/megan/blog/181463?p=1" target="_blank" rel="noopener">NSCoding和NSCopy</a></p>
<h6 id="1-、NSCoding的作用"><a href="#1-、NSCoding的作用" class="headerlink" title="(1)、NSCoding的作用"></a>(1)、NSCoding的作用</h6><p><a href="http://blog.csdn.net/qq5306546/article/details/9240283" target="_blank" rel="noopener">iOS通过NSCoding保存实体对象</a></p>
<p>很多时候我们都需要将对象序列化，比如将一个对象存入到NSUserDefault 里面去的时候，由于NSUserDefault支持存入的类型有限制，所以很多时候我们需要将NSObject类型的对象转换成NSData再存入进去。</p>
<h6 id="2-、NSCopy"><a href="#2-、NSCopy" class="headerlink" title="(2)、NSCopy"></a>(2)、NSCopy</h6><p>当你要进行对象拷贝的时候需要遵循NSCopy协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    id copy = [[[self class] alloc] init];</span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        [copy setId:[self.id copyWithZone:zone]];</span><br><span class="line">        [copy setNickName:[self.nickName copyWithZone:zone]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、-synthesize和-dynamic区别"><a href="#5、-synthesize和-dynamic区别" class="headerlink" title="5、@synthesize和@dynamic区别"></a>5、@synthesize和@dynamic区别</h4><p><a href="http://www.cnblogs.com/xiaodao/archive/2012/10/09/2716244.html" target="_blank" rel="noopener">@synthesize和@dynamic区别</a></p>
<p>在声明property属性后，有2种实现选择</p>
<ul>
<li>@synthesize</li>
</ul>
<p>编译器期间，让编译器自动生成getter/setter方法。当有自定义的存或取方法时，自定义会屏蔽自动生成该方法</p>
<ul>
<li>@dynamic</li>
</ul>
<p>告诉编译器，不自动生成getter/setter方法，避免编译期间产生警告，然后由自己实现存取方法，或存取方法在运行时动态创建绑定：主要使用在CoreData的实现NSManagedObject子类时使用，由Core Data框架在程序运行的时动态生成子类属性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-①修饰词/" data-id="cldyf81cg00ug00r4hihdyvn3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/2内存/2内存-①AutoRelease" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-①AutoRelease/" class="article-date">
  <time datetime="2022-03-16T05:35:04.573Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-内存"><a href="#必备知识架构-内存" class="headerlink" title="必备知识架构-内存"></a>必备知识架构-内存</h1><p>[toc]</p>
<p>必看文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/1b66c4d47cd7" target="_blank" rel="noopener">AutoreleasePool的原理和实现</a></li>
</ul>
<p>什么是内存管理？是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。</p>
<p><strong>内存管理管理的是堆上的内存，栈上的内存并不需要我们管理。</strong></p>
<h2 id="说说内存管理"><a href="#说说内存管理" class="headerlink" title="说说内存管理"></a>说说内存管理</h2><p>我们知道，当不再使用一个对象时应该将其释放，但是在某些情况下，我们很难理清一个对象什么时候不再使用(比如self.name不止在一个方法里会被调用到的时候)，这可怎么办？ObjC提供autorelease方法来解决这个问题。</p>
<p>说到内存管理，我们就不得不提引用计数。当对象的引用计数为0，对象的内存就会被释放。</p>
<blockquote>
<p>引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。</p>
</blockquote>
<p>当我们在创建一个对象的实例并在堆上申请内存时，或者在其他对象中需要持有这个对象时，该对象的引用计数就会加1；<br>当代码结束使用该对象/释放对象时，则将对象的引用计数减1；而想要释放一个对象的内存，我们将该对象的引用计数减到0，即进行release到0。<br>在ARC的情况下，为了方便管理内存，它会有一个autorelease的东西，它省去了我们还要自己去执行release方法的操作。同时与autorelease相关的还有一个叫AutoreleasePool自动释放池。</p>
<p>通过autorelease，当给一个对象发送autorelease消息（类方法创建的对象系统会自动添加autorelease）时，对象在接收到autorelease消息后，它会被添加到了当前的自动释放池autoreleasepool中。在未来某个时间，当自动释放池被销毁时，会给池里所有的对象发送release消息将其释放(释放≠销毁)。如果自动释放池向对象发送release消息后对象的引用计数变为了0，则改对象就会被销毁，内存就会被回收。在释放前这个时间段内，对象还是可以使用的（<strong>注意1：autorelease不会改变对象的引用计数，release才改变引用计数</strong>）（<strong>注意2：自动释放池实质上只是在释放的时候给池中所有对象对象发送release消息，不保证对象一定会销毁，如果自动释放池向对象发送release消息后对象的引用计数仍大于1，对象就无法销毁。</strong>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id array = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">此源代码等同于以下源码。</span><br><span class="line">id array = [[[NSMutableArray alloc] initWithCapacity:1] autorelease];</span><br></pre></td></tr></table></figure>
<p>所以AutoreleasePool的释放有如下两种情况。</p>
<ul>
<li><p>一是Autorelease对象是在当前的<strong>runloop</strong>迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop。（<strong>一定要回答到runloop</strong>）。那runloop什么时候结束呢？</p>
<blockquote>
<p>一个<code>RunLoop</code>包含若干个<code>Mode</code>，每个<code>Mode</code>包含若干个<code>Source</code>/<code>Timer</code>/<code>Observer</code>/<code>Port</code>。当启动一个<code>RunLoop</code>时会先指定一个<code>Mode</code>，检查指定<code>Mode</code>是否存在以及<code>Mode</code>中是否含有<code>Source</code>和<code>Timer</code>，如果<code>Mode</code>不存在或者<code>Mode</code>中无<code>Source</code>和<code>Timer</code>，认为该<code>Mode</code>是一个空的<code>Mode</code>，<code>RunLoop</code>就直接退出。</p>
</blockquote>
</li>
<li><p>二是手动调用AutoreleasePool的释放方法（drain方法）来销毁AutoreleasePool</p>
</li>
</ul>
<h2 id="AutoreleasePool（自动释放池）"><a href="#AutoreleasePool（自动释放池）" class="headerlink" title="AutoreleasePool（自动释放池）"></a>AutoreleasePool（自动释放池）</h2><h3 id="1、AutoreleasePool（自动释放池）介绍"><a href="#1、AutoreleasePool（自动释放池）介绍" class="headerlink" title="1、AutoreleasePool（自动释放池）介绍"></a>1、AutoreleasePool（自动释放池）介绍</h3><p><strong>AutoreleasePool（自动释放池）是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。</strong>即当我们创建了一个对象，并把他加入到了自动释放池中时，他不会立即被释放，会等到一次<code>runloop</code>结束或者作用域超出<code>autoreleasepool{}</code>之后再被释放。在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。</p>
<p>我们把<code>main.m</code>文件通过Xcode自带的xcrun命令，来编译成<a href="./2内存-①AutoRelease/main.cpp">main.cpp</a>文件</p>
<p>命令行如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator clang -rewrite-objc ./main.m</span><br></pre></td></tr></table></figure>
<p>可以在编译出来的cpp文件中，看到如下自动释放池的结构体如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; 	<span class="comment">// 构造函数</span></span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;			<span class="comment">// 析构函数</span></span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>objc4</code>是我们通常说的Runtime源码，我们遇到的<code>libobjc.A.dylib</code>就是用它编译出来的。</p>
<p>源码查看，进入<a href="http://opensource.apple.com/source/" target="_blank" rel="noopener">http://opensource.apple.com/source/</a>搜索objc4，</p>
<p><img src="/iOS/3必备知识架构/2内存/2内存-①AutoRelease/image-20211103173107899-5931876.png" alt="image-20211103173107899"></p>
<h1 id="NSThread、NSRunLoop-和-NSAutoreleasePool三者之间的关系"><a href="#NSThread、NSRunLoop-和-NSAutoreleasePool三者之间的关系" class="headerlink" title="NSThread、NSRunLoop 和 NSAutoreleasePool三者之间的关系"></a>NSThread、NSRunLoop 和 NSAutoreleasePool三者之间的关系</h1><ul>
<li>NSThread 和 NSRunLoop是<code>一一对应</code>的关系</li>
<li>在NSRunLoop对象的每个<code>运行循环（event loop）</code>开始前，系统会自动创建一个autoreleasepool，并在<code>运行循环（event loop）</code>结束时<code>drain</code>掉这个pool，同时释放所有autorelease对象</li>
<li><code>autoreleasepool</code>只会对应<code>一个</code>线程，每个<code>线程</code>可能会对应<code>多个</code>autoreleasepool，比如autoreleasepool<code>嵌套</code>的情况</li>
</ul>
<ul>
<li>autorelease<code>本质</code>上就是<code>延迟</code>调用release方法</li>
<li>MRC环境，通过调用<code>[obj autorelease]</code>来<code>延迟</code>内存的释放</li>
<li>ARC环境，甚至可以<code>完全不知道</code>autorelease也能管理好内存</li>
</ul>
<p>看到这里有人可能会问，那到底延迟到什么时候执行呢？看完本文后，各位心中自然会有答案。</p>
<h5 id="3-、autorelease、autoreleasepool-自动释放池"><a href="#3-、autorelease、autoreleasepool-自动释放池" class="headerlink" title="(3)、autorelease、autoreleasepool(自动释放池)"></a>(3)、autorelease、autoreleasepool(自动释放池)</h5><h5 id="4-、autoreleasepool-自动释放池"><a href="#4-、autoreleasepool-自动释放池" class="headerlink" title="(4)、autoreleasepool(自动释放池)　　"></a>(4)、autoreleasepool(自动释放池)　　</h5><p>　　这里说到的自动释放池，顾名思义，就是一个池，这个池可以容纳对象，而且可以自动释放，这就大大增加了我们处理对象的灵活性。
　　</p>
<h5 id="5-、autoreleasepool里面对象的内存什么时候释放"><a href="#5-、autoreleasepool里面对象的内存什么时候释放" class="headerlink" title="(5)、autoreleasepool里面对象的内存什么时候释放?"></a>(5)、autoreleasepool里面对象的内存什么时候释放?</h5><p>　　在runloop sleep的时候当前autoreleasePool drain（objc_autoreleasePoolPop） 掉，向里面的对象都发送release消息，建立一个新的autoreleasePool(objc_autoreleasePoolPush)。或者简单的说就是当@autoreleasepool结束时，里面的内存就会回收;</p>
<p>ARC时代，系统自动管理自己的autoreleasepool，runloop就是iOS中的消息循环机制，当一个runloop结束时系统才会一次性清理掉被autorelease处理过的对象，其实本质上说是在本次runloop迭代结束时清理掉被本次迭代期间被放到autorelease pool中的对象的。至于何时runloop结束并没有固定的duration。 </p>
<h5 id="6-、runloop、autorelease-pool以及线程之间的关系"><a href="#6-、runloop、autorelease-pool以及线程之间的关系" class="headerlink" title="(6)、runloop、autorelease pool以及线程之间的关系"></a>(6)、runloop、autorelease pool以及线程之间的关系</h5><p>每个线程(包含主线程)都有一个Runloop。对于每一个Runloop，系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个像callstack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</p>
<p>#####　(7)、自动释放池怎样创建</p>
<p>ObjC提供两种方法创建自动释放池：</p>
<p>方法一：使用NSAutoreleasePool来创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool * pool = [[NSAutoreleasePool alloc]init];</span><br><span class="line">//这里写代码</span><br><span class="line">[pool release];</span><br></pre></td></tr></table></figure>
<p>方法二：使用@autoreleasepool创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">//这里写代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动释放池创建后，就会成为活动的池子，释放池子后，池子将释放其所包含的所有对象。</p>
<p>以上两种方法推荐第一种，因为将内存交给ObjC管理更高效。</p>
<h5 id="8-、自动释放池使用注意"><a href="#8-、自动释放池使用注意" class="headerlink" title="(8)、自动释放池使用注意"></a>(8)、自动释放池使用注意</h5><blockquote>
<p>1）自动释放池实质上只是在释放的时候给池中所有对象对象发送release消息，不保证对象一定会销毁，如果自动释放池向对象发送release消息后对象的引用计数仍大于1，对象就无法销毁。</p>
<p>2）自动释放池中的对象会集中同一时间释放，如果操作需要生成的对象较多占用内存空间大，可以使用多个释放池来进行优化。比如在一个循环中需要创建大量的临时变量，可以创建内部的池子来降低内存占用峰值。</p>
<p>3）autorelease不会改变对象的引用计数</p>
</blockquote>
<h5 id="9-、自动释放池的应用-什么时候要用-autoreleasepool"><a href="#9-、自动释放池的应用-什么时候要用-autoreleasepool" class="headerlink" title="(9)、自动释放池的应用/什么时候要用@autoreleasepool"></a>(9)、自动释放池的应用/什么时候要用@autoreleasepool</h5><p>有些情况下，我们还是需要手动创建自动释放池，那么，什么时候呢？</p>
<p>苹果文档中的翻译如下：</p>
<ol>
<li>如果你正在编写不基于UI 框架的程序，比如命令行工具。</li>
<li>如果你编写的循环创建了很多临时对象。那么你可以在循环中使用自动释放池block，在下次迭代前处理这些对象。在循环中使用自动释放池block，有助于减少应用程序的内存占用。</li>
<li>你生成了一个辅助线程。 一旦线程开始执行你必须自己创建自动释放池。否则，应用将泄漏对象。</li>
</ol>
<p>按我的理解，最重要的使用场景，应该是有大量中间临时变量产生时，避免内存使用峰值过高，及时释放内存的场景。 </p>
<p>如在一个循环事件中，如果循环次数较大或者事件处理占用内存较大，就会导致内存占用不断增长，可能会导致不希望看到的后果。</p>
<p>举个例子，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSArray *urls = &lt;# An array of file URLs #&gt;;</span><br><span class="line">for (NSURL *url in urls) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSError *error;</span><br><span class="line">        NSString *fileContents = [NSString stringWithContentsOfURL:url</span><br><span class="line">                                         encoding:NSUTF8StringEncoding</span><br><span class="line">                                         error:&amp;error];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//或</span><br><span class="line">     for (int i = 0; i &lt; 100000; i ++) &#123;</span><br><span class="line">         @autoreleasepool &#123;</span><br><span class="line">             NSString * log  = [NSString stringWithFormat:@&quot;%d&quot;, i];</span><br><span class="line">             NSLog(@&quot;%@&quot;, log);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>如果这个for循环里不使用@autoreleasepool，虽然每个循环中生成的字符串对象都会放在自动释放池子中(假设是1号自动释放池)，但是这个1号自动释放池是需要等到循环事件结束时释放的。这时候由于循环太大，势必会造成在循环期间内存不增长。所以，这里我们需要使用@autoreleasepool，额外创建一个2号自动释放池，来使得在每个@autoreleasepool结束时，里面的临时变量都会回收，内存使用更加合理。</p>
<p>例子2：假如有2000张图片，每张1M左右，现在需要获取所有图片的尺寸，你会怎么做？<br>　　如果这样做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 2000; i ++) &#123;</span><br><span class="line"> CGSize size = [UIImage imageNamed:[NSString stringWithFormat:@&quot;%d.jpg&quot;,i]].size;</span><br><span class="line"> //add size to array</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>　　用imageNamed方法加载图片占用Cache的内存，autoReleasePool也不能释放，对此问题需要另外的解决方法，当然保险的当然是双管齐下了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   for (int i = 0; i &lt; 2000; i ++) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">       CGSize size = [UIImage imageWithContentsOfFile:filePath].size;</span><br><span class="line">       //add siez to array</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p>
<h6 id="自动释放池底层怎么实现"><a href="#自动释放池底层怎么实现" class="headerlink" title="自动释放池底层怎么实现?"></a>自动释放池底层怎么实现?</h6><blockquote>
<p>答:自动释放池以栈的形式实现:当你创建一个新的自动释放池时,它将被添加到栈顶.当一个对象收到发送autorelease消息时,他被添加到当前线程的处于栈顶的自动释放池中,当自动释放池被回收时,他们从栈中被删除,并且会给池子里面所有的对象都会做一次release操作</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-①AutoRelease/" data-id="cldyf81b800ud00r487voba7a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/1语言/1语言Common" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/1语言/1语言Common/" class="article-date">
  <time datetime="2022-03-16T05:35:04.572Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-①语言"><a href="#必备知识架构-①语言" class="headerlink" title="必备知识架构-①语言"></a>必备知识架构-①语言</h1><p>[Toc]</p>
<p>–</p>
<h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p>
<p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p>
<p></p><p id="Objective-C与C++"></p><p></p>
<h2 id="面向对象-OOP"><a href="#面向对象-OOP" class="headerlink" title="面向对象(OOP)"></a>面向对象(OOP)</h2><p>面向对象的三个特性：封装、继承和多态。</p>
<blockquote>
<p>所谓封装，也就是把客观事物封装成抽象的类；</p>
<p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。(或者说是不同对象以自己的方式响应相同的消息的能力叫做多态。)</p>
</blockquote>
<p>继承的问题：如果架构工程师写父类，业务工程师实现子类。那么业务工程师很可能不清楚：哪些方法需要被覆盖重载，哪些不需要。如果子类没有覆重方法，而父类提供的只是空方法，就很容易出问题。如果子类在覆重的时候引入了其他不相关逻辑，那么子类对象就显得不够单纯，角色复杂了。</p>
<blockquote>
<p>多态面临的四个问题：</p>
<ul>
<li><p>父类有部分public的方法是不需要，也不允许子类覆重。</p>
<p>答：公司内部可以规定:<code>不允许覆盖重载父类中的方法</code>、<code>子类需要实现接口协议中的方法</code>。</p>
</li>
<li><p>父类有一些特别的方法是必须要子类去覆重的，在父类的方法其实是个空方法。</p>
</li>
<li><p>父类有一些方法即便被覆重，父类原方法还是要执行的。</p>
</li>
<li><p>父类有一些方法是可选覆重的，一旦覆重，则以子类为准。</p>
</li>
</ul>
</blockquote>
<p></p><p id="常见笔试/面试题"></p><p></p>
<h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p>
<h4 id="2、const-与define使用的区别"><a href="#2、const-与define使用的区别" class="headerlink" title="2、const 与define使用的区别"></a>2、const 与define使用的区别</h4><ul>
<li>define修饰的变量不指定类型,const的指定类型</li>
<li>defien修饰的变量每次引用都开辟一次内存,而const只有一份内存</li>
<li>如果修饰的是代码片段适合用define,如果修饰的是变量适合用const</li>
</ul>
<h4 id="6、nil-Nil-NULL-与-NSNull-的区别"><a href="#6、nil-Nil-NULL-与-NSNull-的区别" class="headerlink" title="6、nil, Nil,NULL 与 NSNull 的区别"></a>6、nil, Nil,NULL 与 NSNull 的区别</h4><ul>
<li>nil 指向一个<strong>对象的指针</strong>为空,在objc.h 的定义如下: <code>NSString *name = nil;</code></li>
<li>Nil 指向一个<strong>类的指针</strong>为空,定义如下: <code>Class aClass = Nil;</code></li>
<li>NULL 指向<strong>C类型的指针</strong>为空, 例如: <code>int*pInt = NULL;</code></li>
<li>NSNull 在Objective-C中是一个类,使用为生成一个空对象<code>[NSNull null];</code>，多用于集合(NSArray,NSDictionary)中值为空的对象</li>
</ul>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/1语言/1语言Common/" data-id="cldyf81a400ua00r4wkgm50s0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/1语言/1语言Swift" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/1语言/1语言Swift/" class="article-date">
  <time datetime="2022-03-16T05:35:04.572Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-①语言Swift"><a href="#必备知识架构-①语言Swift" class="headerlink" title="必备知识架构-①语言Swift"></a>必备知识架构-①语言Swift</h1><p>[Toc]</p>
<h2 id="一、iOS开发中使用OC和swift的对比"><a href="#一、iOS开发中使用OC和swift的对比" class="headerlink" title="一、iOS开发中使用OC和swift的对比"></a>一、iOS开发中使用OC和swift的对比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.import的类</span><br><span class="line">OC：某个只要要使用某个类就要将该类import。</span><br><span class="line">swift：如果是用户自己创建类，其他类无需import可以直接使用。pod的一些三方类和系统的一些类，在使用的时候需要import</span><br></pre></td></tr></table></figure>
<p>Guard语句的语法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> expression <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//语句</span></span><br><span class="line">    <span class="comment">//必须包含一个控制语句：return，break，continue或throw。</span></span><br><span class="line">&#125;</span><br><span class="line">这里，expression是一个布尔表达式（返回<span class="literal">true</span>或者<span class="literal">false</span>）。</span><br><span class="line">如果对表达式求值<span class="literal">false</span>，<span class="keyword">guard</span>则执行代码块内的语句。</span><br><span class="line">如果对表达式求值<span class="literal">true</span>，<span class="keyword">guard</span>则从执行中跳过代码块内的语句</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="literal">false</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Condition not met"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Condition met"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、【iOS】Swift和OC协议的区别？为何Swift是面向协议的？"><a href="#二、【iOS】Swift和OC协议的区别？为何Swift是面向协议的？" class="headerlink" title="二、【iOS】Swift和OC协议的区别？为何Swift是面向协议的？"></a>二、【iOS】Swift和OC协议的区别？为何Swift是面向协议的？</h2><p><a href="https://blog.csdn.net/hanrovey/article/details/106636624" target="_blank" rel="noopener">【iOS】Swift和OC协议的区别？为何Swift是面向协议的？</a></p>
<p>相比于OC，Swift 可以做到协议方法的具体实现，而 OC 则不行。</p>
<blockquote>
<p>OC中协议<code>（Protocol）</code>类似一个类的接口，只声明，不实现。<br>只能定义公用的一套接口，但不能提供具体的实现方法。也就是说，它只告诉你要做什么，但具体怎么做不关心。具体的实现要在遵守这个协议的类中实现。</p>
</blockquote>
<h3 id="OC的Protocol与继承的区别"><a href="#OC的Protocol与继承的区别" class="headerlink" title="OC的Protocol与继承的区别"></a>OC的Protocol与继承的区别</h3><p>继承连同方法的实现也继承了，而protocol只有声明没有实现；<br>protocol能够作用到不同类型的类上。</p>
<h3 id="OC的Protocol与Category的区别"><a href="#OC的Protocol与Category的区别" class="headerlink" title="OC的Protocol与Category的区别"></a>OC的Protocol与Category的区别</h3><p><code>Category</code>可以给一个类扩充方法，既有申明也有实现；而<code>Protocol</code>只有声明，没有实现。<br> 同：<code>Category</code>和<code>Protocol</code>都可以声明方法，不能声明属性。</p>
<h2 id="Swift-面试题解"><a href="#Swift-面试题解" class="headerlink" title="Swift 面试题解"></a>Swift 面试题解</h2><h3 id="的作用"><a href="#的作用" class="headerlink" title="?? 的作用"></a>?? 的作用</h3><p>可选值的默认值, 当可选值为nil 的时候, 会返回后面的值. 如<br><code>let someValue = optional1 ?? 0</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/1语言/1语言Swift/" data-id="cldyf81ah00ub00r4cby0feps" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/1语言/Runtime" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/1语言/Runtime/" class="article-date">
  <time datetime="2022-03-16T05:35:04.572Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Runtime-Interview"><a href="#Runtime-Interview" class="headerlink" title="Runtime_Interview"></a>Runtime_Interview</h1><p>Runtime</p>
<p>前言：</p>
<p>  Objective C的runtime技术功能非常强大，能够在运行时获取并修改类的各种信息，包括获取方法列表、属性列表、变量列表，修改方法、属性，增加方法，属性等等，本文对相关的几个要点做了一个小结。</p>
<p>目录：</p>
<p>（1）使用class_replaceMethod/class_addMethod函数在运行时对函数进行动态替换或增加新函数</p>
<p>（2）重载forwardingTargetForSelector，将无法处理的selector转发给其他对象</p>
<p>（3）重载resolveInstanceMethod，从而在无法处理某个selector时，动态添加一个selector</p>
<p>（4）使用class_copyPropertyList及property_getName获取类的属性列表及每个属性的名称</p>
<p>  (5) 使用class_copyMethodList获取类的所有方法列表</p>
<h4 id="一些参考"><a href="#一些参考" class="headerlink" title="一些参考"></a>一些参考</h4><p><a href="http://www.cnblogs.com/yswdarren/p/3619303.html" target="_blank" rel="noopener">Objective C运行时（runtime）技术总结</a></p>
<p>需求1、当项目中，需要继承某一个父类，但是父类中并没有提供我们需要的调用方法，一般情况下，这种时候，我们可能会再派生一个类，或者会直接为这个类写一个分类（category），在这个分类中，我们可以新增或者替换某个方法（注意：不推荐在分类中重写方法，而且也无法通过 super 来获取所谓父类的方法）。大致在这两种情况下，我们可以通过 class_addMethod 来实现我们想要的效果。</p>
<p>先从一个场景问题带出吧，比如一个应用都是继承于UIViewController，刚开始时候不要求要转屏，到后面才决定加上旋转屏适配，这个时候如果我们去创建一个父类，并让去修改每个类的继承这个方法显然是效率太低了。而且有时候，我们也不想多创个父类，于是我们就只能决定一次过替换掉这些controller里的viewWillAppear:和 willAnimateRotationToInterfaceOrientation:duration:，换成自己的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class clazz = object_getClass((id)self);</span><br><span class="line">        </span><br><span class="line">        //将系统的resolveInstanceMethod替换成自己的myResolveInstanceMethod，而系统的resolveInstanceMethod方法就是当运行时对象调用了一个找不到的方法的时候系统会去寻找的机制。</span><br><span class="line">        [clazz swizzleMethod:@selector(resolveInstanceMethod:) withMethod:@selector(myResolveInstanceMethod:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  用什么方法替换掉什么方法</span><br><span class="line"> *</span><br><span class="line"> *  @param origSel  原方法选择子</span><br><span class="line"> *  @param aftSel   新方法选择子</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)swizzleMethod:(SEL)origSel withMethod:(SEL)aftSel &#123;</span><br><span class="line">	//通过class_getInstanceMethod()拿到对应的Method</span><br><span class="line">    Method originMethod = class_getInstanceMethod(self, origSel);</span><br><span class="line">    Method newMethod = class_getInstanceMethod(self, aftSel);</span><br><span class="line">    </span><br><span class="line">    if(originMethod &amp;&amp; newMethod)&#123; //必须两个Method都要拿到</span><br><span class="line">    	//class_addMethod将本来不存在于被操作的Class里的newMethod的实现添加在被操作的Class里，并使用origSel作为其选择子</span><br><span class="line">        if(class_addMethod(self, origSel, method_getImplementation(newMethod),method_getTypeEncoding(newMethod))) &#123;</span><br><span class="line">        	//当addMethod成功完成后，利用class_replaceMethod换掉method_getImplaementation(oiginMethod)的选择子，将原方法的实现的SEL换成新方法的SEL:aftSel，ok目的达成了。想一想，现在通过旧方法SEL来调用，就会实现新方法的IMP，通过新方法的SEL来调用，就会实现旧方法的IMP。</span><br><span class="line">            class_replaceMethod(self, aftSel, method_getImplementation(originMethod), method_getTypeEncoding(originMethod));</span><br><span class="line">        &#125;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/1语言/Runtime/" data-id="cldyf81au00uc00r41avc2c1v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/1语言/1语言-消息转发" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/1语言/1语言-消息转发/" class="article-date">
  <time datetime="2022-03-16T05:35:04.562Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-①语言-消息转发"><a href="#必备知识架构-①语言-消息转发" class="headerlink" title="必备知识架构-①语言-消息转发"></a>必备知识架构-①语言-消息转发</h1><ol>
<li>什么时候会报<code>unrecognized selector</code>的异常</li>
</ol>
<ul>
<li><p>当调用该对象上某个方法，而该对象上没有实现这个方法的时候。可以通过<code>消息转发</code>进行解决，流程见下图</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1948913-f236e31f679fe683.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/597" alt="img"></p>
<p>image</p>
</li>
<li><p><code>OC</code>在向一个对象发送消息时，<code>runtime</code>库会根据对象的<code>isa</code>指针找到该对象实际所属的类，然后<strong>在该类中的方法列表以及其父类方法列表中寻找方法运行，如果在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常<code>unrecognized selector sent to XXX</code></strong><br><strong>但是在这之前，OC的运行时会给出三次拯救程序崩溃的机会</strong></p>
</li>
<li><p>Method resolution（消息动态解析）<br><code>OC</code>运行时会调用<code>+resolveInstanceMethod:</code>或者<code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则，运行时就会移到下一步，消息转发（<code>Message Forwarding</code>）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写 resolveInstanceMethod: 添加对象方法实现</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="comment">// 如果是执行 run 函数，就动态解析，指定新的 IMP</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"run:"</span>)) &#123;</span><br><span class="line">        <span class="comment">// class: 给哪个类添加方法</span></span><br><span class="line">        <span class="comment">// SEL: 添加哪个方法</span></span><br><span class="line">        <span class="comment">// IMP: 方法实现 =&gt; 函数 =&gt; 函数入口 =&gt; 函数名</span></span><br><span class="line">        <span class="comment">// type: 方法类型：void用v来表示，id参数用@来表示，SEL用:来表示</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)runMethod, <span class="string">"v@:@"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新的 run 函数</span></span><br><span class="line"><span class="keyword">void</span> runMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSNumber</span> *meter) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"跑了%@"</span>, meter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Fast forwarding（消息接受者重定向）<br>  如果目标对象实现了<code>-forwardingTargetForSelector:</code>，<code>Runtime</code>这时就会调用这个方法，给你把这个消息<strong>转发给其他对象</strong>的机会。只要这个方法返回的不是<code>nil</code>和<code>self</code>，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续<code>Normal Fowarding</code>。 这里叫<code>Fast</code>，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个<code>NSInvocation</code>对象，所以相对更快点</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息接受者重定向</span></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="meta">@selector(run:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[Person alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="comment">// 返回 Person 对象，让 Person 对象接收这个消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Normal forwarding（消息重定向）<br>这一步是<code>Runtime</code>最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回<code>nil</code>，<code>Runtime</code>则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，<code>Runtime</code>就会创建一个<code>NSInvocation</code>对象并发送<code>-forwardInvocation:</code>消息给目标对象</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取函数的参数和返回值类型，返回签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(aSelector) isEqualToString:<span class="string">@"run:"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:@"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息重定向</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="comment">// 从 anInvocation 中获取消息</span></span><br><span class="line">    SEL sel = anInvocation.selector;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"run:"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 1\. 指定当前类的一个方法作为IMP</span></span><br><span class="line">        <span class="comment">// anInvocation.selector = @selector(readBook:);</span></span><br><span class="line">        <span class="comment">// [anInvocation invoke];</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2\. 指定其他类来执行这个IMP</span></span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        <span class="comment">// 判断 Person 对象方法是否可以响应 sel</span></span><br><span class="line">        <span class="keyword">if</span>([p respondsToSelector:sel]) &#123;</span><br><span class="line">            <span class="comment">// 若可以响应，则将消息转发给其他对象处理</span></span><br><span class="line">            [anInvocation invokeWithTarget:p];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若仍然无法响应，则报错：找不到响应方法</span></span><br><span class="line">            [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    [<span class="keyword">super</span> doesNotRecognizeSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>既然<code>-forwardingTargetForSelector:</code>和<code>-forwardInvocation:</code>都可以将消息转发给其他对象处理，那么两者的区别在哪？</strong><br>区别就在于<code>-forwardingTargetForSelector:</code>只能将消息转发给一个对象。而<code>-forwardInvocation:</code>可以把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。修改消息的target，selector，参数等。将消息转发给多个对象</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/1语言/1语言-消息转发/" data-id="cldyf818e00u600r42etx1gcj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/1语言/1语言-消息转发NSProxy" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/1语言/1语言-消息转发NSProxy/" class="article-date">
  <time datetime="2022-03-16T05:35:04.562Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-①语言-消息转发2"><a href="#必备知识架构-①语言-消息转发2" class="headerlink" title="必备知识架构-①语言-消息转发2"></a>必备知识架构-①语言-消息转发2</h1><p>[toc]</p>
<h2 id="一、NSProxy"><a href="#一、NSProxy" class="headerlink" title="一、NSProxy"></a>一、NSProxy</h2><p>NSProxy，你可以通过继承它，并重写它的以下两个方法以实现消息转发到另一个实例。说白了，NSProxy专为代理而生（<strong>负责将消息转发到真正的target的代理类</strong>）。从类名来看是代理类，专门负责代理对象转发消息的。相比NSObject类来说NSProxy更轻量级，<strong>通过NSProxy可以帮助Objective-C间接的实现多重继承的功能</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel;</span><br></pre></td></tr></table></figure>
<h3 id="1、通过NSProxy可以帮助Objective-C间接的实现多重继承的功能的例子"><a href="#1、通过NSProxy可以帮助Objective-C间接的实现多重继承的功能的例子" class="headerlink" title="1、通过NSProxy可以帮助Objective-C间接的实现多重继承的功能的例子"></a>1、通过NSProxy可以帮助Objective-C间接的实现多重继承的功能的例子</h3><p>现在比较流行的说法是用它来模拟多重继承，大致过程就是让它Hold住/包含你要实现多继承的类的对象，然后被hold住的对象的行为定义在接口中，并让Proxy去实现这些接口。然后再转发的时候把消息转发到实现了该接口的对象去执行，这样就好像实现了多重继承一样。<strong>注意</strong>：这个真不是多重继承，只是包含，然后把消息路由到指定的对象而已，其实完全可以用NSObject类来实现。</p>
<p>天使=人+鸟</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [Person new];</span><br><span class="line">Bird *bird = [Bird new];</span><br><span class="line"></span><br><span class="line">id angelProxy = [AngelProxy proxyForObject1:person object2:bird];</span><br><span class="line">[proxy speak];	// 人可以说话</span><br><span class="line">[proxy fly];		// 鸟可以飞</span><br></pre></td></tr></table></figure>
<p>另一个例子：<a href="https://www.cnblogs.com/vokie/p/9289958.html" target="_blank" rel="noopener">NSProxy的学习使用</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// AngelProxy.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface AngelProxy : NSProxy</span><br><span class="line"></span><br><span class="line">+ (id)proxyForObject1:(id)obj1 object2:(id)obj2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// AngelProxy.m</span><br><span class="line">#import &quot;AngelProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@interface AngelProxy()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id target1;</span><br><span class="line">@property (nonatomic, weak) id target2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AngelProxy</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithTarget1:(id)obj1 target2:(id)obj2 &#123;</span><br><span class="line">    _target1 = obj1;</span><br><span class="line">    _target2 = obj2;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)proxyForObject1:(id)obj1 object2:(id)obj2 &#123; </span><br><span class="line">    return [[AngelProxy alloc] initWithTarget1:obj1 target2:obj2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重写NSProxy如下两个方法，在处理消息转发时，将消息转发给真正的Target处理</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    id target;</span><br><span class="line">    if ([_target1 methodSignatureForSelector:invocation.selector]) &#123;</span><br><span class="line">        target = _target1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        target = _target2;</span><br><span class="line">    &#125;</span><br><span class="line">    [invocation invokeWithTarget:target];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">    NSMethodSignature *sig;</span><br><span class="line">    </span><br><span class="line">    sig = [_target1 methodSignatureForSelector:selector];</span><br><span class="line">    if (sig) &#123;</span><br><span class="line">        return sig;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sig = [_target2 methodSignatureForSelector:selector];</span><br><span class="line">    return sig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="2、NSProxy-和-NSObject-的比较"><a href="#2、NSProxy-和-NSObject-的比较" class="headerlink" title="2、NSProxy 和 NSObject 的比较"></a>2、NSProxy 和 NSObject 的比较</h3><p>相比NSObject，NSProxy更轻量级，做消息转发效率更高。</p>
<p>NSObject寻找方法顺序：本类-&gt;(父类-)&gt;(动态方法解析)-&gt; 消息转发；<br>NSproxy顺序：本类-&gt;消息转发</p>
<h3 id="3、NSProxy的用途"><a href="#3、NSProxy的用途" class="headerlink" title="3、NSProxy的用途"></a>3、NSProxy的用途</h3><ol>
<li><p>AOP面向切片编程</p>
<p>iOS中面向切片编程一般有两种方式 ，一个是直接基于runtime 的method-Swizzling.还有一种就是基于NSProxy</p>
</li>
<li><p>解决NSTimer, CADisplayLink等强引用target引起的无法释放问题。如NSTimer:利用消息转发来断开NSTimer对象与视图之间的强引用关系。初始化NSTimer时把触发事件的target替换成一个单独的对象，然后这个对象中NSTimer的SEL方法触发时让这个方法在当前的视图self中实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.timer = [NSTimer timerWithTimeInterval:1 target:self.proxy </span><br><span class="line">              								selector:@selector(timerEvent) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br><span class="line">// 这里我们timer的target使用AYProxy对象，它会实现你这个timer想要实现的timerEvent消息转发给self。从而避免了循环引用</span><br></pre></td></tr></table></figure>
<p>协议类代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#import</span><br><span class="line"></span><br><span class="line">@interface AYProxy : NSProxy</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id obj;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;AYProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation AYProxy</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">   NSMethodSignature *sig = nil;</span><br><span class="line">   sig = [self.obj methodSignatureForSelector:aSelector];</span><br><span class="line">   return sig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">   [anInvocation invokeWithTarget:self.obj];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>多重继承</p>
<p>实现类似CAAnimation类族.</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/1语言/1语言-消息转发NSProxy/" data-id="cldyf818v00u700r4vwnrg5cm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/1语言/1语言-请求拦截NSURLProtocol" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/1语言/1语言-请求拦截NSURLProtocol/" class="article-date">
  <time datetime="2022-03-16T05:35:04.562Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-①语言-请求拦截NSURLProtocol"><a href="#必备知识架构-①语言-请求拦截NSURLProtocol" class="headerlink" title="必备知识架构-①语言-请求拦截NSURLProtocol"></a>必备知识架构-①语言-请求拦截NSURLProtocol</h1><p>[toc]</p>
<h2 id="一、NSURLProtocol"><a href="#一、NSURLProtocol" class="headerlink" title="一、NSURLProtocol"></a>一、NSURLProtocol</h2><p>如果开发者自定义的一个 NSURLProtocol 并且注册到 app 中，那么在这个自定义的 NSURLProtocol 中我们可以拦截所有的请求(（注意，不只是webView内的请求，而是整个app内的所有请求）)，进行修改，或者修改 response。即NSURLProtocol这个东西的作用可以让我们在app的内部拦截一切url请求。</p>
<p><strong>「或者这么说吧： NSURLProtocol 就是一个苹果允许的中间人攻击。」</strong></p>
<p>注意事项：</p>
<p>如果我们顺序注册 A B C 三个 Protocol，那么一个 connection 在发送的时候，处理的顺序是 C B A，而且最多只有一个 Protocol 会触发处理。</p>
<p>拦截 UIWebview 的请求，会有被拒的风险。</p>
<p>附：</p>
<blockquote>
<p>iOS的Foundation框架提供了 URL Loading System 这个库(后面简写为ULS)，所有基于URL（例如http://，https:// ,ftp://这些应用层的传输协议)的协议都可以通过ULS提供的基础类和协议来实现。而ULS库里提供了一个强有力的武器 NSURLProtocol。</p>
</blockquote>
<h2 id="NSURLProtocol能做什么？"><a href="#NSURLProtocol能做什么？" class="headerlink" title="NSURLProtocol能做什么？"></a>NSURLProtocol能做什么？</h2><p>举几个例子：</p>
<ul>
<li>全局网络请求设置：我们的APP内的所有请求都需要增加公共的头，像这种我们就可以直接通过NSURLProtocol来实现，当然实现的方式有很多种</li>
<li>自定义 Response （过滤敏感信息）</li>
<li>再比如我们需要将APP某个API进行一些访问的统计</li>
<li>再比如我们需要统计APP内的网络请求失败率</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/1语言/1语言-请求拦截NSURLProtocol/" data-id="cldyf819c00u800r4ead8y4ix" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/">Architecture</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第一章：架构分层/">第一章：架构分层</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/无瑕疵的混编登录页/">无瑕疵的混编登录页</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第一章：Flutter入门/">第一章：Flutter入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第七章：规范/">第七章：规范</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第三章：原生项目与Flutter的交互/">第三章：原生项目与Flutter的交互</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第九章：框架升级/">第九章：框架升级</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第二章：集成Flutter到原生项目/">第二章：集成Flutter到原生项目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第五章：详解/">第五章：详解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第八章：状态管理/">第八章：状态管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第六章：进阶/">第六章：进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第四章：Flutter登录页实战/">第四章：Flutter登录页实战</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/README/">README</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/React/第一章：React入门/">第一章：React入门</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/">ReactNative</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第一章：ReactNative入门/">第一章：ReactNative入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第一章：React入门/">第一章：React入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第五章：ReactNative详解/">第五章：ReactNative详解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第八章：ReactNative实践/">第八章：ReactNative实践</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第六章：ReactNative进阶/">第六章：ReactNative进阶</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/">Script</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Script/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Shell/">Shell</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Weex/">Weex</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Weex/第一章：Weex入门/">第一章：Weex入门</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Swift/">Swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/app安全/">app安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/混编/">混编</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/移动分析/">移动分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/自动化/">自动化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/证书发版/">证书发版</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/npmjs/">npmjs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/代码管理/">代码管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/">实用工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/GitBook/">GitBook</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/Jenkins/">Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/XAMPP/">XAMPP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/Zentao/">Zentao</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/其他小工具/">其他小工具</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作常识/">工作常识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术常识/">技术常识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活常识/">生活常识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/目前痛点/">目前痛点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程工具/">编程工具</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Architecture/">Architecture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/README/">README</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReactNative/">ReactNative</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Script/">Script</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/app安全/">app安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npmjs/">npmjs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/交互/">交互</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/实用工具/">实用工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作常识/">工作常识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术常识/">技术常识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/抓包/">抓包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文档管理/">文档管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境搭建/">环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活常识/">生活常识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/痛点/">痛点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/登录页实战/">登录页实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动分析/">移动分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程工具/">编程工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化/">自动化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨平台/">跨平台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阿里云/">阿里云</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阿里云oss/">阿里云oss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集成/">集成</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Architecture/" style="font-size: 15.45px;">Architecture</a> <a href="/tags/CocoaPods/" style="font-size: 10px;">CocoaPods</a> <a href="/tags/Flutter/" style="font-size: 19.09px;">Flutter</a> <a href="/tags/Git/" style="font-size: 12.73px;">Git</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Jenkins/" style="font-size: 14.55px;">Jenkins</a> <a href="/tags/Python/" style="font-size: 10.91px;">Python</a> <a href="/tags/README/" style="font-size: 10px;">README</a> <a href="/tags/React/" style="font-size: 10.91px;">React</a> <a href="/tags/ReactNative/" style="font-size: 16.36px;">ReactNative</a> <a href="/tags/Ruby/" style="font-size: 10px;">Ruby</a> <a href="/tags/Script/" style="font-size: 14.55px;">Script</a> <a href="/tags/Shell/" style="font-size: 10.91px;">Shell</a> <a href="/tags/Swift/" style="font-size: 12.73px;">Swift</a> <a href="/tags/Weex/" style="font-size: 10px;">Weex</a> <a href="/tags/app安全/" style="font-size: 10px;">app安全</a> <a href="/tags/iOS/" style="font-size: 18.18px;">iOS</a> <a href="/tags/npmjs/" style="font-size: 10.91px;">npmjs</a> <a href="/tags/交互/" style="font-size: 12.73px;">交互</a> <a href="/tags/实用工具/" style="font-size: 17.27px;">实用工具</a> <a href="/tags/工作常识/" style="font-size: 10px;">工作常识</a> <a href="/tags/技术常识/" style="font-size: 11.82px;">技术常识</a> <a href="/tags/抓包/" style="font-size: 10px;">抓包</a> <a href="/tags/文档管理/" style="font-size: 14.55px;">文档管理</a> <a href="/tags/环境搭建/" style="font-size: 10.91px;">环境搭建</a> <a href="/tags/生活常识/" style="font-size: 10px;">生活常识</a> <a href="/tags/痛点/" style="font-size: 10px;">痛点</a> <a href="/tags/登录页实战/" style="font-size: 12.73px;">登录页实战</a> <a href="/tags/移动分析/" style="font-size: 10px;">移动分析</a> <a href="/tags/编程工具/" style="font-size: 11.82px;">编程工具</a> <a href="/tags/自动化/" style="font-size: 11.82px;">自动化</a> <a href="/tags/跨平台/" style="font-size: 20px;">跨平台</a> <a href="/tags/阿里云/" style="font-size: 10px;">阿里云</a> <a href="/tags/阿里云oss/" style="font-size: 13.64px;">阿里云oss</a> <a href="/tags/集成/" style="font-size: 11.82px;">集成</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/Architecture架构/h5_native_interacte/h5_open_app/dvlp_h5_open_app_app_route_url_demo/">(no title)</a>
          </li>
        
          <li>
            <a href="/Architecture架构/h5_native_interacte/h5_open_app/dvlp_h5_open_app_browser_url_demo/">(no title)</a>
          </li>
        
          <li>
            <a href="/Architecture架构/h5_native_interacte/h5_open_app/dvlp_h5_open_app_browser_url_demo/">(no title)</a>
          </li>
        
          <li>
            <a href="/Architecture架构/h5_native_interacte/h5_open_app/dvlp_h5_open_app_app_route_url_demo/">(no title)</a>
          </li>
        
          <li>
            <a href="/HTML/common_js/url_util/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 dvlproad<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>