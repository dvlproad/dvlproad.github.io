<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>dvlproadの博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学而时习之不亦说乎(dvlproad)">
<meta name="keywords" content="blog,IT,iOS,Flutter">
<meta property="og:type" content="website">
<meta property="og:title" content="dvlproadの博客">
<meta property="og:url" content="https://dvlproad.github.io/page/25/index.html">
<meta property="og:site_name" content="dvlproadの博客">
<meta property="og:description" content="学而时习之不亦说乎(dvlproad)">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dvlproadの博客">
<meta name="twitter:description" content="学而时习之不亦说乎(dvlproad)">
  
    <link rel="alternate" href="/atom.xml" title="dvlproadの博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">dvlproadの博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">整理及总结平时过程中的知识点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://dvlproad.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS/3必备知识架构/2内存/2内存-②Block" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-②Block/" class="article-date">
  <time datetime="2019-04-28T01:27:20.000Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/iOS/3必备知识架构/2内存/2内存-②Block/">内存-②Block</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="内存-②Block"><a href="#内存-②Block" class="headerlink" title="内存-②Block"></a>内存-②Block</h1><p>[toc]</p>
<h2 id="iOS-Block本质"><a href="#iOS-Block本质" class="headerlink" title="iOS-Block本质"></a>iOS-Block本质</h2><p><a href="https://www.jianshu.com/p/4e79e9a0dd82" target="_blank" rel="noopener">iOS-Block本质</a></p>
<p>block本质上也是一个OC对象，它内部也有个isa指针，最终继承NSObject。</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSGlobalBlock &lt;--__NSGlobalBlock &lt;--NSBlock &lt;-- NSObject</span><br></pre></td></tr></table></figure>
<h4 id="Q：block有哪几种类型-及-各类型的block在内存中如何分配的？"><a href="#Q：block有哪几种类型-及-各类型的block在内存中如何分配的？" class="headerlink" title="Q：block有哪几种类型 及 各类型的block在内存中如何分配的？"></a>Q：block有哪几种类型 及 各类型的block在内存中如何分配的？</h4><p>block的类型，取决于isa指针，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型。</p>
<p><strong>堆</strong>：动态分配内存，需要程序员自己申请，程序员自己管理</p>
<p><strong>栈</strong>：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况</p>
<ul>
<li><p><strong>NSGlobalBlock </strong> 在数据区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void (^block1)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;block1&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>NSMallocBlock </strong> 在堆区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age1 = 1;</span><br><span class="line">void (^block2)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;block2:%d&quot;, age1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>NSStackBlock </strong> 在栈区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age2 = 2;</span><br><span class="line">NSLog(@&quot;%@&quot;, [^&#123;</span><br><span class="line">        NSLog(@&quot;block3:%d&quot;, age2);</span><br><span class="line">    &#125; class]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>附：打印block类型<code>NSLog(@&quot;%@&quot;, [block1 class]);</code></p>
<h2 id="问：以下各情况，Person的对象什么时候才销毁？或Person对象在block上是如何操作的？"><a href="#问：以下各情况，Person的对象什么时候才销毁？或Person对象在block上是如何操作的？" class="headerlink" title="问：以下各情况，Person的对象什么时候才销毁？或Person对象在block上是如何操作的？"></a>问：以下各情况，Person的对象什么时候才销毁？或Person对象在block上是如何操作的？</h2><p>有Person类如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;Person dealloc&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>了解解题的基础知识：</p>
<h4 id="1、当对象类型的auto变量被block内部访问时，是强引用还是弱引用？-延伸：引用过后，block内部无法修改auto变量值，除非使用-block"><a href="#1、当对象类型的auto变量被block内部访问时，是强引用还是弱引用？-延伸：引用过后，block内部无法修改auto变量值，除非使用-block" class="headerlink" title="1、当对象类型的auto变量被block内部访问时，是强引用还是弱引用？(延伸：引用过后，block内部无法修改auto变量值，除非使用__block)"></a>1、当对象类型的auto变量被block内部访问时，是强引用还是弱引用？(延伸：引用过后，block内部无法修改auto变量值，除非使用__block)</h4><ul>
<li>如果block在<code>栈</code>空间，不管外部变量是强引用还是弱引用，block都会弱引用访问对象</li>
<li>如果block在<code>堆</code>空间，如果外部强引用，block内部也是强引用；如果外部弱引用，block内部也是弱引用</li>
</ul>
<p>2、GCD API的方法参数block，在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上。</p>
<h4 id="附：在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上的几种情况？"><a href="#附：在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上的几种情况？" class="headerlink" title="附：在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上的几种情况？"></a>附：在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上的几种情况？</h4><ul>
<li><p>1.block作为函数返回值时</p>
</li>
<li><p>2.将block赋值给__strong指针时</p>
</li>
<li><p>3.block作为Cocoa API中方法名含有usingBlock的方法参数时</p>
</li>
<li><p>4.block作为GCD API的方法参数时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1、问：-下列代码中的Person的对象什么时候才销毁？"><a href="#1、问：-下列代码中的Person的对象什么时候才销毁？" class="headerlink" title="1、问： 下列代码中的Person的对象什么时候才销毁？"></a>1、问： 下列代码中的Person的对象什么时候才销毁？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = 10;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;age:%d&quot;, person.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：方法代码执行完就person就销毁了</p>
<h3 id="2、问：以下gcd的block中引用-Person的对象什么时候才销毁？"><a href="#2、问：以下gcd的block中引用-Person的对象什么时候才销毁？" class="headerlink" title="2、问：以下gcd的block中引用 Person的对象什么时候才销毁？"></a>2、问：以下gcd的block中引用 Person的对象什么时候才销毁？</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">// 不使用__weak修饰</span></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age:%d"</span>, person.age);	<span class="comment">// 堆block会对Person强引用，故而也就只有block销毁时候Person才会被释放。这里是2秒后销毁。</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"touchesBegan"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：</p>
<p>1、gcd的block默认会做copy操作，即dispatch_after的block是堆block。</p>
<p>2、我们知道<code>如果block在堆空间，如果外部强引用，block内部也是强引用；如果外部弱引用，block内部也是弱引用</code>。</p>
<p>所以这里外部的Person没有声明为__weak，所以堆block会对Person强引用，故而也就只有block销毁时候Person才会被释放。这里是2秒后销毁。(如果没有gcd)</p>
<h3 id="3、续问：如果上述Person被添加上-weak修饰，那Person什么时候释放？会造成什么问题？"><a href="#3、续问：如果上述Person被添加上-weak修饰，那Person什么时候释放？会造成什么问题？" class="headerlink" title="3、续问：如果上述Person被添加上__weak修饰，那Person什么时候释放？会造成什么问题？"></a>3、续问：如果上述Person被添加上__weak修饰，那Person什么时候释放？会造成什么问题？</h3><p>续答：此时上述的代码会变为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = 10;</span><br><span class="line">    </span><br><span class="line">  	// 不使用__weak修饰</span><br><span class="line">    __weak Person *weakPerson = person;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;person:%p&quot;, weakPerson);	// 当Person被添加上__weak修饰后，堆block会对Person弱引用。而在touchesBegan函数结束后，由于Person就会被释放，所以2秒后gcd无法捕捉到Person的后果。所以此处person 是 nil，打印的%p地址，是0x0。</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;touchesBegan&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，还是我们知道<code>如果block在堆空间，如果外部强引用，block内部也是强引用；如果外部弱引用，block内部也是弱引用</code>。所以当Person被添加上__weak修饰后，堆block会对Person弱引用。而在touchesBegan函数结束后，由于Person就会被释放，所以2秒后gcd无法捕捉到Person的后果。即上述的输出结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person 是 nil，打印的%p地址，是0x0。</span><br></pre></td></tr></table></figure>
<h3 id="4、上述代码使用-weak后，变量被释放了，那怎么防止block持有的对象提前释放"><a href="#4、上述代码使用-weak后，变量被释放了，那怎么防止block持有的对象提前释放" class="headerlink" title="4、上述代码使用__weak后，变量被释放了，那怎么防止block持有的对象提前释放"></a>4、上述代码使用__weak后，变量被释放了，那怎么防止block持有的对象提前释放</h3><h4 id="Q：block的属性修饰词为什么是copy？"><a href="#Q：block的属性修饰词为什么是copy？" class="headerlink" title="Q：block的属性修饰词为什么是copy？"></a>Q：block的属性修饰词为什么是copy？</h4><p>block一旦没有进行copy操作，就不会在堆上<br>block在堆上，程序员就可以对block做内存管理等操作，可以控制block的生命周期</p>
<h4 id="Q：当block被copy到堆时，对-block修饰的变量做了什么？"><a href="#Q：当block被copy到堆时，对-block修饰的变量做了什么？" class="headerlink" title="Q：当block被copy到堆时，对__block修饰的变量做了什么？"></a>Q：当block被copy到堆时，对__block修饰的变量做了什么？</h4><ul>
<li>会调用block内部的copy函数</li>
<li>copy函数内部会调用_Block_object_assign函数</li>
<li>_Block_object_assign函数会对__block变量形成强引用（retain）</li>
<li>对于__block 修饰的变量 assign函数对其强引用；对于外部对象 assign函数根据外部如何引用而引用</li>
</ul>
<h4 id="Q：当block从堆中移除时，对-block修饰的变量做了什么？"><a href="#Q：当block从堆中移除时，对-block修饰的变量做了什么？" class="headerlink" title="Q：当block从堆中移除时，对__block修饰的变量做了什么？"></a>Q：当block从堆中移除时，对__block修饰的变量做了什么？</h4><ul>
<li>会调用block内部的dispose函数</li>
<li>dispose函数内部会调用_Block_object_dispose函数</li>
<li>_Block_object_dispose函数会自动释放引用的__block变量（release）</li>
</ul>
<h2 id="二、-block修饰符"><a href="#二、-block修饰符" class="headerlink" title="二、__block修饰符"></a>二、__block修饰符</h2><h4 id="Q：-block-int-age-10，系统做了哪些？"><a href="#Q：-block-int-age-10，系统做了哪些？" class="headerlink" title="Q：__block int age = 10，系统做了哪些？"></a>Q：<code>__block</code> int age = 10，系统做了哪些？</h4><h4 id="Q：-block-修饰符作用？"><a href="#Q：-block-修饰符作用？" class="headerlink" title="Q：__block 修饰符作用？"></a>Q：__block 修饰符作用？</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-②Block/" data-id="cm2nkn642016ubur4ttgg0lbc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/2内存/2内存-③内存泄漏定位" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/" class="article-date">
  <time datetime="2019-04-28T01:27:20.000Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/">内存-③内存泄漏定位</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="内存-③内存泄漏定位"><a href="#内存-③内存泄漏定位" class="headerlink" title="内存-③内存泄漏定位"></a>内存-③内存泄漏定位</h1><p>未整合的文章：</p>
<ul>
<li><a href="https://blog.csdn.net/clovejq/article/details/78689759" target="_blank" rel="noopener">iOS检测内存泄漏的方法</a></li>
<li><a href="https://blog.csdn.net/mr_zhangrmwork/article/details/76210448" target="_blank" rel="noopener">xcode8 使用Instruments检测定位并解决iOS内存泄露</a></li>
</ul>
<p></p><p id="目录"></p><p></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#重要文章">重要文章</a></li>
<li><a href="#Analyze">一、Analyze—静态分析</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、常见的三种泄露情形</span><br><span class="line">(1)、创建了一个对象，但是并没有使用。Xcode提示信息：Value Stored to &apos;number&apos; is never read。翻译一下：存储在&apos;number&apos;里的值从未被读取过。</span><br><span class="line">(2)、创建了一个（指针可变的）对象，且初始化了，但是初始化的值一直没读取过。Xcode提示信息：Value Stored to &apos;str&apos; during its initialization is never read</span><br><span class="line">(3)、调用了让某个对象引用计数加1的函数，但没有调用相应让其引用计数减1的函数。Xcode提示信息：Potential leak of an object stored into &apos;subImageRef&apos;。 翻译一下：subImageRef对象的内存单元有潜在的泄露风险。ARC中常见于CGxxxRef未release。</span><br><span class="line">&gt;</span><br><span class="line">2、.....</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><a href="#Leaks">二、Leaks—内存泄露</a></p>
</li>
<li><p><a href="#dealloc">三、ARC下的dealloc</a></p>
</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、ARC下dealloc的使用</span><br><span class="line">ARC下,系统可以帮我们释放该对象,及其包含的对象;但是却无法释放不属于该对象的一些东西,如:</span><br><span class="line">(1)、通知的观察者,或KVO的观察者；</span><br><span class="line">(2)、对象强委托/引用的解除；</span><br><span class="line">(3)、做一些其他的注销之类的操作,如一个ViewController在销毁之前有可能需要和server打交道。</span><br><span class="line">&gt;</span><br><span class="line">2、controller 不能释放，不走dealloc方法的几种可能</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p>
</li>
<li><p><a href="#END">END</a></p>
</li>
</ul>
<p>以下内容摘自：<a href="https://www.cnblogs.com/lisaloveyou1900/p/5383760.html" target="_blank" rel="noopener">iOS性能优化之内存管理：Analyze、Leaks、Allocations的使用和案例代码</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>内存空间的划分: 我们知道，一个进程占用的内存空间，包含5种不同的数据区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）BSS段：通常是存放未初始化的全局变量；</span><br><span class="line">（2）数据段：通常是存放已初始化的全局变量。</span><br><span class="line">（3）代码段：通常是存放程序执行代码。</span><br><span class="line">（4）堆：通常是用于存放进程运行中被动态分配的内存段，OC对象（所有继承自NSObject的对象）就存放在堆里。</span><br><span class="line">（5）栈：由编译器自动分配释放，存放函数的参数值，局部变量等值。</span><br></pre></td></tr></table></figure>
<p>栈内存是系统来管理的，因此我们常说的内存管理，指的是堆内存的管理，也就是所有OC对象的创建和销毁的管理。</p>
<p>伴随着iOS5的到来，苹果推出了ARC（自动引用计数）技术，此模式下编译器会自动在合适的地方插入retain、release、autorelease语句，也就是说编译器会自动生成内存管理的代码，解放了广大程序猿的双手，也基本上避免了内存泄露问题，但是呢…</p>
<p>内存泄露的定义是：用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。（其实说白了就是该内存空间使用完毕之后未回收）。</p>
<p>在iOS应用中的内存泄露，原因一般有循环引用、错用Strong/copy等。</p>
<p></p><p id="重要文章"></p><p></p>
<h2 id="重要文章"><a href="#重要文章" class="headerlink" title="重要文章"></a>重要文章</h2><ul>
<li><a href="https://blog.csdn.net/clovejq/article/details/78689759" target="_blank" rel="noopener">iOS检测内存泄漏的方法</a></li>
<li><a href="https://www.jianshu.com/p/b72d0a442342" target="_blank" rel="noopener">iOS 内存泄漏的查找</a></li>
<li><a href="https://www.jianshu.com/p/33bda0eed3aa?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">iOS 内存泄漏监测自动化</a></li>
</ul>
<p></p><p id="Analyze"></p><p></p>
<h2 id="一、Analyze—静态分析"><a href="#一、Analyze—静态分析" class="headerlink" title="一、Analyze—静态分析"></a>一、Analyze—静态分析</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>顾名思义，静态分析不需要运行程序，就能检查到存在内存泄露的地方。</p>
<p>使用方法：打开Xcode，command + shift + B；或者Xcode - Product - Analyze；</p>
<h3 id="1、常见的三种泄露情形："><a href="#1、常见的三种泄露情形：" class="headerlink" title="1、常见的三种泄露情形："></a>1、常见的三种泄露情形：</h3><blockquote>
</blockquote>
<p>（1）创建了一个对象，但是并没有使用。Xcode提示信息：Value Stored to ‘number’ is never read。翻译一下：存储在’number’里的值从未被读取过。</p>
<blockquote>
</blockquote>
<p>（2）创建了一个（指针可变的）对象，且初始化了，但是初始化的值一直没读取过。Xcode提示信息：Value Stored to ‘str’ during its initialization is never read</p>
<blockquote>
</blockquote>
<p>（3）调用了让某个对象引用计数加1的函数，但没有调用相应让其引用计数减1的函数。Xcode提示信息：Potential leak of an object stored into ‘subImageRef’。 翻译一下：subImageRef对象的内存单元有潜在的泄露风险。ARC中常见于CGxxxRef未release。</p>
<p>贴上三种常见情形的Demo代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 情 形 一：创建了一个对象，但是并没有使用。</span><br><span class="line"> * 提示信息：Value Stored to &apos;number&apos; is never read</span><br><span class="line"> * 翻译一下：存储在&apos;number&apos;里的值从未被读取过，</span><br><span class="line"> */</span><br><span class="line">- (void)leakOne &#123;</span><br><span class="line">    NSString *str1 = [NSString string];</span><br><span class="line">    NSNumber *number;</span><br><span class="line">    number = @(str1.length);</span><br><span class="line">    /*</span><br><span class="line">     说我们没有读取过它，那就读取一下，比如打开下面这句代码，对它发送class消息，就不再会有这个提示了。</span><br><span class="line">     当然最好的方法还是将有关number的代码都删掉，因为，你只对number赋值，又不使用，那干嘛创建出来呢。</span><br><span class="line">     这是一个比较常见和典型的错误，也很容易检查出来</span><br><span class="line">     */</span><br><span class="line">    // [number class];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 情 形 二：创建了一个（指针可变的）对象，且初始化了，但是初始化的值一直没读取过。</span><br><span class="line"> * 提示信息：Value Stored to &apos;str&apos; during its initialization is never read</span><br><span class="line"> */</span><br><span class="line">- (void)leakTwo &#123;</span><br><span class="line">    NSString *str = [NSString string]; // 创建并初始化str，此时已经有一个内存单元保存str初始化的值</span><br><span class="line">    // NSString *str; // 这样就内存不泄露，因为str是可变的，只需要先声明就行。</span><br><span class="line">    // printf(&quot;str前 = %p\n&quot;,str);</span><br><span class="line">    str = @&quot;ceshi&quot;;             // str被改变了，指向了&quot;ceshi&quot;所在的地址，指针改变了，但之前保存初始化值的内存空间还未释放，保存str初始化值的内存单元泄露了。</span><br><span class="line">    // printf(&quot;str后 = %p\n&quot;,str); // 指针改变了</span><br><span class="line">    [str class];</span><br><span class="line">     </span><br><span class="line">    // 再举两个例子，同理</span><br><span class="line">     </span><br><span class="line">    NSArray *arr = [NSArray array];</span><br><span class="line">    // printf(&quot;arr前 = %p\n&quot;,arr);</span><br><span class="line">    // NSArray *arr;            // 这样就内存不泄露</span><br><span class="line">    arr = @[@&quot;1&quot;,@&quot;2&quot;];</span><br><span class="line">    // printf(&quot;arr后 = %p\n&quot;,arr); // 指针改变了</span><br><span class="line">    [arr class];</span><br><span class="line">     </span><br><span class="line">    CGRect rect = self.view.frame;</span><br><span class="line">    // CGRect rect = CGRectZero; // 这样就内存不泄露</span><br><span class="line">    rect = CGRectMake(0, 0, 0, 0);</span><br><span class="line">    NSLog(@&quot;rect = %@&quot;,NSStringFromCGRect(rect));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 情 形 三：调用了让某个对象引用计数加1的函数，但没有调用相应让其引用计数减1的函数。</span><br><span class="line"> * 提示信息：Potential leak of an object stored into &apos;subImageRef&apos;</span><br><span class="line"> * 翻译一下：subImageRef对象的内存单元有潜在的泄露风险</span><br><span class="line"> */</span><br><span class="line">- (void)leakThree &#123;</span><br><span class="line">    CGRect rect = CGRectMake(0, 0, 50, 50);</span><br><span class="line">    UIImage *image;</span><br><span class="line">    CGImageRef subImageRef = CGImageCreateWithImageInRect(image.CGImage, rect); // subImageRef 引用计数 + 1;</span><br><span class="line">     </span><br><span class="line">    UIImage* smallImage = [UIImage imageWithCGImage:subImageRef];</span><br><span class="line">     </span><br><span class="line">    // 应该调用对应的函数，让subImageRef的引用计数减1,就不会泄露了</span><br><span class="line">    // CGImageRelease(subImageRef);</span><br><span class="line">     </span><br><span class="line">    [smallImage class];</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己遇到的实例:</p>
<blockquote>
<p>情形2：<a href="https://blog.csdn.net/sinat_30898863/article/details/51142127" target="_blank" rel="noopener">静态检测内存泄露Analyze－－Value stored to ‘dataArr’ during its initialization is never read</a><br>即初始化的时候开辟了一块内存，却始终没用到，导致该块内存泄漏</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *tempMutArr = [NSMutableArray arrayWithCapacity:0];</span><br><span class="line">   if ([self.clickedButtonTpye isEqualToString:KClickedButtonTypeLast]) &#123;</span><br><span class="line">       tempMutArr = self.lastDataSourceArr;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       tempMutArr = self.hotDataSourceArr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><a name="Leaks"></a></p>
<h2 id="二、Leaks—内存泄露"><a href="#二、Leaks—内存泄露" class="headerlink" title="二、Leaks—内存泄露"></a>二、Leaks—内存泄露</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<ul>
<li><p><a href="https://wereadteam.github.io/2016/02/22/MLeaksFinder/" target="_blank" rel="noopener">MLeaksFinder：精准 iOS 内存泄露检测工具</a></p>
<blockquote>
<p>项目 <a href="https://github.com/Zepo/MLeaksFinder/blob/master/MLeaksFinder/UIViewController%2BMemoryLeak.m" target="_blank" rel="noopener">UIViewController+MemoryLeak.m     NSObject+MemoryLeak.m</a></p>
<p>原理：MLeaksFinder 一开始从 UIViewController 入手。我们知道，当一个 UIViewController 被 pop 或 dismiss 后，该 UIViewController 包括它的 view，view 的 subviews 等等将很快被释放（除非你把它设计成单例，或者持有它的强引用，但一般很少这样做）。于是，我们只需在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 UIViewController，它的 view，view 的 subviews 等等是否还存在。</p>
<p>即我们hook <code>viewDidDisappear:</code> 和 <code>dismissViewControllerAnimated: completion:</code> 都去执行NSObject的<code>willDealloc</code>方法。</p>
<p>在NSObject的<code>willDealloc</code>方法中，隔2秒后再去尝试调用另一个方法<code>assertNotDealloc</code>。如果UIViewController已经被成功释放，则肯定是 nil 执行 assertNotDealloc，即assertNotDealloc不会被执行，也就不会弹出内存泄露的弹窗。反之，若UIViewController没有释放，则会弹出内存泄露的弹窗。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// UIViewController+MemoryLeak.m</span></span><br><span class="line">&gt; - (<span class="keyword">void</span>)swizzled_viewDidDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">&gt;     [<span class="keyword">self</span> swizzled_viewDidDisappear:animated];</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="keyword">if</span> ([objc_getAssociatedObject(<span class="keyword">self</span>, kHasBeenPoppedKey) boolValue]) &#123;</span><br><span class="line">&gt;         [<span class="keyword">self</span> willDealloc];</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; - (<span class="keyword">void</span>)swizzled_dismissViewControllerAnimated:(<span class="built_in">BOOL</span>)flag completion:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completion &#123;</span><br><span class="line">&gt;     [<span class="keyword">self</span> swizzled_dismissViewControllerAnimated:flag completion:completion];</span><br><span class="line">&gt;     ......</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     [dismissedViewController willDealloc];</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// NSObject+MemoryLeak.m</span></span><br><span class="line">&gt; - (<span class="built_in">BOOL</span>)willDealloc &#123;</span><br><span class="line">&gt;     ......</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     __<span class="keyword">weak</span> <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">&gt;     dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">&gt;         __<span class="keyword">strong</span> <span class="keyword">id</span> strongSelf = weakSelf;</span><br><span class="line">&gt;         [strongSelf assertNotDealloc];</span><br><span class="line">&gt;     &#125;);</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; - (<span class="keyword">void</span>)assertNotDealloc &#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> ([MLeakedObjectProxy isAnyObjectLeakedAtPtrs:[<span class="keyword">self</span> parentPtrs]]) &#123;</span><br><span class="line">&gt;         <span class="keyword">return</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     [MLeakedObjectProxy addLeakedObject:<span class="keyword">self</span>];</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">&gt;     <span class="built_in">NSLog</span>(<span class="string">@"Possibly Memory Leak.\nIn case that %@ should not be dealloced, override -willDealloc in %@ by returning NO.\nView-ViewController stack: %@"</span>, className, className, [<span class="keyword">self</span> viewStack]);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
</li>
<li><p><a href="https://maxieewong.com/Flutter%20%E8%87%AA%E5%8A%A8%E5%8C%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B.html" target="_blank" rel="noopener">自动化内存泄漏检测</a> 项目 <a href="https://github.com/liujiakuoyx/leak_detector/blob/main/lib/src/leak_navigator_observer.dart#L121" target="_blank" rel="noopener">https://github.com/liujiakuoyx/leak_detector/blob/main/lib/src/leak_navigator_observer.dart#L121</a></p>
<blockquote>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">///Such as WebSocket is delay close connect.</span></span><br><span class="line">&gt; <span class="keyword">const</span> <span class="built_in">int</span> _defaultCheckLeakDelay = <span class="number">500</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">typedef</span> ShouldAddedRoute = <span class="built_in">bool</span> <span class="built_in">Function</span>(Route route);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">///NavigatorObserver</span></span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">LeakNavigatorObserver</span> <span class="keyword">extends</span> <span class="title">NavigatorObserver</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">final</span> ShouldAddedRoute? shouldCheck;</span><br><span class="line">&gt;   <span class="keyword">final</span> <span class="built_in">int</span> checkLeakDelay;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">///[callback] if 'null',the all route can added to LeakDetector.</span></span><br><span class="line">&gt;   <span class="comment">///if not 'null', returns ‘true’, then this route will be added to the LeakDetector.</span></span><br><span class="line">&gt;   LeakNavigatorObserver(</span><br><span class="line">&gt;       &#123;<span class="keyword">this</span>.checkLeakDelay = _defaultCheckLeakDelay, <span class="keyword">this</span>.shouldCheck&#125;);</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="meta">@override</span></span><br><span class="line">&gt;   <span class="keyword">void</span> didPop(Route route, Route? previousRoute) &#123;</span><br><span class="line">&gt;     _remove(route);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="meta">@override</span></span><br><span class="line">&gt;   <span class="keyword">void</span> didPush(Route route, Route? previousRoute) &#123;</span><br><span class="line">&gt;     _add(route);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="meta">@override</span></span><br><span class="line">&gt;   <span class="keyword">void</span> didRemove(Route route, Route? previousRoute) &#123;</span><br><span class="line">&gt;     _remove(route);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="meta">@override</span></span><br><span class="line">&gt;   <span class="keyword">void</span> didReplace(&#123;Route? newRoute, Route? oldRoute&#125;) &#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> (newRoute != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt;       _add(newRoute);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="keyword">if</span> (oldRoute != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt;       _remove(oldRoute);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   ......</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
</li>
<li><p><a href="https://docs.flutter.cn/community/tutorials/memory-leak-monitoring-on-flutter" target="_blank" rel="noopener">快手 Flutter 上的内存泄漏监控</a></p>
</li>
</ul>
<p>Leaks是动态的内存泄露检查工具，需要一边运行程序，一边检测。</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/Leak1.jpg" alt="内存泄漏Leak1"></p>
</blockquote>
<p>先不切换到Call Trees，先看看Statistics(统计数据)下的情况</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/Leak2.jpg" alt="内存泄漏Leak2"><br>Allocation中我们主要关注的是Persistent和Persistent Bytes，分别表示当前时间段，申请了但是还没释放的内存数量和大小。</p>
</blockquote>
<p>切换到Call Trees后世这样的</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/Leak3.jpg" alt="内存泄漏Leak3"></p>
</blockquote>
<h4 id="项目中遇到过的内存泄漏"><a href="#项目中遇到过的内存泄漏" class="headerlink" title="项目中遇到过的内存泄漏"></a>项目中遇到过的内存泄漏</h4><p>这里我们不是去查看<code>Call Tree</code>,而是查看<code>Cycles &amp; Roots</code>。</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/循环引用定位1.jpg" alt="循环引用定位1"></p>
<p>点击标记4处为黑色，即代表该处会发生内存泄漏，双击进入代码，如图：<br><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/循环引用定位2.jpg" alt="循环引用定位2"><br>果然存在内存泄漏</p>
</blockquote>
<p>自己遇到的其他例子：</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/Leak_mine_1.jpg" alt="Leak_mine_1"><br>开始不明白为什么这个变量会内存泄漏后面才能白，其实_priceDetailModel这个本身已经用OrderPriceDetailModel赋值过一次了，而这里你又赋值了一次，导致多了一个。代码情况如下两个图：<br><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/Leak_mine_2.jpg" alt="Leak_mine_2"><br>又在set方法中生成了一个地址<br><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/Leak_mine_3.jpg" alt="Leak_mine_3"></p>
</blockquote>
<p><a name="dealloc"></a></p>
<h2 id="三、ARC下的dealloc"><a href="#三、ARC下的dealloc" class="headerlink" title="三、ARC下的dealloc"></a>三、ARC下的dealloc</h2><h4 id="1、ARC下dealloc的使用"><a href="#1、ARC下dealloc的使用" class="headerlink" title="1、ARC下dealloc的使用"></a>1、ARC下dealloc的使用</h4><p>ARC下,系统可以帮我们释放该对象,及其包含的对象;但是却无法释放不属于该对象的一些东西,如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)、通知的观察者,或KVO的观察者；</span><br><span class="line">(2)、对象强委托/引用的解除；</span><br><span class="line">(3)、做一些其他的注销之类的操作,如一个ViewController在销毁之前有可能需要和server打交道。</span><br></pre></td></tr></table></figure>
<h6 id="1-、通知的观察者-或KVO的观察者；"><a href="#1-、通知的观察者-或KVO的观察者；" class="headerlink" title="(1)、通知的观察者,或KVO的观察者；"></a>(1)、通知的观察者,或KVO的观察者；</h6><blockquote>
<p>由于通知中心是系统的一个单例,你在注册通知的观察者时,实际上是在通知中心注册的,</p>
</blockquote>
<p>这时,即使ARC下系统帮我们释放了对象,但是在通知中心的观察还是没有移除,那么当有</p>
<blockquote>
</blockquote>
<p>该通知时,依然会尝试调用该对象的接受通知的方法,这可能会导致一些问题.</p>
<h6 id="2-、对象强委托-引用的解除；"><a href="#2-、对象强委托-引用的解除；" class="headerlink" title="(2)、对象强委托/引用的解除；"></a>(2)、对象强委托/引用的解除；</h6><blockquote>
<p>对于其他的对象来把你当做委托 delegate时,并且是 强引用时,即时你自身被释放,但是引用你的对象依然还在,</p>
</blockquote>
<p>这时需要在引用你的对象移除该delegate</p>
<h6 id="3-、做一些其他的注销之类的操作-如一个ViewController在销毁之前有可能需要和server打交道。"><a href="#3-、做一些其他的注销之类的操作-如一个ViewController在销毁之前有可能需要和server打交道。" class="headerlink" title="(3)、做一些其他的注销之类的操作,如一个ViewController在销毁之前有可能需要和server打交道。"></a>(3)、做一些其他的注销之类的操作,如一个ViewController在销毁之前有可能需要和server打交道。</h6><blockquote>
<p>一个对象,如一个ViewController在销毁之前有可能需要和server打交道;</p>
</blockquote>
<p>这时我们也可以在dealloc中写</p>
<h4 id="2、controller-不能释放，不走dealloc方法的几种可能"><a href="#2、controller-不能释放，不走dealloc方法的几种可能" class="headerlink" title="2、controller 不能释放，不走dealloc方法的几种可能"></a>2、controller 不能释放，不走dealloc方法的几种可能</h4><p>主要原因还是循环引用，引起的内存泄漏。</p>
<p>详情参考：<a href="https://blog.csdn.net/flg1554112450/article/details/70228353" target="_blank" rel="noopener">controller 不能释放，不走dealloc方法的4种可能</a></p>
<p></p><p id="Time Profile"></p><p></p>
<h2 id="四、Time-Profile"><a href="#四、Time-Profile" class="headerlink" title="四、Time Profile"></a>四、Time Profile</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>详情参考：<a href="http://www.cocoachina.com/ios/20160805/17300.html" target="_blank" rel="noopener">instrument Time Profiler总结</a></p>
<p>使用Time Profile前有两点需要注意的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、一定要使用真机调试</span><br><span class="line">2、应用程序一定要使用发布配置</span><br></pre></td></tr></table></figure>
<p>图标为黑色头像的就是Time Profiler给我们的提示，有可能存在性能瓶颈的地方</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/Instruments/TimeProfile1.png" alt="TimeProfile1"></p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他参考材料：</p>
<p>问：Xcode 运行程序，左侧memory 不显示内存。。</p>
<blockquote>
<p>答：运行程序后，xcode 不显示当前使用的内存情况，问题是打开了僵尸–enable zoombie Objects，关闭即可。<br>即打开 product—&gt;SCheme–&gt;EditSCheme –&gt;enable zoombie Objects  取消选中 ok</p>
</blockquote>
<p>就可以继续显示了</p>
<p></p><p id="常见笔试/面试题"></p><p></p>
<h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-③内存泄漏定位/" data-id="cm2nkn64p016xbur49rmnwu64" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/2内存/2内存-①基础" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-①基础/" class="article-date">
  <time datetime="2019-04-28T01:27:20.000Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/iOS/3必备知识架构/2内存/2内存-①基础/">内存-①基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="①基础"><a href="#①基础" class="headerlink" title="①基础"></a>①基础</h1><p>[toc]</p>
<h1 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h1><p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p>
<p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p>
<p></p><p id="目录"></p><p></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#指针">一、指针</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、几个本质</span><br><span class="line">&gt;</span><br><span class="line">2、空指针和未初始化的指针</span><br><span class="line">(1)、空指针和未初始化的指针的区别：</span><br><span class="line">(2)、为什么指针变量定义时一定要初始化？ </span><br><span class="line">&gt;</span><br><span class="line">3、野指针与悬空指针</span><br><span class="line">(1)、指针与内存的常见使用顺序</span><br><span class="line">(2)、内存泄漏的概念</span><br><span class="line">(3)、野指针概念</span><br><span class="line">(4)、在iOS中野指针的后果</span><br><span class="line">(5)、分析野指针的产生原因及解决办法</span><br><span class="line">&gt;</span><br><span class="line">4、iOS NSerror 用双重指针理解</span><br><span class="line">&gt;</span><br><span class="line">5、指针和引用的区别</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><a href="#内存">二、内存</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、堆和栈的区别?</span><br><span class="line">&gt;</span><br><span class="line">2、浅拷贝和深拷贝的区别</span><br><span class="line">&gt;</span><br><span class="line">3、分析NSString、NSMutableString等类的copy、mutableCopy</span><br><span class="line">(1)、分别对NSString、NSMutableString进行copy、mutableCopy生成的类型是什么？</span><br><span class="line">(2)、分别对NSString、NSMutableString进行copy、mutableCopy操作，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</span><br><span class="line">(3)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</span><br><span class="line">(4)、将NSString、NSMutableString变量赋值给用copy、strong修饰的NSMutableString属性的时候，是否会开辟新地址，即是属于深拷贝还是浅拷贝？</span><br><span class="line">(5)、自己代码实现copy修饰符，应该怎么写？？？？</span><br><span class="line">&gt;</span><br><span class="line">4、NSCoding和NSCopy</span><br><span class="line">(1)、NSCoding的作用</span><br><span class="line">(2)、NSCopy</span><br><span class="line">&gt;</span><br><span class="line">5、@synthesize和@dynamic区别</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><a href="#内存">八、谈谈内存管理、内存泄露、循环引用</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、内存管理</span><br><span class="line">(1)、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？</span><br><span class="line">(2)、那怎么知道对象已经没有被引用了呢？</span><br><span class="line">(3)、autorelease、autoreleasepool(自动释放池)</span><br><span class="line">(4)、autoreleasepool(自动释放池)　</span><br><span class="line">(5)、autoreleasepool里面对象的内存什么时候释放? </span><br><span class="line">(6)、runloop、autorelease pool以及线程之间的关系</span><br><span class="line">(7)、自动释放池怎样创建</span><br><span class="line">(8)、自动释放池使用注意</span><br><span class="line">(9)、自动释放池的应用/什么时候要用@autoreleasepool</span><br><span class="line">&gt;</span><br><span class="line">2、如何监测内存泄漏</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><a href="#常见笔试/面试题">常见笔试/面试题</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自动释放池底层怎么实现?</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><a href="#END">END</a></li>
</ul>
<p>常用数据类型占用内存大小</p>
<ul>
<li><a href="https://www.cnblogs.com/guozht/p/7929033.html" target="_blank" rel="noopener">常用数据类型占用内存大小</a></li>
</ul>
<blockquote>
<p><strong>64位编译器</strong></p>
<p>char ：1个字节<br>char*(即指针变量): 8个字节<br>short int : 2个字节<br>int： 4个字节<br>unsigned int : 4个字节<br>float: 4个字节<br>double:  8个字节<br><strong>long:  8个字节</strong><br>long long: 8个字节<br>unsigned long: 8个字节</p>
</blockquote>
<p></p><p id="指针"></p><p></p>
<h2 id="一、指针"><a href="#一、指针" class="headerlink" title="一、指针"></a>一、指针</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<h4 id="1、几个本质"><a href="#1、几个本质" class="headerlink" title="1、几个本质"></a>1、几个本质</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">数据类型：</span><br><span class="line">数据类型的本质是固定大小内存的别名。</span><br><span class="line">对变量声明数据类型，是为了告诉编译器分配几个字节的内存。</span><br><span class="line"></span><br><span class="line">变量：</span><br><span class="line">变量的本质是一段内存空间的别名。</span><br><span class="line">也就是给一段内存空间取一个新的名字，就是变量。</span><br><span class="line"></span><br><span class="line">指针：</span><br><span class="line">指针也是一种数据类型，它的值是某一个内存空间的地址。</span><br><span class="line">指针的步长根据它指向的内存空间的数据类型而定。</span><br><span class="line"></span><br><span class="line">数组中[]的本质：假如有数组array，则array[i]等价于*(array+i)，是因为[]对于程序员来讲是友好的，但是编译器最终还是要将它理解为指针，也就是数组作为函数参数时的退化。array[i] ==&gt; array[0+i] ==&gt;*(array+i)</span><br></pre></td></tr></table></figure>
<h4 id="2、空指针和未初始化的指针-野指针"><a href="#2、空指针和未初始化的指针-野指针" class="headerlink" title="2、空指针和未初始化的指针/野指针"></a>2、空指针和未初始化的指针/野指针</h4><h6 id="1-、空指针和未初始化的指针的区别："><a href="#1-、空指针和未初始化的指针的区别：" class="headerlink" title="(1)、空指针和未初始化的指针的区别："></a>(1)、空指针和未初始化的指针的区别：</h6><blockquote>
<p><strong>①空指针可以确保不指向任何对象或函数</strong>;<br>而<strong>②未初始化指针则可能指向任何地方，即它所指向的地址就是随机的，也就说此时它是个野指针。（附：如果一个指针的指向对象后来被删除，却未置为空指针nil，则它也是野指针）</strong><br>所以空指针在概念上不同于未初始化的指针。<br>对于malloc在其内存分配的时候，如果内存分配成功，返回的一定不是空指针；但是如果malloc内存分配失败,返回的空指针。而不是一个未初始化的指针。</p>
</blockquote>
<p>以下是华为笔试题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下面有关空指针和未初始化指针，说法错误的是？</span><br><span class="line">A.对0x0这个地址取值是非法的</span><br><span class="line">B.空指针可以确保不指向任何对象或函数; 而未初始化指针则可能指向任何地方。</span><br><span class="line">C.空指针与任何对象或函数的指针值都不相等</span><br><span class="line">D.malloc在其内存分配失败时返回的是一个未初始化的指针</span><br></pre></td></tr></table></figure>
<p>错误答案是D，因malloc内存分配失败，返回的是空指针。详细请查看原文地址<br><a href="https://www.nowcoder.com/questionTerminal/9a24bf403b1c4103a23562d52a2091ea" target="_blank" rel="noopener">华为笔试：下面有关空指针和未初始化指针，说法错误的是？</a></p>
<h6 id="2-、为什么指针变量定义时一定要初始化？"><a href="#2-、为什么指针变量定义时一定要初始化？" class="headerlink" title="(2)、为什么指针变量定义时一定要初始化？"></a>(2)、为什么指针变量定义时一定要初始化？</h6><blockquote>
<p>答:因为你首先要理解一点.内存空间不是你分配了才可以使用，只是你分配了之后使用才安全。</p>
<p>为什么要进行对他初始化呢，因为如果你没对它初始化，那么这个指针所指向的地址就是随机的，即此时它是个野指针。这时候如果你引用这个指针并对它做了修改这个指针所指向的内容的操作的话，如果刚好这个指针所指向的内容恰好是另外一个程序的数据的话，那么你原本随意的一个修改，就造成了对另一个程序的数据的修改了，也就会导致另外一个程序可能不能正常运行了。所以使用前一定要进行初始化。</p>
</blockquote>
<h4 id="3、野指针与悬空指针"><a href="#3、野指针与悬空指针" class="headerlink" title="3、野指针与悬空指针"></a>3、野指针与悬空指针</h4><p>在C/C++等语言中，</p>
<p>悬空指针（Dangling Pointer）指的是：<strong>一个指针的指向对象已被删除</strong>，那么就成了悬空指针。</p>
<p><strong>野指针是那些未初始化的指针</strong>。</p>
<p>有时也把野指针和悬空指针通称悬空指针。<br>而好像在iOS中是通称为野指针。</p>
<p>以下内容摘自：<a href="https://baike.baidu.com/item/迷途指针/6959997?fr=aladdin" target="_blank" rel="noopener">百度百科：迷途指针</a></p>
<blockquote>
<p>在计算机编程领域中，迷途指针，或称悬空指针、野指针，指的是不指向任何合法的对象的指针。</p>
<p>当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址，此情况下该指针便称迷途指针。</p>
<p>若操作系统将这部分已经释放的内存重新分配给另外一个进程，而原来的程序重新引用现在的迷途指针，则将产生无法预料的后果。因为此时迷途指针所指向的内存现在包含的已经完全是不同的数据。通常来说，若原来的程序继续往迷途指针所指向的内存地址写入数据，这些和原来程序不相关的数据将被损坏，进而导致不可预料的程序错误。</p>
<p>这种类型的程序错误，不容易找到问题的原因，通常会导致存储器区块错误（Linux系统中）和一般保护错误（Windows系统中）。如果操作系统的内存分配器将已经被覆盖的数据区域再分配，就可能会影响系统的稳定性。</p>
<p>某些编程语言允许未初始化的指针的存在，而这类指针即为野指针。野指针所导致的错误和迷途指针非常相似，但野指针的问题更容易被发现。</p>
</blockquote>
<h6 id="1-、指针与内存的常见使用顺序"><a href="#1-、指针与内存的常见使用顺序" class="headerlink" title="(1)、指针与内存的常见使用顺序"></a>(1)、指针与内存的常见使用顺序</h6><p>在堆中申请了一块内存，并用一个指针指向它。<br>一般我们都会在不用的时候先释放该指针指向的内存，再将该指针置为空指针。<br>即一般正确的写法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针变量和指针所指向的内存变量是两个不同的概念</span></span><br><span class="line"><span class="comment">//使用动态内存分为三步</span></span><br><span class="line"><span class="comment">//1.定义时，将指针为定义NULL</span></span><br><span class="line"><span class="comment">//2.释放内存时，把指针变量重新赋值或者NULL</span></span><br><span class="line"><span class="comment">//3.释放内存后，把指针变量赋值为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);<span class="comment">//释放P所指向的内存空间,但指针变量p仍然留在栈中,成为了野指针</span></span><br><span class="line">        p = <span class="literal">NULL</span>;<span class="comment">//释放野指针（这是关键，记得释放指针所指向的内存空间后，要释放野指针）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是<br>①、如果我们在未来始终没有去手动释放掉我们开辟的内存的话，会导致内存泄漏；<br>②、如果释放掉了该内存，却忘了同时释放只想该内存的指针，会导致产生悬空指针或者说是迷途指针，或者有人也称是野指针。<br>③、如果记得释放指针，却忘了释放指针只想的内存(即记得②忘了①)，那么由于指针已经消失，而指针指向的东西还在，那么久永远无法控制这块内存，而导致一定内存泄漏了。</p>
<h6 id="2-、内存泄漏的概念"><a href="#2-、内存泄漏的概念" class="headerlink" title="(2)、内存泄漏的概念"></a>(2)、内存泄漏的概念</h6><p><strong>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</strong></p>
<h6 id="3-、野指针概念"><a href="#3-、野指针概念" class="headerlink" title="(3)、野指针概念"></a>(3)、野指针概念</h6><blockquote>
<p>C语言: 当我们声明1个指针变量,没有为这个指针变量赋初始值.这个指针变量的值是1个垃圾指针 指向1块随机的内存空间。</p>
<p>OC语言: 指针指向的对象已经被回收掉了.这个指针就叫做野指针.</p>
<p><strong>野指针：指向内存被释放的内存或者没有访问权限的内存的指针</strong>。</p>
</blockquote>
<p>更详细的概念可查看：<a href="https://baike.baidu.com/item/野指针/9654046?fr=aladdin" target="_blank" rel="noopener">百度百科——野指针</a></p>
<h6 id="4-、在iOS中野指针的后果"><a href="#4-、在iOS中野指针的后果" class="headerlink" title="(4)、在iOS中野指针的后果"></a>(4)、在iOS中野指针的后果</h6><p>野指针的后果：崩溃EXC_BAD_ADDRESS</p>
<h6 id="5-、分析野指针的产生原因及解决办法"><a href="#5-、分析野指针的产生原因及解决办法" class="headerlink" title="(5)、分析野指针的产生原因及解决办法"></a>(5)、分析野指针的产生原因及解决办法</h6><blockquote>
<p>知识点：任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</p>
</blockquote>
<p>“野指针”的成因主要有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）指针变量没有被初始化。(即随机只想的这个指针很有可能只想一块没人用的内存，)</span><br><span class="line"><span class="keyword">char</span> *p; <span class="comment">//此时p为野指针</span></span><br><span class="line"><span class="comment">//正确的为在声明之后加上 p=new char[10];我们常直接写为一行，即char *p=new char[10];</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）指针p被<span class="built_in">free</span>或者<span class="keyword">delete</span>之后，没有置为<span class="literal">NULL</span>，让人误以为p是个合法的指针.</span><br><span class="line"><span class="keyword">char</span> *p=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];  <span class="comment">//指向堆中分配的内存首地址，p存储在栈区</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; p;</span><br><span class="line"><span class="keyword">delete</span> []p; <span class="comment">//p重新变为野指针</span></span><br><span class="line"><span class="comment">//正确的应该在指针p被free或者delete之后,加上p = Null;</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）指针操作超越了变量的作用范围。</span><br><span class="line"><span class="keyword">char</span> *p=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; <span class="comment">//指向堆中分配的内存首地址</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; p;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(p+<span class="number">10</span>); <span class="comment">//可能输出未知数据</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/tgycoder/p/5661431.html" target="_blank" rel="noopener">iOS 关于僵尸对象和僵尸指针的那些事儿</a></p>
<h4 id="4、iOS-NSerror-用双重指针理解"><a href="#4、iOS-NSerror-用双重指针理解" class="headerlink" title="4、iOS NSerror 用双重指针理解"></a>4、iOS NSerror 用双重指针理解</h4><p>常见代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *error = nil;</span><br><span class="line">[[NSFileManager defaultManager] removeItemAtPath:absoluteFilePath error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">	NSLog(@&quot;删除单个文件的时候出现错误：%@&quot;,error.localizedDescription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，如果我们不是传指针的指针&amp;error,而是传error，那么if(error)中的error就肯定是nil了。那就没用了。</p>
<p>所以这里传error的指针的原因可简单概括为：<br>因为我们要得到一个新的error值。所以如果有方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSError *)getNewErrorForremoveItemAtPathremoveItemAtPath:(NSString *)path  error:(NSError **)error &#123;</span><br><span class="line">	NSError *newError = [NSError errorWithDomain:...];</span><br><span class="line">	</span><br><span class="line">	return newError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这边，我们的error,就可以直接传error本身，甚至不传都是可以的。</p>
<p>但是实际是这些方法本身的返回值，已经被定义为判断能否进行某种操作，而不是操作是否成功给占用了，如这边已经被判断能否进行删除文件给占用了，所以如果我们还想知道这个删除文件操作结果的error，那就把error的指针的指针传进去，最后其出来的就是我们想要的。<br>所以，猜测其内部结构应该是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)removeItemAtPath:(NSString *)path error:(NSError **)error &#123;</span><br><span class="line">	BOOL canRemove = ...;</span><br><span class="line">	if (!canRemove) &#123;</span><br><span class="line">		* error = [NSError errorWithDomain:...];</span><br><span class="line">		return NO;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		//* error = * error; //即不变</span><br><span class="line">		return YES;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下解释原因摘自：<a href="https://zhidao.baidu.com/question/484954523.html" target="_blank" rel="noopener">ios中处理错误为什么传递的是&amp;error，而不是error？</a></p>
<blockquote>
<p>因为 需要将error 传入后修改其值，然后再返回来，返回来后还要保证己经修改过了。</p>
<p>&amp;error传入是传的地址引用，传入后处理函数直接访问变量的地址，可以修改其值再返回同一个地址， 调用函数就可以知道值是否有修改，即是否有错。</p>
<p>而error传入是传的值引用，值引用传入到程序栈中后其实是把原来的值复制了一份传过去，处理函数可以修改，但无法将改后的值传出函数体。</p>
</blockquote>
<h4 id="5、指针和引用的区别"><a href="#5、指针和引用的区别" class="headerlink" title="5、指针和引用的区别"></a>5、指针和引用的区别</h4><p>(1)定义和性质的区别<br>①指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；<br>②而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。<br>简单点说：一个是存地址，一个是变量别名<br>（2）指针和引用作为函数参数进行传递时的区别<br>①用指针传递参数，可以实现对实参进行改变的目的，是因为传递过来的是实参的地址<br>②引用作为函数参数进行传递时，实质上传递的是实参本身，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。</p>
<p></p><p id="内存"></p><p></p>
<h2 id="二、内存"><a href="#二、内存" class="headerlink" title="二、内存"></a>二、内存</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<h4 id="1、堆和栈的区别"><a href="#1、堆和栈的区别" class="headerlink" title="1、堆和栈的区别?"></a>1、堆和栈的区别?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一、堆栈空间分配区别：</span><br><span class="line">1、栈（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；</span><br><span class="line">2、堆（操作系统）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</span><br><span class="line"></span><br><span class="line">二、堆栈缓存方式区别：</span><br><span class="line">1、栈使用的是一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放；</span><br><span class="line">2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</span><br></pre></td></tr></table></figure>
<h2 id="八、谈谈内存管理、内存泄露、循环引用"><a href="#八、谈谈内存管理、内存泄露、循环引用" class="headerlink" title="八、谈谈内存管理、内存泄露、循环引用"></a>八、谈谈内存管理、内存泄露、循环引用</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>ARC已经出来很久了，自动释放内存的确很方便，但是并非绝对安全绝对不会产生内存泄露。</p>
<h3 id="1、内存管理"><a href="#1、内存管理" class="headerlink" title="1、内存管理"></a>1、内存管理</h3><h5 id="1-、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？"><a href="#1-、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？" class="headerlink" title="(1)、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？"></a>(1)、在ObjC中，对象什么时候会被释放（或者对象占用的内存什么时候会被回收利用）？</h5><p>答案是：当对象没有被任何变量引用（也可以说是没有指针指向该对象）的时候，就会被释放。</p>
<h5 id="2-、那怎么知道对象已经没有被引用了呢？"><a href="#2-、那怎么知道对象已经没有被引用了呢？" class="headerlink" title="(2)、那怎么知道对象已经没有被引用了呢？"></a>(2)、那怎么知道对象已经没有被引用了呢？</h5><p>ObjC采用引用计数（reference counting）的技术来进行管理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）每个对象都有一个关联的整数，称为引用计数器；</span><br><span class="line">2）当代码需要使用该对象时，则将对象的引用计数加1；</span><br><span class="line">3）当代码结束使用该对象时，则将对象的引用计数减1；</span><br><span class="line">4）当引用计数的值变为0时，表示对象没有被任何代码使用，此时对象将被释放。</span><br></pre></td></tr></table></figure>
<p>与之对应的消息发送方法如下：</p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th>OC中对应的方法</th>
<th>引用计数的变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>当对象被创建时</td>
<td>alloc/new/copy/mutableCopy等</td>
<td>+1</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain</td>
<td>+1</td>
</tr>
<tr>
<td>释放对象</td>
<td>release</td>
<td>-1</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc</td>
<td>-</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）当对象被创建（通过alloc、new或copy/mutableCopy等方法）时，其引用计数初始值为1；</span><br><span class="line">2）给对象发送retain消息，其引用计数加1；</span><br><span class="line">3）给对象发送release消息，其引用计数减1；</span><br><span class="line">4）当对象引用计数归0时，ObjC給对象发送dealloc消息销毁对象</span><br><span class="line">当创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1；</span><br><span class="line">在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1；</span><br><span class="line">需要释放一个对象时，就将该对象的引用计数减1；</span><br><span class="line">直至对象的引用计数为0，对象的内存会被立刻释放。</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];	<span class="comment">// 执行后，引用计数 = 1 </span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n 引用计数 = %lu \n 对象内存 = %p \n object指针内存地址 = %x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[object retainCount], object, &amp;object);</span><br><span class="line">    <span class="keyword">self</span>.property = object;											<span class="comment">// 执行后，引用计数 = 2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n 引用计数 = %lu \n 对象内存 = %p \n object指针内存地址 = %x \n property指针内存地址 = %x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[object retainCount], object, &amp;object, &amp;_property);</span><br><span class="line">    [object release];														<span class="comment">// 执行后，引用计数 = 1 </span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n 引用计数 = %lu \n 对象内存 = %p \n object指针内存地址 = %x \n property指针内存地址 = %x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[object retainCount], object, &amp;object, &amp;_property);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要释放强引用指向的对象时，需要保证所有指向对象强引用置为 nil。<code>__strong</code> 修饰符是 id 类型和对象类型默认的所有权修饰符。</p>
<p><code>__weak</code> 表示弱引用，对应定义 <code>property</code> 时用到的 weak。弱引用不会影响对象的释放，而当对象被释放时，所有指向它的弱引用都会自定被置为 nil，这样可以防止野指针。</p>
<h3 id="2、如何监测内存泄漏"><a href="#2、如何监测内存泄漏" class="headerlink" title="2、如何监测内存泄漏"></a>2、如何监测内存泄漏</h3><p>如果内存管理不当，势必会造成内存泄露。那我们如何快速的来找出内存泄露呢？以前我们可能会使用Instruments来监测，但是我们会发现使用Instruments特别繁琐，而且不一定能定位到内存泄露。</p>
<p>所以这里伟大的Facebook工程师们开源了一些自动化工具来解决监测内存泄露问题：FBRetainCycleDetector、FBAllocationTracker、FBMemoryProfiler。详情查看<a href="http://www.cocoachina.com/ios/20160419/15954.html" target="_blank" rel="noopener">在iOS上自动检测内存泄露</a></p>
<h6 id="你在开发大型项目时-如何进行内存泄露检测的"><a href="#你在开发大型项目时-如何进行内存泄露检测的" class="headerlink" title="你在开发大型项目时,如何进行内存泄露检测的?"></a>你在开发大型项目时,如何进行内存泄露检测的?</h6><blockquote>
<p>instruments下有个leaks工具，启动此工具后，运行项目，工具里可以显示内存泄露的情况，双击可找到源码位置，可以帮助进行内存泄露的处理。</p>
</blockquote>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-①基础/" data-id="cm2nkn6590170bur4j7gifkto" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/2内存/2内存-②循环引用" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-②循环引用/" class="article-date">
  <time datetime="2019-04-28T01:27:20.000Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/iOS/3必备知识架构/2内存/2内存-②循环引用/">内存-②循环引用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="内存-②循环引用"><a href="#内存-②循环引用" class="headerlink" title="内存-②循环引用"></a>内存-②循环引用</h1><p>[toc]</p>
<p></p><p id="目录"></p><p></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><p><a href="#循环引用原因">一、循环引用原因</a></p>
</li>
<li><p><a href="#NSTimer的循环引用">二、NSTimer的循环引用</a></p>
</li>
<li><p><a href="#委托delegate的循环引用">三、委托delegate的循环引用</a></p>
</li>
<li><p><a href="#block的循环引用">四、block的循环引用</a></p>
</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、Objective-C中block为何得用copy修饰，能否用其他</span><br><span class="line">2、block的循环引用</span><br><span class="line">3、block循环引用的解决</span><br><span class="line">4、判断该block是否会发生循环引用</span><br><span class="line">5、为什么masonry的block里引用self不需要weak？</span><br><span class="line">6、是否所有的Block中，使用self 都会导致循环引用？</span><br><span class="line">7、block修改外部局部变量</span><br><span class="line">(1)、在block中无法直接修改外部变量的原因</span><br><span class="line">(2)、解决如何在 block 中修改外部变量</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p>
</li>
<li><p><a href="#END">END</a></p>
</li>
</ul>
<p></p><p id="循环引用原因"></p><p></p>
<h2 id="一、循环引用原因"><a href="#一、循环引用原因" class="headerlink" title="一、循环引用原因"></a>一、循环引用原因</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>导致iOS对象无法按预期释放的一个无形杀手是——循环引用。循环引用可以简单理解为A引用了B，而B又引用了A，双方都同时保持对方的一个引用，导致任何时候引用计数都不为0，始终无法释放。若当前对象是一个ViewController，则在dismiss或者pop之后其dealloc无法被调用，在频繁的push或者present之后内存暴增，然后APP就duang地挂了。</p>
<p><strong>循环引用会导致内存泄露，因为循环应用会导致，有些对象没办法在已经不会再使用的时候被释放掉</strong></p>
<p>下面列举我们变成中比较容易碰到的三种循环引用的情形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）计时器NSTimer：✅__weak typeof(self) weakSelf = self;</span><br><span class="line">循环引用：self -&gt; timer -&gt; block -&gt; self</span><br><span class="line">（2）block：✅copy</span><br><span class="line">@property (nonatomic, copy) void (^myBlock)(void);</span><br><span class="line">（3）委托delegate：✅weak</span><br><span class="line">@property (nonatomic, weak) id&lt;YourDelegateProtocol&gt; delegate;</span><br></pre></td></tr></table></figure>
<p></p><p id="NSTimer的循环引用"></p><p></p>
<h2 id="二、NSTimer的循环引用"><a href="#二、NSTimer的循环引用" class="headerlink" title="二、NSTimer的循环引用"></a>二、NSTimer的循环引用</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>NSTimer的循环引用详情，我们放在下面讲解NSTimer(前面已经提过NSTimer 其实就是RunLoop中的CFRunLoopTimerRef，一个基于时间的触发器)的时候介绍。</p>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@interface HWWeakTimerTarget : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id target;			// 注意是 weak</span><br><span class="line">@property (nonatomic, assign) SEL selector; // assign</span><br><span class="line">@property (nonatomic, weak) NSTimer* timer;	// 注意是 weak</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation HWWeakTimerTarget</span><br><span class="line"></span><br><span class="line">- (void)fire:(NSTimer *)timer &#123;</span><br><span class="line">    if(self.target) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">        [self.target performSelector:self.selector withObject:timer.userInfo afterDelay:0.0f];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.timer invalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation HWWeakTimer</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval</span><br><span class="line">                                     target:(id)aTarget</span><br><span class="line">                                   selector:(SEL)aSelector</span><br><span class="line">                                   userInfo:(id)userInfo</span><br><span class="line">                                    repeats:(BOOL)repeats &#123;</span><br><span class="line">    HWWeakTimerTarget *timerTarget = [[HWWeakTimerTarget alloc] init];</span><br><span class="line">    timerTarget.target = aTarget;</span><br><span class="line">    timerTarget.selector = aSelector;</span><br><span class="line">    timerTarget.timer = [NSTimer scheduledTimerWithTimeInterval:interval</span><br><span class="line">                                                         target:timerTarget</span><br><span class="line">                                                       selector:@selector(fire:)</span><br><span class="line">                                                       userInfo:userInfo</span><br><span class="line">                                                        repeats:repeats];</span><br><span class="line">    return timerTarget.timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p></p><p id="委托delegate的循环引用"></p><p></p>
<h2 id="三、委托delegate的循环引用"><a href="#三、委托delegate的循环引用" class="headerlink" title="三、委托delegate的循环引用"></a>三、委托delegate的循环引用</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>在委托问题上出现循环引用问题已经是老生常谈了，声明delegate时请用weak(ARC)，如果是MRC则用assign。千万别手贱。</p>
<p></p><p id="block的循环引用"></p><p></p>
<h2 id="四、block的循环引用"><a href="#四、block的循环引用" class="headerlink" title="四、block的循环引用"></a>四、block的循环引用</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<h5 id="1、Objective-C中block为何得用copy修饰，能否用其他"><a href="#1、Objective-C中block为何得用copy修饰，能否用其他" class="headerlink" title="1、Objective-C中block为何得用copy修饰，能否用其他"></a>1、Objective-C中block为何得用copy修饰，能否用其他</h5><blockquote>
<p>答：因为<strong>block在创建的时候，它的内存是分配在栈(stack)上，而不是在堆(heap)上。他本身的作于域是属于创建时候的作用域，一旦在创建时候的作用域外面调用block将导致程序崩溃。所以，为了能够在block的声明域外也能够使用block，我们需要将block拷贝到堆上，所以使用copy属性。</strong>对于堆中的block，也就是copy修饰的block。他的生命周期是随着对象的销毁而结束的。只要对象不销毁，我们就可以调用的到在堆中的block。</p>
</blockquote>
<p>Block 在创建时可能存储在不同的内存区域（栈或堆）中，而在将其赋值给对象或作为函数或方法的参数时，需要确保 Block 存储在堆中，以便在调用时能够正常执行。如果 Block 存储在栈中，则在函数或方法返回后，Block 对象所在的内存区域将被释放，从而导致程序崩溃或者产生其他未定义的行为。所以block应该被持有，即<strong>应该使用copy或者strong修改。那为什么我们还是习惯使用copy呢？因为使用 copy 可以提高线程安全性</strong>，因为每个线程可以独立地使用 block 的副本，而不必担心其他线程对原始 block 的修改。举例点击一个按钮</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^updateUIBlock)(<span class="keyword">void</span>); <span class="comment">// 使用 copy 属性</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>; <span class="comment">// 使用 __weak 避免循环引用</span></span><br><span class="line">    <span class="keyword">self</span>.updateUIBlock = ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        <span class="keyword">if</span> (strongSelf) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [strongSelf __updateUI];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)__updateUI &#123;</span><br><span class="line">    <span class="comment">// 更新 UI 的代码</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"UI updated on main thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)clickToUpdateUI &#123;</span><br><span class="line">    <span class="comment">// 执行异步任务，并在完成后调用 updateUIBlock</span></span><br><span class="line">    [<span class="keyword">self</span> performBackgroundTaskWithCompletion:<span class="keyword">self</span>.updateUIBlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// completion这个block如果是原block的副本，那么这里即使多个后台任务尝试同时更新 UI，每个任务都会有 `updateUIBlock` 的独立副本，不会相互干扰。这确保了 UI 更新操作的线程安全性。</span></span><br><span class="line">- (<span class="keyword">void</span>)performBackgroundTaskWithCompletion:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completion &#123;</span><br><span class="line">    <span class="comment">// 模拟后台线程任务</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">// ... 执行一些后台操作 ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 任务完成后，调用 completion block</span></span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            completion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>扩展：为什么NSString 可以使用strong和copy，却选择使用 <code>copy</code>？（个人理解：因为NSString是不可变的，既然不可变还不如使用copy再加一层线程安全）</p>
<p>使用 <code>copy</code> 属性修饰符通常有以下原因：</p>
<ol>
<li><strong>确保线程安全</strong>：如果你在多线程环境中操作字符串，使用 <code>copy</code> 可以确保每个线程都有自己的副本，从而避免线程安全问题。</li>
<li><strong>避免外部修改</strong>：如果你不希望外部代码修改原始字符串，使用 <code>copy</code> 可以确保你的属性持有的是原始字符串的一个副本，外部代码对原始字符串的修改不会影响到你的属性。</li>
</ol>
<h5 id="2、block的循环引用"><a href="#2、block的循环引用" class="headerlink" title="2、block的循环引用"></a>2、block的循环引用</h5><p><strong>由于block在copy时都会对block内部用到的对象进行强引用(ARC)或者retainCount增1(非ARC)。所以，不管是在ARC还是非ARC环境下对block使用不当都会引起循环引用问题</strong></p>
<p>一般表现为，某个类将block作为自己的属性变量(则该类就对block强引用了)，然后该类在block的方法体里面又使用了该类本身。即当对象（比如self）拥有一个block属性的时候，在block属性中又引用了对象的其他成员变量或者调用了对象的其他方法。形成你中有我，我中有你，谁都无法将谁释放的困局。形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">self.myBlock = ^&#123;</span><br><span class="line">   [self doSomething];</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line">又或者</span><br><span class="line"></span><br><span class="line">ClassA* objA = [[ClassA alloc] init];</span><br><span class="line">objA.myBlock = ^&#123;</span><br><span class="line">   [self doSomething];</span><br><span class="line">&#125;;</span><br><span class="line">self.objA = objA;</span><br></pre></td></tr></table></figure>
<p>block的这种循环引用会被编译器捕捉到并及时提醒。</p>
<p>以上参考自：<a href="http://www.jianshu.com/p/b79bac09177e" target="_blank" rel="noopener">Block的循环引用</a></p>
<h5 id="3、block循环引用的解决"><a href="#3、block循环引用的解决" class="headerlink" title="3、block循环引用的解决"></a>3、block循环引用的解决</h5><h6 id="1-、常规简单解法"><a href="#1-、常规简单解法" class="headerlink" title="(1)、常规简单解法"></a>(1)、常规简单解法</h6><p>解决方法,就一句话的事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof (self) weakSelf = self; </span><br><span class="line">self.myBlock = ^&#123;</span><br><span class="line">    [weakSelf doSomething];</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  附1：如果是non-ARC环境下就将__weak替换为__block即可。non-ARC情况下，__block变量的含义是在Block中引入一个新的结构体成员变量指向这个__block变量，那么__block typeof(self) weakSelf = self;就表示Block别再对self对象retain啦，这就打破了循环引用。</span><br><span class="line">  </span><br><span class="line">  附2：__weak 是 iOS 5.0 推出的，_weak 相当于 weak，不会做强引用，如果对象被释放，执行的地址，会指向 nil</span><br></pre></td></tr></table></figure>
<h6 id="2-、block中使用-weak–strong-dance-技术避免循环引用"><a href="#2-、block中使用-weak–strong-dance-技术避免循环引用" class="headerlink" title="(2)、block中使用 weak–strong dance 技术避免循环引用"></a>(2)、block中使用 weak–strong dance 技术避免循环引用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self)weakSelf = self;</span><br><span class="line">  [header setTapHandle:^&#123;</span><br><span class="line">  		__strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line">  		if (strongSelf) &#123;</span><br><span class="line">     		NSLog(@&quot;strongSelf = %@&quot;, strongSelf);</span><br><span class="line">  		&#125;</span><br><span class="line"> 	[weakSelf headerAction:header];</span><br><span class="line">	&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>精髓2：①在 block 之前定义对 self 的一个弱引用weakSelf，因为是弱引用，所以当 self 被释放时weakSelf会变为nil；② 在 block 中引用该弱应用，考虑到多线程情况，通过使用强引用 strongSelf 来引用该弱引用，这时如果 self 不为 nil 就会 retain self，以防止在后面的使用过程中 self 被释放;③在之后的 block 块中使用该强引用 bself，注意在使用前要对 bSelf 进行了 nil 检测，因为多线程环境下在用弱引用weakSelf对强引用strongSelf赋值时，弱引用weakSelf可能已经为nil了。通过这种手法，block 就不会持有 self 的引用，从而打破了循环引用。</strong></p>
<h4 id="iOS开发中在block中为什么要weak和strong配合使用"><a href="#iOS开发中在block中为什么要weak和strong配合使用" class="headerlink" title="iOS开发中在block中为什么要weak和strong配合使用"></a><a href="https://www.jianshu.com/p/0b87b4e7da2c" target="_blank" rel="noopener">iOS开发中在block中为什么要<strong>weak和</strong>strong配合使用</a></h4><blockquote>
<p>答：<strong>weak是为了解决循环引用。</strong>strong是为了防止block持有的对象提前释放。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">  [self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line"></span><br><span class="line">  __weak typeof(self) weakSelf = self;</span><br><span class="line">  self.block = ^&#123;</span><br><span class="line">      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          NSLog(@&quot;%@&quot;, weakSelf);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  self.block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>点击屏幕，当前控制器消失，同时被销毁掉，5秒后打印的weakSelf就是一个(null)。<br>而我们如果在block内使用__strong后就能保证再打印完strongSelf之后再释放当前控制器。</p>
</blockquote>
<h5 id="4、判断该block是否会发生循环引用"><a href="#4、判断该block是否会发生循环引用" class="headerlink" title="4、判断该block是否会发生循环引用"></a>4、判断该block是否会发生循环引用</h5><p><a href="http://www.cocoachina.com/ios/20170122/18601.html" target="_blank" rel="noopener">判断该block是否会发生循环引用例子</a></p>
<h5 id="5、为什么masonry的block里引用self不需要weak？"><a href="#5、为什么masonry的block里引用self不需要weak？" class="headerlink" title="5、为什么masonry的block里引用self不需要weak？"></a>5、为什么masonry的block里引用self不需要weak？</h5><p>这个就和网络请求里面使用self道理是一样的。因为UIView未强持有block，所以这个block只是个栈block，而且构不成循环引用的条件。栈block有个特性就是它执行完毕之后就出栈，出栈了就会被释放掉。看mas_makexxx的方法实现会发现这个block很快就被调用了，完事儿就出栈销毁，构不成循环引用，所以可以直接放心的使用self。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    self.translatesAutoresizingMaskIntoConstraints = NO;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    return [constraintMaker install];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果要强引用，block应该是masnory的一个属性，即被masnory对象持有。且是copy修饰符</span><br></pre></td></tr></table></figure>
<h4 id="6、是否所有的Block中，使用self-都会导致循环引用？"><a href="#6、是否所有的Block中，使用self-都会导致循环引用？" class="headerlink" title="6、是否所有的Block中，使用self 都会导致循环引用？"></a>6、是否所有的Block中，使用self 都会导致循环引用？</h4><h4 id="7、block修改外部局部变量"><a href="#7、block修改外部局部变量" class="headerlink" title="7、block修改外部局部变量"></a>7、block修改外部局部变量</h4><p>如果是全局变量呢？</p>
<h6 id="1-、在block中无法直接修改外部变量的原因"><a href="#1-、在block中无法直接修改外部变量的原因" class="headerlink" title="(1)、在block中无法直接修改外部变量的原因"></a>(1)、在block中无法直接修改外部变量的原因</h6><p>错误示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//声明一个局部整型变量 </span><br><span class="line">int intValue = 3; //漏掉了__block修饰符</span><br><span class="line"></span><br><span class="line">//声明一个返回值为int,一个int参数的block变量</span><br><span class="line">int (^block)(int) = ^(int m)&#123;</span><br><span class="line">    intValue++;</span><br><span class="line">    return m * intValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//调用block变量,5作为参数之后的结果</span><br><span class="line">NSLog(@&quot;block(5) = %d&quot;,block(5));</span><br></pre></td></tr></table></figure>
<p>在上面的例子中,我们编译程序后发现编译器会有红色错误,错误提示为<br>Variable is not assignable (missing __block type specifier)</p>
<p>为什么会出现不能被赋值的错误提示呢？</p>
<p>block在实现时就会对它引用到的它所在方法中定义的栈变量进行一次只读拷贝，在 block 块内使用该只读拷贝。<br>那为了避免上述错误，就要<strong>精髓1：使用__block修饰符来修饰外部变量,用来通知编译器该外部变量intValue与block中的intValue指的是同一块儿内存地址，而不需要内存拷贝。</strong></p>
<h6 id="2-、解决如何在-block-中修改外部变量"><a href="#2-、解决如何在-block-中修改外部变量" class="headerlink" title="(2)、解决如何在 block 中修改外部变量"></a>(2)、解决如何在 block 中修改外部变量</h6><ul>
<li><p>有必要了解：<a href="http://www.jianshu.com/p/404ff9d3cd42" target="_blank" rel="noopener">iOS中__block 关键字的底层实现原理</a></p>
</li>
<li><p>结论：<code>block可以访问外部变量，但是无法修改外部变量的值，如果要修改外部变量的值，需要对外部变量加上__block作为该变量的修饰</code></p>
<p>来源：<a href="http://bbs.itheima.com/thread-248328-1-1.html" target="_blank" rel="noopener">OC学习笔记之block访问外部变量【重点面试】</a></p>
</li>
</ul>
<ul>
<li>问题： <a href="http://blog.csdn.net/huyisu/article/details/40543291" target="_blank" rel="noopener">如何在 block 中修改外部变量</a></li>
</ul>
<p>有两种办法<br>① 第一种是可以修改 static 全局变量；<br>② 第二种是可以修改用新关键字 __block 修饰的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__block int blockLocal  = 100;</span><br><span class="line">static int staticLocal  = 100;</span><br><span class="line"></span><br><span class="line">void (^aBlock)(void) = ^(void)&#123; </span><br><span class="line">    NSLog(@&quot; &gt;&gt; Sum: %d\n&quot;, global + staticLocal);</span><br><span class="line">    </span><br><span class="line">    global++;</span><br><span class="line">    blockLocal++;</span><br><span class="line">    staticLocal++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">aBlock();</span><br></pre></td></tr></table></figure>
<p><code>附：静态变量 和 全局变量   在加和不加  __block 都会直接引用变量地址。也就意味着静态变量和全局变量的修改可以直接修改，不需要作添加__block的步骤。</code></p>
<h4 id="在ARC下获取对象的引用计数值"><a href="#在ARC下获取对象的引用计数值" class="headerlink" title="在ARC下获取对象的引用计数值"></a>在ARC下获取对象的引用计数值</h4><p>在ARC下获取对象的引用计数值，可以使用CFGetRetainCount。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于Core Foundation对象：</span><br><span class="line">NSLog(@&quot;CFGetRetainCount is %ld&quot;,  CFGetRetainCount(aCFString));</span><br><span class="line"></span><br><span class="line">对于Foundation对象</span><br><span class="line">NSLog(@&quot;CFGetRetainCount is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)aNNstring));</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@ CFGetRetainCount is %ld&quot;, NSStringFromClass([self class]), CFGetRetainCount((__bridge CFTypeRef)self));</span><br></pre></td></tr></table></figure>
<p>以下获取引用计数的方法错了，但是不知道正确的应该怎么用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%@ dealloc&quot;, NSStringFromClass([self class]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@ viewWillDisappear and CFGetRetainCount is %ld&quot;, NSStringFromClass([self class]), CFGetRetainCount((__bridge CFTypeRef)self));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@ viewDidDisappear and CFGetRetainCount is %ld&quot;, NSStringFromClass([self class]), CFGetRetainCount((__bridge CFTypeRef)self));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几篇文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/bcc0bcaadd6c" target="_blank" rel="noopener">iOS杂谈：影响控制器正常释放的常见问题</a></li>
<li><a href="https://www.cnblogs.com/songliquan/p/4970505.html" target="_blank" rel="noopener">iOS中控制器的释放问题</a></li>
<li><a href="https://blog.csdn.net/u014222687/article/details/51767685" target="_blank" rel="noopener">Block与Self的循环引用</a></li>
<li><p><a href="http://www.cocoachina.com/ios/20170122/18601.html" target="_blank" rel="noopener">ARC下用块（block）的循环引用问题样例探究</a></p>
</li>
<li><p><a href="https://blog.csdn.net/y_csdnblog_xx/article/details/51483111" target="_blank" rel="noopener">ReactiveCocoa之RAC内存管理（十二）</a></p>
</li>
<li><a href="https://www.jianshu.com/p/16b78d72dc95" target="_blank" rel="noopener">ReactiveCocoa入门教程——第二部分</a></li>
<li><a href="https://www.jianshu.com/p/16e8e2e5773c" target="_blank" rel="noopener">subscribenext 循环引用</a></li>
</ul>
<p></p><p id="常见笔试/面试题"></p><p></p>
<h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p>
<h6 id="block和weak修饰符的区别是什么？"><a href="#block和weak修饰符的区别是什么？" class="headerlink" title="block和weak修饰符的区别是什么？"></a><strong>block和</strong>weak修饰符的区别是什么？</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，在MRC时代，__block修饰，可以避免循环引用；ARC时代，__block修饰，同样会引起循环引用问题；</span><br><span class="line">2，__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型；</span><br><span class="line">3，__weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；</span><br><span class="line">4，__block对象可以在block中被重新赋值，__weak不可以；</span><br></pre></td></tr></table></figure>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-②循环引用/" data-id="cm2nkn65u0173bur4vnqd4xhp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/2内存/2内存-②循环引用Timer" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/" class="article-date">
  <time datetime="2019-04-28T01:27:20.000Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/">内存-②循环引用Timer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="内存-②循环引用Timer"><a href="#内存-②循环引用Timer" class="headerlink" title="内存-②循环引用Timer"></a>内存-②循环引用Timer</h1><p>–</p>
<p></p><p id="目录"></p><p></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#NSTimer">九、NSTimer</a></li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、NSTimer和NSRunLoop的关系？</span><br><span class="line">2、NSTimer使用细节</span><br><span class="line">3、NSTimer的创建</span><br><span class="line">4、NSTimer的循环引用</span><br><span class="line">5、NSTimer使用的优化</span><br><span class="line">&gt;</span><br><span class="line">6、NSTimer的销毁问题</span><br><span class="line">(1)、子线程中NSTimer的创建和销毁问题</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p>
</li>
<li><p><a href="#END">END</a></p>
</li>
</ul>
<p></p><p id="NSTimer"></p><p></p>
<h2 id="九、NSTimer"><a href="#九、NSTimer" class="headerlink" title="九、NSTimer"></a>九、NSTimer</h2><blockquote>
<p>&lt; <a href="#目录">返回目录</a></p>
</blockquote>
<h3 id="1、NSTimer的创建"><a href="#1、NSTimer的创建" class="headerlink" title="1、NSTimer的创建"></a>1、NSTimer的创建</h3><p>NSTimer的创建通常有两种方式，尽管都是类方法，一种是timerWithXXX，另一种scheduedTimerWithXXX。</p>
<p>二者最大的区别就是后者除了创建一个定时器外会自动以NSDefaultRunLoopModeMode添加到当前线程RunLoop中，不添加到RunLoop中的NSTimer是无法正常工作的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController1 ()</span><br><span class="line">@property (nonatomic, weak) NSTimer *timer1;</span><br><span class="line">@property (nonatomic, weak) NSTimer *timer2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation ViewController1</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.timer1 = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timeInterval1:) userInfo:nil repeats:YES];</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    错误做法：</span><br><span class="line">    self.timer2 = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timeInterval2:) userInfo:nil repeats:YES];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:self.timer2 forMode:NSDefaultRunLoopMode];</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    //正确做法：</span><br><span class="line">    //特别注意：timer2创建时并没直接赋值给timer2。</span><br><span class="line">    //原因是timer2是weak属性，如果直接赋值给timer2会被立即释放。</span><br><span class="line">    //因为timerWithXXX方法创建的NSTimer默认并没有加入RunLoop，只有后面加入RunLoop以后才可以将引用指向timer2。从而导致执行到addTimer:forMode的时候，访问了野指针而发生EXC_BAD_ACCESS，崩溃。</span><br><span class="line">    NSTimer *tempTimer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timeInterval2:) userInfo:nil repeats:YES];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:tempTimer forMode:NSDefaultRunLoopMode];</span><br><span class="line">    self.timer2 = tempTimer;</span><br><span class="line">    。。。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)timeInterval1:(id)object &#123;</span><br><span class="line">    NSLog(@&quot;111&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timeInterval2:(id)object &#123;</span><br><span class="line">    NSLog(@&quot;222&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="2、NSTimer的修饰符"><a href="#2、NSTimer的修饰符" class="headerlink" title="2、NSTimer的修饰符"></a>2、NSTimer的修饰符</h3><p><strong>runloop强制持有timer(runloop-&gt;timer),timer会强制持有其target，未处理的情况下一般都是self(timer-&gt;self)，导致self无法释放。</strong><br>虽然设置timer为weak属性时候，self未强制持有timer,没构成循环应用，但还是导致了self无法释放的问题，dealloc无法执行。</p>
<h3 id="2、NSTimer的循环引用"><a href="#2、NSTimer的循环引用" class="headerlink" title="2、NSTimer的循环引用"></a>2、NSTimer的循环引用</h3><p>关于循环引用，我们先看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController1 ()</span><br><span class="line">@property (nonatomic, strong) NSTimer *timer;//注意这里的属性不是为weak,从而很容易引起循环引用</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation ViewController1</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    // 代码标记1 (产生timer与self之前的强引用，如下图中的L3强引用线)</span><br><span class="line">    NSTimer *timer = [[NSTimer alloc] initWithFireDate:[NSDate date] interval:1 target:self selector:@selector(timerFire) userInfo:nil repeats:YES];</span><br><span class="line">    // 代码标记2 (产生RunLoop与timer之间的强引用，如下图中的L4强引用线)</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">    // 代码标记3 (产生self与timer之间的强引用，，如下图中的L2强引用线)</span><br><span class="line">    self.timer = timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timerFire &#123;</span><br><span class="line">    NSLog(@&quot;timer fire&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>假设代码中的视图控制器由UINavigationController管理，由于self.timer是strong类型，则强引用可以表示如下：</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/2内存-②循环引用/NSTimer循环引用例子1.png" alt="NSTimer循环引用例子1"></p>
</blockquote>
<p>由于，很容易看出来，由于timer本身在创建时候已经与self发生了强引用（<strong>不管target使用<code>weak</code>还是<code>strong</code>修饰，timer都会对target强引用。</strong>）。而赋值时候又由于timer是被设为strong的，而导致self与timer之间也发生了强引用，最终这两个强引用，就形成了循环引用。</p>
<p>所以，</p>
<p>①、首先，我们先解决循环引用，为了解决timer的循环应用问题，我们上面的timer属性应该使用weak。设置成weak后，L2就消失了。</p>
<p>②、但是<strong>即使使用了弱引用，上面的代码中ViewController1在pop退出的时候也无法正常释放，原因是在创建NSTimer时指定了target为self，这样一来造成了timer对ViewController1有一个强引用</strong>。从而导致，timer没释放的时候，viewController也是不会被释放的。<strong>为了让timer能够释放，我们就需要调用NSTimer的invalidate方法</strong>（注意：无论是重复执行的定时器还是一次性的定时器只要调用invalidate方法则会变得无效，只是一次性的定时器执行完操作后会自动调用invalidate方法）。所以，假设在viewController pop回去前，我们通过一个按钮来让timer调用invalidate方法，那么viewController在pop回去时候，就能够被释放了。</p>
<p>问题是我们一般不会有这个按钮操作，那么这时候让timer调用invalidate方法的操作，应该写在哪里呢。这时候，你可能会想到那就写在viewDidDisappear中呗。但是一旦在viewWillDisappear中写<code>[timer invalidate]; timer = nil;</code>那么你也得把timer的创建放在viewWillAppear中。因为我们可能执行的是push跳到下一页,再返回来的操作。然而显然将timer的创建放在viewWillAppear中这样的方式，显然会是导致当timer可能需要频繁添加。所以，我们放弃此方法，还是把timer的创建放在viewDidLoad中，然后考虑其他方法。</p>
<p>所以，我们最后<strong>为了让ViewController1在pop退出的时候不会因为timer的强引用，而导致无法正常释放。我们选择转移timer中的target</strong>。这样就能确保，viewController在pop退出的时候能够正常释放，从而调用viewController的dealloc方法。</p>
<blockquote>
<p>附：转移timer中的target的方法通常有两种：</p>
</blockquote>
<p>一种是将target分离出来独立成一个对象（在这个对象中创建NSTimer并将对象本身作为NSTimer的target），控制器通过这个对象间接使用NSTimer；</p>
<blockquote>
</blockquote>
<p>另一种方式的思路仍然是转移target，只是可以直接增加NSTimer扩展（分类），让NSTimer自身做为target，同时可以将操作selector封装到block中。</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/2内存-②循环引用/NSTimer转移target方法二.jpg" alt="NSTimer转移target方法二"><br>图中参考<a href="https://github.com/mBrissman/NSTimer-Block" target="_blank" rel="noopener">NSTimer+Block</a></p>
</blockquote>
<p>后者相对优雅，也是目前使用较多的方案。显然Apple也认识到了这个问题，如果你可以确保代码只在iOS 10下运行就可以使用iOS 10新增的系统级block方案（上面的代码中已经贴出这种方法）。</p>
<p>③、如果不做②中的转移timer的target的话，那么viewController就会无法释放，造成内存泄露。<br>但是，我们发现<strong>通过转移timer的target后，虽然解决了UIViewController1因为被timer强引用而导致的在pop回来的时候无法释放的问题。</strong>我们的计时器，却在UIViewController1 pop退出被释放后，两个定时器仍然在运行，也就是它还没被释放。所以，我们还需要解决timer的释放。那怎么让timer释放呢？答：<strong>如果要让timer释放掉的话，需要调用NSTimer的invalidate方法</strong>（注意：无论是重复执行的定时器还是一次性的定时器只要调用invalidate方法则会变得无效，只是一次性的定时器执行完操作后会自动调用invalidate方法）。<br><strong>invalidate方法有2个功能：一是将timer从runloop中移除，那么图中的L4就消失，二是timer本身也会释放它持有资源，比如它的target、userinfo、block等，因为这里的target是self，所以强引用L3也就消失。</strong><br>所以，最终当viewController在pop退出的时候，其正常释放并调用了dealloc放。我们只需要在dealloc方法中，添加上timer调用invalidate的方法，即可以解决viewController被释放了，但timer没被释放的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    NSLog(@&quot;ViewController1 dealloc...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，一个完整的timer过程，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure>
<h3 id="3、NSTimer和NSRunLoop的关系？"><a href="#3、NSTimer和NSRunLoop的关系？" class="headerlink" title="3、NSTimer和NSRunLoop的关系？"></a>3、NSTimer和NSRunLoop的关系？</h3><p>只要出现NSTimer必须要有NSRunLoop，NSTimer必须依赖NSRunLoop才能执行 。NSTimer其实也是一种资源，如果看过多线程编程指引文档的话，我们会发现所有的source如果要起作用，就得加到runloop中去。同理timer这种资源要想起作用，那肯定也需要加到runloop中才会生效喽。如果一个runloop里面不包含任何资源的话，运行该runloop时会立马退出。</p>
<p>NSRunLoop与timer有关方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addTimer:(NSTimer *)timer forMode:(NSString *)mode; //在run loop上注册timer</span><br></pre></td></tr></table></figure>
<p>注意事项:</p>
<blockquote>
<p>我们通常在主线程中使用NSTimer，有个实际遇到的问题需要注意。当滑动界面时，系统为了更好地处理UI事件和滚动显示，主线程runloop会暂时停止处理一些其它事件，这时主线程中运行的NSTimer就会被暂停。解决办法就是改变NSTimer运行的mode（mode可以看成事件类型），不使用缺省的NSDefaultRunLoopMode，而是改用NSRunLoopCommonModes，这样主线程就会继续处理NSTimer事件了。具体代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timer:) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<h3 id="4、NSTimer使用细节："><a href="#4、NSTimer使用细节：" class="headerlink" title="4、NSTimer使用细节："></a>4、NSTimer使用细节：</h3><p>NSTimer上的定时任务是在创建NSTimer的线程上执行的。NSTimer的销毁和创建必须在同一个线程上操作<br>NSTimer要被添加到当前线程的 Runloop 里面且 Runloop 被启动，定时任务（selector或者invocation）才会触发。</p>
<p>以下内容摘自：<a href="https://www.cnblogs.com/mddblog/p/6517377.html" target="_blank" rel="noopener">NSTimer定时器进阶——详细介绍，循环引用分析与解决</a></p>
<ol>
<li>它需要被添加到runloop，否则不会运行，当然添加的runloop不存在也不会运行；</li>
<li>还要指定添加到的runloop的哪个模式，而且还可以指定添加到runloop的多个模式，模式不对也是不会运行的</li>
<li><strong>runloop会对timer有强引用，timer会对目标对象进行强引用(是否隐约的感觉到坑了。。。)</strong></li>
<li>timer的执行时间并不准确，系统繁忙的话，还会被跳过去。(具体的两种不准时，请查看原文)</li>
<li>invalidate调用后，timer停止运行后，就一定能从runloop中消除吗，资源？？？？invalidate方法的调用必须在timer添加到的runloop所在的线程，如果不在的话：由于调用invalidate 方法后，timer本身会释放掉它自己持有的资源比如target、userinfo、block，图中的L3会消失。但是runloop不会释放timer，即图中的L4不会消失，假设，self被pop了–&gt;L1无效–&gt;self引用计数为0,self释放–&gt;L2也消失。此时就剩runloop、timer、L4，timer也就永远不会释放了，造成内存泄露。</li>
</ol>
<p>NSTimer的强引用问题举例:</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/2内存-②循环引用/NSTimer的强引用问题举例.png" alt="NSTimer的强引用问题举例"></p>
</blockquote>
<h4 id="5、NSTimer使用的优化"><a href="#5、NSTimer使用的优化" class="headerlink" title="5、NSTimer使用的优化"></a>5、NSTimer使用的优化</h4><p>问：为什么要在非主线程创建NSTimer？</p>
<ul>
<li>将 timer 添加到主线程的Runloop里面本身会增加线程负荷；</li>
<li>如果主线程因为某些原因阻塞卡顿了，timer 定时任务触发的时间精度肯定也会受到影响；</li>
<li>有些定时任务不是UI相关的，本来就没必要在主线程执行，给主线程增加不必要的负担。当然也可以在定时任务执行时，手动将任务指派到非主线程上，但这也是有额外开销的。</li>
</ul>
<h4 id="6、NSTimer的销毁问题"><a href="#6、NSTimer的销毁问题" class="headerlink" title="6、NSTimer的销毁问题"></a>6、NSTimer的销毁问题</h4><p>前面我们已经简单讲过要让NSTimer销毁释放的时候，只能通过调用其invalidate来达到销毁目的。关于invalidate的第一个作用以及它在哪个线程调用的问题，我的理解如下：</p>
<p>invalidate方法的第一个作用将timer从runloop中移除。这里的runLoop指的应该是当前的runLoop，而不是timer被添加到的runLoop，这个纯属个人理解，未验证，因为如果是其添加的runLoop的话，那子线程timer的销毁，就不会有人说还要和timer所在的线程一致了。所以，这里的个人理解有如下：</p>
<p><em>为了销毁timer和去除runloop与timer之间的强引用</em>，我们调用了timer的invalidate方法。</p>
<blockquote>
<p>1、对于invalidate方法的调用是写在必须在timer所添加到的runloop所在的线程（如主线程）的时候，invalidate方法会将timer从runloop中移除，并且释放它持有资源。即上面的L4和L3都消失。</p>
<p>2、对于invalidate方法的调用不是写在必须在timer所添加到的runloop所在的线程的时候（如子线程中添加timer，在主线程中调用该timer的invalidate），虽然timer本身会释放掉它自己持有的资源比如target、userinfo、block，图中的L3会消失。但是runloop不会释放timer，即图中的L4不会消失，假设，self被pop了–&gt;L1无效–&gt;self引用计数为0,self释放–&gt;L2也消失。此时就剩runloop、timer、L4，timer也就永远不会释放了，造成内存泄露。</p>
<p>如果invalidate方法的调用的位置不更改的话，这时候要让L4消失的方法，</p>
<p>方法①手动销毁runloop。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    //[[NSRunLoop currentRunLoop] run]; //将原本的方法注释掉</span><br><span class="line">    NSDate *date = [NSDate dateWithTimeIntervalSinceNow:5.f];</span><br><span class="line">    [[NSRunLoop currentRunLoop] runUntilDate:date]; //让runloop在5s后销毁</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这种方式，只适用于销毁时间确定的情况。那如果销毁时间不确定怎么办？</p>
<p>方法②：因为<strong>当某个线程销毁时，其runloop也随之销毁</strong>，所以方法二即为通过销毁timer所在的线程，来达到销毁runloop的目的。如果是在主线程，线程一直存在，我们没法让主线程销毁。</p>
</blockquote>
<p>所以，下面我们讨论的是<em>在子线程中添加timer的时候，<strong>如果</strong>该timer的invalidate方法的调用位置不是写在对应子线程，而是写在主线程的时候，我们该怎么通过销毁子线程，来销毁runLoop。从而接触该runloop对timerd的强引用？</em></p>
<h5 id="6-1子线程中NSTimer的创建和销毁问题"><a href="#6-1子线程中NSTimer的创建和销毁问题" class="headerlink" title="6.1子线程中NSTimer的创建和销毁问题"></a>6.1子线程中NSTimer的创建和销毁问题</h5><p>我们按上诉2中②的讨论描述的：子线程中添加timer的时候，如果该timer的invalidate方法的调用位置不是写在对应子线程，而是写在主线程的时候，写出的对应代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) NSTimer *threadTimer; //子线程timer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    // 开辟子线程</span><br><span class="line">    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)newThread &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSThread *currentThread = [NSThread currentThread];</span><br><span class="line">        [currentThread setName:@&quot;这是子线程&quot;];</span><br><span class="line">        </span><br><span class="line">        self.threadTimer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(threadTimerAction) userInfo:nil repeats:YES];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)threadTimerAction &#123;</span><br><span class="line">    static NSInteger counter = 0;</span><br><span class="line">    </span><br><span class="line">    NSString *isMainThreadDescription = [NSThread isMainThread] ? @&quot;YES&quot; : @&quot;NO&quot;;</span><br><span class="line">    NSLog(@&quot;当前方法执行的线程：%@, 它是否是主线程:%@, counter = %@&quot;, [NSThread currentThread], isMainThreadDescription, @(counter++));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，我们该怎么通过销毁子线程，来销毁runLoop。从而接触该runloop对timerd的强引用？即怎么销毁线程？</p>
<p>乍看当在子线程开启runloop后，timer会一直在子线程中运行，所以子线程不会销毁，runloop也就无法停止，runloop也就没法销毁，runloop与timer之间的强引用则还是被保留着，这似乎又是个死循环。但实际上，<em>由于上述代码runloop的mode item只有Timer，所以只要销毁timer，runloop就会退出。</em>所以，上述的代码是没问题的，不存在内存泄露问题。</p>
<p>附：NSTimer上的定时任务是在创建NSTimer的线程上执行的。</p>
<p>–</p>
<p>附：以上NSTimer的内容，有空的话还可参考<a href="https://www.imooc.com/article/22331" target="_blank" rel="noopener">NSTimer,NSRunLoop,autoreleasepool,多线程的爱恨情仇</a>，它那边讲的，和这边自己理解的基本是一样的。只是对于有些点的介绍详细不一定一样而已。</p>
<p>其他有空可看<a href="http://www.cocoachina.com/ios/20150710/12444.html" target="_blank" rel="noopener">iOS 中的 NSTimer</a></p>
<p></p><p id="常见笔试/面试题"></p><p></p>
<h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-②循环引用Timer/" data-id="cm2nkn66d0176bur4wjh2wic3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/3视图/3视图-①本质" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/3视图/3视图-①本质/" class="article-date">
  <time datetime="2019-04-28T01:27:20.000Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/iOS/3必备知识架构/3视图/3视图-①本质/">视图-①本质</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="视图-①本质"><a href="#视图-①本质" class="headerlink" title="视图-①本质"></a>视图-①本质</h1><p>[toc]</p>
<p></p><p id="目录"></p><p></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><p><a href="#响应链及事件链">一、在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么</a></p>
</li>
<li><p><a href="#事件的响应链">二、事件的响应链</a></p>
</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">附：整个响应链及事件链</span><br><span class="line">1、完善响应链查找知识点</span><br><span class="line">2、基础概念等详解</span><br><span class="line">2.1 响应者对象(UIResponder)</span><br><span class="line">2.2、UITouch(点击对象)</span><br><span class="line">2.2.1、UITouch的几个主要属性和方法</span><br><span class="line">2.2.2、UITouch的生成场景</span><br><span class="line">2.3、UIEvent(事件对象)</span><br><span class="line">3、响应链的应用</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><a href="#CALayer和UIView">三、CALayer和UIView</a></li>
</ul>
<p></p><p id="响应链及事件链"></p><p></p>
<h2 id="一、在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么"><a href="#一、在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么" class="headerlink" title="一、在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么"></a>一、在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么</h2><p>这其实是一个事件传递和响应链的问题。（其实，按钮点击后，这里还包括runloop的唤醒等知识，不过这点我们放在下一大点讲）。</p>
<p>答：在我们点击按钮的时候，会产生了UITouch(点击对象)和UIEvent(事件对象)，这两个对象组合成一个点击事件。而发生触摸事件后，</p>
<p>①消息循环(runloop)/系统就会接收到这个触摸事件，并将它放到一个由UIApplication管理的消息队列(先进先出)里。</p>
<p>②UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理。首先UIApplication将事件传递给的是UIWindow对象(即一般为应用程序的主窗口keyWindow)。</p>
<p>③然后，UIWindow(继承自UIView)对象会继续向它的子View对象传递，直到传递到最上层。（或者说UIWindow使用hitTest:withEvent:方法查找touch操作的所在的视图view）</p>
<p>其中的应用程序逐级寻找能够响应这个事件的对象，直到没有响应者响应。这一寻找的过程，被称作<strong>事件的响应链</strong>。</p>
<h2 id="二、事件的响应链"><a href="#二、事件的响应链" class="headerlink" title="二、事件的响应链"></a>二、事件的响应链</h2><p>事件的响应链大概过程如下图所示：</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/3视图/3视图-①本质/事件的响应链.png" alt="事件的响应链"></p>
</blockquote>
<ul>
<li><p>1、在传递的过程中，下一响应者的查找是通过UIView里的<code>- pointInside: withEvent:</code> 和 <code>- hitTest: withEvent:</code>两个方法来确定的。当从最初的只有一个响应者通过这样的方式不断的找到下一响应者后，这些响应者就组成了一个响应者链。</p>
</li>
<li><p>2、当通过<code>- hitTest: withEvent:</code>找到第一响应者后，若第一响应者没有处理事件，则沿着响应者链向上追溯寻找响应者(即灰色箭头方向)执行touches方法。这个过程就是<strong>事件的传递过程</strong>。从这可以看出它的方向是跟响应链方向相反的。这里我们可以用UITableViewCell中点击上面的label来想象。</p>
</li>
</ul>
<h4 id="附：整个响应链及事件链"><a href="#附：整个响应链及事件链" class="headerlink" title="附：整个响应链及事件链"></a>附：整个响应链及事件链</h4><p>整个响应链(向下)及事件链(向上)，大概如图所示：</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/3视图/3视图-①本质/响应链(向下" alt="响应链(向下)及事件链(向上)">及事件链(向上).png)<br>在上图，当<code>- hitTest: withEvent:</code>方法沿着红色箭头方向寻找第一响应者后，若第一响应者没有处理事件，则沿着响应者链向上追溯寻找响应者(即灰色箭头方向)执行touches方法。<br>所以响应链为红色部分，事件链的顺序可以理解为图上的灰色箭头部分（个人理解）。</p>
</blockquote>
<h4 id="1、完善响应链查找知识点"><a href="#1、完善响应链查找知识点" class="headerlink" title="1、完善响应链查找知识点"></a>1、完善响应链查找知识点</h4><p>我们已经知道响应者链是由多个响应者组合起来的链条。那么怎么找到这些相应者呢？</p>
<p><strong>响应者的查找</strong>为通过UIView内部的下面两个方法来查找的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//根据点击坐标返回事件是否发生在本视图以内</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;   // default returns YES if point is in bounds</span><br><span class="line"></span><br><span class="line">// 返回响应点击事件的对象（当点击区域在分为内时候，如果有子视图则返回子视图里最终的响应者，如果没有子视图则返回自身）</span><br><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;   // recursively calls -pointInside:withEvent:. point is in the receiver&apos;s coordinate system</span><br></pre></td></tr></table></figure>
<p>对于一个视图</p>
<blockquote>
<p>①、若子视图中的<code>- pointInside: withEvent:</code>方法返回为NO，即判断用户点击的区域不在该子视图范围内的话，则停止对这个子视图里的子视图继续查找，<code>- hitTest: withEvent:</code>返回nil。</p>
<p>②、若子视图中的<code>- pointInside: withEvent:</code>方法返回为YES，即判断用户点击的区域在该子视图范围内的话，则继续往该子视图里的子视图查找，直到没有子视图，然后<code>- hitTest: withEvent:</code>返回这个子视图，而后之前的视图的<code>- hitTest: withEvent:</code>也返回这个子视图。</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>hitTest-withEvent-查找过程举例，如下图</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/3视图/3视图-①本质/hitTest-withEvent-查找过程举例.png" alt="hitTest-withEvent-查找过程举例" style="zoom:33%;"><br>图片中view等级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ViewA addSubview:ViewB];</span><br><span class="line">[ViewA addSubview:ViewC];</span><br><span class="line">[ViewB addSubview:ViewD];</span><br><span class="line">[ViewB addSubview:ViewE];</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>那么点击viewE后，发生的过程是怎样的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.A 是UIWindow的根视图，首先对A进行hitTest:withEvent:</span><br><span class="line">2.判断A的userInteractionEnabled，如果为NO，A的hitTest:withEvent返回nil;</span><br><span class="line">3.pointInside:withEvent:方法判断用户点击是否在A的范围内，显然返回YES</span><br><span class="line">4.遍历A的子视图B和C。由于从后向前遍历，因此先查看C，再查看B。</span><br><span class="line">&gt;</span><br><span class="line">4.1 查看C：</span><br><span class="line">调用C的hitTest:withEvent方法：pointInside:withEvent:方法判断用户点击是否在C的范围内，不在返回NO，C对应的hitTest:withEvent: 方法return nil；</span><br><span class="line">&gt;	</span><br><span class="line">4.2 再查看B</span><br><span class="line">调用B的hitTest:withEvent方法：pointInside:withEvent:判断用户点击是否在B的返回内，在返回YES。</span><br><span class="line">&gt;遍历B的子视图D和E，从后向前遍历，所以先查看E，再查看D。</span><br><span class="line">		4.2.1先查看E，调用E的hitTest:withEvent方法：pointInside:withEvent:方法 判断用户点击是否在E的范围内，在返回YES，E没有子视图，因此E对应的hitTest:withEvent方法返回E,再往前回溯，就是B的hitTest:withEvent方法返回E，因此A的hitTest:withEvent方法返回E。</span><br><span class="line">		4.2.2查看D，略</span><br><span class="line">&gt;</span><br><span class="line">至此，点击事件的第一响应者就找到了。</span><br></pre></td></tr></table></figure>
<h3 id="2、基础概念等详解"><a href="#2、基础概念等详解" class="headerlink" title="2、基础概念等详解"></a>2、基础概念等详解</h3><p>iOS中的事件可以分为3大类型：</p>
<ol>
<li>触摸事件</li>
<li>加速计事件</li>
<li>远程控制事件</li>
</ol>
<p>在iOS中不是任何对象都能处理事件，能接受并这些处理事件的对象只有直接或间接继承自UIResponder的对象，我们称之为“响应者对象”。</p>
<h4 id="2-1-响应者对象-UIResponder"><a href="#2-1-响应者对象-UIResponder" class="headerlink" title="2.1 响应者对象(UIResponder)"></a>2.1 响应者对象(UIResponder)</h4><p>①、为什么只有继承自UIResponder的类才能够接收并处理事件呢？因为处理这些事件的方法是卸载UIResponder中的啊。详细的UIResponder中提供的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">4个处理触摸事件的对象方法</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">和3个处理加速计事件</span><br><span class="line">- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;</span><br><span class="line">- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;</span><br><span class="line">- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">以及1个处理远程控制事件的方法</span><br><span class="line">- (void)remoteControlReceivedWithEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure>
<p>附：如何实现UIView的拖拽呢？即让UIView随着手指的移动而移动。</p>
<p>答： 重写touchsMoved:withEvent:方法</p>
<p>代码如下：</p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 想让控件随着手指移动而移动,监听手指移动</span><br><span class="line">    // 获取UITouch对象</span><br><span class="line">    UITouch *touch = [touches anyObject];</span><br><span class="line">    // 获取当前点的位置</span><br><span class="line">    CGPoint curP = [touch locationInView:self];</span><br><span class="line">    // 获取上一个点的位置</span><br><span class="line">    CGPoint preP = [touch previousLocationInView:self];</span><br><span class="line">    // 获取它们x轴的偏移量,每次都是相对上一次</span><br><span class="line">    CGFloat offsetX = curP.x - preP.x;</span><br><span class="line">    // 获取y轴的偏移量</span><br><span class="line">    CGFloat offsetY = curP.y - preP.y;</span><br><span class="line">    // 修改控件的形变或者frame,center,就可以控制控件的位置</span><br><span class="line">    // 形变也是相对上一次形变(平移)</span><br><span class="line">    // CGAffineTransformMakeTranslation:会把之前形变给清空,重新开始设置形变参数</span><br><span class="line">    // make:相对于最原始的位置形变</span><br><span class="line">    // CGAffineTransform t:相对这个t的形变的基础上再去形变</span><br><span class="line">    // 如果相对哪个形变再次形变,就传入它的形变</span><br><span class="line">    self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②、那么iOS中能接收并处理事件或者说继承自UIResponder的类有哪些呢？</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; iOS中能接收并处理事件或者说继承自UIResponder的类有：</span><br><span class="line">UIApplication、UIWindow、UIViewController和所有继承UIView的UIKit类都直接或间接的继承自UIResponder。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<p>从UIResponder内部提供的方法可以看出，触摸方法接收两个参数，一个UITouch对象的集合，还有一个UIEvent对象。这两个参数分别代表的是点击对象和事件对象。</p>
<h4 id="2-2、UITouch-点击对象"><a href="#2-2、UITouch-点击对象" class="headerlink" title="2.2、UITouch(点击对象)"></a>2.2、UITouch(点击对象)</h4><p>UITouch表示单个点击，其类文件中存在枚举类型UITouchPhase的属性，用来表示当前点击的状态。这些状态包括点击开始、移动、停止不动、结束和取消五个状态。每次点击发生的时候，点击对象都放在一个集合中传入UIResponder的回调方法中。</p>
<h6 id="2-2-1、UITouch的几个主要属性和方法："><a href="#2-2-1、UITouch的几个主要属性和方法：" class="headerlink" title="2.2.1、UITouch的几个主要属性和方法："></a>2.2.1、UITouch的几个主要属性和方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly) NSTimeInterval      timestamp;    // 记录了触摸事件产生或变化时的时间，单位是秒</span><br><span class="line">@property(nonatomic,readonly) UITouchPhase        phase;        // 当前触摸事件所处的状态</span><br><span class="line">@property(nonatomic,readonly) NSUInteger          tapCount;     // 短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击</span><br><span class="line">@property(nonatomic,readonly) UITouchType         type NS_AVAILABLE_IOS(9_0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,readonly,strong) UIWindow                        *window;      //触摸产生时所处的窗口</span><br><span class="line">@property(nullable,nonatomic,readonly,strong) UIView                          *view;        //触摸产生时所处的视图</span><br><span class="line">@property(nullable,nonatomic,readonly,copy)   NSArray &lt;UIGestureRecognizer *&gt; *gestureRecognizers NS_AVAILABLE_IOS(3_2);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  获取当前点击位置的坐标点</span><br><span class="line"> *</span><br><span class="line"> *  @param view 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回值表示触摸在view上的位置点(这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）)</span><br><span class="line"> */</span><br><span class="line">- (CGPoint)locationInView:(nullable UIView *)view;</span><br><span class="line"></span><br><span class="line">/// 获取前一个触摸点位置的坐标点</span><br><span class="line">- (CGPoint)previousLocationInView:(nullable UIView *)view;</span><br></pre></td></tr></table></figure>
<h6 id="2-2-2、UITouch的生成场景："><a href="#2-2-2、UITouch的生成场景：" class="headerlink" title="2.2.2、UITouch的生成场景："></a>2.2.2、UITouch的生成场景：</h6><blockquote>
<p>前言：每根手指触摸屏幕时都会创建一个与该手指相关的UITouch对象。一根手指对应一个UITouch对象。每个UITouch对象保存着跟手指相关的信息，比如触摸的位置、时间、阶段。<br>当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置。<br>当手指离开屏幕时，系统会销毁相应的UITouch对象</p>
<p>实际调用现象举例：</p>
<p>①、当用户用一根手指触摸屏幕时，view会调用1次touchesBegan:withEvent:方法。touches参数中装着1个UITouch对象。</p>
<p>②、如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象。</p>
<p>③、如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象</p>
</blockquote>
<h4 id="2-3、UIEvent-事件对象"><a href="#2-3、UIEvent-事件对象" class="headerlink" title="2.3、UIEvent(事件对象)"></a>2.3、UIEvent(事件对象)</h4><p>iOS使用UIEvent表示用户交互的事件对象，在UIEvent.h文件中，我们可以看到有一个UIEventType类型的属性，这个属性表示了当前的响应事件类型。分别有多点触控、摇一摇以及远程操作（在iOS之后新增了3DTouch事件类型）。在一个用户点击事件处理过程中，UIEvent对象是唯一的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly) UIEventType     type NS_AVAILABLE_IOS(3_0);</span><br><span class="line">@property(nonatomic,readonly) UIEventSubtype  subtype NS_AVAILABLE_IOS(3_0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, UIEventType) &#123;</span><br><span class="line">    UIEventTypeTouches,</span><br><span class="line">    UIEventTypeMotion,</span><br><span class="line">    UIEventTypeRemoteControl,</span><br><span class="line">    UIEventTypePresses NS_ENUM_AVAILABLE_IOS(9_0),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, UIEventSubtype) &#123;</span><br><span class="line">    // available in iPhone OS 3.0</span><br><span class="line">    UIEventSubtypeNone                              = 0,</span><br><span class="line">    </span><br><span class="line">    // for UIEventTypeMotion, available in iPhone OS 3.0</span><br><span class="line">    UIEventSubtypeMotionShake                       = 1,</span><br><span class="line">    </span><br><span class="line">    // for UIEventTypeRemoteControl, available in iOS 4.0</span><br><span class="line">    UIEventSubtypeRemoteControlPlay                 = 100,</span><br><span class="line">    UIEventSubtypeRemoteControlPause                = 101,</span><br><span class="line">    UIEventSubtypeRemoteControlStop                 = 102,</span><br><span class="line">    UIEventSubtypeRemoteControlTogglePlayPause      = 103,</span><br><span class="line">    UIEventSubtypeRemoteControlNextTrack            = 104,</span><br><span class="line">    UIEventSubtypeRemoteControlPreviousTrack        = 105,</span><br><span class="line">    UIEventSubtypeRemoteControlBeginSeekingBackward = 106,</span><br><span class="line">    UIEventSubtypeRemoteControlEndSeekingBackward   = 107,</span><br><span class="line">    UIEventSubtypeRemoteControlBeginSeekingForward  = 108,</span><br><span class="line">    UIEventSubtypeRemoteControlEndSeekingForward    = 109,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>介绍了以上响应者对象(UIResponder)及其相关的UITouch(点击对象)和UIEvent(事件对象)相关概念后，我们就知道了用户点击后，会产生了UITouch(点击对象)和UIEvent(事件对象)并打包发送，最后由响应者对象(UIResponder)来处理这些事件。</p>
<p>现在的问题是你知道它是怎么通过用户的点击位置找到处理该点击事件的响应者对象吗？</p>
<h4 id="3、响应链的应用"><a href="#3、响应链的应用" class="headerlink" title="3、响应链的应用"></a>3、响应链的应用</h4><p>既然已经知道了系统是怎么获取响应视图的流程了，那么我们可以通过重写查找事件处理者的方法来实现不规则形状点击。</p>
<p>最常见的不规则视图就是圆形视图，在demo中我设置view的宽高为200，那么重写方法事件如下:</p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    const CGFloat halfWidth = 100;</span><br><span class="line">    CGFloat xOffset = point.x - 100;</span><br><span class="line">    CGFloat yOffset = point.y - 100;</span><br><span class="line">    CGFloat radius = sqrt(xOffset * xOffset + yOffset * yOffset);</span><br><span class="line">    return radius &lt;= halfWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最终的效果图如下：<br><img src="/iOS/3必备知识架构/3视图/3视图-①本质/响应链的应用1_点击不规则图形.gif" alt="响应链的应用1_点击不规则图形"></p>
</blockquote>
<p>前面说过按钮点击后，这里还包括一些runloop相关的知识，如唤醒等，所以下面我们就专门开讲一件Runloop。</p>
<p></p><p id="CALayer和UIView"></p><p></p>
<h2 id="三、CALayer和UIView"><a href="#三、CALayer和UIView" class="headerlink" title="三、CALayer和UIView"></a>三、CALayer和UIView</h2><p><strong>UIView与CALayer</strong>是什么关系。</p>
<blockquote>
<p>&lt;单一职责原则&gt;<br>UIView为CALayer提供内容，以及负责处理触摸等事件，参与响应链<br>CALayer负责显示内容contents</p>
</blockquote>
<p><code>UIView</code>是<code>CALayer</code>的<code>delegate</code>(<code>CALayerDelegate</code>)</p>
<p><code>UIView</code>继承自<code>UIResponder</code>类，可以响应事件</p>
<p><code>CALayer</code>直接继承自<code>NSObject</code>类，不可以响应事件</p>
<p><code>UIView</code>主要处理事件，<code>CALayer</code>负责绘制</p>
<p>每个<code>UIView</code>内部都有一个<code>CALayer</code>在背后提供内容的绘制和显示，并且<code>UIView</code>的尺寸样式都由内部的<code>Layer</code>所提供。两者都有树状层级结构，<code>Layer</code>内部有<code>SubLayers</code>，<code>View</code>内部有<code>SubViews</code>，但是<code>Layer</code>比<code>View</code>多了个<code>AnchorPoint</code></p>
<p>CALayer的结构图如下：</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/3视图/3视图-①本质/CALayer的结构图.jpg" alt="CALayer的结构图"></p>
</blockquote>
<blockquote>
<p>在 iOS 系统中所有显示的视图都是从基类UIView继承而来的，同时UIView负责接收用户交互。 但是<em>实际上你所看到的视图内容，包括图形等，都是由UIView的一个实例图层属性来绘制和渲染的，那就是CALaye</em>r。</p>
<p>CALayer类的概念与UIView非常类似，它也具有树形的层级关系，并且可以包含图片文本、背景色等。它与UIView最大的不同在于它不能响应用户交互，可以说它根本就不知道响应链的存在。</p>
<p>在每一个UIView实例当中，都有一个默认的支持图层，UIView负责创建并且管理这个图层。实际上这个CALayer图层才是真正用来在屏幕上显示的，UIView仅仅是对它的一层封装，实现了CALayer的delegate，提供了处理事件交互的具体功能，还有动画底层方法的高级 API。</p>
<p>以上摘要来自:<a href="https://blog.csdn.net/jijiji000111/article/details/50480405" target="_blank" rel="noopener">内存恶鬼drawRect - 谈画图功能的内存优化</a>中的CALayer和UIView介绍部分。</p>
</blockquote>
<p>CALayer有三个视觉元素：背景色、内容和边框，其中，内容的本质是一个CGImage</p>
<p><a href="https://www.cnblogs.com/jiayongqiang/p/5339678.html" target="_blank" rel="noopener">CALayer和UIView</a></p>
<blockquote>
<p>简述CALayer和UIView的关系</p>
</blockquote>
<p>答:<strong>UIView和CALayer是相互依赖的关系。UIView依赖与calayer提供的内容，CALayer依赖uivew提供的容器来显示绘制的内容。归根到底CALayer是这一切的基础，如果没有CALayer，UIView自身也不会存在，UIView是一个特殊的CALayer实现，添加了响应事件的能力</strong>。</p>
<blockquote>
</blockquote>
<p>结论：<br>UIView来自CALayer，高于CALayer，是CALayer高层实现与封装。UIView的所有特性来源于CALayer支持。</p>
<p></p><p id="常见笔试/面试题"></p><p></p>
<h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p>
<p><em>问：UIButton从子类到父类依次继承自什么？</em></p>
<blockquote>
<p>答:UIControl-&gt; UIView-&gt; UIResponder。</p>
</blockquote>
<h4 id="哪些视图的设置能禁止其相应事件"><a href="#哪些视图的设置能禁止其相应事件" class="headerlink" title="哪些视图的设置能禁止其相应事件"></a>哪些视图的设置能禁止其相应事件</h4><p>1、userInterface = NO;<br>2、hidden = YES;<br>3、当UIBUTTON透明度为0就不响应事件了，当UIBUTTON透明度为0就不响应事件了。</p>
<p>更多参考：<a href="https://blog.csdn.net/mingming24/article/details/45177377" target="_blank" rel="noopener">iOS开发经验：button不能响应的原因</a></p>
<h5 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h5><p>在使用圆角、阴影和遮罩等视图功能的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，所有就需要在屏幕外的上下文中渲染，即离屏渲染。</p>
<p>更多参考:<a href="https://www.cnblogs.com/fishbay/p/7576176.html" target="_blank" rel="noopener">iOS离屏渲染之优化分析</a>该文非常重要。</p>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/3视图/3视图-①本质/" data-id="cm2nkn6d8017ybur4h6sc35dc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/3视图/3视图-②布局" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/3视图/3视图-②布局/" class="article-date">
  <time datetime="2019-04-28T01:27:20.000Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/iOS/3必备知识架构/3视图/3视图-②布局/">视图-②布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="视图-②布局"><a href="#视图-②布局" class="headerlink" title="视图-②布局"></a>视图-②布局</h1><p>[toc]</p>
<h2 id="一、Intrinsic-Content-Size-Content-Hugging-Priority和Content-Compression-Resistance-Priority"><a href="#一、Intrinsic-Content-Size-Content-Hugging-Priority和Content-Compression-Resistance-Priority" class="headerlink" title="一、Intrinsic Content Size,Content Hugging Priority和Content Compression Resistance Priority"></a>一、Intrinsic Content Size,Content Hugging Priority和Content Compression Resistance Priority</h2><p>看一下下面的例子，看给出的例子约束是否完整？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UILabel *label = [[UILabel alloc] init];</span><br><span class="line"> label.font = [UIFont systemFontOfSize:15];</span><br><span class="line"> label.text = @&quot;Hello&quot;;</span><br><span class="line"> [self.view addSubview:label];</span><br><span class="line"> [label mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">     make.left.equalTo(self.view.mas_left).offset(16);</span><br><span class="line">     make.top.equalTo(self.view.mas_top).offset(16);</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<p>这里只定义了两个约束，left 和 top，只够计算出frame的originX和orginY，没有width和height。那么是不是属于不完整的约束呢？其实在这里给出的约束已经是完整的了。因为对于UILabel这个控件而言 ，只要通过其font和text系统就可以计算出Label该有的长度和宽度。这里的长度和宽度就是UILabel的intrinsic content size（固有属性）。</p>
<p>Intrinsic Content Size, 通俗来讲，就是控件(UIButton,UILabel,UIImageView)能根据它们的内容(content)计算自己的大小(Size）</p>
<p>开发中用到的一些控件或视图，本身就自带大小，比如UIButton控件，设置完title后就能知道这个UIButton是文字的大小再加上两个固定的button margin。<br> 像这种控件或视图本身就带有的高度、宽度，就叫做intrinsic content size（固定内容尺寸）。</p>
<h3 id="2、浅谈-iOS-AutoLayout-中-Label-的抗拉伸和抗压缩"><a href="#2、浅谈-iOS-AutoLayout-中-Label-的抗拉伸和抗压缩" class="headerlink" title="2、浅谈 iOS AutoLayout 中 Label 的抗拉伸和抗压缩"></a>2、浅谈 iOS AutoLayout 中 Label 的抗拉伸和抗压缩</h3><ul>
<li><a href="https://www.jianshu.com/p/8e68b82b471a" target="_blank" rel="noopener">浅谈 iOS AutoLayout 中 Label 的抗拉伸和抗压缩</a></li>
</ul>
<blockquote>
<p>在 Autolayout 优先级的范围是 1 ~ 1000，创建一个约束，默认的优先级是最高的 1000。</p>
<p>Content Hugging Priority:<br>该优先级表示一个控件抗被拉伸的优先级。优先级越高，越不容易被拉伸(即越容易保持原状)，默认是251。</p>
<p>Content Compression Resistance Priority:<br>该优先级表示一个控件抗压缩的优先级。优先级越高，越不容易被压缩(即越容易保持原状)，默认是750。</p>
</blockquote>
<p>使用场景：</p>
<p>当一个视图上有多个 <code>intrinsic content size</code> 的子控件，并且子控件可能会超出父视图的区域时，此属性可控制哪些视图被内容被优先压缩，使其不超出父视图区域。</p>
<p>场景举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[yellowLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">  make.center.equalTo(self.view);</span><br><span class="line">  make.left.equalTo(self.view).offset(100);</span><br><span class="line">  make.right.equalTo(self.view).offset(-100);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>当yellowLable的宽度最多为screenWidth-200。</p>
<p>则我们想让lable对左右两边的约束性没那么高，可以设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[yellowLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">  make.center.equalTo(self.view);</span><br><span class="line">  make.left.equalTo(self.view).offset(100).priority(250);</span><br><span class="line">  make.right.equalTo(self.view).offset(-100).priority(250);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>给出一个比较常见的需求：</p>
<p>在同一行中显示标题和时间，时间必须显示完全，标题如果太长就截取可显示的部分，剩余的用…表示。</p>
<p><img src="/iOS/3必备知识架构/3视图/3视图-②布局/intrinsic content size.png" alt="intrinsic content size"></p>
<p>目标：我们想让绿色的时间显示全，则应该要压缩前面的titleLabel。也就是要降低titleLabel的抗压缩。</p>
<p>即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (b) &#123;</span><br><span class="line">        [timeLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line">        // 或</span><br><span class="line">        //[titleLabel setContentHuggingPriority:UILayoutPriorityFittingSizeLevel forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>UILayoutPriorityRequired：1000</p>
<p>UILayoutPriorityDefaultHigh：750</p>
<p>UILayoutPriorityDefaultLow：250</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//在同一行中显示标题和时间，时间必须显示完全，标题如果太长就截取可显示的部分，剩余的用…表示。</span><br><span class="line">- (UIView *)contentViewWith:(BOOL)b &#123;</span><br><span class="line">    UIView *contentView = [[UIView alloc] init];</span><br><span class="line">    contentView.backgroundColor = [UIColor lightGrayColor];</span><br><span class="line">    </span><br><span class="line">    UILabel *titleLabel = [[UILabel alloc] init];</span><br><span class="line">    titleLabel.backgroundColor = [UIColor redColor];</span><br><span class="line">    titleLabel.text = @&quot;Each of these constraints can have its own priority. By default, &quot;;</span><br><span class="line">    titleLabel.font = [UIFont systemFontOfSize:17];</span><br><span class="line">    [contentView addSubview:titleLabel];</span><br><span class="line">    [titleLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.top.equalTo(contentView.mas_top);</span><br><span class="line">        make.left.equalTo(contentView.mas_left).offset(16);</span><br><span class="line">    &#125;];</span><br><span class="line">        </span><br><span class="line">    UILabel *timeLabel = [[UILabel alloc] init];</span><br><span class="line">    timeLabel.backgroundColor = [UIColor greenColor];</span><br><span class="line">    timeLabel.text = @&quot;2017/03/12 18:20:22&quot;;</span><br><span class="line">    timeLabel.font = [UIFont systemFontOfSize:17];</span><br><span class="line">    [contentView addSubview:timeLabel];</span><br><span class="line">    [timeLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.top.equalTo(titleLabel.mas_top);</span><br><span class="line">        make.left.equalTo(titleLabel.mas_right).offset(8);</span><br><span class="line">        make.right.lessThanOrEqualTo(contentView.mas_right).offset(-8);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    if (b) &#123;</span><br><span class="line">        [timeLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line">        // 或</span><br><span class="line">        //[titleLabel setContentHuggingPriority:UILayoutPriorityFittingSizeLevel forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return contentView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、iOS使用topLayoutGuide和bottomLayoutGuide"><a href="#二、iOS使用topLayoutGuide和bottomLayoutGuide" class="headerlink" title="二、iOS使用topLayoutGuide和bottomLayoutGuide"></a>二、iOS使用topLayoutGuide和bottomLayoutGuide</h2><p>参考文章：<a href="https://www.jianshu.com/p/0086d11d45b7" target="_blank" rel="noopener">iOS使用topLayoutGuide和bottomLayoutGuide</a></p>
<p>在iOS中，可以使用topLayoutGuide和bottomLayoutGuide来适配屏幕内容，它们是属于UIViewController的属性，配合masonry和SnapKit等约束工具，效果更好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UIView *bottomPayView = [[UIView alloc] init];</span><br><span class="line">bottomPayView.backgroundColor = [UIColor grayColor];</span><br><span class="line">[self.view addSubview:bottomPayView];</span><br><span class="line">[bottomPayView mas_makeConstraints:^(MASConstraintMaker *x) &#123;</span><br><span class="line">        x.height.equalTo(@45);</span><br><span class="line">        x.left.right.equalTo(self.view);</span><br><span class="line">        x.bottom.equalTo(self.mas_bottomLayoutGuide);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="三、UITableView自动计算cell高度并缓存，再也不用管高度啦"><a href="#三、UITableView自动计算cell高度并缓存，再也不用管高度啦" class="headerlink" title="三、UITableView自动计算cell高度并缓存，再也不用管高度啦"></a>三、UITableView自动计算cell高度并缓存，再也不用管高度啦</h2><p><a href="https://www.jianshu.com/p/64f0e1557562" target="_blank" rel="noopener">UITableView自动计算cell高度并缓存，再也不用管高度啦</a></p>
<p>用xib加约束和用masonry加代码约束都是可以的。注意约束一定要自上而下加好，让系统知道怎么去计算高度。</p>
<p>加好约束后，然后告诉tableView自己去适应高度就可以了。有两种写法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.rowHeight = <span class="built_in">UITableViewAutomaticDimension</span>;</span><br><span class="line"><span class="keyword">self</span>.tableView.estimatedRowHeight = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>或者直接写这个代理方法就可以了</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView estimatedHeightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个的意思就是告诉tableView，你需要自己适应高度，我不给你算啦哈哈哈。但是我们需要告诉它一个大概高度，例如上面的100，理论上这个是可以随便写的，并不影响显示结果，但是越接近真实高度越好。</p>
<h3 id="可能遇到的问题和解决办法"><a href="#可能遇到的问题和解决办法" class="headerlink" title="可能遇到的问题和解决办法"></a>可能遇到的问题和解决办法</h3><p><strong>1.高度不对</strong><br>有时候有可能运行出来后看到cell的高度显示的不对。这个问题是因为约束没有满足自上而下，从而系统不知道怎么去计算。解决办法就是去修改约束，直到满足为止。一定要好好理解约束啊！</p>
<p><strong>2.点击状态栏无法滚动到顶部</strong><br>我们知道，如果界面中有UIScrollView的话，点击状态栏会让其滚动到顶部，就像这样：</p>
<p>但是如果我们用了自动计算高度的方法，又调用了tableView的reloadData方法（例如我们的数据有分页的时候，加载完下一页的数据后会去刷新tableView）。这时候就会出现问题，点击状态栏就有几率不能精确滚动到顶部了：</p>
<p>解决这个问题的办法是去缓存cell的高度，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *heightAtIndexPath;<span class="comment">//缓存高度所用字典</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - UITableViewDelegate</span></span><br><span class="line">-(<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView estimatedHeightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *height = [<span class="keyword">self</span>.heightAtIndexPath objectForKey:indexPath];</span><br><span class="line">    <span class="keyword">if</span>(height)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height.floatValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *height = @(cell.frame.size.height);</span><br><span class="line">    [<span class="keyword">self</span>.heightAtIndexPath setObject:height forKey:indexPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h2><h4 id="问题1：使用Masonry的时候进行updateConstraints没有效果"><a href="#问题1：使用Masonry的时候进行updateConstraints没有效果" class="headerlink" title="问题1：使用Masonry的时候进行updateConstraints没有效果"></a>问题1：使用Masonry的时候进行updateConstraints没有效果</h4><p>原因：使用updateConstraints更新的时候必须是makeConstraints里面设置过的约束。但如果只是这样还不行，还需要约束对象匹配才能成功。</p>
<p>问题详见：<a href="https://blog.csdn.net/wq5201314o/article/details/52184622" target="_blank" rel="noopener">使用Masonry的时候进行updateConstraints没有效果</a></p>
<h1 id="iOS11适配-Safe-Area"><a href="#iOS11适配-Safe-Area" class="headerlink" title="iOS11适配-Safe Area"></a>iOS11适配-Safe Area</h1><p><a href="https://blog.csdn.net/gaoqinghuadage/article/details/79961750" target="_blank" rel="noopener">iOS11适配-Safe Area</a></p>
<blockquote>
<p>在iOS 11，UIViewController中的UIView的topLayoutGuide和bottomLayoutGuide被替换成了新的安全区属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; @available(iOS 11.0, *)</span><br><span class="line">&gt; open var safeAreaInsets: UIEdgeInsets &#123; get &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; @available(iOS 11.0, *)</span><br><span class="line">&gt; open var safeAreaLayoutGuide: UILayoutGuide &#123; get &#125;12345</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>safeAreaInsets属性意味着屏幕可以被任何方向遮挡，并不只是上下，当iPhone X出现时，我们就明白了为什么我们需要对左右两边也进行缩进。</p>
</blockquote>
<p>Masonry动画</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/3视图/3视图-②布局/" data-id="cm2nkn6ds0180bur4dgc9wgew" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/3视图/3视图-①本质RunLoop" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/3视图/3视图-①本质RunLoop/" class="article-date">
  <time datetime="2019-04-28T01:27:20.000Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/iOS/3必备知识架构/3视图/3视图-①本质RunLoop/">视图-①Runloop</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="视图-①Runloop"><a href="#视图-①Runloop" class="headerlink" title="视图-①Runloop"></a>视图-①Runloop</h1><p>[toc]</p>
<p></p><p id="RunLoop"></p><p></p>
<h2 id="一、RunLoop的理解"><a href="#一、RunLoop的理解" class="headerlink" title="一、RunLoop的理解"></a>一、RunLoop的理解</h2><p>让线程永不休眠。</p>
<p>背景：负责持续性的处理各种任务（比如Source，Timer，Observer），让<strong>线程</strong>能一直运行，且在没有任务的时候能够进入休眠，减少 CPU 的使用率，从而节省电量和资源。</p>
<p>1、正常一个线程一次只能执行一个任务，执行完成后线程就退出了。为了让线程能随时处理事件但并不退出，使用do－while循环实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	initialize();  </span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">  	<span class="keyword">var</span> message = get_next_message();</span><br><span class="line">    process_message(message);  </span><br><span class="line"> 	&#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、do-while的检查是一直主动检查？线程使用RunLoop时，不需要一直主动检查输入源是否有事件到来。而是靠<strong>事件驱动</strong>。即</p>
<blockquote>
<p>事件驱动（Event-Driven）</p>
<p>在事件驱动的编程模型中，应用程序的执行流程是由事件（如用户操作、消息、定时器超时等）来驱动的。应用程序不需要不断地检查某个条件，而是注册事件处理函数，并让操作系统在相应的事件发生时通知应用程序。这样，应用程序就可以在没有事件发生时执行其他任务或者进入休眠状态，从而节省资源。</p>
</blockquote>
<p>3、do-while性能消耗？</p>
<p>当 RunLoop 检测到没有待处理的事件时，它会<strong>将线程置于”休眠等待”状态</strong>，而不是忙等。这时，线程不会消耗 CPU 资源。当事件到来时，如用户输入、定时器超时或 I/O 完成等，RunLoop 会被唤醒，处理相应的事件，然后再次进入休眠状态。</p>
<p>Runloop是绑定到线程上的（每个线程可以有一个对应的 RunLoop 对象。这些 RunLoop 对象被保存在一个全局的 Dictionary 中，其中线程作为 Key，RunLoop 作为 Value。）。每个线程可以有自己的 RunLoop，这样每个线程可以独立地处理与自己任务相关的事件，提高了事件处理的效率和局部性。</p>
<p>每个Runloop有多种Model。不同的 Mode 可以包含不同的事件源（Sources）和定时器（Timers）。通过切换 Mode，RunLoop 可以过滤掉一些不想要的事件，只处理当前 Mode 下相关的事件。这样可以避免在处理特定任务时被不相关的事件打扰，提高程序的响应性和效率。例如当用户滚动列表时，iOS 应用程序的 RunLoop 通常会切换到 <code>UITrackingRunLoopMode</code> 模式。这个模式会降低非滚动相关的事件（如未将定时器添加到 <code>NSRunLoopCommonModes</code> 模式则timer会暂停）处理优先级，从而确保滚动操作的流畅性 。</p>
<p>主线程是如何切换runloop？</p>
<p>当系统检测到有scrollerview滑动时，系统就会将当前进程的主线程切换到UITrackingRunLoopMode,直到滑动结束，又会切换到NSDefaultRunLoopMode。</p>
<p>模拟主线程runloop的mode切换。在touchbegan的时候切换到UITrackingRunLoopMode，touchend的时候又切换回NSDefaultRunLoopMode。<strong>从模拟中可以看出如果所切到的mode是timer未添加的，则timer会暂停。</strong>这也就是为什么NSTimer需要设置在NSRunLoopCommonModes模式下运行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">     <span class="keyword">self</span>.rl = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//timer1 运行在 default mode</span></span><br><span class="line">      <span class="built_in">NSTimer</span> *timer1 = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.</span>f repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"timer1 fired"</span>);</span><br><span class="line">      &#125;];</span><br><span class="line">      [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer1 forMode:<span class="built_in">NSDefaultRunLoopMode</span>];	<span class="comment">// NSDefaultRunLoopMode</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//timer2 运行在 track Mode</span></span><br><span class="line">      <span class="built_in">NSTimer</span> *timer2 = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.</span>f repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"timer2 fired"</span>);</span><br><span class="line">      &#125;];</span><br><span class="line">      [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer2 forMode:<span class="built_in">UITrackingRunLoopMode</span>];	<span class="comment">// UITrackingRunLoopMode</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//指定当前运行mode</span></span><br><span class="line">      <span class="keyword">self</span>.currentMode = <span class="built_in">NSDefaultRunLoopMode</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">          [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="keyword">self</span>.currentMode beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"touch began"</span>)</span><br><span class="line">      <span class="comment">//touchbegan 切换成track mode</span></span><br><span class="line">      <span class="keyword">self</span>.currentMode = <span class="built_in">UITrackingRunLoopMode</span>;</span><br><span class="line">      <span class="built_in">CFRunLoopStop</span>(<span class="keyword">self</span>.rl);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> - (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"touch end"</span>);</span><br><span class="line">    <span class="comment">//touchend 切换成kCFRunLoopDefaultMode</span></span><br><span class="line">    <span class="keyword">self</span>.currentMode = kCFRunLoopDefaultMode;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="keyword">self</span>.rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runloop与卡顿的关系</p>
<blockquote>
<p>在iOS开发中，卡顿通常是由于主线程被长时间占用导致的。<code>CFRunLoop</code>的状态变化可以反映主线程的运行情况，因此通过监听<code>CFRunLoop</code>的状态，我们可以检测到应用的卡顿现象。</p>
<p>正常情况下，<code>CFRunLoop</code>会经历以下几个状态：</p>
<ol>
<li><p><code>kCFRunLoopEntry</code>：即将进入<code>RunLoop</code>。</p>
</li>
<li><p><code>kCFRunLoopBeforeTimers</code>：即将处理定时器。</p>
</li>
<li><p><strong><code>kCFRunLoopBeforeSources</code>：即将处理输入源。</strong></p>
</li>
<li><p><code>kCFRunLoopBeforeWaiting</code>：即将进入休眠。</p>
</li>
<li><p><strong><code>kCFRunLoopAfterWaiting</code>：刚从休眠中唤醒。</strong></p>
</li>
<li><p><code>kCFRunLoopExit</code>：即将退出<code>RunLoop</code>。</p>
</li>
</ol>
<p>为什么通常选择<code>kCFRunLoopBeforeSources</code>和<code>kCFRunLoopAfterWaiting</code>这两个状态来作为卡顿的判断依据，而不使用<code>kCFRunLoopBeforeWaiting</code>和<code>kCFRunLoopBeforeTimers</code>呢？</p>
<p>因为①卡顿通常发生在事件处理阶段，而<code>kCFRunLoopBeforeWaiting</code>状态标志着<code>RunLoop</code>即将进入休眠，而不是正在处理事件。<strong>当应用处于静止状态，即用户没有进行任何操作时，<code>RunLoop</code>通常处于<code>kCFRunLoopBeforeWaiting</code>状态，等待新的事件到来。在这种状态下，线程会进入休眠模式，以节省CPU资源。</strong></p>
<p>②至于<code>kCFRunLoopBeforeTimers</code>状态，虽然它也是<code>RunLoop</code>状态之一，但它主要表示<code>RunLoop</code>即将处理定时器事件。如果定时器回调执行时间过长，确实可能导致卡顿，但是在实际应用中，定时器回调通常执行时间较短，且定时器回调的执行时间可以通过调整定时器的触发频率来控制，因此<code>kCFRunLoopBeforeTimers</code>状态不是卡顿判断的主要依据。</p>
<p>在没有卡顿的情况下，<code>CFRunLoop</code>在<code>kCFRunLoopBeforeSources</code>和<code>kCFRunLoopAfterWaiting</code>这两个状态的停留时间通常是非常短的。<code>kCFRunLoopBeforeSources</code>状态表示<code>RunLoop</code>即将处理输入源，而<code>kCFRunLoopAfterWaiting</code>状态表示<code>RunLoop</code>从休眠中被唤醒。如果主线程在这两个状态之间花费的时间过长，说明线程可能被阻塞，导致应用无法响应用户操作，从而出现卡顿。</p>
<p>这两个状态是<code>RunLoop</code>循环中的关键点，它们分别代表了事件处理前后的状态。如果主线程在这两个状态之间花费的时间过长，说明线程可能被阻塞，导致应用无法响应用户操作，从而出现卡顿。因此，通过监控这两个状态，我们可以有效地检测和优化应用的性能，提高用户体验。</p>
</blockquote>
<p>runloop与崩溃的关系</p>
<p>在 iOS 开发中，由于 RunLoop 导致的崩溃通常不是直接由 RunLoop 本身引起的，而是由于 RunLoop 中的事件处理代码存在问题。</p>
<p>《起死回生/回光返照》见《<a href="../../../Architecture架构/监控相关/性能监控/异常与崩溃.md">异常与崩溃.md</a>》</p>
<p>runtime</p>
<p>运行时（Runtime）是 Objective-C 语言的核心特性之一，它提供了一组丰富的 API，允许程序在运行时查询和修改程序的行为。这种动态性使得 Objective-C 语言具有很高的灵活性。</p>
<h3 id="1、RunLoop概念"><a href="#1、RunLoop概念" class="headerlink" title="1、RunLoop概念"></a>1、RunLoop概念</h3><p>Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。一个run loop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。其内部就是do－while循环，这个循环内部不断地处理各种任务（比如Source，Timer，Observer）。使用run loop的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。</p>
<h3 id="2、RunLoop和线程的关系？"><a href="#2、RunLoop和线程的关系？" class="headerlink" title="2、RunLoop和线程的关系？"></a>2、RunLoop和线程的关系？</h3><p>run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程相关的基础框架的一部分，Cocoa和CoreFundation都提供了run loop对象方便配置和管理线程的run loop（以下都已Cocoa为例）。</p>
<p>每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。</p>
<p>①、主线程的run loop默认是启动的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了本文开始说的为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>
</blockquote>
<p>②、对其它线程来说，run loop默认是没有启动的。</p>
<p>③、在任何一个Cocoa程序的线程中，都可以通过：<code>NSRunLoop *runloop = [NSRunLoop currentRunLoop];</code>来获取到当前线程的run loop。</p>
<h3 id="3、RunLoop相关各类关系"><a href="#3、RunLoop相关各类关系" class="headerlink" title="3、RunLoop相关各类关系"></a>3、RunLoop相关各类关系</h3><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef</span><br><span class="line">CFRunLoopModeRef</span><br><span class="line">CFRunLoopSourceRef</span><br><span class="line">CFRunLoopTimerRef</span><br><span class="line">CFRunLoopObserverRef</span><br></pre></td></tr></table></figure>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系/RunLoop相关各类关系，如下图所示：</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/3视图/3视图-①本质RunLoop/3视图-①本质/RunLoop相关各类关系.png" alt="RunLoop相关各类关系"><br>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p>RunLoop的内部逻辑<br><img src="/iOS/3必备知识架构/3视图/3视图-①本质RunLoop/3视图-①本质/RunLoop的内部逻辑.png" alt="RunLoop的内部逻辑"></p>
</blockquote>
<h4 id="3-1-CFRunLoopSourceRef"><a href="#3-1-CFRunLoopSourceRef" class="headerlink" title="3.1 CFRunLoopSourceRef"></a>3.1 CFRunLoopSourceRef</h4><p>Source有两个版本：Source0 和 Source1。</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>
</ul>
<p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>在iOS 中，除了source1可以自己唤醒run loop之外，其他的事件都需要用户手动唤醒run loop才可以。</p>
<h5 id="3-1-附上题中button点击后，关于RunLoop的过程-此处略过对响应链的描述"><a href="#3-1-附上题中button点击后，关于RunLoop的过程-此处略过对响应链的描述" class="headerlink" title="3.1.附上题中button点击后，关于RunLoop的过程(此处略过对响应链的描述)"></a>3.1.附上题中button点击后，关于RunLoop的过程(此处略过对响应链的描述)</h5><blockquote>
<p>大概为：当一个硬件事件(触摸/锁屏/摇晃等)发生后，<br>①、首先由 IOKit.framework 生成一个 IOHIDEvent 事件，Source1 接收到系统事件，<em>RunLoop被唤醒</em>。<br>②、RunLoop<em>通知Observer，处理Timer和Source 0</em>。<br>③、<em>RunLoop处理Source 1，Source1 触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发</em>。<br>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。<br>④、Springboard接受touch event，并用source1 的 之后mach port 转发给App进程。<br>⑤、<em>RunLoop处理完毕进入睡眠，此前会释放旧的autorelease pool并新建一个autorelease pool。</em></p>
</blockquote>
<h4 id="3-2-CFRunLoopTimerRef"><a href="#3-2-CFRunLoopTimerRef" class="headerlink" title="3.2 CFRunLoopTimerRef"></a>3.2 CFRunLoopTimerRef</h4><p>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。<strong>当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调</strong>（NSTimer 其实就是 CFRunLoopTimerRef）。</p>
<h4 id="3-3-CFRunLoopObserverRef"><a href="#3-3-CFRunLoopObserverRef" class="headerlink" title="3.3 CFRunLoopObserverRef"></a>3.3 CFRunLoopObserverRef</h4><p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。</p>
<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h3 id="4、RunLoop的应用"><a href="#4、RunLoop的应用" class="headerlink" title="4、RunLoop的应用"></a>4、RunLoop的应用</h3><p>最常见的为定时器 NSTimer</p>
<blockquote>
<p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
</blockquote>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>讲到RunLoop，我们需明确一点。<strong>runloop会对timer有强引用，timer会对目标对象进行强引用</strong></p>
<p>其他详细参考以下文章：</p>
<ul>
<li><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></li>
<li><a href="https://www.cnblogs.com/jiangzzz/p/5619512.html" target="_blank" rel="noopener">iOS面试题之runloop</a></li>
</ul>
<h4 id="4-1、autoreleasepool-自动释放池"><a href="#4-1、autoreleasepool-自动释放池" class="headerlink" title="4.1、autoreleasepool 自动释放池"></a>4.1、autoreleasepool 自动释放池</h4><p>既然说到runloop，简单说下autoreleasepool自动释放池。runloop会默认创建autoreleasepool，在runloop睡眠前或者退出前会执行pop操作。线程池详情查看下面的内存管理中的介绍。</p>
<p>@autoreleasepool是自动释放池，让我们更自由的管理内存;所以我们下面说说内存管理。</p>
<h4 id="4-2、runloop、autorelease-pool以及线程之间的关系"><a href="#4-2、runloop、autorelease-pool以及线程之间的关系" class="headerlink" title="4.2、runloop、autorelease pool以及线程之间的关系"></a>4.2、runloop、autorelease pool以及线程之间的关系</h4><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>其他参考文档：<a href="https://www.cnblogs.com/zyzmlc/p/14087616.html" target="_blank" rel="noopener">runloop</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/3视图/3视图-①本质RunLoop/" data-id="cm2nkn6ey0186bur4svs8r9i3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/3视图/3视图-②生命周期" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/3视图/3视图-②生命周期/" class="article-date">
  <time datetime="2019-04-28T01:27:20.000Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/iOS/3必备知识架构/3视图/3视图-②生命周期/">视图-②生命周期</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p id="目录"></p><p></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#生命周期">五、控制器View的生命周期</a></li>
</ul>
<ul>
<li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p>
</li>
<li><p><a href="#END">END</a></p>
</li>
</ul>
<p></p><p id="生命周期"></p><p></p>
<h2 id="五、控制器View的生命周期"><a href="#五、控制器View的生命周期" class="headerlink" title="五、控制器View的生命周期"></a>五、控制器View的生命周期</h2><p><a href="#目录">&lt; 返回目录</a></p>
<p>更详细的生命周期请查看：<a href="https://www.jianshu.com/p/d60b388b19f5" target="_blank" rel="noopener">iOS程序执行顺序和UIViewController 的生命周期(整理)</a></p>
<h5 id="题目1：控制器View的生命周期及相关函数是什么-你在开发中是如何用的"><a href="#题目1：控制器View的生命周期及相关函数是什么-你在开发中是如何用的" class="headerlink" title="题目1：控制器View的生命周期及相关函数是什么?你在开发中是如何用的?"></a>题目1：控制器View的生命周期及相关函数是什么?你在开发中是如何用的?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.在视图显示之前调用viewWillAppear;该函数可以调用多次; </span><br><span class="line">2.视图显示完毕,调用viewDidAppear;</span><br><span class="line">3.在视图消失之前调用viewWillDisAppear;该函数可以调用多次(如需要);</span><br><span class="line">4.在布局变化前后,调用viewWill/DidLayoutSubviews处理相关信息;</span><br></pre></td></tr></table></figure>
<p>viewWillAppear——-》viewWillLayoutSubviews—–》viewDidLayoutSubviews———–》</p>
<p>viewDidAppear</p>
<h5 id="题目2：loadView-viewDidLoad-viewDidUnLoad-分别是在什么时候被调用的"><a href="#题目2：loadView-viewDidLoad-viewDidUnLoad-分别是在什么时候被调用的" class="headerlink" title="题目2：loadView, viewDidLoad, viewDidUnLoad,分别是在什么时候被调用的."></a>题目2：loadView, viewDidLoad, viewDidUnLoad,分别是在什么时候被调用的.</h5><p><a href="http://blog.csdn.net/w_sx_/article/details/39431205" target="_blank" rel="noopener">loadView, viewDidLoad, viewDidUnLoad,分别是在什么时候被调用的.</a></p>
<h4 id="3、layoutSubviews布局与drawRect重绘"><a href="#3、layoutSubviews布局与drawRect重绘" class="headerlink" title="3、layoutSubviews布局与drawRect重绘"></a>3、layoutSubviews布局与drawRect重绘</h4><h6 id="1-、layoutSubviews布局"><a href="#1-、layoutSubviews布局" class="headerlink" title="(1)、layoutSubviews布局"></a>(1)、layoutSubviews布局</h6><p>layoutSubviews是对subviews重新布局；<br>比如，我们想更新子视图的位置的时候，可以通过调用layoutSubviews方法，即可以实现对子视图重新布局。但实际上<strong>一般我们都是不要直接手动调用layoutSubviews方法</strong>。因为有操作时候，系统会自动调用layoutSubviews。</p>
<blockquote>
<p>那我们进行哪些操作会触发layoutSubviews方法呢？答如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先注意：</span><br><span class="line">①init初始化不会触发layoutSubviews，</span><br><span class="line">但是使用initWithFrame进行初始化时，当rect的值不为CGRectZero时，会触发layoutSubviews。</span><br><span class="line">②、直接调用setLayoutSubviews。</span><br><span class="line">③、addSubview的时候一般都会触发layoutSubviews。(最常见) 注：但当本View的frame为0时,addSubView也不会调用layoutSubViews。</span><br><span class="line">④、当view的frame发生改变的时候触发layoutSubviews。</span><br><span class="line">⑤、滑动UIScrollView的时候触发layoutSubviews。</span><br><span class="line">⑥、旋转Screen会触发父UIView上的layoutSubviews事件。</span><br><span class="line">⑦、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。</span><br></pre></td></tr></table></figure>
<p>所以我们可以看出当视图约束/frame变化时候，会触发layoutSubviews，进行重新布局。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">附：</span><br><span class="line">如果你还是想强制更新布局，你可以调用setNeedsLayout方法；</span><br><span class="line">如果你想立即显示你的views，你需要调用layoutIfNeed方法。</span><br><span class="line"></span><br><span class="line">①、- (void)layoutSubviews; </span><br><span class="line">这个方法，默认没有做任何事情，需要子类进行重写；</span><br><span class="line">②、- (void)setNeedsLayout; </span><br><span class="line">标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用；</span><br><span class="line">③、- (void)layoutIfNeeded; </span><br><span class="line">如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）。</span><br></pre></td></tr></table></figure>
<p>其他参考文章:<a href="https://blog.csdn.net/u011146511/article/details/51234907" target="_blank" rel="noopener">iOS layoutSubview的方法总结／重绘drawRect</a></p>
<p>什么时候用layoutSubviews?</p>
<blockquote>
<p>答：仅仅在以下情况下:自动布局达不到想要效果时你才有必要重写这个方法.可以直接设置subviews的尺寸.</p>
</blockquote>
<h6 id="2-、drawRect重绘"><a href="#2-、drawRect重绘" class="headerlink" title="(2)、drawRect重绘"></a>(2)、drawRect重绘</h6><p>重绘作用：重写该方法以实现自定义的绘制内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-drawRect:(CGRect)rect方法：重写此方法，执行重绘任务</span><br><span class="line">-setNeedsDisplay方法：标记为需要重绘，异步调用drawRect</span><br><span class="line">-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘</span><br></pre></td></tr></table></figure>
<h6 id="3-、updateConstraints更新约束、layoutSubviews重新布局与drawRect重绘的调用顺序"><a href="#3-、updateConstraints更新约束、layoutSubviews重新布局与drawRect重绘的调用顺序" class="headerlink" title="(3)、updateConstraints更新约束、layoutSubviews重新布局与drawRect重绘的调用顺序"></a>(3)、updateConstraints更新约束、layoutSubviews重新布局与drawRect重绘的调用顺序</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layoutSubviews是对subviews重新布局；</span><br><span class="line">drawRect重绘；</span><br><span class="line">layoutSubviews方法调用先于drawRect，也就是先布局子视图，在重绘。</span><br></pre></td></tr></table></figure>
<p>所以，在调用updateConstraintsIfNeeded可能会立即执行updateConstraints，然后调用layoutSubviews。因为按照Autolayout布局的步骤，应该是先更新约束然后更新布局的。</p>
<p></p><p id="常见笔试/面试题"></p><p></p>
<h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/3视图/3视图-②生命周期/" data-id="cm2nkn6fi0188bur4ogr82188" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/3视图/3视图-③跳转" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/3视图/3视图-③跳转/" class="article-date">
  <time datetime="2019-04-28T01:27:20.000Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/iOS/3必备知识架构/3视图/3视图-③跳转/">视图-③跳转</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="视图-③跳转"><a href="#视图-③跳转" class="headerlink" title="视图-③跳转"></a>视图-③跳转</h1><p>–</p>
<p></p><p id="目录"></p><p></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#视图的跳转">一、视图的跳转</a></li>
</ul>
<ul>
<li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p>
</li>
<li><p><a href="#END">END</a></p>
</li>
</ul>
<p></p><p id="视图的跳转"></p><p></p>
<h2 id="一、视图的跳转"><a href="#一、视图的跳转" class="headerlink" title="一、视图的跳转"></a>一、视图的跳转</h2><p><a href="#目录">&lt; 返回目录</a></p>
<h4 id="1、获取当前显示的视图控制器ViewController"><a href="#1、获取当前显示的视图控制器ViewController" class="headerlink" title="1、获取当前显示的视图控制器ViewController"></a>1、获取当前显示的视图控制器ViewController</h4><h4 id="2、如何在多次presentViewController后直接返回到指定层"><a href="#2、如何在多次presentViewController后直接返回到指定层" class="headerlink" title="2、如何在多次presentViewController后直接返回到指定层"></a>2、如何在多次presentViewController后直接返回到指定层</h4><p>场景：如果多个控制器都通过 present 的方式跳转呢？比如从A跳转到B，从B跳转到C，从C跳转到D，如何由D直接返回到A呢？</p>
<p>答：可以通过 presentingViewController 一直找到A控制器，然后调用A控制器的 dismissViewControllerAnimated 方法。方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *controller = self;</span><br><span class="line">while(controller.presentingViewController != nil)&#123;</span><br><span class="line">    controller = controller.presentingViewController;</span><br><span class="line">&#125;</span><br><span class="line">[controller dismissViewControllerAnimated:YES completion:nil];</span><br></pre></td></tr></table></figure>
<p>PS：如果不是想直接返回到A控制器，比如想回到B控制器，while循环的终止条件可以通过控制器的类来判断。</p>
<h4 id="3、presentedViewController-与-presentingViewController"><a href="#3、presentedViewController-与-presentingViewController" class="headerlink" title="3、presentedViewController 与  presentingViewController"></a>3、presentedViewController 与  presentingViewController</h4><blockquote>
<p>假设从A控制器通过present的方式跳转到了B控制器，那么 A.presentedViewController 就是B控制器；<br>B.presentingViewController 就是A控制器。</p>
</blockquote>
<h4 id="4、如何通过视图-view-获取该视图所在的控制器-viewController"><a href="#4、如何通过视图-view-获取该视图所在的控制器-viewController" class="headerlink" title="4、如何通过视图(view)获取该视图所在的控制器(viewController)"></a>4、如何通过视图(view)获取该视图所在的控制器(viewController)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (nullable UIViewController *)findBelongViewControllerForView:(UIView *)view &#123;</span><br><span class="line">    UIResponder *responder = view;</span><br><span class="line">    while ((responder = [responder nextResponder]))</span><br><span class="line">        if ([responder isKindOfClass: [UIViewController class]]) &#123;</span><br><span class="line">            return (UIViewController *)responder;</span><br><span class="line">        &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p><p id="常见笔试/面试题"></p><p></p>
<h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="#目录">&lt; 返回目录</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/3视图/3视图-③跳转/" data-id="cm2nkn6g3018bbur4m2bn11gl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/24/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/26/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/">Architecture</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第一章：架构相关/">第一章：架构相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第七章：技术选型/">第七章：技术选型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第三章：基础规范/">第三章：基础规范</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第九章：监控相关/">第九章：监控相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第二章：框架相关/">第二章：框架相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第八章：页面加载相关/">第八章：页面加载相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第六章：通用业务规范/">第六章：通用业务规范</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第四章：基础框架设计及接口文档/">第四章：基础框架设计及接口文档</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/无瑕疵的混编登录页/">无瑕疵的混编登录页</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第一章：Flutter入门/">第一章：Flutter入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第七章：规范/">第七章：规范</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第三章：原生项目与Flutter的交互/">第三章：原生项目与Flutter的交互</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第九章：框架升级/">第九章：框架升级</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第二章：集成Flutter到原生项目/">第二章：集成Flutter到原生项目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第五章：详解/">第五章：详解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第八章：状态管理/">第八章：状态管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第六章：进阶/">第六章：进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第四章：Flutter登录页实战/">第四章：Flutter登录页实战</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第零章：Flutter源码/">第零章：Flutter源码</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/QA/">QA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/README/">README</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/React/第一章：React入门/">第一章：React入门</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/">ReactNative</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第一章：ReactNative入门/">第一章：ReactNative入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第一章：React入门/">第一章：React入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第五章：ReactNative详解/">第五章：ReactNative详解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第八章：ReactNative实践/">第八章：ReactNative实践</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第六章：ReactNative进阶/">第六章：ReactNative进阶</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/">Script</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Script/JQuery/">JQuery</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Mac快速操作/">Mac快速操作</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Shell/">Shell</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Weex/">Weex</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Weex/第一章：Weex入门/">第一章：Weex入门</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Swift/">Swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/混编/">混编</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/移动分析/">移动分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/自动化/">自动化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/证书发版/">证书发版</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/npmjs/">npmjs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/上架相关/">上架相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/代码管理/">代码管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全与破解/">安全与破解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/">实用工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/ChatGPT/">ChatGPT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/GitBook/">GitBook</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/Jenkins/">Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/XAMPP/">XAMPP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/Zentao/">Zentao</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/其他小工具/">其他小工具</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作常识/">工作常识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术常识/">技术常识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活常识/">生活常识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/电脑使用/">电脑使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/管理相关/">管理相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/管理相关/第一章：账号管理/">第一章：账号管理</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程工具/">编程工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/跨平台/">跨平台</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/跨平台/第一章：混编事项说明/">第一章：混编事项说明</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Architecture/">Architecture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChatGPT/">ChatGPT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac快速操作/">Mac快速操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QA/">QA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/README/">README</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReactNative/">ReactNative</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Script/">Script</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/h5与app交互/">h5与app交互</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npmjs/">npmjs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/上架相关/">上架相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/交互/">交互</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/埋点/">埋点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基类/">基类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/实用工具/">实用工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作常识/">工作常识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/打包/">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术常识/">技术常识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/抓包/">抓包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/搜索相关/">搜索相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文档管理/">文档管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/权限相关/">权限相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构模式/">架构模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境搭建/">环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活常识/">生活常识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/电脑使用/">电脑使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/瘦身/">瘦身</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/登录页实战/">登录页实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/破解/">破解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动分析/">移动分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/管理相关/">管理相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程工具/">编程工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化/">自动化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/请求/">请求</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨平台/">跨平台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/路由及跳转/">路由及跳转</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阿里云/">阿里云</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阿里云oss/">阿里云oss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集成/">集成</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Architecture/" style="font-size: 20px;">Architecture</a> <a href="/tags/ChatGPT/" style="font-size: 10.83px;">ChatGPT</a> <a href="/tags/CocoaPods/" style="font-size: 10px;">CocoaPods</a> <a href="/tags/Flutter/" style="font-size: 18.33px;">Flutter</a> <a href="/tags/Git/" style="font-size: 13.33px;">Git</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Jenkins/" style="font-size: 14.17px;">Jenkins</a> <a href="/tags/Mac快速操作/" style="font-size: 10px;">Mac快速操作</a> <a href="/tags/Python/" style="font-size: 11.67px;">Python</a> <a href="/tags/QA/" style="font-size: 10px;">QA</a> <a href="/tags/README/" style="font-size: 10px;">README</a> <a href="/tags/React/" style="font-size: 10.83px;">React</a> <a href="/tags/ReactNative/" style="font-size: 15.83px;">ReactNative</a> <a href="/tags/Ruby/" style="font-size: 10px;">Ruby</a> <a href="/tags/Script/" style="font-size: 15px;">Script</a> <a href="/tags/Shell/" style="font-size: 11.67px;">Shell</a> <a href="/tags/Swift/" style="font-size: 12.5px;">Swift</a> <a href="/tags/Weex/" style="font-size: 10px;">Weex</a> <a href="/tags/h5与app交互/" style="font-size: 12.5px;">h5与app交互</a> <a href="/tags/iOS/" style="font-size: 17.5px;">iOS</a> <a href="/tags/npmjs/" style="font-size: 10.83px;">npmjs</a> <a href="/tags/上架相关/" style="font-size: 10px;">上架相关</a> <a href="/tags/交互/" style="font-size: 12.5px;">交互</a> <a href="/tags/埋点/" style="font-size: 10.83px;">埋点</a> <a href="/tags/基类/" style="font-size: 10.83px;">基类</a> <a href="/tags/安全/" style="font-size: 14.17px;">安全</a> <a href="/tags/实用工具/" style="font-size: 16.67px;">实用工具</a> <a href="/tags/工作常识/" style="font-size: 10px;">工作常识</a> <a href="/tags/打包/" style="font-size: 10px;">打包</a> <a href="/tags/技术常识/" style="font-size: 13.33px;">技术常识</a> <a href="/tags/抓包/" style="font-size: 10px;">抓包</a> <a href="/tags/搜索相关/" style="font-size: 10px;">搜索相关</a> <a href="/tags/文档管理/" style="font-size: 14.17px;">文档管理</a> <a href="/tags/权限相关/" style="font-size: 10px;">权限相关</a> <a href="/tags/架构模式/" style="font-size: 11.67px;">架构模式</a> <a href="/tags/环境搭建/" style="font-size: 10.83px;">环境搭建</a> <a href="/tags/生活常识/" style="font-size: 10px;">生活常识</a> <a href="/tags/电脑使用/" style="font-size: 10px;">电脑使用</a> <a href="/tags/瘦身/" style="font-size: 11.67px;">瘦身</a> <a href="/tags/登录页实战/" style="font-size: 12.5px;">登录页实战</a> <a href="/tags/破解/" style="font-size: 11.67px;">破解</a> <a href="/tags/移动分析/" style="font-size: 11.67px;">移动分析</a> <a href="/tags/管理相关/" style="font-size: 11.67px;">管理相关</a> <a href="/tags/编程工具/" style="font-size: 12.5px;">编程工具</a> <a href="/tags/自动化/" style="font-size: 11.67px;">自动化</a> <a href="/tags/请求/" style="font-size: 10.83px;">请求</a> <a href="/tags/跨平台/" style="font-size: 19.17px;">跨平台</a> <a href="/tags/路由及跳转/" style="font-size: 11.67px;">路由及跳转</a> <a href="/tags/阿里云/" style="font-size: 10px;">阿里云</a> <a href="/tags/阿里云oss/" style="font-size: 13.33px;">阿里云oss</a> <a href="/tags/集成/" style="font-size: 11.67px;">集成</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/Architecture架构/架构相关/3组件化/5框架设计模式-⑦组件化/">框架设计模式-⑦组件化</a>
          </li>
        
          <li>
            <a href="/Architecture架构/监控相关/日志系统/">日志系统</a>
          </li>
        
          <li>
            <a href="/总目录/">总目录</a>
          </li>
        
          <li>
            <a href="/安全/网络加密/">网络接口数据安全的【攻与防大全】</a>
          </li>
        
          <li>
            <a href="/Architecture架构/监控相关/灰度系统/">灰度系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 dvlproad<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>