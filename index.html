<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>dvlproadの博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学而时习之不亦说乎(dvlproad)">
<meta name="keywords" content="blog,IT,iOS,Flutter">
<meta property="og:type" content="website">
<meta property="og:title" content="dvlproadの博客">
<meta property="og:url" content="https://dvlproad.github.io/index.html">
<meta property="og:site_name" content="dvlproadの博客">
<meta property="og:description" content="学而时习之不亦说乎(dvlproad)">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dvlproadの博客">
<meta name="twitter:description" content="学而时习之不亦说乎(dvlproad)">
  
    <link rel="alternate" href="/atom.xml" title="dvlproadの博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">dvlproadの博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">整理及总结平时过程中的知识点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://dvlproad.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS/3必备知识架构/3视图/3视图-①本质RunLoop" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/3视图/3视图-①本质RunLoop/" class="article-date">
  <time datetime="2024-09-05T11:40:17.438Z" itemprop="datePublished">2024-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-视图-①本质"><a href="#必备知识架构-视图-①本质" class="headerlink" title="必备知识架构-视图-①本质"></a>必备知识架构-视图-①本质</h1><p>[toc]</p>
<p></p><p id="RunLoop"></p><p></p>
<h2 id="四、RunLoop"><a href="#四、RunLoop" class="headerlink" title="四、RunLoop"></a>四、RunLoop</h2><blockquote>
<p>&lt; <a href="#目录">返回目录</a></p>
</blockquote>
<h3 id="1、RunLoop概念"><a href="#1、RunLoop概念" class="headerlink" title="1、RunLoop概念"></a>1、RunLoop概念</h3><p>Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。一个run loop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。其内部就是do－while循环，这个循环内部不断地处理各种任务（比如Source，Timer，Observer）。使用run loop的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。</p>
<h3 id="2、RunLoop和线程的关系？"><a href="#2、RunLoop和线程的关系？" class="headerlink" title="2、RunLoop和线程的关系？"></a>2、RunLoop和线程的关系？</h3><p>run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程相关的基础框架的一部分，Cocoa和CoreFundation都提供了run loop对象方便配置和管理线程的run loop（以下都已Cocoa为例）。</p>
<p>每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。</p>
<p>①、主线程的run loop默认是启动的。</p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了本文开始说的为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>
</blockquote>
<p>②、对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</p>
<p>③、在任何一个Cocoa程序的线程中，都可以通过：<code>NSRunLoop *runloop = [NSRunLoop currentRunLoop];</code>来获取到当前线程的run loop。</p>
<h3 id="3、RunLoop相关各类关系"><a href="#3、RunLoop相关各类关系" class="headerlink" title="3、RunLoop相关各类关系"></a>3、RunLoop相关各类关系</h3><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef</span><br><span class="line">CFRunLoopModeRef</span><br><span class="line">CFRunLoopSourceRef</span><br><span class="line">CFRunLoopTimerRef</span><br><span class="line">CFRunLoopObserverRef</span><br></pre></td></tr></table></figure>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系/RunLoop相关各类关系，如下图所示：</p>
<blockquote>
<p><img src="/iOS/3必备知识架构/3视图/3视图-①本质RunLoop/3视图-①本质/RunLoop相关各类关系.png" alt="RunLoop相关各类关系"><br>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p>RunLoop的内部逻辑<br><img src="/iOS/3必备知识架构/3视图/3视图-①本质RunLoop/3视图-①本质/RunLoop的内部逻辑.png" alt="RunLoop的内部逻辑"></p>
</blockquote>
<h4 id="3-1-CFRunLoopSourceRef"><a href="#3-1-CFRunLoopSourceRef" class="headerlink" title="3.1 CFRunLoopSourceRef"></a>3.1 CFRunLoopSourceRef</h4><p>Source有两个版本：Source0 和 Source1。</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>
</ul>
<p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>在iOS 中，除了source1可以自己唤醒run loop之外，其他的事件都需要用户手动唤醒run loop才可以。</p>
<h5 id="3-1-附上题中button点击后，关于RunLoop的过程-此处略过对响应链的描述"><a href="#3-1-附上题中button点击后，关于RunLoop的过程-此处略过对响应链的描述" class="headerlink" title="3.1.附上题中button点击后，关于RunLoop的过程(此处略过对响应链的描述)"></a>3.1.附上题中button点击后，关于RunLoop的过程(此处略过对响应链的描述)</h5><blockquote>
<p>大概为：当一个硬件事件(触摸/锁屏/摇晃等)发生后，<br>①、首先由 IOKit.framework 生成一个 IOHIDEvent 事件，Source1 接收到系统事件，<em>RunLoop被唤醒</em>。<br>②、RunLoop<em>通知Observer，处理Timer和Source 0</em>。<br>③、<em>RunLoop处理Source 1，Source1 触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发</em>。<br>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。<br>④、Springboard接受touch event，并用source1 的 之后mach port 转发给App进程。<br>⑤、<em>RunLoop处理完毕进入睡眠，此前会释放旧的autorelease pool并新建一个autorelease pool。</em></p>
</blockquote>
<h4 id="3-2-CFRunLoopTimerRef"><a href="#3-2-CFRunLoopTimerRef" class="headerlink" title="3.2 CFRunLoopTimerRef"></a>3.2 CFRunLoopTimerRef</h4><p>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。<strong>当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调</strong>（NSTimer 其实就是 CFRunLoopTimerRef）。</p>
<h4 id="3-3-CFRunLoopObserverRef"><a href="#3-3-CFRunLoopObserverRef" class="headerlink" title="3.3 CFRunLoopObserverRef"></a>3.3 CFRunLoopObserverRef</h4><p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。</p>
<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h3 id="4、RunLoop的应用"><a href="#4、RunLoop的应用" class="headerlink" title="4、RunLoop的应用"></a>4、RunLoop的应用</h3><p>最常见的为定时器 NSTimer</p>
<blockquote>
<p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
</blockquote>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>讲到RunLoop，我们需明确一点。<strong>runloop会对timer有强引用，timer会对目标对象进行强引用</strong></p>
<p>其他详细参考以下文章：</p>
<ul>
<li><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></li>
<li><a href="https://www.cnblogs.com/jiangzzz/p/5619512.html" target="_blank" rel="noopener">iOS面试题之runloop</a></li>
</ul>
<h4 id="4-1、autoreleasepool-自动释放池"><a href="#4-1、autoreleasepool-自动释放池" class="headerlink" title="4.1、autoreleasepool 自动释放池"></a>4.1、autoreleasepool 自动释放池</h4><p>既然说到runloop，简单说下autoreleasepool自动释放池。runloop会默认创建autoreleasepool，在runloop睡眠前或者退出前会执行pop操作。线程池详情查看下面的内存管理中的介绍。</p>
<p>@autoreleasepool是自动释放池，让我们更自由的管理内存;所以我们下面说说内存管理。</p>
<h4 id="4-2、runloop、autorelease-pool以及线程之间的关系"><a href="#4-2、runloop、autorelease-pool以及线程之间的关系" class="headerlink" title="4.2、runloop、autorelease pool以及线程之间的关系"></a>4.2、runloop、autorelease pool以及线程之间的关系</h4><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>其他参考文档：<a href="https://www.cnblogs.com/zyzmlc/p/14087616.html" target="_blank" rel="noopener">runloop</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/3视图/3视图-①本质RunLoop/" data-id="cm1p887i20180zwr4e7r3be35" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS/3必备知识架构/2内存/2内存-②循环引用" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS/3必备知识架构/2内存/2内存-②循环引用/" class="article-date">
  <time datetime="2024-08-31T21:18:22.624Z" itemprop="datePublished">2024-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="必备知识架构-内存-②循环引用"><a href="#必备知识架构-内存-②循环引用" class="headerlink" title="必备知识架构-内存-②循环引用"></a>必备知识架构-内存-②循环引用</h1><p>[toc]</p>
<p></p><p id="目录"></p><p></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><p><a href="#循环引用原因">一、循环引用原因</a></p>
</li>
<li><p><a href="#NSTimer的循环引用">二、NSTimer的循环引用</a></p>
</li>
<li><p><a href="#委托delegate的循环引用">三、委托delegate的循环引用</a></p>
</li>
<li><p><a href="#block的循环引用">四、block的循环引用</a></p>
</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、Objective-C中block为何得用copy修饰，能否用其他</span><br><span class="line">2、block的循环引用</span><br><span class="line">3、block循环引用的解决</span><br><span class="line">4、判断该block是否会发生循环引用</span><br><span class="line">5、为什么masonry的block里引用self不需要weak？</span><br><span class="line">6、是否所有的Block中，使用self 都会导致循环引用？</span><br><span class="line">7、block修改外部局部变量</span><br><span class="line">(1)、在block中无法直接修改外部变量的原因</span><br><span class="line">(2)、解决如何在 block 中修改外部变量</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><a href="#常见笔试/面试题">常见笔试/面试题</a></p>
</li>
<li><p><a href="#END">END</a></p>
</li>
</ul>
<p></p><p id="循环引用原因"></p><p></p>
<h2 id="一、循环引用原因"><a href="#一、循环引用原因" class="headerlink" title="一、循环引用原因"></a>一、循环引用原因</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>导致iOS对象无法按预期释放的一个无形杀手是——循环引用。循环引用可以简单理解为A引用了B，而B又引用了A，双方都同时保持对方的一个引用，导致任何时候引用计数都不为0，始终无法释放。若当前对象是一个ViewController，则在dismiss或者pop之后其dealloc无法被调用，在频繁的push或者present之后内存暴增，然后APP就duang地挂了。</p>
<p><strong>循环引用会导致内存泄露，因为循环应用会导致，有些对象没办法在已经不会再使用的时候被释放掉</strong></p>
<p>下面列举我们变成中比较容易碰到的三种循环引用的情形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）计时器NSTimer</span><br><span class="line">（2）block</span><br><span class="line">（3）委托delegate</span><br></pre></td></tr></table></figure>
<p></p><p id="NSTimer的循环引用"></p><p></p>
<h2 id="二、NSTimer的循环引用"><a href="#二、NSTimer的循环引用" class="headerlink" title="二、NSTimer的循环引用"></a>二、NSTimer的循环引用</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>NSTimer的循环引用详情，我们放在下面讲解NSTimer(前面已经提过NSTimer 其实就是RunLoop中的CFRunLoopTimerRef，一个基于时间的触发器)的时候介绍。</p>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@interface HWWeakTimerTarget : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id target;			// 注意是 weak</span><br><span class="line">@property (nonatomic, assign) SEL selector; // assign</span><br><span class="line">@property (nonatomic, weak) NSTimer* timer;	// 注意是 weak</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation HWWeakTimerTarget</span><br><span class="line"></span><br><span class="line">- (void) fire:(NSTimer *)timer &#123;</span><br><span class="line">    if(self.target) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">        [self.target performSelector:self.selector withObject:timer.userInfo afterDelay:0.0f];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.timer invalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation HWWeakTimer</span><br><span class="line"></span><br><span class="line">+ (NSTimer *) scheduledTimerWithTimeInterval:(NSTimeInterval)interval</span><br><span class="line">                                      target:(id)aTarget</span><br><span class="line">                                    selector:(SEL)aSelector</span><br><span class="line">                                    userInfo:(id)userInfo</span><br><span class="line">                                     repeats:(BOOL)repeats &#123;</span><br><span class="line">    HWWeakTimerTarget* timerTarget = [[HWWeakTimerTarget alloc] init];</span><br><span class="line">    timerTarget.target = aTarget;</span><br><span class="line">    timerTarget.selector = aSelector;</span><br><span class="line">    timerTarget.timer = [NSTimer scheduledTimerWithTimeInterval:interval</span><br><span class="line">                                                         target:timerTarget</span><br><span class="line">                                                       selector:@selector(fire:)</span><br><span class="line">                                                       userInfo:userInfo</span><br><span class="line">                                                        repeats:repeats];</span><br><span class="line">    return timerTarget.timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p></p><p id="委托delegate的循环引用"></p><p></p>
<h2 id="三、委托delegate的循环引用"><a href="#三、委托delegate的循环引用" class="headerlink" title="三、委托delegate的循环引用"></a>三、委托delegate的循环引用</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<p>在委托问题上出现循环引用问题已经是老生常谈了，声明delegate时请用weak(ARC)，如果是MRC则用assign。千万别手贱。</p>
<p></p><p id="block的循环引用"></p><p></p>
<h2 id="四、block的循环引用"><a href="#四、block的循环引用" class="headerlink" title="四、block的循环引用"></a>四、block的循环引用</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>
<h5 id="1、Objective-C中block为何得用copy修饰，能否用其他"><a href="#1、Objective-C中block为何得用copy修饰，能否用其他" class="headerlink" title="1、Objective-C中block为何得用copy修饰，能否用其他"></a>1、Objective-C中block为何得用copy修饰，能否用其他</h5><blockquote>
<p>答：因为<strong>block在创建的时候，它的内存是分配在栈(stack)上，而不是在堆(heap)上。他本身的作于域是属于创建时候的作用域，一旦在创建时候的作用域外面调用block将导致程序崩溃。所以，为了能够在block的声明域外也能够使用block，我们需要将block拷贝到堆上，所以使用copy属性。</strong>对于堆中的block，也就是copy修饰的block。他的生命周期是随着对象的销毁而结束的。只要对象不销毁，我们就可以调用的到在堆中的block。</p>
</blockquote>
<p>Block 在创建时可能存储在不同的内存区域（栈或堆）中，而在将其赋值给对象或作为函数或方法的参数时，需要确保 Block 存储在堆中，以便在调用时能够正常执行。如果 Block 存储在栈中，则在函数或方法返回后，Block 对象所在的内存区域将被释放，从而导致程序崩溃或者产生其他未定义的行为。所以block应该被持有，即<strong>应该使用copy或者strong修改。那为什么我们还是习惯使用copy呢？因为使用 copy 可以提高线程安全性</strong>，因为每个线程可以独立地使用 block 的副本，而不必担心其他线程对原始 block 的修改。举例点击一个按钮</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^updateUIBlock)(<span class="keyword">void</span>); <span class="comment">// 使用 copy 属性</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>; <span class="comment">// 使用 __weak 避免循环引用</span></span><br><span class="line">    <span class="keyword">self</span>.updateUIBlock = ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        <span class="keyword">if</span> (strongSelf) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [strongSelf __updateUI];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)__updateUI &#123;</span><br><span class="line">    <span class="comment">// 更新 UI 的代码</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"UI updated on main thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)clickToUpdateUI &#123;</span><br><span class="line">    <span class="comment">// 执行异步任务，并在完成后调用 updateUIBlock</span></span><br><span class="line">    [<span class="keyword">self</span> performBackgroundTaskWithCompletion:<span class="keyword">self</span>.updateUIBlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// completion这个block如果是原block的副本，那么这里即使多个后台任务尝试同时更新 UI，每个任务都会有 `updateUIBlock` 的独立副本，不会相互干扰。这确保了 UI 更新操作的线程安全性。</span></span><br><span class="line">- (<span class="keyword">void</span>)performBackgroundTaskWithCompletion:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completion &#123;</span><br><span class="line">    <span class="comment">// 模拟后台线程任务</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">// ... 执行一些后台操作 ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 任务完成后，调用 completion block</span></span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            completion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>扩展：为什么NSString 可以使用strong和copy，却选择使用 <code>copy</code>？（个人理解：因为NSString是不可变的，既然不可变还不如使用copy再加一层线程安全）</p>
<p>使用 <code>copy</code> 属性修饰符通常有以下原因：</p>
<ol>
<li><strong>确保线程安全</strong>：如果你在多线程环境中操作字符串，使用 <code>copy</code> 可以确保每个线程都有自己的副本，从而避免线程安全问题。</li>
<li><strong>避免外部修改</strong>：如果你不希望外部代码修改原始字符串，使用 <code>copy</code> 可以确保你的属性持有的是原始字符串的一个副本，外部代码对原始字符串的修改不会影响到你的属性。</li>
</ol>
<h5 id="2、block的循环引用"><a href="#2、block的循环引用" class="headerlink" title="2、block的循环引用"></a>2、block的循环引用</h5><p><strong>由于block在copy时都会对block内部用到的对象进行强引用(ARC)或者retainCount增1(非ARC)。所以，不管是在ARC还是非ARC环境下对block使用不当都会引起循环引用问题</strong></p>
<p>一般表现为，某个类将block作为自己的属性变量(则该类就对block强引用了)，然后该类在block的方法体里面又使用了该类本身。即当对象（比如self）拥有一个block属性的时候，在block属性中又引用了对象的其他成员变量或者调用了对象的其他方法。形成你中有我，我中有你，谁都无法将谁释放的困局。形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">self.myBlock = ^&#123;</span><br><span class="line">   [self doSomething];</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line">又或者</span><br><span class="line"></span><br><span class="line">ClassA* objA = [[ClassA alloc] init];</span><br><span class="line">objA.myBlock = ^&#123;</span><br><span class="line">   [self doSomething];</span><br><span class="line">&#125;;</span><br><span class="line">self.objA = objA;</span><br></pre></td></tr></table></figure>
<p>block的这种循环引用会被编译器捕捉到并及时提醒。</p>
<p>以上参考自：<a href="http://www.jianshu.com/p/b79bac09177e" target="_blank" rel="noopener">Block的循环引用</a></p>
<h5 id="3、block循环引用的解决"><a href="#3、block循环引用的解决" class="headerlink" title="3、block循环引用的解决"></a>3、block循环引用的解决</h5><h6 id="1-、常规简单解法"><a href="#1-、常规简单解法" class="headerlink" title="(1)、常规简单解法"></a>(1)、常规简单解法</h6><p>解决方法,就一句话的事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof (self) weakSelf = self; </span><br><span class="line">self.myBlock = ^&#123;</span><br><span class="line">    [weakSelf doSomething];</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  附1：如果是non-ARC环境下就将__weak替换为__block即可。non-ARC情况下，__block变量的含义是在Block中引入一个新的结构体成员变量指向这个__block变量，那么__block typeof(self) weakSelf = self;就表示Block别再对self对象retain啦，这就打破了循环引用。</span><br><span class="line">  </span><br><span class="line">  附2：__weak 是 iOS 5.0 推出的，_weak 相当于 weak，不会做强引用，如果对象被释放，执行的地址，会指向 nil</span><br></pre></td></tr></table></figure>
<h6 id="2-、block中使用-weak–strong-dance-技术避免循环引用"><a href="#2-、block中使用-weak–strong-dance-技术避免循环引用" class="headerlink" title="(2)、block中使用 weak–strong dance 技术避免循环引用"></a>(2)、block中使用 weak–strong dance 技术避免循环引用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self)weakSelf = self;</span><br><span class="line">  [header setTapHandle:^&#123;</span><br><span class="line">  		__strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line">  		if (strongSelf) &#123;</span><br><span class="line">     		NSLog(@&quot;strongSelf = %@&quot;, strongSelf);</span><br><span class="line">  		&#125;</span><br><span class="line"> 	[weakSelf headerAction:header];</span><br><span class="line">	&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>精髓2：①在 block 之前定义对 self 的一个弱引用weakSelf，因为是弱引用，所以当 self 被释放时weakSelf会变为nil；② 在 block 中引用该弱应用，考虑到多线程情况，通过使用强引用 strongSelf 来引用该弱引用，这时如果 self 不为 nil 就会 retain self，以防止在后面的使用过程中 self 被释放;③在之后的 block 块中使用该强引用 bself，注意在使用前要对 bSelf 进行了 nil 检测，因为多线程环境下在用弱引用weakSelf对强引用strongSelf赋值时，弱引用weakSelf可能已经为nil了。通过这种手法，block 就不会持有 self 的引用，从而打破了循环引用。</strong></p>
<h4 id="iOS开发中在block中为什么要weak和strong配合使用"><a href="#iOS开发中在block中为什么要weak和strong配合使用" class="headerlink" title="iOS开发中在block中为什么要weak和strong配合使用"></a><a href="https://www.jianshu.com/p/0b87b4e7da2c" target="_blank" rel="noopener">iOS开发中在block中为什么要<strong>weak和</strong>strong配合使用</a></h4><blockquote>
<p>答：<strong>weak是为了解决循环引用。</strong>strong是为了防止block持有的对象提前释放。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">  [self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line"></span><br><span class="line">  __weak typeof(self) weakSelf = self;</span><br><span class="line">  self.block = ^&#123;</span><br><span class="line">      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          NSLog(@&quot;%@&quot;, weakSelf);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  self.block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>点击屏幕，当前控制器消失，同时被销毁掉，5秒后打印的weakSelf就是一个(null)。<br>而我们如果在block内使用__strong后就能保证再打印完strongSelf之后再释放当前控制器。</p>
</blockquote>
<h5 id="4、判断该block是否会发生循环引用"><a href="#4、判断该block是否会发生循环引用" class="headerlink" title="4、判断该block是否会发生循环引用"></a>4、判断该block是否会发生循环引用</h5><p><a href="http://www.cocoachina.com/ios/20170122/18601.html" target="_blank" rel="noopener">判断该block是否会发生循环引用例子</a></p>
<h5 id="5、为什么masonry的block里引用self不需要weak？"><a href="#5、为什么masonry的block里引用self不需要weak？" class="headerlink" title="5、为什么masonry的block里引用self不需要weak？"></a>5、为什么masonry的block里引用self不需要weak？</h5><p>这个就和网络请求里面使用self道理是一样的。因为UIView未强持有block，所以这个block只是个栈block，而且构不成循环引用的条件。栈block有个特性就是它执行完毕之后就出栈，出栈了就会被释放掉。看mas_makexxx的方法实现会发现这个block很快就被调用了，完事儿就出栈销毁，构不成循环引用，所以可以直接放心的使用self。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    self.translatesAutoresizingMaskIntoConstraints = NO;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    return [constraintMaker install];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果要强引用，block应该是masnory的一个属性，即被masnory对象持有。且是copy修饰符</span><br></pre></td></tr></table></figure>
<h4 id="6、是否所有的Block中，使用self-都会导致循环引用？"><a href="#6、是否所有的Block中，使用self-都会导致循环引用？" class="headerlink" title="6、是否所有的Block中，使用self 都会导致循环引用？"></a>6、是否所有的Block中，使用self 都会导致循环引用？</h4><h4 id="7、block修改外部局部变量"><a href="#7、block修改外部局部变量" class="headerlink" title="7、block修改外部局部变量"></a>7、block修改外部局部变量</h4><p>如果是全局变量呢？</p>
<h6 id="1-、在block中无法直接修改外部变量的原因"><a href="#1-、在block中无法直接修改外部变量的原因" class="headerlink" title="(1)、在block中无法直接修改外部变量的原因"></a>(1)、在block中无法直接修改外部变量的原因</h6><p>错误示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//声明一个局部整型变量 </span><br><span class="line">int intValue = 3; //漏掉了__block修饰符</span><br><span class="line"></span><br><span class="line">//声明一个返回值为int,一个int参数的block变量</span><br><span class="line">int (^block)(int) = ^(int m)&#123;</span><br><span class="line">    intValue++;</span><br><span class="line">    return m * intValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//调用block变量,5作为参数之后的结果</span><br><span class="line">NSLog(@&quot;block(5) = %d&quot;,block(5));</span><br></pre></td></tr></table></figure>
<p>在上面的例子中,我们编译程序后发现编译器会有红色错误,错误提示为<br>Variable is not assignable (missing __block type specifier)</p>
<p>为什么会出现不能被赋值的错误提示呢？</p>
<p>block在实现时就会对它引用到的它所在方法中定义的栈变量进行一次只读拷贝，在 block 块内使用该只读拷贝。<br>那为了避免上述错误，就要<strong>精髓1：使用__block修饰符来修饰外部变量,用来通知编译器该外部变量intValue与block中的intValue指的是同一块儿内存地址，而不需要内存拷贝。</strong></p>
<h6 id="2-、解决如何在-block-中修改外部变量"><a href="#2-、解决如何在-block-中修改外部变量" class="headerlink" title="(2)、解决如何在 block 中修改外部变量"></a>(2)、解决如何在 block 中修改外部变量</h6><ul>
<li><p>有必要了解：<a href="http://www.jianshu.com/p/404ff9d3cd42" target="_blank" rel="noopener">iOS中__block 关键字的底层实现原理</a></p>
</li>
<li><p>结论：<code>block可以访问外部变量，但是无法修改外部变量的值，如果要修改外部变量的值，需要对外部变量加上__block作为该变量的修饰</code></p>
<p>来源：<a href="http://bbs.itheima.com/thread-248328-1-1.html" target="_blank" rel="noopener">OC学习笔记之block访问外部变量【重点面试】</a></p>
</li>
</ul>
<ul>
<li>问题： <a href="http://blog.csdn.net/huyisu/article/details/40543291" target="_blank" rel="noopener">如何在 block 中修改外部变量</a></li>
</ul>
<p>有两种办法<br>① 第一种是可以修改 static 全局变量；<br>② 第二种是可以修改用新关键字 __block 修饰的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__block int blockLocal  = 100;</span><br><span class="line">static int staticLocal  = 100;</span><br><span class="line"></span><br><span class="line">void (^aBlock)(void) = ^(void)&#123; </span><br><span class="line">    NSLog(@&quot; &gt;&gt; Sum: %d\n&quot;, global + staticLocal);</span><br><span class="line">    </span><br><span class="line">    global++;</span><br><span class="line">    blockLocal++;</span><br><span class="line">    staticLocal++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">aBlock();</span><br></pre></td></tr></table></figure>
<p><code>附：静态变量 和 全局变量   在加和不加  __block 都会直接引用变量地址。也就意味着静态变量和全局变量的修改可以直接修改，不需要作添加__block的步骤。</code></p>
<h4 id="在ARC下获取对象的引用计数值"><a href="#在ARC下获取对象的引用计数值" class="headerlink" title="在ARC下获取对象的引用计数值"></a>在ARC下获取对象的引用计数值</h4><p>在ARC下获取对象的引用计数值，可以使用CFGetRetainCount。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于Core Foundation对象：</span><br><span class="line">NSLog(@&quot;CFGetRetainCount is %ld&quot;,  CFGetRetainCount(aCFString));</span><br><span class="line"></span><br><span class="line">对于Foundation对象</span><br><span class="line">NSLog(@&quot;CFGetRetainCount is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)aNNstring));</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@ CFGetRetainCount is %ld&quot;, NSStringFromClass([self class]), CFGetRetainCount((__bridge CFTypeRef)self));</span><br></pre></td></tr></table></figure>
<p>以下获取引用计数的方法错了，但是不知道正确的应该怎么用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%@ dealloc&quot;, NSStringFromClass([self class]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@ viewWillDisappear and CFGetRetainCount is %ld&quot;, NSStringFromClass([self class]), CFGetRetainCount((__bridge CFTypeRef)self));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@ viewDidDisappear and CFGetRetainCount is %ld&quot;, NSStringFromClass([self class]), CFGetRetainCount((__bridge CFTypeRef)self));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几篇文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/bcc0bcaadd6c" target="_blank" rel="noopener">iOS杂谈：影响控制器正常释放的常见问题</a></li>
<li><a href="https://www.cnblogs.com/songliquan/p/4970505.html" target="_blank" rel="noopener">iOS中控制器的释放问题</a></li>
<li><a href="https://blog.csdn.net/u014222687/article/details/51767685" target="_blank" rel="noopener">Block与Self的循环引用</a></li>
<li><p><a href="http://www.cocoachina.com/ios/20170122/18601.html" target="_blank" rel="noopener">ARC下用块（block）的循环引用问题样例探究</a></p>
</li>
<li><p><a href="https://blog.csdn.net/y_csdnblog_xx/article/details/51483111" target="_blank" rel="noopener">ReactiveCocoa之RAC内存管理（十二）</a></p>
</li>
<li><a href="https://www.jianshu.com/p/16b78d72dc95" target="_blank" rel="noopener">ReactiveCocoa入门教程——第二部分</a></li>
<li><a href="https://www.jianshu.com/p/16e8e2e5773c" target="_blank" rel="noopener">subscribenext 循环引用</a></li>
</ul>
<p></p><p id="常见笔试/面试题"></p><p></p>
<h2 id="常见笔试-面试题"><a href="#常见笔试-面试题" class="headerlink" title="常见笔试/面试题"></a>常见笔试/面试题</h2><p><a href="#目录">&lt; 返回目录</a></p>
<h6 id="block和weak修饰符的区别是什么？"><a href="#block和weak修饰符的区别是什么？" class="headerlink" title="block和weak修饰符的区别是什么？"></a><strong>block和</strong>weak修饰符的区别是什么？</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，在MRC时代，__block修饰，可以避免循环引用；ARC时代，__block修饰，同样会引起循环引用问题；</span><br><span class="line">2，__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型；</span><br><span class="line">3，__weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；</span><br><span class="line">4，__block对象可以在block中被重新赋值，__weak不可以；</span><br></pre></td></tr></table></figure>
<p></p><p id="END"></p><p></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote>
<p><a href="#目录">&lt; 返回目录</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/iOS/3必备知识架构/2内存/2内存-②循环引用/" data-id="cm1p887d3017hzwr4qz0x8z6t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Architecture架构/架构相关/3组件化/5框架设计模式-⑦组件化" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/Architecture架构/架构相关/3组件化/5框架设计模式-⑦组件化/" class="article-date">
  <time datetime="2024-08-31T20:18:25.441Z" itemprop="datePublished">2024-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="框架设计模式-⑦组件化"><a href="#框架设计模式-⑦组件化" class="headerlink" title="框架设计模式-⑦组件化"></a>框架设计模式-⑦组件化</h1><p>[toc]</p>
<p>好文分享：</p>
<ul>
<li><p><a href="https://www.cnblogs.com/dins/p/ios-zu-jian-hua-fang-an.html" target="_blank" rel="noopener">iOS 组件化方案</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/67a6004f6930" target="_blank" rel="noopener">组件化架构漫谈</a></p>
</li>
<li><p><a href="https://tech.youzan.com/you-zan-ioszu-jian-hua-jia-gou-she-ji-shi-jian/" target="_blank" rel="noopener">有赞移动 iOS 组件化（模块化）架构设计实践</a></p>
</li>
</ul>
<h2 id="一、概念了解"><a href="#一、概念了解" class="headerlink" title="一、概念了解"></a>一、概念了解</h2><h4 id="1、组件化"><a href="#1、组件化" class="headerlink" title="1、组件化"></a>1、组件化</h4><blockquote>
<p>​    就是<strong>“基础库”</strong>或者<strong>“基础组件”，</strong>意思是把代码重复的部分提炼出一个个组件供给功能使用。</p>
<p>​    使用：Dialog，各种自定义的UI控件、能在项目或者不同项目重复应用的代码等等。</p>
<p>​    目的：复用，解耦。</p>
<p>​    依赖：组件之间低依赖，比较独立。</p>
<p>​    架构定位：纵向分层（位于架构底层，被其他层所依赖）。</p>
</blockquote>
<h4 id="2、模块化"><a href="#2、模块化" class="headerlink" title="2、模块化"></a>2、模块化</h4><blockquote>
<p>​    就是<strong>“业务框架”</strong>或者<strong>“业务模块”</strong>，也可以理解为“框架”，意思是把功能进行划分，将同一类型的代码整合在一起，所以模块的功能相对复杂，但都同属于一个业务。</p>
<p>​    使用：按照项目功能需求划分成不同类型的业务框架（例如：注册、登录、外卖、直播…..）</p>
<p>​    目的：隔离/封装 （高内聚）。</p>
<p>​    依赖：模块之间有依赖的关系，可通过路由器进行模块之间的耦合问题。</p>
<p>​    架构定位：横向分块（位于架构业务框架层）。</p>
</blockquote>
<h4 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h4><p>​      其实组件相当于<strong>库</strong>，把一些能在<strong>项目里或者不同类型项目中</strong>可复用的代码进行工具性的封装。</p>
<p>​      而模块相应于<strong>业务逻辑模块</strong>，把<strong>同一类型项目里</strong>的功能逻辑进行进行需求性的封装。</p>
<h2 id="二、组件化的必要性-产生背景"><a href="#二、组件化的必要性-产生背景" class="headerlink" title="二、组件化的必要性/产生背景"></a>二、组件化的必要性/产生背景</h2><p>1、产生背景：</p>
<p>所有模块代码都编写在一个项目中，在项目越来越大后，<strong>测试/使用某个模块或功能，需要编译运行整个项目，麻烦</strong>。</p>
<p>2、组件化思路：</p>
<p>将每个模块作为一个组件，加一个<strong>中间层</strong>来协调各个模块间的调用，<strong>所有的模块间的调用都会经过中间层中转。</strong>（<strong>只让其他模块对中间层产生耦合关系，中间层不对其他模块发生耦合</strong>。）</p>
<p>3、组件化好处：</p>
<blockquote>
<p>业务划分更佳清晰，新人接手更佳容易，可以按组件分配开发任务。</p>
<p>项目可维护性更强，提高开发效率。</p>
<p>更好排查问题，某个组件出现问题，直接对组件进行处理。</p>
<p>开发测试过程中，可以只编译自己那部分代码，不需要编译整个项目代码。</p>
<p>方便集成，项目需要哪个模块直接通过<code>CocoaPods</code>集成即可。</p>
</blockquote>
<h2 id="三、组件化设计思路1：有管理中心"><a href="#三、组件化设计思路1：有管理中心" class="headerlink" title="三、组件化设计思路1：有管理中心"></a>三、组件化设计思路1：有管理中心</h2><p>完整的项目：<a href="https://github.com/dvlproad/033-Data-Notification-iOS" target="_blank" rel="noopener">https://github.com/dvlproad/033-Data-Notification-iOS</a></p>
<h3 id="1、核心思想"><a href="#1、核心思想" class="headerlink" title="1、核心思想"></a>1、核心思想</h3><p>启动时候注册关系表，执行时候遍历关系表</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心思想1：注册，以统一管理，后续调用时候，从注册表中查询并执行对应的操作</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">register</span>(url, handle) &#123;</span><br><span class="line">  model.url = url;</span><br><span class="line">  model.handle = handle;</span><br><span class="line">  models.add(model); <span class="comment">// 问题1:用什么管理所有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心思想2：执行，遍历在注册表中的所有操作，找到对应的操作后进行执行</span></span><br><span class="line"><span class="keyword">void</span> exec(url) &#123;</span><br><span class="line">  <span class="keyword">for</span> (var model <span class="keyword">in</span> models) &#123;</span><br><span class="line">    <span class="keyword">if</span> (model.url == url) &#123;</span><br><span class="line">      model.handle();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、实现方案"><a href="#2、实现方案" class="headerlink" title="2、实现方案"></a>2、实现方案</h3><h4 id="2-1、方案1：Url-block-路由器"><a href="#2-1、方案1：Url-block-路由器" class="headerlink" title="2.1、方案1：Url+block   路由器"></a>2.1、方案1：Url+block   路由器</h4><p>缺点：入参，取参不明显。</p>
<h4 id="2-2、方法2：protocal-class"><a href="#2-2、方法2：protocal-class" class="headerlink" title="2.2、方法2：protocal - class"></a>2.2、方法2：protocal - class</h4><p>将要执行的方法统一放到类中，通过protocal或者类。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 protocal 查找 class</span></span><br><span class="line"><span class="comment">// 方法1（可一对多）：为 protocal 添加监听者数组属性（通过runtime，形成类似于 protocal.listeners ），</span></span><br><span class="line"><span class="built_in">NSHashTable</span> *protocalListeners = objc_getAssociatedObject(protocol, CJ_BROADCAST_PROTOCOL_LISTENER); <span class="comment">// 找到之前绑定到这个protocal上的监听者列表。</span></span><br><span class="line">objc_setAssociatedObject(protocol, CJ_BROADCAST_PROTOCOL_LISTENER, protocalListeners, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">注册的时候 [protocalListeners addObject:listener];</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法2（只能一对一）：以 protocal 为 key , 通过 protocal 存取 module 模块(模块自身遵循协议)</span></span><br><span class="line"><span class="comment">// 创建一个NSMapTable实例，其中键是强引用，值是弱引用</span></span><br><span class="line"><span class="built_in">NSMapTable</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSObject</span> *&gt; *weakRefHashTable = [<span class="built_in">NSMapTable</span> strongToStrongObjectsMapTable];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向哈希表中添加一个键值对</span></span><br><span class="line"><span class="built_in">NSString</span> *key = <span class="string">@"someKey"</span>;</span><br><span class="line"><span class="built_in">NSObject</span> *value = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">[weakRefHashTable setObject:value forKey:key];</span><br></pre></td></tr></table></figure>
<p>模块协议拆分为多个子协议，用户</p>
<p>网络处理协议、数据管理协议（单独）、用户界面更新协议</p>
<p>改进思想</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、发起请求(LoginViewController)</span></span><br><span class="line"><span class="keyword">id</span>&lt;OrderModulePublic&gt; moduler = [[CJMoudleManager shared] modulerForProtocal:@protocal(OrderModulePublic)];</span><br><span class="line"><span class="built_in">UIViewController</span> *vc = [moduler orderViewControllerWithPageType:xxx];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、实现请求(TSOrderModuleImpl)</span></span><br><span class="line">[CJProtocolCenter addModule:<span class="keyword">self</span> forProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">OrderModulePublic</span>)];</span></span><br><span class="line"><span class="meta">#pragma mark - OrderModulePublic</span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)orderViewControllerWithPageType:(<span class="keyword">int</span>)pageType</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码还可以演变成实现通知的一种形式（当注入的类中，有多个类都遵循了(实际上不应该出现)模块协议时候）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、发起请求(LoginViewController)</span></span><br><span class="line"><span class="built_in">NSMutableSet</span>&lt;<span class="keyword">id</span>&lt;CJUserServiceProtocolForModule&gt;&gt; listener = [[CJMoudleManager shared] listenersForProtocal:@protocal(CJUserServiceProtocolForModule)];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span>&lt;CJUserServiceProtocolForModule&gt; listener <span class="keyword">in</span> listeners) &#123;</span><br><span class="line">  [listener userNameUpadte:userName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、实现请求(OrderHomeViewController)</span></span><br><span class="line">[CJProtocolCenter addModule:<span class="keyword">self</span> forProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">CJUserServiceProtocolForModule</span>)];</span></span><br><span class="line"><span class="meta">#pragma mark - CJUserServiceProtocolForModule</span></span><br><span class="line">- (<span class="keyword">void</span>)userNameUpadte:(<span class="built_in">NSString</span> *)userName</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下列图片来源于 《<a href="../../架构相关/1架构模式/架构模式-①概览/架构分层.graffle">架构分层.graffle</a>》 中的【三、模块间设计】</p>
<p>跳转的使用示例：</p>
<blockquote>
<p><img src="/Architecture架构/架构相关/3组件化/5框架设计模式-⑦组件化/modular_CJProtocalManager 跳转.png" alt="modular_CJProtocalManager 跳转"></p>
</blockquote>
<p>通知的实现示例：</p>
<blockquote>
<p><img src="/Architecture架构/架构相关/3组件化/5框架设计模式-⑦组件化/modular_CJProtocalManager 通知.png" alt="modular_CJProtocalManager 通知"></p>
</blockquote>
<p>跳转 + 数据变化后内部通知的实现示例：</p>
<blockquote>
<p><img src="/Architecture架构/架构相关/3组件化/5框架设计模式-⑦组件化/modular_CJProtocalManager 跳转 + 数据变化后内部通知.png" alt="modular_CJProtocalManager 跳转 + 数据变化后内部通知"></p>
</blockquote>
<h2 id="四、组件化设计思路2：无管理中心"><a href="#四、组件化设计思路2：无管理中心" class="headerlink" title="四、组件化设计思路2：无管理中心"></a>四、组件化设计思路2：无管理中心</h2><p>项目示例：<a href="https://github.com/dvlproad/CJStandardProject/blob/fb796e4f5c3d30c3942e7fe088bba6cc406b6c01/CJStandardProjectDemo/Pods/CJDemoModuleMainMediator/CJDemoModuleMainMediator/CTMediator%2BCJDemoModuleMain.m" target="_blank" rel="noopener">CJStandardProject 中 CTMediator+CJDemoModuleMain.h </a></p>
<h3 id="1、核心思想-1"><a href="#1、核心思想-1" class="headerlink" title="1、核心思想"></a>1、核心思想</h3><p><strong>核心思想：直接执行，让系统通过反射来找到要响应事件的类和方法</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> exec(target, action, params) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、实现方案-1"><a href="#2、实现方案-1" class="headerlink" title="2、实现方案"></a>2、实现方案</h3><h4 id="2-1、方案1：CTMediator-target-action-param"><a href="#2-1、方案1：CTMediator-target-action-param" class="headerlink" title="2.1、方案1：CTMediator target+action+param"></a>2.1、方案1：CTMediator target+action+param</h4><p>实现示例：</p>
<p><img src="/Architecture架构/架构相关/3组件化/5框架设计模式-⑦组件化/modular_CTMediator target+action+param.png" alt="modular_CTMediator target+action+param"></p>
<h4 id="2-2、方案2：XXXService-Implemention"><a href="#2-2、方案2：XXXService-Implemention" class="headerlink" title="2.2、方案2：XXXService+Implemention"></a>2.2、方案2：XXXService+Implemention</h4><p><img src="/Architecture架构/架构相关/3组件化/5框架设计模式-⑦组件化/modular_XXXService+Implemention.png" alt="modular_XXXService+Implemention"></p>
<h2 id="五、组件化实施过程的思考"><a href="#五、组件化实施过程的思考" class="headerlink" title="五、组件化实施过程的思考"></a>五、组件化实施过程的思考</h2><h3 id="1、架构分层"><a href="#1、架构分层" class="headerlink" title="1、架构分层"></a>1、架构分层</h3><p>整个APP架构上从上到下分为<strong>三层</strong>，独立于APP的通用层，通用业务层，业务层。</p>
<p><img src="/Architecture架构/架构相关/3组件化/5框架设计模式-⑦组件化/架构分层1.png" alt="架构分层1" style="zoom: 33%;"></p>
<h4 id="1-1、独立于APP的通用层"><a href="#1-1、独立于APP的通用层" class="headerlink" title="1.1、独立于APP的通用层"></a>1.1、独立于APP的通用层</h4><p>此层常为：一些Cocoapods公有库或者自己编写的独立于APP的库。</p>
<p>举例：MJExtension、CJNetwork、分享、CJOverlayKit(Toast、HUD、ActionSheet)、CJShareList</p>
<h4 id="1-2、每个APP自己的通用层"><a href="#1-2、每个APP自己的通用层" class="headerlink" title="1.2、每个APP自己的通用层"></a>1.2、每个APP自己的通用层</h4><p>此层常为：前面的独立于APP的通用层的二次封装。若公司内部引用了第三方库，按照依赖倒置的原则，建议封装一层之后放到Basic Specs供业务方使用。好处：跟外部环境有效隔离，第三方库发生问题，公司内部可控。</p>
<p>如：CQNetwork、CQOverlayKit、CQShareKit、网络库CQNetwork、数据库(FMDB/WCDB)、缓存库等</p>
<p>依赖倒置原则告诉我们要面向接口编程；通过抽象（接口或抽象类）使各个类或模块实现彼此独立，互不影响，实现模块间的松耦合。</p>
<h4 id="1-3、业务模块"><a href="#1-3、业务模块" class="headerlink" title="1.3、业务模块"></a>1.3、业务模块</h4><p>业务层的模块应该按照模块化的设计思想，尽量做到高度的“高内聚，低耦合”。</p>
<p>因模块高度独立，且高频使用，若公司内部有多个App同时需要依赖，建议单独创建私有库Specs。</p>
<h2 id="iOS端APP架构设计心得"><a href="#iOS端APP架构设计心得" class="headerlink" title="iOS端APP架构设计心得"></a>iOS端APP架构设计心得</h2><ul>
<li><a href="https://www.jianshu.com/p/0ea6b72ea1a3" target="_blank" rel="noopener">iOS端APP架构设计心得</a></li>
<li><a href="https://mobile.51cto.com/hot-600305.htm" target="_blank" rel="noopener">对于App架构和组件化的思考</a></li>
</ul>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/Architecture架构/架构相关/3组件化/5框架设计模式-⑦组件化/" data-id="cm1p886zx0142zwr4rzrbmv4f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Architecture架构/监控相关/日志系统" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/Architecture架构/监控相关/日志系统/" class="article-date">
  <time datetime="2024-08-28T09:08:41.000Z" itemprop="datePublished">2024-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Architecture/">Architecture</a>►<a class="article-category-link" href="/categories/Architecture/第九章：监控相关/">第九章：监控相关</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Architecture架构/监控相关/日志系统/">日志系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h2 id="前言：主要事项"><a href="#前言：主要事项" class="headerlink" title="前言：主要事项"></a>前言：主要事项</h2><p>1、异常数据的发现及补充、日志分类优化<br>2、日志数据的文件保存、滚动存储<br>3、日志文件上传<br>4、日志回捞</p>
<h2 id="一、日志收集"><a href="#一、日志收集" class="headerlink" title="一、日志收集"></a>一、日志收集</h2><h3 id="1、日志分类"><a href="#1、日志分类" class="headerlink" title="1、日志分类"></a>1、日志分类</h3><h4 id="1-1、日志目标"><a href="#1-1、日志目标" class="headerlink" title="1.1、日志目标"></a>1.1、日志目标</h4><table>
<thead>
<tr>
<th>序号</th>
<th>目标(Target)</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>app</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>sdk</td>
<td>三方库</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>h5</td>
<td>网页</td>
</tr>
</tbody>
</table>
<p><a name="日志类型"></a></p>
<h4 id="1-2、日志类型"><a href="#1-2、日志类型" class="headerlink" title="1.2、日志类型"></a>1.2、日志类型</h4><table>
<thead>
<tr>
<th>序号</th>
<th>类型</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>api_app</td>
<td>app中的网络请求</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>api_app_cache</td>
<td>app中的网络请求的网络缓存请求</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>api_buriedPoint</td>
<td>埋点的网络请求</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>sdk_other</td>
<td>sdk的各种事件(初始化等)</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>sdk_api</td>
<td>sdk中的网络请求</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>dart</td>
<td>语法</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>widget</td>
<td>视图(布局像素越界等)</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>click_other</td>
<td>点击、</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>click_share</td>
<td>分享</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>native_route</td>
<td>路由/跳转</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>h5_route</td>
<td>与网页跳转有关</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>h5_js</td>
<td>js交互</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>monitor_network</td>
<td>监控：网络类型变化</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>monitor_lifecycle</td>
<td>监控：生命周期变化</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>buriedPoint_other</td>
<td>埋点数据生成等</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>im</td>
<td>IM</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>heartbeat</td>
<td>心跳</td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>other</td>
<td>其他</td>
</tr>
</tbody>
</table>
<h3 id="2、日志等级"><a href="#2、日志等级" class="headerlink" title="2、日志等级"></a>2、日志等级</h3><table>
<thead>
<tr>
<th>序号</th>
<th>目标(Level)</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Normal</td>
<td>正常信息(目前用于请求开始)</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>Success</td>
<td>成功信息(目前用于请求结束：成功)</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>Warning</td>
<td>警告信息(目前用于请求结束：报错)</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>Error</td>
<td>错误日志(目前用于请求结束：失败)</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>Dangerous</td>
<td>危险(处理白屏等)</td>
<td>一般会<strong>进行额外的埋点</strong></td>
</tr>
</tbody>
</table>
<p><a name="日志整合归类"></a></p>
<h3 id="3、日志整合归类"><a href="#3、日志整合归类" class="headerlink" title="3、日志整合归类"></a>3、日志整合归类</h3><table>
<thead>
<tr>
<th>序号</th>
<th>列表</th>
<th>标志</th>
<th>包含</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>全部</td>
<td>all</td>
<td>所有</td>
</tr>
<tr>
<td>2</td>
<td>警告</td>
<td>warning</td>
<td>所有的警告</td>
</tr>
<tr>
<td>3</td>
<td>错误</td>
<td>error</td>
<td>所有的错误</td>
</tr>
<tr>
<td>4</td>
<td>接口</td>
<td>api</td>
<td>api_app、api_cache(不包括sdk_api、api_buriedPoint)</td>
</tr>
<tr>
<td>5</td>
<td>点击</td>
<td>click</td>
<td>click_share、click_other、h5_js</td>
</tr>
<tr>
<td>6</td>
<td>路由</td>
<td>route</td>
<td>navite_route、h5_route</td>
</tr>
<tr>
<td>7</td>
<td>网页</td>
<td>H5</td>
<td>h5_route、h5_js</td>
</tr>
<tr>
<td>8</td>
<td>sdk</td>
<td>sdk</td>
<td>sdk_api、sdk_other</td>
</tr>
<tr>
<td>9</td>
<td>code</td>
<td>code</td>
<td>dart、widget</td>
</tr>
<tr>
<td>10</td>
<td>埋点</td>
<td>buriedPoint</td>
<td>api_buriedPoint、buriedPoint_other</td>
</tr>
<tr>
<td>11</td>
<td>监控</td>
<td>monitor</td>
<td>monitor_lifecycle、monitor_network</td>
</tr>
<tr>
<td>12</td>
<td>其他</td>
<td>other</td>
<td>other</td>
</tr>
<tr>
<td>13</td>
<td>api结果</td>
<td>api_result</td>
<td>type=api_app &amp; level != Normal</td>
</tr>
<tr>
<td>14</td>
<td>im</td>
<td>im</td>
<td>本地缓存消息、历史消息、收到的消息等</td>
</tr>
<tr>
<td>15</td>
<td>心跳</td>
<td>heartbeat</td>
</tr>
</tbody>
</table>
<p><img src="/Architecture架构/监控相关/日志系统/devtool_log_home_page.gif" alt="devtool_log_home_page" style="zoom:50%;"></p>
<h3 id="4、日志的补充收集及其策略"><a href="#4、日志的补充收集及其策略" class="headerlink" title="4、日志的补充收集及其策略"></a>4、日志的补充收集及其策略</h3><p>要收集的数据已在上述《<a href="#日志类型">1.2、日志类型</a>》中说明。</p>
<h4 id="4-1、页面跳转"><a href="#4-1、页面跳转" class="headerlink" title="4.1、页面跳转"></a>4.1、页面跳转</h4><p>详见上述 《<a href="#日志整合归类">3、日志整合归类</a>》中的”路由”</p>
<h4 id="4-2、截断的收集"><a href="#4-2、截断的收集" class="headerlink" title="4.2、截断的收集"></a>4.2、截断的收集</h4><table>
<thead>
<tr>
<th>序号</th>
<th>关键字</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>break</td>
<td>for 、 swtich</td>
</tr>
<tr>
<td>2</td>
<td>return</td>
</tr>
</tbody>
</table>
<h4 id="4-3、用户关键行为"><a href="#4-3、用户关键行为" class="headerlink" title="4.3、用户关键行为"></a>4.3、用户关键行为</h4><table>
<thead>
<tr>
<th>序号</th>
<th>行为</th>
<th>用途的场景说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>用户的资源选择</td>
<td>判断选择的本地资源是否上传到错误的存储桶</td>
</tr>
</tbody>
</table>
<h2 id="二、日志数据的文件保存、滚动存储"><a href="#二、日志数据的文件保存、滚动存储" class="headerlink" title="二、日志数据的文件保存、滚动存储"></a>二、日志数据的文件保存、滚动存储</h2><h3 id="1、数据的文件保存"><a href="#1、数据的文件保存" class="headerlink" title="1、数据的文件保存"></a>1、数据的文件保存</h3><p>写入xlog文件中。</p>
<h3 id="2、数据的文件滚动存储"><a href="#2、数据的文件滚动存储" class="headerlink" title="2、数据的文件滚动存储"></a>2、数据的文件滚动存储</h3><h4 id="2-1、日志的过期清理"><a href="#2-1、日志的过期清理" class="headerlink" title="2.1、日志的过期清理"></a>2.1、日志的过期清理</h4><p>1、本地日志文件结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- Document</span><br><span class="line">	-- log</span><br><span class="line">		-- 2020-10-01</span><br><span class="line">			-- xlog_2020-10-01_1.xlog</span><br><span class="line">			-- xlog_2020-10-01_2.xlog</span><br><span class="line">		-- 2020-10-18</span><br><span class="line">			-- xlog_2020-10-18_1.xlog</span><br></pre></td></tr></table></figure>
<p>2、日志保留清理的配置信息(摘自/同 下文的日志接口中的《日志文件配置信息》)</p>
<blockquote>
<table>
<thead>
<tr>
<th>序号</th>
<th>说明</th>
<th>字段</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口回值1</td>
<td>最多保留几个天的日志目录</td>
<td>maxDayDirCount</td>
<td>7</td>
</tr>
<tr>
<td>接口回值2</td>
<td>最多每天保留几个文件</td>
<td>maxDayFileCount</td>
<td>10</td>
</tr>
<tr>
<td>接口回值3</td>
<td>每个日志文件超过多少后创建新文件</td>
<td>perFileMaxMB</td>
<td>5</td>
</tr>
</tbody>
</table>
</blockquote>
<p>3、清理方案</p>
<p><strong>清理时机：在切换前后台的时候，</strong></p>
<ul>
<li>日志配置信息的更新</li>
<li>根据最新的日志配置信息，延迟10s后(避免影响启动)，进行清理判断及清理<ul>
<li>遍历总日志目录 Document/log 下的所有日志文件夹</li>
<li>如果天日志文件夹<strong>个数</strong>超过保留个数（避免是用保留时间，导致保留时间内只有一个日志，也被删掉），则按顺序删除早期日志<ul>
<li>遍历天日志目录 Document/log/yyyy-MM-dd 下的所有日志文件夹</li>
<li>如果天日志文件夹<strong>个数</strong>超过保留个数（避免是用保留时间，导致保留时间内只有一个日志，也被删掉），则按顺序删除早期日志</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-2、日志文件的滚动写入"><a href="#2-2、日志文件的滚动写入" class="headerlink" title="2.2、日志文件的滚动写入"></a>2.2、日志文件的滚动写入</h4><p>要增加的日志记录，如果添加后会超过日志文件的大小，则使用新文件写入。</p>
<p><strong>细节点</strong>：<br>1、日志文件的大小判断，不要每次都去读取文件，而是记录住大小变化<br>2、日志不要有一条写一条，而是使用写入缓冲区+定时器，5s尝试写入一次</p>
<h3 id="3、数据的加密、解密"><a href="#3、数据的加密、解密" class="headerlink" title="3、数据的加密、解密"></a>3、数据的加密、解密</h3><p>1、加密：</p>
<p>写入日志字符串时候，对编码后的字节数据，额外增加一个三位随机值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// 使用 GZip 压缩算法将字符串进行压缩，并返回压缩后的字节数据（List&lt;int&gt; 类型）。</span></span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; _gzipCompressString(<span class="built_in">String</span> inputString) &#123;</span><br><span class="line">  <span class="keyword">final</span> codec = GZipCodec();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将输入字符串 inputString 编码为 UTF-8 格式的字节数据</span></span><br><span class="line">  <span class="keyword">final</span> encoded = utf8.encode(inputString);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对编码后的字节数据进行压缩，并返回压缩后的字节数据。</span></span><br><span class="line">  <span class="keyword">final</span> compressedData = codec.encode(encoded);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> compressedData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// 加密日志字符串</span></span></span><br><span class="line"><span class="built_in">String</span> _encryptLogString(<span class="built_in">String</span> logString) &#123;</span><br><span class="line">  <span class="keyword">final</span> compressedData = _gzipCompressString(logString); <span class="comment">// 压缩字符串，并返回压缩后的字节数据（List&lt;int&gt; 类型）</span></span><br><span class="line">  <span class="keyword">final</span> randomNumber = Random().nextInt(<span class="number">800</span>) + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">final</span> confound = compressedData.toString().substring(<span class="number">0</span>, compressedData.toString().length - <span class="number">1</span>) + <span class="string">", <span class="subst">$randomNumber</span>]"</span>; <span class="comment">// 在压缩后的字符串尾部加上一个随机字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> confound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、解密：</p>
<p>使用python脚本对log文件进行解密</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取.clog文件并解析数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_clog_file</span><span class="params">(input_file)</span>:</span></span><br><span class="line">    parsed_data = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(input_file, <span class="string">'r'</span>) <span class="keyword">as</span> clog_file:</span><br><span class="line">        current_data = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> clog_file:</span><br><span class="line">            <span class="keyword">if</span> current_data:</span><br><span class="line">                parsed_data.append(current_data)</span><br><span class="line">            binary_data = line[:<span class="number">-6</span>] + <span class="string">']'</span> <span class="comment"># 去除加密时候额外添加的三位随机数</span></span><br><span class="line">            byte_data = bytes(eval(binary_data))</span><br><span class="line">            decompressed_data = gzip.decompress(byte_data)</span><br><span class="line">            <span class="comment"># current_data = byte_data.decode('utf-8')</span></span><br><span class="line">            print(decompressed_data)</span><br><span class="line">            current_data = decompressed_data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加最后一个数据条目</span></span><br><span class="line">        <span class="keyword">if</span> current_data:</span><br><span class="line">            parsed_data.append(current_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parsed_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将解析后的数据写入与输入文件同名的.log文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_log_file</span><span class="params">(parsed_data, input_file)</span>:</span></span><br><span class="line">    base_name = os.path.splitext(input_file)[<span class="number">0</span>]</span><br><span class="line">    output_file = base_name + <span class="string">".log"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(output_file, <span class="string">'w'</span>) <span class="keyword">as</span> log_file:</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> parsed_data:</span><br><span class="line">            log_file.write(data + <span class="string">"\n"</span>)</span><br><span class="line">            log_file.write(<span class="string">"\n"</span>)</span><br><span class="line">            log_file.write(<span class="string">"================================================================================================="</span> + <span class="string">"\n"</span>)</span><br><span class="line">            log_file.write(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">"Usage: python script.py &lt;clogFileName&gt;"</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    input_clog_file = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析.clog文件</span></span><br><span class="line">    parsed_data = parse_clog_file(input_clog_file)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将解析后的数据写入与输入文件同名的.log文件</span></span><br><span class="line">    write_to_log_file(parsed_data, input_clog_file)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"Log data parsed from <span class="subst">&#123;input_clog_file&#125;</span> and written to <span class="subst">&#123;input_clog_file&#125;</span>.log."</span>)</span><br></pre></td></tr></table></figure>
<h2 id="三、日志文件上传"><a href="#三、日志文件上传" class="headerlink" title="三、日志文件上传"></a>三、日志文件上传</h2><h3 id="1、日志文件命名及目录规范"><a href="#1、日志文件命名及目录规范" class="headerlink" title="1、日志文件命名及目录规范"></a>1、日志文件命名及目录规范</h3><p>以用户<code>1000001</code>在<code>2020-01</code>时候上传<code>声音文件 beautiful_scenery.aac</code>为例，其路径完整示例如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://media.xxx.com/app1_test1/audio/1/1000001/2020-01/beautiful_scenery.aac</span></span><br></pre></td></tr></table></figure>
<p>要上传的存储桶：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>说明</th>
<th>参数</th>
<th>约定值示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>存储桶region<br>regionGetFunction</td>
<td>网络环境</td>
<td>ap-shanghai</td>
</tr>
<tr>
<td>2</td>
<td>存储桶bucket<br>bucketGetFunction</td>
<td>网络环境</td>
<td>xxx-pro-image-1302324914</td>
</tr>
<tr>
<td>3</td>
<td>上传成功后，桶的映射路径值<br>cosFileUrlPrefixGetFunction</td>
<td></td>
<td>1、图片桶：<a href="https://images.xxx.com/" target="_blank" rel="noopener">https://images.xxx.com/</a><br>2、媒体桶：<a href="https://media.xxx.com/" target="_blank" rel="noopener">https://media.xxx.com/</a><br>3、日志桶：<a href="https://static.xxx.com/" target="_blank" rel="noopener">https://static.xxx.com/</a></td>
</tr>
<tr>
<td>4</td>
<td>要上传到桶的哪个相对路径下<br>cosFileRelativePathGetFunction<br>上传成功后完整路径=以上桶值+此相对路径<br></td>
<td>见下文</td>
<td>见下文<br>eg：app1_test1/audio/1/1000001/2020-01/beautiful_scenery.aac</td>
</tr>
</tbody>
</table>
<p>《要上传到桶的哪个相对路径下 <strong>cosFileRelativePathGetFunction</strong> 》的文件路径分批说明：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>层次说明</th>
<th>层次值算法</th>
<th>层次值描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1</td>
<td>存储桶里相对路径的前缀</td>
<td>app标志_环境标志<br>eg：app1_pro、app1_test1、app1_dev1</td>
<td>文件区分</td>
</tr>
<tr>
<td>1.2</td>
<td>是否在存储桶里进行进一步路径区分(可选)</td>
<td>根据场景决定是否对桶进行进一步分类。<br>if ( mediaType == xxx ) {<br>     if(mediaScene == yyy) {<br>     <br>     }<br>}</td>
<td>如<br>1、都是图片，但自拍图片要求独立出来<br>2、都是多媒体，但音视频要区分开</td>
</tr>
<tr>
<td>2.1</td>
<td>用户1级</td>
<td>int.parse(uid) % 1000; // 取余数</td>
<td>用户名取余，有效减少同层上文件夹个数</td>
</tr>
<tr>
<td>2.2</td>
<td>用户2级</td>
<td>uid</td>
<td>用户名</td>
</tr>
<tr>
<td>3</td>
<td>年月</td>
<td>DateTime.now().toString().substring(0, 7);</td>
<td>年-月</td>
</tr>
<tr>
<td>4</td>
<td>文件名</td>
<td>${fileOriginName}_<br>${DateTime.now().microsecondsSinceEpoch}<br>.$fileExtensionType</td>
<td>文件名</td>
</tr>
</tbody>
</table>
<p>附1：MediaType 媒体类型</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>UploadMediaType 媒体类型</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>unkonw</td>
<td>未知（默认值）</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>image</td>
<td>图片</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>audio</td>
<td>音频</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>video</td>
<td>视频</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>xlog</td>
<td>日志文件</td>
</tr>
</tbody>
</table>
<p>附2：MediaScene场景 说明</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>UploadMediaScene场景</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>unkonw</td>
<td>未知（默认值）</td>
</tr>
<tr>
<td>2</td>
<td>selfie</td>
<td>自拍（安全等级较多）</td>
</tr>
<tr>
<td>3</td>
<td>im</td>
<td>会话聊天</td>
</tr>
<tr>
<td>4</td>
<td>live</td>
<td>直播</td>
</tr>
</tbody>
</table>
<h2 id="四、日志接口"><a href="#四、日志接口" class="headerlink" title="四、日志接口"></a>四、日志接口</h2><h3 id="1、日志记录接口（区别于回捞接口，需要在回捞前就有日志信息）"><a href="#1、日志记录接口（区别于回捞接口，需要在回捞前就有日志信息）" class="headerlink" title="1、日志记录接口（区别于回捞接口，需要在回捞前就有日志信息）"></a>1、日志记录接口（区别于回捞接口，需要在回捞前就有日志信息）</h3><p>1、是否记录日志的开关及其配置信息</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>说明</th>
<th>字段</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>网页配置1</td>
<td>是否开启日志记录</td>
<td>isLogOn</td>
<td>1:开启、其他:关</td>
</tr>
<tr>
<td>网页配置2</td>
<td>要开启日志的用户(灰度上线)<br>(当且仅当开启上述日志记录时有效)<br>📢：未配置但开关为开时为全记录</td>
<td>logUserids</td>
<td>[“101”, “102”]</td>
</tr>
<tr>
<td>网页配置3</td>
<td>要开启日志的设备(灰度上线)<br>(当且仅当开启上述日志记录时有效)<br>📢：未配置但开关为开时为全记录</td>
<td>logDeviceIds</td>
<td>[“udid001”, “udid002”]</td>
</tr>
<tr>
<td>接口回值1</td>
<td>是否进行日志记录(灰度上线)</td>
<td>needLog</td>
<td>1:记录、其他:不记录</td>
</tr>
</tbody>
</table>
<p>2、不需要记录什么日志信息</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>说明</th>
<th>字段</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口回值1</td>
<td>不需要记录的日志类型</td>
<td>ignoreLogLevel</td>
<td>[“Normal”, “Success”]</td>
</tr>
<tr>
<td>接口回值2</td>
<td>不需要记录的日志等级</td>
<td>ignoreLogType</td>
<td>[“api_buriedPoint”, “buriedPoint_other”]</td>
</tr>
</tbody>
</table>
<p>3、日志文件配置信息</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>说明</th>
<th>字段</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口回值1</td>
<td>最多保留几个天的日志目录</td>
<td>maxDayDirCount</td>
<td>7</td>
</tr>
<tr>
<td>接口回值2</td>
<td>最多每天保留几个文件</td>
<td>maxDayFileCount</td>
<td>10</td>
</tr>
<tr>
<td>接口回值3</td>
<td>每个日志文件超过多少后创建新文件</td>
<td>perFileMaxMB</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>4、日志文件问题回滚</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>说明</th>
<th>字段</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>网页配置1</td>
<td>强制删除什么时间前的日志</td>
<td>removeLogBeforeDate</td>
<td>2020-12-31</td>
</tr>
<tr>
<td>网页配置2</td>
<td>强制删除哪个用户的日志</td>
<td>removeUserids</td>
<td>[“101”, “102”]</td>
</tr>
<tr>
<td>网页配置2</td>
<td>强制删除哪个设备的日志</td>
<td>logDeviceIds</td>
<td>[“udid001”, “udid002”]</td>
</tr>
<tr>
<td>接口回值1</td>
<td>强制删除什么时间前的日志(不删除时空)</td>
<td>removeLogBeforeDate</td>
<td>2020-12-31 或 空值</td>
</tr>
</tbody>
</table>
<p>接口名定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getLoggerConfig(userid, deviceId)</span><br></pre></td></tr></table></figure>
<p>接口结果的json示例如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"logConfig"</span>: &#123;</span><br><span class="line">		<span class="attr">"needLog"</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">"ignoreLogLevel"</span>: [<span class="string">"Normal"</span>, <span class="string">"Success"</span>],</span><br><span class="line">		<span class="attr">"ignoreLogType"</span>: [<span class="string">"api_buriedPoint"</span>, <span class="string">"buriedPoint_other"</span>],</span><br><span class="line">		<span class="attr">"maxDayDirCount"</span>: <span class="number">7</span>,</span><br><span class="line">		<span class="attr">"maxDayFileCount"</span>: <span class="number">10</span>,</span><br><span class="line">		<span class="attr">"perFileMaxMB"</span>: <span class="number">5</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"logRevert"</span>: &#123;</span><br><span class="line">		<span class="attr">"removeLogBeforeDate"</span>: <span class="string">"2020-12-31"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、日志回捞及问题回滚接口"><a href="#2、日志回捞及问题回滚接口" class="headerlink" title="2、日志回捞及问题回滚接口"></a>2、日志回捞及问题回滚接口</h3><p>1、日志回捞</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>说明</th>
<th>字段</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>网页配置1</td>
<td>要回捞日志的用户</td>
<td>salvageUserids</td>
<td>[“101”, “102”]</td>
</tr>
<tr>
<td>网页配置2</td>
<td>要回捞日志的设备</td>
<td>salvageDeviceIds</td>
<td>[“udid001”, “udid002”]</td>
</tr>
<tr>
<td>网页配置3</td>
<td>日志回捞的开始时间</td>
<td>salvageStartDate</td>
<td>2020-01-01</td>
</tr>
<tr>
<td>网页配置4</td>
<td>日志回捞的结束时间</td>
<td>salvageEndDate</td>
<td>2020-01-07</td>
</tr>
<tr>
<td>接口回值1</td>
<td>此用户此设备日志回捞的开始时间</td>
<td>salvageStartDate</td>
<td>2020-01-01</td>
</tr>
<tr>
<td>接口回值1</td>
<td>此用户此设备日志回捞的结束时间</td>
<td>salvageEndDate</td>
<td>2020-01-07</td>
</tr>
</tbody>
</table>
<p>2、日志文件问题回滚</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>说明</th>
<th>字段</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>网页配置1</td>
<td>强制删除什么时间前的日志</td>
<td>removeLogBeforeDate</td>
<td>2020-12-31</td>
</tr>
<tr>
<td>网页配置2</td>
<td>强制删除哪个用户的日志</td>
<td>removeUserids</td>
<td>[“101”, “102”]</td>
</tr>
<tr>
<td>网页配置2</td>
<td>强制删除哪个设备的日志</td>
<td>logDeviceIds</td>
<td>[“udid001”, “udid002”]</td>
</tr>
<tr>
<td>接口回值1</td>
<td>强制删除什么时间前的日志(不删除时空)</td>
<td>removeLogBeforeDate</td>
<td>2020-12-31 或 空值</td>
</tr>
</tbody>
</table>
<p>接口名定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getLoggerSalvageAndRevert(salvageUserids, salvageDeviceIds)</span><br></pre></td></tr></table></figure>
<p>接口结果的json示例如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"salvageId"</span>: <span class="string">"1001"</span>, </span><br><span class="line">	<span class="attr">"salvageStartDate"</span>: <span class="string">"2020-01-01"</span>,</span><br><span class="line">  <span class="attr">"salvageEndDate"</span>: <span class="string">"2020-01-07"</span>,</span><br><span class="line">	<span class="attr">"removeLogBeforeDate"</span>: <span class="string">"2020-12-31"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、日志文件上传到cos后同步给后台"><a href="#3、日志文件上传到cos后同步给后台" class="headerlink" title="3、日志文件上传到cos后同步给后台"></a>3、日志文件上传到cos后同步给后台</h3><p>用途：日志文件上传到cos后同步给后台，后台数据库记录每个用户，每个设备都捞到了什么数据。</p>
<p>接口名定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function addLoggerFile(userid, deviceId)</span><br></pre></td></tr></table></figure>
<p>接口结果的json示例如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、日志回捞"><a href="#四、日志回捞" class="headerlink" title="四、日志回捞"></a>四、日志回捞</h2><p>1、后台通过接口返回要回捞的信息。</p>
<p>2、前端用户在下次使用，收到后台信息时候，进行本地日志的上传。在腾云存储桶能收到对应日志，即代表成功。</p>
<h2 id="五、方案实施"><a href="#五、方案实施" class="headerlink" title="五、方案实施"></a>五、方案实施</h2><p>灰度方案：请参照 <a href="灰度系统">灰度系统 </a> 。（附：日志记录开关里目前已有灰度策略。）</p>
<p>目的：避免功能异常，出现集体性问题。</p>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/Architecture架构/监控相关/日志系统/" data-id="cm1p884qi008pzwr4ip89rfn8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Architecture/">Architecture</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-电脑使用/旧电脑数据清理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/电脑使用/旧电脑数据清理/" class="article-date">
  <time datetime="2024-08-27T09:03:10.752Z" itemprop="datePublished">2024-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="旧电脑-Mac-数据清理"><a href="#旧电脑-Mac-数据清理" class="headerlink" title="旧电脑(Mac)数据清理"></a>旧电脑(Mac)数据清理</h1><p>[TOC]</p>
<h2 id="清理项"><a href="#清理项" class="headerlink" title="清理项"></a>清理项</h2><p>系统偏好设置-用户与群组，左下角解锁点击加号添加一个新的管理员账号 点击左上角苹果图标，注销登陆新账号 同一个位置选择之前的账号点击减号删除 删除的时候选择删除文件就可以了</p>
<ul>
<li><p>AppleID(涉及appstore)</p>
<ul>
<li style="list-style: none"><input type="checkbox"> 系统设置里退出</li>
<li style="list-style: none"><input type="checkbox"> appStore –&gt; 商店 –&gt; 退出登录</li>
</ul>
</li>
<li><p>iCloud账号(涉及备忘录、提醒事项、Safari等)</p>
</li>
</ul>
<ul>
<li style="list-style: none"><input type="checkbox"> 设置 –&gt; iCloud</li>
</ul>
<ul>
<li><p>邮件、备忘录、提醒事项 清理</p>
<ul>
<li><p>[ ] 清理系统邮箱内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入 ~/Library/Containers/com.apple.mail/Data/Library/Mail Downloads</span><br><span class="line">请不要在终端用open命令，因为Mail Downloads这个有空格。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li style="list-style: none"><input type="checkbox"> 备忘录、提醒事项</li>
</ul>
<ul>
<li>钥匙串</li>
</ul>
<ul>
<li style="list-style: none"><input type="checkbox"> 清除系统钥匙串中的密码等相关</li>
</ul>
<ul>
<li><p>浏览器</p>
<ul>
<li style="list-style: none"><input type="checkbox"> Safari、Chrome账号&amp;密码</li>
</ul>
<blockquote>
<p>附：<a href="https://jingyan.baidu.com/article/e3c78d649cfbdd3c4c85f5af.html" target="_blank" rel="noopener">Mac如何查看Safari保存的密码</a></p>
</blockquote>
<ul>
<li style="list-style: none"><input type="checkbox"> Safari、Chrome浏览记录</li>
<li style="list-style: none"><input type="checkbox"> Safari、Chrome个人收藏</li>
</ul>
</li>
<li><p>微信记录<br>在输入框中输入 <code>~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/</code>，然后找到<code>com.tencent.xinWeChat</code>删除整个文件夹即可。</p>
</li>
<li><p>QQ记录<br>在输入框输入<code>~/Library/Containers/com.tencent.qq</code>，删除整个文件即可。</p>
</li>
<li><p>Keynote、Page等清除打开的文件记录</p>
<ul>
<li style="list-style: none"><input type="checkbox"> 打开软件 –&gt; 文件 –&gt; 打开最近使用 –&gt; 清除菜单</li>
</ul>
</li>
<li><p>应用软件账号删除(百度网盘、Evernote、SourceTree等)</p>
</li>
<li><p>其他</p>
<ul>
<li><p>iPhone模拟器重置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">顶部 -&gt; Erase All Content And Setting</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>应用软件删除</p>
</li>
<li><p>应用软件账号删除(百度网盘、Evernote、SourceTree等)</p>
</li>
<li><p>文件夹删除(文稿、图片、下载内容等)</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/电脑使用/旧电脑数据清理/" data-id="cm1p883li004gzwr4gvicwzek" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-总目录" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/总目录/" class="article-date">
  <time datetime="2024-08-08T02:39:52.000Z" itemprop="datePublished">2024-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/总目录/">总目录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h2 id="Architecture架构"><a href="#Architecture架构" class="headerlink" title="Architecture架构"></a>Architecture架构</h2><ul>
<li>第一章：架构相关<ul>
<li><a href="Architecture架构/架构相关/1架构模式/架构模式-①概览">第1.1节：架构模式-①概览</a><br>项目目录结构规范、架构分层、页面与服务类设计、依赖关系可视化</li>
<li><a href="Architecture架构/架构相关/1架构模式/架构模式-④MVC与MVVM">第1.2节：架构模式-④MVC与MVVM</a></li>
<li><a href="Architecture架构/架构相关/1架构细节/你真的会用RAC吗">第1.3节：架构细节-①你真的会用RAC吗</a></li>
<li><a href="Architecture架构/架构相关/2设计模式/设计模式-①概览">第2.1节：设计模式-①概览</a></li>
<li><a href="Architecture架构/架构相关/2设计模式/设计模式-②单例模式">第2.2节：设计模式-②单例模式</a></li>
<li><a href="Architecture架构/架构相关/2设计模式/设计模式-③观察者模式(Notification&amp;KVO">第2.3节：设计模式-③观察者模式(Notification&amp;KVO)</a>)</li>
<li><a href="Architecture架构/架构相关/2设计模式/设计模式-④适配器、策略、责任链模式">第2.4节：设计模式-④适配器、策略、责任链模式(Adapter、Strategy、Chain of Responsibility)</a></li>
<li><a href="Architecture架构/架构相关/2设计模式/设计模式-⑤多代理模式">第2.4节：设计模式-⑤多代理模式</a></li>
<li><a href="Architecture架构/架构相关/3组件化/5框架设计模式-⑦组件化">第3节：组件化</a></li>
<li><a href="Architecture架构/架构相关/4瘦身/瘦身-①UIViewController">第4.1节：瘦身-①UIViewController</a></li>
<li><a href="Architecture架构/架构相关/4瘦身/瘦身-②AppDelegate瘦身">第4.2节：瘦身-②AppDelegate瘦身</a></li>
<li><a href="Architecture架构/架构相关/9架构实操/新项目实施步骤">第9.1节：新项目实施步骤</a></li>
<li><a href="Architecture架构/架构相关/9架构实操/项目目录结构规范实践">第9.2节：项目目录结构规范实践</a></li>
<li><a href="Architecture架构/架构相关/9架构实操/依赖关系可视化">第9.3节：依赖关系可视化</a></li>
</ul>
</li>
<li>第二章：框架相关<ul>
<li><a href="Architecture架构/框架相关/框架的重要性">第1节：框架的重要性</a></li>
<li><a href="Architecture架构/框架相关/UI框架.xmind">第2节：UI框架</a></li>
<li><a href="Architecture架构/框架相关/foundation框架">第3节：foundation</a></li>
<li><a href="Architecture架构/框架相关/网络相关/网络框架">第4.1节：网络框架</a></li>
<li><a href="Architecture架构/框架相关/图片相关/图片框架">第5.1节：图片框架</a></li>
<li><a href="Architecture架构/框架相关/WebView相关/WebView优化">第6.1节：WebView</a></li>
<li><a href="Architecture架构/框架相关/WebView相关/h5_native_interacte/h5js">第6.2节：H5与原生交互：h5js</a></li>
<li><a href="Architecture架构/框架相关/WebView相关/h5_native_interacte/h5_open_app">第6.3节：H5与原生交互：h5 open app</a></li>
</ul>
</li>
<li>第三章：基础规范<ul>
<li><a href="Architecture架构/架构相关/1架构模式/架构模式-①概览">第1.1节：项目目录结构规范</a></li>
<li><a href="Architecture架构/基础规范/分支规范">第1.2节：分支规范</a></li>
<li><a href="Architecture架构/基础规范/请求规范">第2.1节：请求规范</a></li>
<li><a href="Architecture架构/基础规范/请求规范_JS">第2.2节：请求规范_JS</a></li>
<li><a href="Architecture架构/基础规范/路由及跳转/路由规范(含点击属性规范">第3.1节：路由规范(含点击属性规范)</a>)</li>
<li><a href="Architecture架构/基础规范/分页规范">第4.1节：分页规范</a></li>
<li><a href="Architecture架构/基础规范/埋点规范">第5节：埋点规范</a></li>
</ul>
</li>
<li>第四章：基础框架设计及接口文档<ul>
<li><a href="Architecture架构/基础框架设计及接口文档/网络库接口文档">第1节：网络库接口文档</a></li>
<li><a href="Architecture架构/基础框架设计及接口文档/版本检查">第2节：版本检查</a></li>
</ul>
</li>
<li>第五章：基础数据基类<ul>
<li><a href="Architecture架构/基础数据基类/基础数据整合方案">第1节：基础数据整合方案</a></li>
<li><a href="Architecture架构/基础数据基类/基础数据基类-①用户">第2.1节：基础数据基类-①用户</a></li>
<li><a href="Architecture架构/基础数据基类/基础数据基类-②商品">第2.2节：基础数据基类-②商品</a></li>
<li><a href="Architecture架构/基础数据基类/基础数据基类-③标签">第2.3节：基础数据基类-③标签</a></li>
<li><a href="Architecture架构/基础数据基类/业务数据基类-消息">第3.1节：业务数据基类-消息</a></li>
<li><a href="Architecture架构/基础数据基类/业务数据基类-卡片">第3.2节：业务数据基类-卡片</a></li>
</ul>
</li>
<li>第六章：通用业务规范<ul>
<li><a href="Architecture架构/通用业务规范/发布业务规范">第1节：发布业务规范</a></li>
<li><a href="Architecture架构/通用业务规范/分享业务规范">第2节：分享业务规范</a></li>
</ul>
</li>
<li>第七章：技术选型<ul>
<li><a href="Architecture架构/技术选型/技术选型流程">第1节：技术选型流程</a></li>
<li><a href="Architecture架构/技术选型/UI组件选择历程">第2节：UI组件选择历程</a></li>
<li><a href="Architecture架构/技术选型/切为H5的标准">第3节：切为H5的标准</a></li>
<li><a href="Architecture架构/技术选型/FlutterGetX框架选择历程">第4节：FlutterGetX框架选择历程</a></li>
<li><a href="Architecture架构/技术选型/加固选型-1调研">第5.1节：加固选型-1调研</a></li>
<li><a href="Architecture架构/技术选型/APM选型-1调研">第6.1节：APM选型-1调研</a></li>
<li><a href="Architecture架构/技术选型/APM选型-2备选筛选">第6.2节：APM选型-2备选筛选</a></li>
</ul>
</li>
<li>第八章：页面加载相关<ul>
<li><a href="Architecture架构/页面加载相关/页面加载体验优化">第1节：页面加载体验优化</a></li>
<li><a href="Architecture架构/框架相关/网络相关/弱网优化空间探索">第1.1节：弱网优化空间探索</a></li>
<li><a href="Architecture架构/框架相关/网络相关/弱网测试">第1.2节：弱网测试</a></li>
</ul>
</li>
<li>第九章：监控相关<ul>
<li><a href="Architecture架构/监控相关/日志系统">第1节：日志系统</a></li>
<li><a href="Architecture架构/监控相关/灰度系统">第2节：灰度系统</a></li>
<li><a href="Architecture架构/监控相关/性能监控/异常与崩溃">第3.1节：性能系统：异常与崩溃</a></li>
<li><a href="Architecture架构/监控相关/问题排查/app内存问题">第4.1节：问题排查：app内存问题</a></li>
<li><a href="Architecture架构/监控相关/问题排查/app发热问题">第4.2节：问题排查：app发热问题</a></li>
</ul>
</li>
<li>第十章：其他体验优化<ul>
<li><a href="Architecture架构/架构相关/4瘦身/瘦身-③app安装包">第1.1节：瘦身-③app安装包</a></li>
</ul>
</li>
</ul>
<h2 id="安全与破解"><a href="#安全与破解" class="headerlink" title="安全与破解"></a>安全与破解</h2><ul>
<li>第一章：项目安全<ul>
<li><a href="安全/网络加密">第1节：网络接口数据安全的【攻与防大全】</a></li>
<li><a href="安全/开发工具的安全性保障">第2.1节：开发工具的安全性保障</a></li>
<li><a href="安全/app打包保证">第2.2节：app打包保证</a></li>
<li><a href="安全/风控相关">第3节：风控相关</a></li>
</ul>
</li>
<li>第二章：iOS<ul>
<li><a href="安全/iOS加固">第1节：iOS加固</a></li>
<li><a href="安全/iOS逆向">第2节：iOS逆向</a></li>
<li><a href="安全/iOS的重签名">第3节：iOS的重签名</a></li>
</ul>
</li>
<li>第三章：Android<ul>
<li><a href="安全/Android合规安全">第1节：Android合规安全</a></li>
<li><a href="安全/Android加固">第2节：Android加固</a></li>
<li><a href="安全/Android反编译">第3节：Android反编译</a></li>
</ul>
</li>
</ul>
<h2 id="管理相关"><a href="#管理相关" class="headerlink" title="管理相关"></a>管理相关</h2><ul>
<li><a href="管理相关/账号管理">第一章：账号管理</a><ul>
<li><a href="管理相关/苹果设备注册管理">第1.1节：苹果设备注册管理</a></li>
</ul>
</li>
<li><a href="管理相关/常见痛点">第二章：常见痛点</a></li>
</ul>
<h2 id="混编"><a href="#混编" class="headerlink" title="混编"></a>混编</h2><ul>
<li><a href="混编/混编事项说明">第一章：混编事项说明</a></li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><a href="数据结构/9数据结构-①nil、isEqual、Hash">第一章：nil、isEqual、Hash</a></li>
<li><a href="数据结构/9数据结构-②堆栈">第二章：堆栈</a></li>
<li><a href="数据结构/9数据结构-②二叉树">第三章：二叉树</a></li>
<li><a href="数据结构/9数据结构-②链表">第四章：链表</a></li>
<li><a href="数据结构/9数据结构-③环">第五章：环</a></li>
</ul>
<h2 id="算法与数学"><a href="#算法与数学" class="headerlink" title="算法与数学"></a>算法与数学</h2><ul>
<li>算法<ul>
<li><a href="算法与数学/9算法">第一章：算法</a></li>
</ul>
</li>
<li>数学<ul>
<li><a href="算法与数学/数学-三维">第一章：三维</a></li>
<li><a href="算法与数学/数学-三角函数">第二章：三角函数</a></li>
</ul>
</li>
</ul>
<h2 id="iOS部分"><a href="#iOS部分" class="headerlink" title="iOS部分"></a>iOS部分</h2><ul>
<li><a href="./iOS/README">前言</a></li>
<li><a href="iOS/开发规范/开发规范">第一章：开发规范</a></li>
<li><a href="iOS/Swift/README">第二章：Swift</a><ul>
<li><a href="iOS/Swift/1入门/Swift基础知识">第1节：Swift基础知识</a></li>
</ul>
</li>
<li><a href="iOS/性能相关/README">第四章：性能相关</a><ul>
<li><a href="iOS/性能相关/性能优化-①TableView优化">第1.1节：性能优化-①TableView优化</a></li>
<li><a href="iOS/性能相关/性能优化-②其他">第1.2节：性能优化-②其他</a></li>
<li><a href="iOS/性能相关/性能监控-①卡顿监控">第2节：性能监控-①卡顿监控</a></li>
<li><a href="iOS/性能相关/6编译优化hmap">第3节：编译优化hmap</a></li>
<li><a href="iOS/性能相关/启动优化">第4节：启动优化</a></li>
</ul>
</li>
<li><a href="iOS/第三方库/README">第X章：第三方库</a><ul>
<li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage①缓存-①NSCache">第1.1节：图片库SDWebImage①缓存-①NSCache</a></li>
<li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage①缓存-②缓存原理">第1.2节：图片库SDWebImage①缓存-②缓存原理</a></li>
<li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage①缓存-③缓存不更新问题">第1.3节：图片库SDWebImage①缓存-③缓存不更新问题</a></li>
<li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage②请求-①简介">第2.1节：图片库SDWebImage②请求-①简介</a></li>
<li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage②请求-②避免重复请求问题">第2.2节：图片库SDWebImage②请求-②避免重复请求问题</a></li>
<li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage③解码">第3节：图片库SDWebImage③解码</a></li>
<li><a href="iOS/第三方库/图片库SDWebImage/SDWebImage④其他">第4节：图片库SDWebImage④其他</a></li>
<li><a href="iOS/第三方库/数据库FMDB/数据库-①FMDB">第5.1节：数据库FMDB</a></li>
<li><a href="iOS/第三方库/数据库FMDB/数据库">第5.2节：数据库</a></li>
<li><a href="iOS/第三方库/网络库AFNetworking/第三方网络库AFNetworking">第6节：网络库AFNetworking</a></li>
</ul>
</li>
<li>进阶<ul>
<li><a href="iOS/进阶/iOS进阶_多Target">第1节：iOS进阶_多Target</a></li>
<li><a href="iOS/进阶/iOS进阶_多Configuration">第2节：iOS进阶_多Configuration</a></li>
<li><a href="iOS/进阶/APNS+TCP推送流程">第3节：APNS+TCP推送流程</a></li>
<li><a href="iOS/进阶/iOS进阶_推送模拟">第4节：iOS进阶_推送模拟</a></li>
<li><a href="iOS/进阶/企业版灰度流程">第5节：企业版灰度流程</a></li>
</ul>
</li>
<li>功能性技术<ul>
<li><a href="iOS/功能性技术/iOS功能-通用链接">第1节：iOS功能-通用链接</a></li>
<li><a href="iOS/功能性技术/iOS功能-Transform">第2节：iOS功能-Transform</a></li>
</ul>
</li>
<li>证书发版<ul>
<li><a href="iOS/证书发版/邓白氏编码申请">第1节：邓白氏编码申请</a></li>
</ul>
</li>
<li><a href="iOS/移动分析/README">第四章：移动分析</a></li>
<li><a href="iOS/自动化/README">第五章：自动化</a><ul>
<li><a href="iOS/自动化/iOS 安装包0-完整自动化流程">第1节：iOS 安装包0-完整自动化流程</a></li>
<li><a href="iOS/自动化/iOS 安装包1-编译&amp;打包">第2节：iOS 安装包1-编译&amp;打包</a></li>
<li><a href="iOS/自动化/iOS 安装包2-上传">第3节：iOS 安装包2-上传</a></li>
<li><a href="iOS/自动化/iOS 自动化测试">第4节：iOS 自动化测试</a></li>
<li><a href="iOS/自动化/iOS 单元测试">第5节：iOS 单元测试</a></li>
</ul>
</li>
</ul>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><ul>
<li>第一章：入门<ul>
<li><a href="Android/1入门/Android开发环境搭建与运行">第1节：Android开发环境搭建与运行</a></li>
<li><a href="Android/1入门/JDK相关">第2节：JDK相关</a></li>
<li><a href="Android/1入门/Android_devices">第3节：Android_devices</a></li>
</ul>
</li>
</ul>
<h2 id="Flutter部分"><a href="#Flutter部分" class="headerlink" title="Flutter部分"></a>Flutter部分</h2><ul>
<li><a href="./Flutter/README">前言</a></li>
<li><a href="Flutter/1入门/README">第一章：入门</a><ul>
<li><a href="Flutter/1入门/Flutter开发环境搭建与运行">第1节：Flutter开发环境搭建与运行</a></li>
<li><a href="Flutter/1入门/Flutter的Hello World">第2节：Flutter的Hello World</a></li>
<li><a href="Flutter/1入门/Flutter的最基础知识">第3节：Flutter的最基础知识</a></li>
<li><a href="Flutter/1入门/Dart语言必备基础知识">第4节：Dart语言必备基础知识</a></li>
</ul>
</li>
<li><a href="Flutter/2集成/README">第二章：原生项目集成Flutter</a><ul>
<li><a href="Flutter/2集成/iOS项目集成Flutter">第1节：iOS项目集成Flutter</a></li>
<li><a href="Flutter/2集成/Android项目集成Flutter">第2节：Android项目集成Flutter</a></li>
</ul>
</li>
<li><a href="Flutter/3交互/README">第三章：原生项目与Flutter交互</a><ul>
<li><a href="Flutter/3交互/用于测试交互的Flutter项目">第1节：用于测试交互的Flutter项目</a></li>
<li><a href="Flutter/3交互/交互时iOS端的代码编写">第2节：交互时iOS端的代码编写</a></li>
<li><a href="Flutter/3交互/交互时Android端的代码编写">第3节：交互时Android端的代码编写</a></li>
</ul>
</li>
<li><a href="Flutter/4登录页实战/README">第四章：Flutter登录页实战</a><ul>
<li><a href="Flutter/4登录页实战/登录页在Flutter工程中的代码">第1节：登录页在Flutter工程中的代码</a></li>
<li><a href="Flutter/4登录页实战/登录页在iOS工程中的代码">第2节：登录页在iOS工程中的代码</a></li>
<li><a href="Flutter/4登录页实战/登录页在Android工程中的代码">第3节：登录页在Android工程中的代码</a></li>
</ul>
</li>
<li><a href="Flutter/5详解/README">第五章：Flutter详解</a><ul>
<li><a href="Flutter/5详解/详解Button">第1节：详解Button</a></li>
<li><a href="Flutter/5详解/详解TextField">第2节：详解TextField</a></li>
<li><a href="Flutter/5详解/详解Platform Channel">第3节：详解Platform Channel</a></li>
</ul>
</li>
<li><a href="Flutter/6进阶/README">第六章：Flutter进阶</a><ul>
<li><a href="Flutter/6进阶/iOS项目集成Flutter高级">第1节：iOS项目集成Flutter高级</a></li>
<li><a href="Flutter/6进阶/Flutter控件的封装">第2节：Flutter控件Widget的封装</a></li>
<li><a href="Flutter/6进阶/Package的使用、开发与发布">第3节：Package的使用、开发与发布</a></li>
<li><a href="Flutter/6进阶/Flutter的设计模式">第4节：Flutter的设计模式</a></li>
</ul>
</li>
<li><a href="Flutter/7规范/README">第七章：Flutter规范</a><ul>
<li><a href="Flutter/7规范/Flutter开发规范">第1节：Flutter开发规范</a></li>
</ul>
</li>
<li><a href="Flutter/8状态管理/README">第八章：Flutter状态管理</a><ul>
<li><a href="Flutter/8状态管理/状态管理1Provider">第1节：状态管理1Provider</a></li>
<li><a href="Flutter/8状态管理/状态管理-框架对比">第2节：状态管理-框架对比</a></li>
</ul>
</li>
<li><a href="Flutter/9框架升级/README">第九章：Flutter框架升级</a><ul>
<li><a href="Flutter/9框架升级/基础框架">第1节：基础框架</a></li>
<li><a href="Flutter/9框架升级/基础框架的接入">第2节：基础框架的接入</a></li>
<li><a href="Flutter/9框架升级/组件的使用">第3节：组件的使用</a></li>
</ul>
</li>
</ul>
<h2 id="React-Native-部分"><a href="#React-Native-部分" class="headerlink" title="React Native 部分"></a>React Native 部分</h2><ul>
<li><a href="./ReactNative/ReactNative README">前言</a></li>
<li><a href="ReactNative/1入门/README">第一章：入门</a><ul>
<li><a href="ReactNative/1入门/ReactNative开发环境搭建与运行">第1节：ReactNative开发环境搭建与运行</a></li>
<li><a href="ReactNative/1入门/ReactNative的Hello World">第2节：ReactNative的Hello World</a></li>
<li><a href="ReactNative/1入门/ReactNative的最基础知识">第3节：ReactNative的最基础知识</a></li>
<li><a href="ReactNative/1入门/ReactNative必备的语言基础知识">第4节：ReactNative必备的语言基础知识</a></li>
<li><a href="ReactNative/1入门/ReactNative的常用库">第5节：ReactNative的常用库</a></li>
</ul>
</li>
<li><a href="ReactNative/5详解/README">第五章：ReactNative详解</a><ul>
<li><a href="ReactNative/5详解/ReactNative详解布局">第1节：详解布局</a></li>
<li><a href="ReactNative/5详解/ReactNative详解Button">第2节：详解Button</a></li>
</ul>
</li>
<li><a href="ReactNative/6进阶/README">第六章：ReactNative进阶</a><ul>
<li><a href="ReactNative/6进阶/ReactNative使用技巧">第1节：ReactNative使用技巧</a></li>
<li><a href="ReactNative/6进阶/ReactNative的继承重写等">第2节：ReactNative的继承重写等</a></li>
<li><a href="ReactNative/6进阶/ReactNative组件的封装">第3节：ReactNative组件Component的封装</a></li>
</ul>
</li>
<li><a href="ReactNative/8实践/README">第八章：ReactNative实践</a><ul>
<li><a href="ReactNative/8实践/ReactNative的Demo实践">第1节：ReactNative的Demo实践</a></li>
</ul>
</li>
</ul>
<h2 id="React-部分"><a href="#React-部分" class="headerlink" title="React 部分"></a>React 部分</h2><ul>
<li><a href="./React/React README">前言</a></li>
<li><a href="React/1入门/README">第一章：入门</a><ul>
<li><a href="ReactNative/1入门/ReactNative开发环境搭建与运行">第1节：React开发环境搭建与运行</a></li>
<li><a href="React/1入门/ReactNative的Hello World">第2节：React的Hello World</a></li>
<li><a href="React/1入门/ReactNative的最基础知识">第3节：React的最基础知识</a></li>
<li><a href="React/1入门/ReactNative必备的语言基础知识">第4节：React必备的语言基础知识</a></li>
<li><a href="ReactNative/1入门/ReactNative的常用库">第5节：ReactNative的常用库</a></li>
<li><a href="React/1入门/React与ReactNative的区别">React与ReactNative的区别</a></li>
</ul>
</li>
</ul>
<h2 id="H5-APP"><a href="#H5-APP" class="headerlink" title="H5-APP"></a>H5-APP</h2><ul>
<li><a href="H5-APP/1入门/README">第一章：入门</a><ul>
<li><a href="H5-APP/1入门/H5-APP开发环境搭建与运行">第1节：H5-APP开发环境搭建与运行</a></li>
<li><a href="H5-APP/1入门/H5-APP开发小技巧">第2节：H5-APP开发小技巧</a></li>
</ul>
</li>
</ul>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul>
<li><a href="HTML/1入门/README">第一章：入门</a><ul>
<li><a href="HTML/1入门/web必备基础1-学习路线">第1节：web必备基础1-学习路线</a></li>
<li><a href="HTML/1入门/web必备基础2-实践基础">第2节：web必备基础2-实践基础</a></li>
<li><a href="HTML/1入门/web必备基础3-代码复用">第3节：web必备基础3-代码复用</a></li>
</ul>
</li>
<li><a href="HTML/2扩展/README">第二章：扩展</a><ul>
<li><a href="HTML/2扩展/web扩展1">第1节：web扩展1</a></li>
</ul>
</li>
</ul>
<h2 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h2><ul>
<li><a href="Weex/1入门/README">第一章：入门</a><ul>
<li><a href="Weex/1入门/Weex开发环境搭建与运行">第1节：Weex开发环境搭建与运行</a></li>
</ul>
</li>
</ul>
<h2 id="上架相关"><a href="#上架相关" class="headerlink" title="上架相关"></a>上架相关</h2><ul>
<li><a href="上架相关/上架-发版频率">第一章：上架-发版频率</a></li>
<li><a href="上架相关/上架-提审前自检">第二章：上架-提审前自检</a></li>
<li><a href="上架相关/上架-账号主体变更">第三章：上架-账号主体变更</a></li>
<li><a href="上架相关/上架-app链接">第四章：上架-app链接</a></li>
</ul>
<h2 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h2><ul>
<li><a href="Script/Script README">前言</a></li>
<li>Shell<ul>
<li><a href="./Script/Shell/Shell入门">Shell</a></li>
</ul>
</li>
<li>Ruby<ul>
<li><a href="Script/Ruby/Ruby入门">Ruby</a></li>
</ul>
</li>
<li>JavaScript<ul>
<li><a href="Script/JavaScript/JavaScript入门">JavaScript</a></li>
</ul>
</li>
<li>Python<ul>
<li><a href="Script/Python/Python入门">Python</a></li>
</ul>
</li>
</ul>
<h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><ul>
<li>第一章：阿里云<ul>
<li><a href="实用工具/阿里云oss/阿里云">第1节：阿里云</a></li>
</ul>
</li>
<li>第二章：阿里云oss<ul>
<li><a href="实用工具/阿里云oss/阿里云oss1上传">第1节：阿里云oss1上传</a></li>
</ul>
</li>
<li>第三章：阿里云服务器ECS<ul>
<li><a href="实用工具/阿里云服务器ECS/阿里云服务器ECS的购买与远程连接">第1节：阿里云服务器ECS的购买与远程连接</a></li>
<li><a href="实用工具/阿里云服务器ECS/阿里云服务器ECS的使用">第2节：阿里云服务器ECS的使用</a></li>
<li><a href="实用工具/阿里云服务器ECS/阿里云服务器ECS域名绑定">第3节：阿里云服务器ECS域名绑定</a></li>
<li><a href="实用工具/阿里云服务器ECS/阿里云服务器ECS的数据备份">第4节：阿里云服务器ECS的数据备份</a></li>
</ul>
</li>
</ul>
<h2 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h2><ul>
<li>第二章：腾讯云cos<ul>
<li><a href="实用工具/腾讯云/腾讯云cos1上传">第1节：腾讯云cos1上传</a></li>
</ul>
</li>
</ul>
<h2 id="实用工具部分"><a href="#实用工具部分" class="headerlink" title="实用工具部分"></a>实用工具部分</h2><ul>
<li><a href="实用工具/Terminal/README">Terminal</a><ul>
<li><a href="实用工具/Terminal/1终端常用命令">第1节：终端常用命令</a></li>
<li><a href="实用工具/Terminal/终端命令安装">第2节：终端命令安装</a></li>
<li><a href="实用工具/Terminal/终端命令使用">第3节：终端命令使用</a></li>
</ul>
</li>
<li><a href="实用工具/Hexo/README">Hexo</a><ul>
<li><a href="实用工具/Hexo/1Hexo的使用">第1节：1Hexo的使用</a></li>
<li><a href="实用工具/Hexo/2Hexo的进阶">第2节：2Hexo的进阶</a></li>
</ul>
</li>
<li><a href="实用工具/GitBook/README">GitBook</a><ul>
<li><a href="实用工具/GitBook/1GitBook的使用">第1节：GitBook的使用</a></li>
</ul>
</li>
<li><a href="实用工具/XAMPP/XAMPP问题整理">XAMPP</a></li>
<li>yapi<ul>
<li><a href="实用工具/yapi/yapi的安装">第1节：yapi的安装</a></li>
<li><a href="实用工具/yapi/yapi的项目运行">第2节：yapi的项目运行</a></li>
<li><a href="实用工具/yapi/yapi在云服务器ECS上的使用-阿里云">第3节：yapi在云服务器ECS上的使用-阿里云</a></li>
<li><a href="实用工具/yapi/yapi的使用之入门篇">第4节：yapi的使用之入门篇</a></li>
<li><a href="实用工具/yapi/yapi的使用之设置篇">第5节：yapi的使用之设置篇</a></li>
<li>第6节：Mock<ul>
<li><a href="实用工具/yapi/Mock基础知识">第6.1节：Mock基础知识</a></li>
<li><a href="实用工具/yapi/yapi的使用之Mock篇">第6.2节：yapi的使用之Mock篇</a></li>
<li><a href="实用工具/yapi/yapi的使用之Mock篇2-类型修改">第6.3节：yapi的使用之Mock篇2-类型修改</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="实用工具/iconFont">iconFont</a></li>
<li><a href="实用工具/MySQL/MySQL问题整理">MySQL</a></li>
<li><a href="实用工具/Zentao/Zentao问题整理">Zentao</a></li>
<li>明道<ul>
<li><a href="实用工具/明道/明道任务划分">第1节：明道任务划分</a></li>
</ul>
</li>
<li><a href="实用工具/Jenkins/Jenkins使用问题常见">Jenkins</a><ul>
<li><a href="实用工具/Jenkins/Jenkins的安装与启动">第1节：Jenkins的安装与启动</a></li>
<li><a href="实用工具/Jenkins/Jenkins基本操作">第2节：Jenkins基本操作</a></li>
<li><a href="实用工具/Jenkins/Jenkins使用技巧常用">第3节：Jenkins使用技巧常用</a></li>
<li><a href="实用工具/Jenkins/Jenkins使用问题常见">第4节：Jenkins使用问题常见</a></li>
<li><a href="实用工具/Jenkins/Jenkins常用插件介绍">第5节：Jenkins常用插件介绍</a></li>
<li><a href="实用工具/Jenkins/Jenkins上显示二维码图片">第6节：Jenkins上显示二维码图片</a></li>
<li><a href="实用工具/Jenkins/Jenkins参数化构建">第7节：Jenkins参数化构建</a></li>
</ul>
</li>
<li>qrencode<ul>
<li><a href="实用工具/qrencode/qrencode">第1节：qrencode</a></li>
</ul>
</li>
<li>Xcode Extensions<ul>
<li><a href="实用工具/Xcode Extensions/Swifttify for Xcode">Swifttify for Xcode</a></li>
</ul>
</li>
<li><a href="实用工具/Charles">Charles</a></li>
<li>AI<ul>
<li><a href="实用工具/ChatGPT">ChatGPT</a></li>
</ul>
</li>
<li><a href="实用工具/Nginx">Nginx</a></li>
<li><a href="实用工具/其他小工具/其他小工具">其他小工具</a><br>截图、录屏、音频转换</li>
</ul>
<h2 id="代码管理"><a href="#代码管理" class="headerlink" title="代码管理"></a>代码管理</h2><ul>
<li>Git<ul>
<li><a href="代码管理/Git/Git Permission">第1节：Git Permission</a></li>
<li><a href="代码管理/Git/Git Log">第1节：Git Log</a></li>
<li><a href="代码管理/Git/Git Feature">第1节：Git Feature</a></li>
<li><a href="代码管理/Git/Git Rebase">第1节：Git Rebase</a></li>
<li><a href="代码管理/Git/Git Search">第1节：Git Search</a></li>
<li><a href="代码管理/Git/Git2">第1节：Git2</a></li>
<li><a href="代码管理/Git/Git代码同步">第1节：Git代码同步</a></li>
<li><a href="代码管理/Git/Git获取信息">第1节：Git获取信息</a></li>
<li><a href="代码管理/Git/Git使用">第1节：Git使用</a></li>
<li><a href="代码管理/Git/Git项目管理">第1节：Git项目管理</a></li>
<li><a href="代码管理/Git/Git Push方式">第1节：Git Push方式</a></li>
<li><a href="代码管理/Git/Git Push失败问题">第1节：Git Push失败问题</a></li>
<li><a href="代码管理/Git/Git随笔">第1节：Git随笔</a></li>
<li><a href="代码管理/Git/Git Commit规范">第1节：Git Commit规范</a></li>
</ul>
</li>
<li><a href="代码管理/SVN">SVN</a></li>
<li>库管理<ul>
<li><a href="代码管理/库管理/CocoaPods">CocoaPods</a></li>
<li><a href="代码管理/库管理/homebrew">homebrew</a></li>
<li>npmjs<ul>
<li><a href="代码管理/库管理/npmjs的命令">第1节：npmjs的命令</a></li>
<li><a href="代码管理/库管理/npmjs的调试">第2节：npmjs的调试</a></li>
<li><a href="代码管理/库管理/npmjs的发布">第3节：npmjs的发布</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="电脑使用"><a href="#电脑使用" class="headerlink" title="电脑使用"></a>电脑使用</h2><ul>
<li><a href="电脑使用/新电脑初始配置">第1节：新电脑初始配置</a></li>
<li><a href="电脑使用/旧电脑数据清理">第2节：旧电脑数据清理</a></li>
<li><a href="电脑使用/电脑使用过程中的问题">第3节：电脑使用过程中的问题</a></li>
<li><a href="电脑使用/Mac中个各种文件夹">第4节：Mac中个各种文件夹</a></li>
<li>第5节：远程控制<ul>
<li><a href="电脑使用/远程桌面连接">第5.1节：远程桌面连接</a></li>
<li><a href="电脑使用/远程共享文件夹">第5.2节：远程共享文件夹</a></li>
</ul>
</li>
<li><a href="电脑使用/环境变量设置">第6节：环境变量设置</a></li>
</ul>
<h2 id="常识类"><a href="#常识类" class="headerlink" title="常识类"></a>常识类</h2><ul>
<li>技术常识<ul>
<li><a href="常识类/技术常识/好用的网站">第1节：好用的网站</a></li>
<li>第2节：科学上网<ul>
<li><a href="常识类/技术常识/科学上网_ClashX">第1节：科学上网_ClashX</a></li>
<li><a href="常识类/技术常识/科学上网_SMS">第2节：科学上网_SMS</a></li>
<li><a href="常识类/技术常识/科学上网_AppleID">第3节：科学上网_AppleID</a></li>
<li><a href="常识类/技术常识/科学上网_ModHeader">第4节：科学上网_ModHeader</a></li>
</ul>
</li>
<li><a href="常识类/技术常识/图片相关常识">第3节：图片相关常识</a></li>
</ul>
</li>
<li>Office常识<ul>
<li><a href="常识类/Office常识/PPT常识">第1节：PPT常识</a></li>
</ul>
</li>
<li>生活常识<ul>
<li><a href="常识类/生活常识/楼房常识">第1节：楼房常识</a></li>
</ul>
</li>
</ul>
<h2 id="编程工具部分"><a href="#编程工具部分" class="headerlink" title="编程工具部分"></a>编程工具部分</h2><ul>
<li><a href="编程工具/WebStorm">WebStorm</a></li>
<li><a href="编程工具/VSCode">VSCode</a></li>
<li><a href="编程工具/UI2Code">UI2Code</a></li>
<li><a href="编程工具/OnlineCoding在线编码">OnlineCoding在线编码</a></li>
</ul>
<p><a href="http://lib.csdn.net/base/ios/structure" target="_blank" rel="noopener">iOS知识库</a></p>
<p><a href="http://lib.csdn.net/base/Android/structure" target="_blank" rel="noopener">Android知识库</a></p>
<p>随笔</p>
<p>专利申请</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/总目录/" data-id="cm1p8837g0008zwr4uq2k4xwy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-安全/网络加密" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/安全/网络加密/" class="article-date">
  <time datetime="2024-06-07T02:39:52.000Z" itemprop="datePublished">2024-06-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/安全与破解/">安全与破解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/安全/网络加密/">网络接口数据安全的【攻与防大全】</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h2 id="一、对数据加密的概述"><a href="#一、对数据加密的概述" class="headerlink" title="一、对数据加密的概述"></a>一、对数据加密的概述</h2><h3 id="1、安全的数据传输是什么样的"><a href="#1、安全的数据传输是什么样的" class="headerlink" title="1、安全的数据传输是什么样的"></a>1、安全的数据传输是什么样的</h3><p>数据传输：都是使用密文（客户端提供加密的参数，服务端提供加密的结果）。</p>
<p>【客户端提供加密的参数】：需要在客户端加密后，上传到服务端，并在服务端对其进行解密，以确认传过来的参数。</p>
<p>【服务端提供加密的结果】：需要在服务端加密后，返回给客户端，并在客户端对其进行解密，以确认传过来的结果。</p>
<p><img src="/安全/网络加密/数据安全传输(AES).jpg" alt="数据安全传输(AES)" style="zoom:50%;"></p>
<p>若要了解加密方式可查看下文【<a href="#附1：加密的方式有哪些">附1：加密的方式有哪些</a>】</p>
<h3 id="2、一端的AESKey怎么【安全的】传给另一端-为什么要对AES的密钥进行RSA公钥加密后传输？？"><a href="#2、一端的AESKey怎么【安全的】传给另一端-为什么要对AES的密钥进行RSA公钥加密后传输？？" class="headerlink" title="2、一端的AESKey怎么【安全的】传给另一端 / 为什么要对AES的密钥进行RSA公钥加密后传输？？"></a>2、一端的AESKey怎么【安全的】传给另一端 / 为什么要对AES的密钥进行RSA公钥加密后传输？？</h3><p>答：为了安全，一端的AESKey必须先加密，然后才能传给另一端，这样才能防止用户从请求中抓取到AESKey。同时另一端需要对传过来的数据进行解密得到AESKey原值，后续两端才能都通过AESkey原值进行两边数据的对称加解密。即<strong>数据加密采用AES，而把AES的加密秘钥用RSA加密。</strong>（附：<strong>为什么AESKey不是使用md5方式加密？答：因为另一端要解密来使用原值。</strong>）。</p>
<p><strong>问题：为什么要对AES的密钥进行RSA公钥加密后传输？</strong></p>
<p>AES是对称加密算法，加密和解密的密钥都是同一个，为了防止被别人恶意获取到该密钥，然后对我们的业务请求参数进行解密，我们需要将AES密钥进行非对称加密后再进行传输。</p>
<h4 id="2-1、密钥来源于客户端（类似Https）"><a href="#2-1、密钥来源于客户端（类似Https）" class="headerlink" title="2.1、密钥来源于客户端（类似Https）"></a>2.1、密钥来源于客户端（类似Https）</h4><p><img src="/安全/网络加密/数据安全传输(Https_AES+RSA).jpg" alt="数据安全传输(AES+RSA)" style="zoom:50%;"></p>
<p>上图和Https原理有点相像。</p>
<h5 id="2-1-1、客户端密钥保存的安全问题"><a href="#2-1-1、客户端密钥保存的安全问题" class="headerlink" title="2.1.1、客户端密钥保存的安全问题"></a>2.1.1、客户端密钥保存的安全问题</h5><p>如果密钥是来源于客户端，那如何在客户端安全的保存密钥？请查看下文中的【<a href="#附2：如何在客户端安全的保存密钥AESKey">附2：如何在客户端安全的保存密钥AESKey</a>】</p>
<h4 id="2-2、密钥来源于服务端（为了密钥能够像版本那样进行控制）"><a href="#2-2、密钥来源于服务端（为了密钥能够像版本那样进行控制）" class="headerlink" title="2.2、密钥来源于服务端（为了密钥能够像版本那样进行控制）"></a>2.2、密钥来源于服务端（为了密钥能够像版本那样进行控制）</h4><p>实际过程中，可能你的AESKey为了能够像版本那样进行控制，可能你的AESKey是由服务端分发的，则其过程可能如下：</p>
<p><img src="/安全/网络加密/数据安全传输_AES+RSA.jpg" alt="数据安全传输(AES+RSA)"></p>
<p>空 ==&gt;  getServicePublicKey ==&gt;  servicePublicKey</p>
<p>clientPublicKey(使用ServicePublicKey加密)  ==&gt;   sendClientPublicKey  ==&gt;  使用servicePrivateKey解密得到clientPublicKey</p>
<p>空 ==&gt;   getServiceAESKey ==&gt;   aesKey(使用clientPublicKey加密)</p>
<p>参考文章：</p>
<ul>
<li><a href="https://juejin.cn/post/7078952957739286542" target="_blank" rel="noopener">前端RSA+AES混合加密</a></li>
<li><a href="https://juejin.cn/post/7146386827522342948" target="_blank" rel="noopener">客户端与服务端数据加密传输方案</a></li>
</ul>
<p>最终网络数据传输，可能就只剩下类似下面一样，只有一个参数和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">只剩一个参数：</span><br><span class="line">encryptedParametersString: xxxx</span><br><span class="line"></span><br><span class="line">只剩一个返回：</span><br><span class="line">encryptedResultString: yyyy</span><br></pre></td></tr></table></figure>
<h2 id="二、被破解后，篡改参数值，进行请求攻击，怎么办？（二次加密：签名）"><a href="#二、被破解后，篡改参数值，进行请求攻击，怎么办？（二次加密：签名）" class="headerlink" title="二、被破解后，篡改参数值，进行请求攻击，怎么办？（二次加密：签名）"></a>二、被破解后，篡改参数值，进行请求攻击，怎么办？（二次加密：签名）</h2><p>如果上面的加密过程被破解了，用户就能自己还原原始参数和原始返回值了。这时候如果他篡改参数值进行请求攻击怎么办？</p>
<h3 id="1、请求参数值被篡改的场景"><a href="#1、请求参数值被篡改的场景" class="headerlink" title="1、请求参数值被篡改的场景"></a>1、请求参数值被篡改的场景</h3><p>购物车多商品结算时候，本需共100美元的商品。在生成订单的时候，携带了所要支付的各个商品的id，以及总费用。结果总费用被篡改成以0.01美元的价格生成了订单Id。而后服务端却没有校验这些商品是不是0.01美元，从而导致平台损失。</p>
<p>以购物车结算为例，传统的传给服务器的参数一般是如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">goods: [</span><br><span class="line">  &#123;</span><br><span class="line">    id: xxx</span><br><span class="line">    title: </span><br><span class="line">    price: </span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: yyy</span><br><span class="line">    title: </span><br><span class="line">    price: </span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line">totoalPrice: 100</span><br></pre></td></tr></table></figure>
<p>当用户破解了我们之前的加密算法后，其就能还原原始参数结果，并篡改参数值，然后再利用破解所得的加密算法得到一个新的加密参数如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">篡改前所传参数：</span><br><span class="line">encryptedParametersString: xxxx1</span><br><span class="line"></span><br><span class="line">篡改后所传参数：</span><br><span class="line">encryptedParametersString: xxxx2</span><br></pre></td></tr></table></figure>
<p>之后，如果服务器接收和处理的就是被修改过的值了。</p>
<p>那这种情况下怎么办法呢？答：再加一层加密算法，即签名。</p>
<h3 id="2、请求参数值被篡改的解决-防篡改方案"><a href="#2、请求参数值被篡改的解决-防篡改方案" class="headerlink" title="2、请求参数值被篡改的解决/防篡改方案"></a>2、请求参数值被篡改的解决/防篡改方案</h3><p>为了防篡改，通常有以下三个步骤：</p>
<p>1、我们通过上述原始参数计算得出一个签名值。然后将签名值添加一起传给服务端。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">篡改前所传参数：</span><br><span class="line">encryptedParametersString: xxxx1</span><br><span class="line">signatureValue: xxxx1的签名值</span><br><span class="line">signatureMethod: xxx1的签名方式（如果客户端有md5、sha256等多种加密方式）</span><br><span class="line"></span><br><span class="line">篡改后所传参数：</span><br><span class="line">encryptedParametersString: xxxx2</span><br><span class="line">signatureValue: xxxx1的签名值（用户不知道此签名值的计算方法）</span><br><span class="line">signatureMethod: xxx1的签名方式（如果客户端有md5、sha256等多种加密方式）</span><br></pre></td></tr></table></figure>
<p>由于用户不知道签名值的计算方法，所以即使其篡改了原原始参数中的部分参数值并生成加密参数，其也仍需要再破解出这个签名值的计算方法，如果其不修改签名值，而是把签名值直接上传到服务端，则服务端会进行以下操作。</p>
<p>2、然后服务端接收到所传的参数（含签名值）后，也按照和客户端一样的方式对除签名值外的其他参数再计算一遍签名值。</p>
<p>3、如果所得的签名值和客户端传过来的签名值不一样，则是参数被篡改了，服务端放弃该请求。（注：<strong>为了保证正常情况下计算出的客户端和服务端的签名一样，我们会对请求参数进行字典排序后再签名。</strong>）</p>
<p>所以，防篡改的解决办法是客户端加签，服务端验签。</p>
<h4 id="2-1、加签的方法"><a href="#2-1、加签的方法" class="headerlink" title="2.1、加签的方法"></a>2.1、加签的方法</h4><p>对上述的 <code>encryptedParametersString: xxxx1</code> 进行md5、sha256或其他加密算法。</p>
<h5 id="2-1-1、签名算法的防猜测"><a href="#2-1-1、签名算法的防猜测" class="headerlink" title="2.1.1、签名算法的防猜测"></a>2.1.1、签名算法的防猜测</h5><p>如果签名的加密算法被猜到是用md5进行的签名。则用户可以也跟着对<code>encryptedParametersString: xxxx1</code> 进行md5加密即可得到签名会被服务端认证通过的请求了。那是不是md5不能用呢？如果用怎么用？答：md5加盐，进一步增加破解的难度。</p>
<p>为什么加盐？<br>避免用户直接使用参数值进行md5加密，发现签名值就是由参数值md5加密而来。所以为了让MD5码更加安全 ，我们现在都采用加盐，盐要越长越乱。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">加盐前：</span><br><span class="line">digest = hash(input)</span><br><span class="line"></span><br><span class="line">加盐后：用户拿参数值直接md5发现和签名值匹配不上，则一般就不会发现是用md5加密了。</span><br><span class="line">digest = hash(salt + input)</span><br></pre></td></tr></table></figure>
<p>这样加盐后，当用户再拿参数值直接进行md5后，发现和签名值匹配不上，则一般就不会想到算法是用md5加密了。</p>
<p><strong>这个salt可以看作是一个额外的“认证码”，可以是固定的值，也可以是动态的值，如每个用户自己的userid。</strong></p>
<p>更多MD5及其加盐可查看下文中的【<a href="#附3：签名 --&gt; md5(加盐">附3：签名 –&gt; md5(加盐)</a>)】</p>
<h5 id="2-1-2、签名算法关注的内容"><a href="#2-1-2、签名算法关注的内容" class="headerlink" title="2.1.2、签名算法关注的内容"></a>2.1.2、签名算法关注的内容</h5><p>除了请求参数外，签名算法还关注请求的接口和方法，即其一般是对含参数在内、外加其他值（如URL、Method)一起进行签名。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1557750" target="_blank" rel="noopener">如何设计一个API签名</a></li>
<li><a href="https://help.aliyun.com/zh/api-gateway/traditional-api-gateway/user-guide/use-digest-authentication-to-call-an-api" target="_blank" rel="noopener">使用摘要签名认证方式调用API</a></li>
</ul>
<h2 id="三、不破解，但进行二次请求-API重放攻击-Replay-Attacks-怎么办？"><a href="#三、不破解，但进行二次请求-API重放攻击-Replay-Attacks-怎么办？" class="headerlink" title="三、不破解，但进行二次请求/API重放攻击(Replay Attacks)怎么办？"></a>三、不破解，但进行二次请求/API重放攻击(Replay Attacks)怎么办？</h2><p>加密后，破解难度增加了，但是如果用户不破解，而是通过API重放攻击你的服务器呢，怎么办？</p>
<h3 id="1、重放攻击-Replay-Attacks-概述及危害介绍"><a href="#1、重放攻击-Replay-Attacks-概述及危害介绍" class="headerlink" title="1、重放攻击(Replay Attacks)概述及危害介绍"></a>1、重放攻击(Replay Attacks)概述及危害介绍</h3><p>API重放攻击(Replay Attacks)又称为重播攻击、回放攻击。它的原理就是把之前窃听到的数据原封不动的重新发送给接收方。</p>
<h4 id="1-1、即使有幂等性情况下，重放请求的危害"><a href="#1-1、即使有幂等性情况下，重放请求的危害" class="headerlink" title="1.1、即使有幂等性情况下，重放请求的危害"></a>1.1、即使有幂等性情况下，重放请求的危害</h4><p>追问：服务端不是应该有做幂等性了吗，为什么还需要处理防重放问题？</p>
<p>答：虽然如果一个系统操作是幂等的，即使攻击者重放了一个请求，系统也不会因为重复执行而产生不同的结果或状态。在一定程度上可以减少重放攻击的潜在损害（例如，一个幂等的HTTP GET请求，无论请求多少次，服务器都会返回相同的结果，而不会对服务器的状态产生影响）。但是即使请求本身是幂等的，也需要<strong>防止恶意用户发送大量重放请求来耗尽系统资源</strong>，从而实现拒绝服务攻击（DoS）。</p>
<p>若要了解幂等性知识，可查看</p>
<ul>
<li><a href="https://developer.aliyun.com/article/812075" target="_blank" rel="noopener">接口的幂等性设计和防重保证，详细分析幂等性的几种实现方法</a></li>
<li><a href="https://blog.csdn.net/XinTeng2012/article/details/121093535" target="_blank" rel="noopener">幂等性问题的思考和总结，防重、幂等，常用解决方案，解决方式</a></li>
</ul>
<h4 id="1-2、没有幂等性情况下，重放请求的危害"><a href="#1-2、没有幂等性情况下，重放请求的危害" class="headerlink" title="1.2、没有幂等性情况下，重放请求的危害"></a>1.2、没有幂等性情况下，重放请求的危害</h4><p>如果服务端没有幂等性，则假设有一个在线投票系统，用于选举或表决，每个用户只能投票一次。那么攻击者可能会尝试重放投票请求，进行<strong>重复投票</strong>，以增加他们支持的候选人或选项的票数。</p>
<h3 id="2、重放攻击-Replay-Attacks-的解决方案"><a href="#2、重放攻击-Replay-Attacks-的解决方案" class="headerlink" title="2、重放攻击(Replay Attacks)的解决方案"></a>2、重放攻击(Replay Attacks)的解决方案</h3><p><strong>防止重放攻击必须要保证请求仅一次有效</strong>。需要通过在请求体中携带当前请求的唯一标识，并且进行签名防止被篡改。所以，防止重放攻击需要建立在添加签名且防止签名被篡改的基础之上。</p>
<h4 id="2-1、措施一：添加请求的时效性参数-Timestamp"><a href="#2-1、措施一：添加请求的时效性参数-Timestamp" class="headerlink" title="2.1、措施一：添加请求的时效性参数 Timestamp"></a>2.1、措施一：添加请求的时效性参数 Timestamp</h4><p>即某个请求，其请求时间戳<strong>Timestamp</strong>，和服务端的当前时间在规定时间内（如1分钟内）则为合法请求，反之，则视为无效请求。</p>
<p><strong>服务端时间戳的获取时机</strong>和服务端的RSA公钥一致，你可理解为网络库的初始化阶段（虽然这是真正初始化之后的请求的”二次初始化”）。</p>
<p><img src="/安全/网络加密/数据安全传输_防重放_1加timestamp.png" alt="数据安全传输_防重放_1加timestamp" style="zoom:50%;"></p>
<p>客户端与服务端的时间戳差值 diff = 服务器返回的时间戳 - 客户端请求结束的时间戳</p>
<p>校准服务端后的客户端的时间戳 = 当前客户端时间戳 + 客户端与服务端的时间戳差值 diff</p>
<h4 id="2-2、措施二：添加一个唯一的随机数Nonce"><a href="#2-2、措施二：添加一个唯一的随机数Nonce" class="headerlink" title="2.2、措施二：添加一个唯一的随机数Nonce"></a>2.2、措施二：添加一个唯一的随机数Nonce</h4><h5 id="2-2-1、Nonce的核心思路："><a href="#2-2-1、Nonce的核心思路：" class="headerlink" title="2.2.1、Nonce的核心思路："></a>2.2.1、Nonce的核心思路：</h5><p>调用者每次调用时：</p>
<p>​        A：调用者生成并带上一个随机数<strong>Nonce</strong>（可以考虑用用户id+当前时间戳+接口url）</p>
<p>​        B：服务端该随机数是否已出现，有则拒绝，无则存储该随机数并放过请求。</p>
<p>则请求参数变为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">未加 timestamp 和 nonce 前：</span><br><span class="line">encryptedParametersString: xxxx1</span><br><span class="line">signatureValue: xxxx1的签名值</span><br><span class="line">signatureMethod: xxx1的签名方式（如果客户端有md5、sha256等多种加密方式）</span><br><span class="line"></span><br><span class="line">加了 timestamp 和 nonce 后：</span><br><span class="line">encryptedParametersString: xxxx1</span><br><span class="line">signatureValue: xxxx1的签名值,📢：要把timestamp和nonce也包括进去，避免它们被篡改</span><br><span class="line">signatureMethod: xxx1的签名方式（如果客户端有md5、sha256等多种加密方式）</span><br><span class="line">nonce: xxx1的nonce</span><br><span class="line">timestamp: xxx1的timestamp</span><br></pre></td></tr></table></figure>
<p>这里注意：计算xxxx1的<strong>签名值要把timestamp和nonce也包括进去，避免它们被篡改。</strong></p>
<h5 id="2-2、Nonce的优化思路："><a href="#2-2、Nonce的优化思路：" class="headerlink" title="2.2、Nonce的优化思路："></a>2.2、Nonce的优化思路：</h5><p>这里服务端要保证Nonce唯一，就得存储已经用过的Nonce，但长期保持会带来两个问题</p>
<p>​        （1）存储成本增加，日积月累，这里要存储的Nonce会越来越多，需要的存储空间就越大</p>
<p>​        （2）碰撞概率增加，正常服务被拒绝概率增大；这里随着生成Nonce值越来越多，碰撞的概率一定越来越大，若通过增加Nonce值的长度，有增加存储成本。</p>
<p>​         那么，另一个可行的办法，就是调用者每次请求时带上当前请求时间点Timestamp，然后由服务端限制请求的时效性。   </p>
<p>​         如此，上面提到的Nonce值存储成本可能比较大的问题，在结合Timestamp后，可大大降低存储成本，如Timestamp=1min，则仅需存储1min内的请求Nonce值即可，大大减少存储的量级。</p>
<p>至此，客户端发送的参数为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">encryptedParametersString: xxxx1</span><br><span class="line">signatureValue: xxxx1的签名值,📢：要把timestamp和nonce也包括进去，避免它们被篡改</span><br><span class="line">signatureMethod: xxx1的签名方式（如果客户端有md5、sha256等多种加密方式）</span><br><span class="line">nonce: xxx1的nonce</span><br><span class="line">timestamp: xxx1的timestamp</span><br></pre></td></tr></table></figure>
<h3 id="3、扩展：客户端自己如何防止接口重复请求？"><a href="#3、扩展：客户端自己如何防止接口重复请求？" class="headerlink" title="3、扩展：客户端自己如何防止接口重复请求？"></a>3、扩展：客户端自己如何防止接口重复请求？</h3><p>1、界面添加 loading</p>
<p>2、进行节流（最后执行）和防抖（立即执行）中的防抖。</p>
<p>3、请求队列：类似SDWebImage加载相同地址的图片。</p>
<p>如果重复请求的话，客户端的优化：</p>
<p>1、缓存</p>
<p>其他可参考：<a href="https://juejin.cn/post/7377208894551261193" target="_blank" rel="noopener">功能问题：如何防止接口重复请求？</a></p>
<hr>
<p>## </p>
<p><a name="附1：加密的方式有哪些"></a></p>
<h2 id="附1：加密的方式有哪些"><a href="#附1：加密的方式有哪些" class="headerlink" title="附1：加密的方式有哪些"></a>附1：加密的方式有哪些</h2><table>
<thead>
<tr>
<th></th>
<th>对称加密</th>
<th>非对称加密</th>
</tr>
</thead>
<tbody>
<tr>
<td>概念</td>
<td>加密密钥和解密密钥相同</td>
<td>加密密钥和解密密钥不相同</td>
</tr>
<tr>
<td>算法</td>
<td>DES、AES、RC2、RC4、RC5 等</td>
<td>RSA、ECC 等</td>
</tr>
<tr>
<td>缺点</td>
<td>速度快，安全性低。使用<code>同一个密钥</code>，如果一方密钥泄露，数据就不安全了</td>
<td>非对称加密的安全性更高，但加密速度较慢。</td>
</tr>
</tbody>
</table>
<p>注意：非对称加密的安全性更高，但加密速度较慢。一般我们在项目中采用的是 <strong>”结合对称和非对称加密，数据加密采用AES，而把AES的加密秘钥用RSA加密，这样兼顾速度及安全性“</strong>。<a href="https://juejin.cn/post/7002058547395559438" target="_blank" rel="noopener">https://juejin.cn/post/7002058547395559438</a></p>
<h3 id="1-1、对称加密"><a href="#1-1、对称加密" class="headerlink" title="1.1、对称加密"></a>1.1、对称加密</h3><p><img src="/安全/网络加密/加密方式_对称.png" alt="加密方式_对称" style="zoom: 33%;"></p>
<p>1、李雷想要给韩梅梅发送消息，他们约定使用对称加密的方式把消息进行加密</p>
<p>2、李雷用密钥把消息加密然后发送给韩梅梅</p>
<p>3、韩梅梅用同一个密钥解密，然后看到李雷发送给自己的消息</p>
<h3 id="1-2、非对称加密"><a href="#1-2、非对称加密" class="headerlink" title="1.2、非对称加密"></a>1.2、非对称加密</h3><p><img src="/安全/网络加密/加密方式_非对称.png" alt="加密方式_非对称" style="zoom: 33%;"></p>
<p>1、李雷想要给韩梅梅发送消息，他们约定使用非对称加密的方式把消息进行加密</p>
<p>2、李雷首先要得到韩梅梅的公钥</p>
<p>2、李雷用韩梅梅的公钥把消息加密然后发送给韩梅梅</p>
<p>3、韩梅梅用自己的私钥解密，然后看到李雷发送给自己的消息</p>
<p>韩梅梅给李雷发送消息同理。</p>
<p><a name="附2：如何在客户端安全的保存密钥AESKey"></a></p>
<h2 id="附2：如何在客户端安全的保存密钥AESKey"><a href="#附2：如何在客户端安全的保存密钥AESKey" class="headerlink" title="附2：如何在客户端安全的保存密钥AESKey"></a>附2：如何在客户端安全的保存密钥AESKey</h2><p>如果密钥是来源于客户端，那如何在客户端安全的保存密钥？</p>
<h3 id="1、密钥在代码上-内部"><a href="#1、密钥在代码上-内部" class="headerlink" title="1、密钥在代码上(内部)"></a>1、密钥在代码上(内部)</h3><h4 id="1-1、存放密码的常见的代码"><a href="#1-1、存放密码的常见的代码" class="headerlink" title="1.1、存放密码的常见的代码"></a>1.1、存放密码的常见的代码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define kSecret <span class="meta-string">"abcd1234"</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 或者</span></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">char</span>* kSecret = <span class="string">"abcd1234"</span>;</span><br></pre></td></tr></table></figure>
<p>这是非常危险的，因为常量会被直接编译到可执行文件的data段，只要对生成的可执行文件使用<code>strings</code>、<code>otool</code>等命令就可以dump出原始字符串。</p>
<h4 id="1-2、对密码加加密"><a href="#1-2、对密码加加密" class="headerlink" title="1.2、对密码加加密"></a>1.2、对密码加加密</h4><p>仍然存</p>
<p>1、类的代码层面</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：密码在可执行文件的data段，且是明文</span></span><br><span class="line"><span class="meta">#define kSecret <span class="meta-string">"abcd1234"</span></span></span><br><span class="line"><span class="keyword">void</span> getSecret &#123;</span><br><span class="line">	<span class="keyword">return</span> kSecret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：密码在可执行文件的data段，虽是明文，但取到的值要再经过一层你自己知道的方法解密</span></span><br><span class="line"><span class="meta">#define kSecret <span class="meta-string">"\x7e\x77\x64\x3c\xa7\xd4\x6d\x46\x29\x8b\xe3\x23\x9f\x1a\x5c\xdb"</span>;  // 使用aes加密后的</span></span><br><span class="line"><span class="meta">#define kAESKey	<span class="meta-string">"abcdefgh12345678"</span>;</span></span><br><span class="line"><span class="keyword">char</span>* getSecret() &#123;</span><br><span class="line">	<span class="keyword">return</span> decryptSecretByAESKey(kSecret, kAESKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法2的优化：内部代码使用额外包在宏(kAppSecret)上，由于宏没有明确的入口，使得静态分析相比直接调用函数形式的getSecret更加不容易被破解。</span></span><br><span class="line"><span class="meta">#define kAppSecret                                          \</span></span><br><span class="line">(&#123;                                                          \</span><br><span class="line">    <span class="keyword">char</span>* buf = decryptSecretByAESKey(kSecret, kAESKey);		\</span><br><span class="line">    [<span class="built_in">NSString</span> stringWithUTF8String:buf];					    			\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>附：<strong><a href="https://tanqisen.github.io/blog/2014/06/06/how-to-prevent-app-crack/" target="_blank" rel="noopener">宏定义的两个技巧：</a></strong></p>
<blockquote>
<ul>
<li>带返回值的宏</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; #define SOME_MACRO \ </span><br><span class="line">&gt; (&#123;                 \</span><br><span class="line">&gt; 	expression;      \</span><br><span class="line">&gt; &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>最后一个表达式的值就是宏的返回值，使用时更像函数的返回值。</p>
<ul>
<li>局部标签</li>
</ul>
<p>局部标签用<code>__label__</code>定义。如果标签<code>end</code>没有<code>__label__</code>修饰，在同一个函数中多次使用<code>kAppSecret</code>将产生编译错误，因为宏展开后相当于定义了多个<code>end</code>标签，标签重复定义。</p>
</blockquote>
<p>2、类本身（可包含类中的函数名）</p>
<p>因为objc代码的动态性，编译器会在binary中留下类名、函数名等信息，这些信息是可以被<code>class-dump-z</code>等工具提取的，友好的命名让程序猿更方便，但同时也方便了破解者。对安全相关的重要模块类，可以故意混淆类名，让人不容易轻易联想到该的真实目的。</p>
<p>PS、更多混淆知识可看我写的另一篇文章：<a href="https://www.jianshu.com/p/ccfe5623483d" target="_blank" rel="noopener">iOS APP安全加固方案(一、代码混淆CodeObfuscation)</a></p>
<h3 id="2、密钥保存在外部"><a href="#2、密钥保存在外部" class="headerlink" title="2、密钥保存在外部"></a>2、密钥保存在外部</h3><h4 id="2-1、密钥保存在Keychain"><a href="#2-1、密钥保存在Keychain" class="headerlink" title="2.1、密钥保存在Keychain"></a>2.1、密钥保存在Keychain</h4><p>密钥保存在Keychain并不安全，iOS越狱后可以导出Keychain的内容。应该尽量避免存放重要信息(如：token、用户名、密码等)在Keychain中，即使要存放，也一定要加密后存放。参考：<a href="http://blog.csdn.net/yiyaaixuexi/article/details/18404343" target="_blank" rel="noopener">iOS安全攻防（九）：使用Keychain-Dumper导出keychain数据</a></p>
<h4 id="2-2、密钥保存在文件"><a href="#2-2、密钥保存在文件" class="headerlink" title="2.2、密钥保存在文件"></a>2.2、密钥保存在文件</h4><p>保存在app bundle、plist等配置文件更不安全，但可以使用隐写术等方式迷惑hackers。</p>
<blockquote>
<p><strong>*Xcode打包时会对png图片做特殊处理，如果将密码携带在png中，可能会在使用的时候无法复原。</strong>当然现在的隐写术非常多，不只是图片能作为载体，视频、音乐等文件都可以，隐写的方法也多种多样，选择适合自己的就行，据说基地组织就是通过岛国电影传递信息的。*</p>
</blockquote>
<h5 id="2-2-1、隐写术"><a href="#2-2-1、隐写术" class="headerlink" title="2.2.1、隐写术"></a>2.2.1、隐写术</h5><ul>
<li><a href="https://blog.csdn.net/wpgdream/article/details/126497352" target="_blank" rel="noopener">隐写术，图片中隐藏的秘密！</a></li>
</ul>
<p>本节点【如何防止客户端被破解/密钥的保护】部分内容摘自/参考：<a href="https://tanqisen.github.io/blog/2014/06/06/how-to-prevent-app-crack/" target="_blank" rel="noopener">如何防止客户端被破解</a></p>
<p><strong>LSB算法</strong>：LSB全称为 Least Significant Bit（最低有效位），是一种常被用做图片隐写的算法。为了避免我们对图片进行的处理可能会在压缩的过程中被破坏，建议在无压缩的bmp图片上实现。（png图片是无损压缩，jpg图片是有损压缩。）</p>
<blockquote>
<p><img src="/安全/网络加密/steganography_lbs.png" alt="steganography_lbs">图片来源于：《<a href="./网络加密/网络加密.graffle">网络加密.graffle</a>》中的【隐写术】</p>
</blockquote>
<p>bmp的隐写，相比lsb隐写，bmp简单的多，并且达到了无损隐写。</p>
<p>bmp了解：<a href="https://maidang.cool/2022/14839.html" target="_blank" rel="noopener">BMP位图隐写</a></p>
<p><a href="https://www.onctf.com/posts/30da720a.html" target="_blank" rel="noopener">ctf杂项中图片隐写拿到一张图片常见的解题方法</a></p>
<p><a name="附3：签名 --> md5(加盐)"></a></p>
<h2 id="附3：签名-–-gt-md5-加盐"><a href="#附3：签名-–-gt-md5-加盐" class="headerlink" title="附3：签名 –&gt; md5(加盐)"></a>附3：签名 –&gt; md5(加盐)</h2><p>md5是哈希函数。SHA-256或SHA-3也是哈希函数，相比md5更安全。</p>
<p>Mac：在终端上实现将abcd1234进行MD5（Message Digest algorithm 5 ,信息摘要算法）加密。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo -n 'abcd1234' | md5</span><br><span class="line"></span><br><span class="line">得到结果：e19d5cd5af0378da05f63f891c7467af</span><br></pre></td></tr></table></figure>
<p>使用MD5就是将一串字符串通过某特定的算法来将其变成另一种形式，这样子就在外观上起到了加密的效果，但是由于背后的算法(<strong>md5是一种常见的hash算法</strong>)是固定的，所以每一个字符串都有固定的MD5格式。（反过来，一个hash值是否只能是一个值才可能？答：不是）</p>
<p>因为<strong>每一个字符串就只有一种特定的MD5格式</strong>，所以md5的破解（从c=hash(m)逆向得到原始明文m）容易想到的方式有：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>优缺点</th>
<th>推荐程度</th>
</tr>
</thead>
<tbody>
<tr>
<td>暴力破解法</td>
<td>时间成本太高</td>
<td>⭐️</td>
</tr>
<tr>
<td>字典法</td>
<td>提前构建一个“明文-&gt;密文”对应关系的一个大型数据库，破解时通过密文直接反查明文。但存储一个这样的数据库，空间成本是惊人的</td>
<td>⭐️⭐️⭐️</td>
</tr>
<tr>
<td>构建彩虹表</td>
<td>在字典法的基础上改进，以时间换空间。是现在破解哈希常用的办法。<br>彩虹表：彩虹表记录了几乎所有字符串的MD5对照表。</td>
<td>⭐️⭐️⭐️⭐️⭐️</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong><a href="https://www.cmd5.com/" target="_blank" rel="noopener">md5在线解密网站</a></strong></p>
<p><img src="/安全/网络加密/md5在线解密.png" alt="md5在线解密" style="zoom:50%;"></p>
</blockquote>
<p>因为已经有了类似彩虹表的破解方法，所以如果不<strong>‘加盐’</strong>，则当用户知道是 e19d5cd5af0378da05f63f891c7467af 时候，就很容易知道原值是 ‘abcd1234’了。</p>
<p>所以Md5加密方式的进化之路小结：</p>
<table>
<thead>
<tr>
<th></th>
<th>密码存储的种方式</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>直接存储密码明文m</td>
<td>明文存储，无安全性可言。</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>存储密码明文的哈希值hash(m)</td>
<td>虽然是入侵者得到的是hash值，但由于<strong>彩虹表</strong>的存在，也很容易批量还原出密码明文来。</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>存储密码明文的加盐哈希 hash(m+salt)。<br><strong>这里的salt可以是用户名，手机号等</strong>，但必须保证每个用户的salt都不一样才是安全的。</td>
<td>相对前两种安全</td>
</tr>
</tbody>
</table>
<h2 id="网路本身的安全"><a href="#网路本身的安全" class="headerlink" title="网路本身的安全"></a>网路本身的安全</h2><p><strong>HTTPS是应用层的安全协议。TCP是传输层的协议，但是它不安全，因为它是明文传输的，所以SSL的诞生就是给TCP加了一层保险，使HTTPS和TCP之间使用加密传输。而TLS只是SSL的升级版，他们的作用是一样的。</strong></p>
<p>以下内容摘自<a href="https://www.sohu.com/a/251746171_216613" target="_blank" rel="noopener">HTTPS、SSL/TLS、TCP之间错综复杂的情感纠葛 </a></p>
<blockquote>
<p>SSL(Secure Sockets Layer) 安全套接层：为网络通信提供安全及数据完整性的一种安全协议。</p>
<p>TLS(Transport Layer Security）安全传输层协议：用于在两个通信应用程序之间提供保密性和数据完整性。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake），是更新、更安全的SSL版本。</p>
</blockquote>
<p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。<strong>==&gt; 类似 RSA</strong></p>
<p>但是，这里有两个问题。</p>
<p>（1）如何保证公钥不被篡改？</p>
<p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>
<p>（2）公钥加密计算量太大，如何减少耗用的时间？</p>
<p>解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。 <strong>==&gt; 类似 AES</strong></p>
<p>HTTPS（超文本传输安全协议）是建立在HTTP（超文本传输协议）之上，通过SSL/TLS（安全套接字层/传输层安全协议）进行加密的安全协议。在HTTPS的握手过程中，SSL/TLS握手会先于HTTP握手发生。以下是HTTPS连接建立的基本步骤：</p>
<ol>
<li><strong>TCP握手</strong>：客户端首先通过TCP（传输控制协议）与服务器建立一个普通的连接。这个过程包括三次握手，确保双方都准备好进行数据传输。</li>
<li><strong>SSL/TLS握手</strong>：一旦TCP连接建立，SSL/TLS握手就开始了。这个过程包括：<ul>
<li>客户端发送一个“hello”消息给服务器，请求建立一个安全的连接。</li>
<li>服务器响应自己的“hello”消息，并发送其证书（包含公钥）给客户端。</li>
<li><strong>客户端验证服务器的证书</strong>，如果证书有效，客户端会生成一个随机数（用于会话加密），并使用服务器的公钥加密这个随机数，然后发送给服务器。（<a href="https://juejin.cn/post/6844903564960088071" target="_blank" rel="noopener">使用 AFNetworking 时怎么进行证书认证：AFSSLPinningModeNone(Default)：客户端自己不会对服务端证书进行自主校验，而是直接默认信任</a>)</li>
<li>服务器使用自己的私钥解密这个随机数，然后使用这个随机数来加密接下来的通信。</li>
</ul>
</li>
<li><strong>应用层协议</strong>：一旦SSL/TLS握手完成，客户端和服务器就可以使用这个安全的连接来传输加密的数据。这时，HTTP请求和响应就会在SSL/TLS层之上进行传输。</li>
</ol>
<p>因此，HTTPS的连接建立过程中，是先进行TCP握手，然后进行SSL/TLS握手，最后才开始HTTP通信。</p>
<h2 id="其他参考文章"><a href="#其他参考文章" class="headerlink" title="其他参考文章"></a>其他参考文章</h2><ul>
<li><p><a href="https://www.cnblogs.com/xingxia/p/api_security.html" target="_blank" rel="noopener">API接口之安全篇(含https原理图解)</a></p>
</li>
<li><p><a href="https://blog.csdn.net/HO1_K/article/details/109285565" target="_blank" rel="noopener">Java API加密 从sign签名验证到RSA、AES数据加密的实际应用</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1557750" target="_blank" rel="noopener">如何设计一个API签名</a></p>
</li>
</ul>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/安全/网络加密/" data-id="cm1p883k40038zwr4ujbcpfh6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/安全/">安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Architecture架构/监控相关/灰度系统" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/Architecture架构/监控相关/灰度系统/" class="article-date">
  <time datetime="2024-05-31T09:07:41.000Z" itemprop="datePublished">2024-05-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Architecture/">Architecture</a>►<a class="article-category-link" href="/categories/Architecture/第九章：监控相关/">第九章：监控相关</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Architecture架构/监控相关/灰度系统/">灰度系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<p><strong>目的：避免功能异常，出现集体性问题。</strong></p>
<h2 id="一、灰度接口"><a href="#一、灰度接口" class="headerlink" title="一、灰度接口"></a>一、灰度接口</h2><h3 id="1、灰度开关接口"><a href="#1、灰度开关接口" class="headerlink" title="1、灰度开关接口"></a>1、灰度开关接口</h3><p>1、是否进行功能的灰度使用的开关</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>说明</th>
<th>字段</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>网页配置1</td>
<td>是否开启功能</td>
<td>isOpen</td>
<td>1:开启、其他:关</td>
</tr>
<tr>
<td>网页配置2</td>
<td>要开启功能的用户(灰度上线)<br>(当且仅当开启上述功能时有效)</td>
<td>openUserids</td>
<td>[“101”, “102”]</td>
</tr>
<tr>
<td>网页配置3</td>
<td>要开启功能的设备(灰度上线)<br>(当且仅当开启上述功能时有效)<br>未配置但开关为开时为全记录</td>
<td>openDeviceIds</td>
<td>[“udid001”, “udid002”]</td>
</tr>
<tr>
<td>接口回值1</td>
<td>是否进行功能的使用(灰度上线)</td>
<td>needOpen</td>
<td>1:使用、其他:不使用</td>
</tr>
</tbody>
</table>
<p>接口名定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getGrayscaleSwitchConfig(userid, deviceId)</span><br></pre></td></tr></table></figure>
<p>接口结果的json示例如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"logFuture"</span>: &#123;</span><br><span class="line">		<span class="attr">"needOpen"</span>: <span class="number">1</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"cacheOptimize"</span>: &#123;</span><br><span class="line">		<span class="attr">"needOpen"</span>: <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/Architecture架构/监控相关/灰度系统/" data-id="cm1p884qn008szwr4ygvxvhqf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Architecture/">Architecture</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Architecture架构/框架相关/WebView相关/h5_native_interacte/h5js/dvlp_h5js_demo_hardware" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/Architecture架构/框架相关/WebView相关/h5_native_interacte/h5js/dvlp_h5js_demo_hardware/" class="article-date">
  <time datetime="2024-05-17T08:11:13.519Z" itemprop="datePublished">2024-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        [{"sectionTitle":"权限相关","sectionDatas":[{"h5CallBridgeActionDes":"打开app设置（常用场景:h5 只获取权限值，自定义弹窗时候，需要调用此方法）","h5CallBridgeActionName":"h5CallBridgeAction_openAppSettings_v10000","h5CallBridgeSendMessage":{"callbackMethod":"bridgeCallH5Action_showCallbackJsonString"}},{"h5CallBridgeActionDes":"获取定位权限(只获取值，不会请求打开)","h5CallBridgeActionName":"h5CallBridgeAction_location_get_permission_v10000","h5CallBridgeSendMessage":{"types":["permission","accuracy"],"callbackMethod":"bridgeCallH5Action_showCallbackJsonString"},"h5CallBridgeDescription":{"types":["permission 是否开启定位权限","accuracy 开始时定位数据是否精确"],"callbackMethod":"获取到的数值在h5上用哪个方法来接口"},"appCallbackDemo_ValueAndDescription":{"resultCode":0,"result":[{"isPermissionAllow":"定位开关是否打开(永不 permanentlyDenied、下次询问或在我共享时、使用APP期间、始终)","isDataFullAccuracy":"开启权限时，定位是否开启高精度模式(定位开关为永不的时候，设置里无此操作)"}]}}]},{"sectionTitle":"应用基础系统能力（保存图片、视频）","sectionDatas":[{"h5CallBridgeActionDes":"保存《IMAGE图片、VIDEO视频》到【相册】","h5CallBridgeActionName":"h5CallBridgeAction_saveAssetUrls_toAlbum_v10000","h5CallBridgeSendMessage":{"albumName":"XXXapp","assetUrls":["https://img1.baidu.com/it/u=1605341541,1182642759&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1673370000&t=4e694f8a257f10a7f6b52bd051288e7d","https://statics.xihuanwu.com/offical/wishhouse/static1683361771686/media/bg_video.895d2a6a.mp4"]},"h5CallBridgeDescription":{"albumName":"相册名字，可为空，为空时候为默认地址","assetUrls":["图片或视频网页地址","图片或视频网页地址"]}}]},{"sectionTitle":"h5调用app的方法-其他操作(①无入参和回参;②有入参给app,但无需回参;③需回参给h5)","sectionDatas":[{"h5CallBridgeActionDes":"声音控制(播放、暂停、停止)-一定会用于iOS的网页声音控制","h5CallBridgeActionName":"h5CallBridgeAction_audioPlayer_v10000","h5CallBridgeSendMessage":{"type":"play","url":"https://tape.xihuanwu.com/wish_dev/audio/640/1460136481476464640/2022-08/bgm.mp3"},"h5CallBridgeDescription":{"type":"play:播放、pause:暂停、stop:停止","url":"play播放的时候，才必须传，其他操作，可为空"}}]}]
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/Architecture架构/框架相关/WebView相关/h5_native_interacte/h5js/dvlp_h5js_demo_hardware/" data-id="cm1p88bav01bizwr487o2ico0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Architecture架构/框架相关/WebView相关/h5_native_interacte/h5js/dvlp_h5js_demo_webview" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/Architecture架构/框架相关/WebView相关/h5_native_interacte/h5js/dvlp_h5js_demo_webview/" class="article-date">
  <time datetime="2024-05-17T08:06:10.514Z" itemprop="datePublished">2024-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        [{"sectionTitle":"WebControl的方法","sectionDatas":[{"h5CallBridgeActionDes":"关闭WebView","h5CallBridgeActionName":"h5CallBridgeAction_closeAppWebView_v10000","h5CallBridgeSendMessage":{"callbackMethod":"bridgeCallH5Action_showCallbackJsonString"}},{"h5CallBridgeActionDes":"刷新网页(到新地址)","h5CallBridgeActionName":"h5CallBridgeAction_reloadAppWebView_v10000","h5CallBridgeSendMessage":{"url":"https://www.baidu.com"}}]}]
      
    </div>
    <footer class="article-footer">
      <a data-url="https://dvlproad.github.io/Architecture架构/框架相关/WebView相关/h5_native_interacte/h5js/dvlp_h5js_demo_webview/" data-id="cm1p88bc601bozwr4n948bwva" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/">Architecture</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第一章：架构相关/">第一章：架构相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第七章：技术选型/">第七章：技术选型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第三章：基础规范/">第三章：基础规范</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第九章：监控相关/">第九章：监控相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第二章：框架相关/">第二章：框架相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第八章：页面加载相关/">第八章：页面加载相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第六章：通用业务规范/">第六章：通用业务规范</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/第四章：基础框架设计及接口文档/">第四章：基础框架设计及接口文档</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/无瑕疵的混编登录页/">无瑕疵的混编登录页</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第一章：Flutter入门/">第一章：Flutter入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第七章：规范/">第七章：规范</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第三章：原生项目与Flutter的交互/">第三章：原生项目与Flutter的交互</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第九章：框架升级/">第九章：框架升级</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第二章：集成Flutter到原生项目/">第二章：集成Flutter到原生项目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第五章：详解/">第五章：详解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第八章：状态管理/">第八章：状态管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第六章：进阶/">第六章：进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第四章：Flutter登录页实战/">第四章：Flutter登录页实战</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/第零章：Flutter源码/">第零章：Flutter源码</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/QA/">QA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/README/">README</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/React/第一章：React入门/">第一章：React入门</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/">ReactNative</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第一章：ReactNative入门/">第一章：ReactNative入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第一章：React入门/">第一章：React入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第五章：ReactNative详解/">第五章：ReactNative详解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第八章：ReactNative实践/">第八章：ReactNative实践</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/第六章：ReactNative进阶/">第六章：ReactNative进阶</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/">Script</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Script/JQuery/">JQuery</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Mac快速操作/">Mac快速操作</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Script/Shell/">Shell</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Weex/">Weex</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Weex/第一章：Weex入门/">第一章：Weex入门</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Swift/">Swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/混编/">混编</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/移动分析/">移动分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/自动化/">自动化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/证书发版/">证书发版</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/npmjs/">npmjs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/上架相关/">上架相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/代码管理/">代码管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全与破解/">安全与破解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/">实用工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/ChatGPT/">ChatGPT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/GitBook/">GitBook</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/Jenkins/">Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/XAMPP/">XAMPP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/Zentao/">Zentao</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实用工具/其他小工具/">其他小工具</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作常识/">工作常识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术常识/">技术常识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活常识/">生活常识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/管理相关/">管理相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/管理相关/第一章：账号管理/">第一章：账号管理</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程工具/">编程工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/跨平台/">跨平台</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/跨平台/第一章：混编事项说明/">第一章：混编事项说明</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Architecture/">Architecture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChatGPT/">ChatGPT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac快速操作/">Mac快速操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QA/">QA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/README/">README</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReactNative/">ReactNative</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Script/">Script</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/h5与app交互/">h5与app交互</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npmjs/">npmjs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/上架相关/">上架相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/交互/">交互</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/埋点/">埋点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基类/">基类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/实用工具/">实用工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作常识/">工作常识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/打包/">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术常识/">技术常识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/抓包/">抓包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/搜索相关/">搜索相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文档管理/">文档管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/权限相关/">权限相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构模式/">架构模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境搭建/">环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活常识/">生活常识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/瘦身/">瘦身</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/登录页实战/">登录页实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/破解/">破解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动分析/">移动分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/管理相关/">管理相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程工具/">编程工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化/">自动化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/请求/">请求</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨平台/">跨平台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/路由及跳转/">路由及跳转</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阿里云/">阿里云</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阿里云oss/">阿里云oss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集成/">集成</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Architecture/" style="font-size: 20px;">Architecture</a> <a href="/tags/ChatGPT/" style="font-size: 10.83px;">ChatGPT</a> <a href="/tags/CocoaPods/" style="font-size: 10px;">CocoaPods</a> <a href="/tags/Flutter/" style="font-size: 18.33px;">Flutter</a> <a href="/tags/Git/" style="font-size: 13.33px;">Git</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Jenkins/" style="font-size: 14.17px;">Jenkins</a> <a href="/tags/Mac快速操作/" style="font-size: 10px;">Mac快速操作</a> <a href="/tags/Python/" style="font-size: 11.67px;">Python</a> <a href="/tags/QA/" style="font-size: 10px;">QA</a> <a href="/tags/README/" style="font-size: 10px;">README</a> <a href="/tags/React/" style="font-size: 10.83px;">React</a> <a href="/tags/ReactNative/" style="font-size: 15.83px;">ReactNative</a> <a href="/tags/Ruby/" style="font-size: 10px;">Ruby</a> <a href="/tags/Script/" style="font-size: 15px;">Script</a> <a href="/tags/Shell/" style="font-size: 11.67px;">Shell</a> <a href="/tags/Swift/" style="font-size: 12.5px;">Swift</a> <a href="/tags/Weex/" style="font-size: 10px;">Weex</a> <a href="/tags/h5与app交互/" style="font-size: 12.5px;">h5与app交互</a> <a href="/tags/iOS/" style="font-size: 16.67px;">iOS</a> <a href="/tags/npmjs/" style="font-size: 10.83px;">npmjs</a> <a href="/tags/上架相关/" style="font-size: 10px;">上架相关</a> <a href="/tags/交互/" style="font-size: 12.5px;">交互</a> <a href="/tags/埋点/" style="font-size: 10.83px;">埋点</a> <a href="/tags/基类/" style="font-size: 10.83px;">基类</a> <a href="/tags/安全/" style="font-size: 14.17px;">安全</a> <a href="/tags/实用工具/" style="font-size: 17.5px;">实用工具</a> <a href="/tags/工作常识/" style="font-size: 10px;">工作常识</a> <a href="/tags/打包/" style="font-size: 10px;">打包</a> <a href="/tags/技术常识/" style="font-size: 13.33px;">技术常识</a> <a href="/tags/抓包/" style="font-size: 10px;">抓包</a> <a href="/tags/搜索相关/" style="font-size: 10px;">搜索相关</a> <a href="/tags/文档管理/" style="font-size: 14.17px;">文档管理</a> <a href="/tags/权限相关/" style="font-size: 10px;">权限相关</a> <a href="/tags/架构模式/" style="font-size: 11.67px;">架构模式</a> <a href="/tags/环境搭建/" style="font-size: 10.83px;">环境搭建</a> <a href="/tags/生活常识/" style="font-size: 10px;">生活常识</a> <a href="/tags/瘦身/" style="font-size: 11.67px;">瘦身</a> <a href="/tags/登录页实战/" style="font-size: 12.5px;">登录页实战</a> <a href="/tags/破解/" style="font-size: 11.67px;">破解</a> <a href="/tags/移动分析/" style="font-size: 11.67px;">移动分析</a> <a href="/tags/管理相关/" style="font-size: 11.67px;">管理相关</a> <a href="/tags/编程工具/" style="font-size: 12.5px;">编程工具</a> <a href="/tags/自动化/" style="font-size: 11.67px;">自动化</a> <a href="/tags/请求/" style="font-size: 10.83px;">请求</a> <a href="/tags/跨平台/" style="font-size: 19.17px;">跨平台</a> <a href="/tags/路由及跳转/" style="font-size: 11.67px;">路由及跳转</a> <a href="/tags/阿里云/" style="font-size: 10px;">阿里云</a> <a href="/tags/阿里云oss/" style="font-size: 13.33px;">阿里云oss</a> <a href="/tags/集成/" style="font-size: 11.67px;">集成</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/iOS/3必备知识架构/3视图/3视图-①本质RunLoop/">(no title)</a>
          </li>
        
          <li>
            <a href="/iOS/3必备知识架构/2内存/2内存-②循环引用/">(no title)</a>
          </li>
        
          <li>
            <a href="/Architecture架构/架构相关/3组件化/5框架设计模式-⑦组件化/">(no title)</a>
          </li>
        
          <li>
            <a href="/Architecture架构/监控相关/日志系统/">日志系统</a>
          </li>
        
          <li>
            <a href="/电脑使用/旧电脑数据清理/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 dvlproad<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>